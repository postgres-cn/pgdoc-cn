<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-altertable">
<!--==========================orignal english content==========================
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>change the definition of a table</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>更改一个表的定义</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">column_name</replaceable> TO <replaceable class="parameter">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> TO <replaceable class="parameter">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    RENAME TO <replaceable class="parameter">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    SET SCHEMA <replaceable class="parameter">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">name</replaceable> [ OWNED BY <replaceable class="parameter">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    DETACH PARTITION <replaceable class="parameter">partition_name</replaceable>

<phrase>where <replaceable class="parameter">action</replaceable> is one of:</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>sequence_option</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">restart</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STATISTICS <replaceable class="parameter">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    DISABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">parent_table</replaceable>
    NO INHERIT <replaceable class="parameter">parent_table</replaceable>
    OF <replaceable class="parameter">type_name</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">new_owner</replaceable> | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">index_name</replaceable> | FULL | NOTHING }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | NULL } [, ...] ) |
FROM ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint_using_index</replaceable> is:</phrase>

    [ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">column_name</replaceable> TO <replaceable class="parameter">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> TO <replaceable class="parameter">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    RENAME TO <replaceable class="parameter">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    SET SCHEMA <replaceable class="parameter">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">name</replaceable> [ OWNED BY <replaceable class="parameter">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    DETACH PARTITION <replaceable class="parameter">partition_name</replaceable>

<phrase>其中<replaceable class="parameter">action</replaceable> 是以下之一：</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>sequence_option</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">restart</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STATISTICS <replaceable class="parameter">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    DISABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">parent_table</replaceable>
    NO INHERIT <replaceable class="parameter">parent_table</replaceable>
    OF <replaceable class="parameter">type_name</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">new_owner</replaceable> | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">index_name</replaceable> | FULL | NOTHING }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | NULL } [, ...] ) |
FROM ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">numeric_literal</replaceable> | <replaceable class="parameter">string_literal</replaceable> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>而<replaceable class="parameter">table_constraint</replaceable>是：</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">action</replaceable> ] [ ON UPDATE <replaceable class="parameter">action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>并且 <replaceable class="parameter">table_constraint_using_index</replaceable> 是：</phrase>

    [ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>以及<literal>EXCLUDE</literal>约束中的<replaceable class="parameter">index_parameters</replaceable>是：</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>ALTER TABLE</command> changes the definition of an existing table.
   There are several subforms described below. Note that the lock level required
   may differ for each subform. An <literal>ACCESS EXCLUSIVE</literal> lock is held
   unless explicitly noted. When multiple subcommands are listed, the lock
   held will be the strictest one required from any subcommand.

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
    <listitem>
     <para>
      This form adds a new column to the table, using the same syntax as
      <xref linkend="sql-createtable"/>. If <literal>IF NOT EXISTS</literal>
      is specified and a column already exists with this name,
      no error is thrown.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      This form drops a column from a table.  Indexes and
      table constraints involving the column will be automatically
      dropped as well.
      Multivariate statistics referencing the dropped column will also be
      removed if the removal of the column would cause the statistics to
      contain data for only a single column.
      You will need to say <literal>CASCADE</literal> if anything outside the table
      depends on the column, for example, foreign key references or views.
      If <literal>IF EXISTS</literal> is specified and the column
      does not exist, no error is thrown. In this case a notice
      is issued instead.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
      This form changes the type of a column of a table. Indexes and
      simple table constraints involving the column will be automatically
      converted to use the new column type by reparsing the originally
      supplied expression.
      The optional <literal>COLLATE</literal> clause specifies a collation
      for the new column; if omitted, the collation is the default for the
      new column type.
      The optional <literal>USING</literal>
      clause specifies how to compute the new column value from the old;
      if omitted, the default conversion is the same as an assignment
      cast from old data type to new.  A  <literal>USING</literal>
      clause must be provided if there is no implicit or assignment
      cast from old to new type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      These forms set or remove the default value for a column.
      Default values only apply in subsequent <command>INSERT</command>
      or <command>UPDATE</command> commands; they do not cause rows already in the
      table to change.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      These forms change whether a column is marked to allow null
      values or to reject null values.  You can only use <literal>SET
      NOT NULL</literal> when the column contains no null values.
     </para>

     <para>
      If this table is a partition, one cannot perform <literal>DROP NOT NULL</literal>
      on a column if it is marked <literal>NOT NULL</literal> in the parent
      table.  To drop the <literal>NOT NULL</literal> constraint from all the
      partitions, perform <literal>DROP NOT NULL</literal> on the parent
      table.  Even if there is no <literal>NOT NULL</literal> constraint on the
      parent, such a constraint can still be added to individual partitions,
      if desired; that is, the children can disallow nulls even if the parent
      allows them, but not the other way around.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      These forms change whether a column is an identity column or change the
      generation attribute of an existing identity column.
      See <xref linkend="sql-createtable"/> for details.
     </para>

     <para>
      If <literal>DROP IDENTITY IF EXISTS</literal> is specified and the
      column is not an identity column, no error is thrown.  In this case a
      notice is issued instead.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET <replaceable>sequence_option</replaceable></literal></term>
    <term><literal>RESTART</literal></term>
    <listitem>
     <para>
      These forms alter the sequence that underlies an existing identity
      column.  <replaceable>sequence_option</replaceable> is an option
      supported by <xref linkend="sql-altersequence"/> such
      as <literal>INCREMENT BY</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      This form
      sets the per-column statistics-gathering target for subsequent
      <xref linkend="sql-analyze"/> operations.
      The target can be set in the range 0 to 10000; alternatively, set it
      to -1 to revert to using the system default statistics
      target (<xref linkend="guc-default-statistics-target"/>).
      For more information on the use of statistics by the
      <productname>PostgreSQL</productname> query planner, refer to
      <xref linkend="planner-stats"/>.
     </para>
     <para>
      <literal>SET STATISTICS</literal> acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</literal> and
      <literal>n_distinct_inherited</literal>, which override the
      number-of-distinct-values estimates made by subsequent
      <xref linkend="sql-analyze"/>
      operations.  <literal>n_distinct</literal> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</literal> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</command> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</command> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats"/>.
     </para>
     <para>
      Changing per-attribute options acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>per-column storage settings</secondary>
     </indexterm>
    </term>
    <listitem>
     <para>
      This form sets the storage mode for a column. This controls whether this
      column is held inline or in a secondary <acronym>TOAST</acronym> table, and
      whether the data
      should be compressed or not. <literal>PLAIN</literal> must be used
      for fixed-length values such as <type>integer</type> and is
      inline, uncompressed. <literal>MAIN</literal> is for inline,
      compressible data. <literal>EXTERNAL</literal> is for external,
      uncompressed data, and <literal>EXTENDED</literal> is for external,
      compressed data.  <literal>EXTENDED</literal> is the default for most
      data types that support non-<literal>PLAIN</literal> storage.
      Use of <literal>EXTERNAL</literal> will make substring operations on
      very large <type>text</type> and <type>bytea</type> values run faster,
      at the penalty of increased storage space.  Note that
      <literal>SET STORAGE</literal> doesn't itself change anything in the table,
      it just sets the strategy to be pursued during future table updates.
      See <xref linkend="storage-toast"/> for more information.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <para>
      This form adds a new constraint to a table using the same syntax as
      <xref linkend="sql-createtable"/>, plus the option <literal>NOT
      VALID</literal>, which is currently only allowed for foreign key
      and CHECK constraints.
      If the constraint is marked <literal>NOT VALID</literal>, the
      potentially-lengthy initial check to verify that all rows in the table
      satisfy the constraint is skipped.  The constraint will still be
      enforced against subsequent inserts or updates (that is, they'll fail
      unless there is a matching row in the referenced table, in the case
      of foreign keys; and they'll fail unless the new row matches the
      specified check constraints).  But the
      database will not assume that the constraint holds for all rows in
      the table, until it is validated by using the <literal>VALIDATE
      CONSTRAINT</literal> option.  Foreign key constraints on partitioned
      tables may not be declared <literal>NOT VALID</literal> at present.
     </para>

     <para>
      The addition of a foreign key constraint requires a
      <literal>SHARE ROW EXCLUSIVE</literal> lock on the referenced table.
     </para>

     <para>
      Additional restrictions apply when unique or primary key constraints
      are added to partitioned tables; see <xref linkend="sql-createtable" />.
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <para>
      This form adds a new <literal>PRIMARY KEY</literal> or <literal>UNIQUE</literal>
      constraint to a table based on an existing unique index.  All the
      columns of the index will be included in the constraint.
     </para>

     <para>
      The index cannot have expression columns nor be a partial index.
      Also, it must be a b-tree index with default sort ordering.  These
      restrictions ensure that the index is equivalent to one that would be
      built by a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.
     </para>

     <para>
      If <literal>PRIMARY KEY</literal> is specified, and the index's columns are not
      already marked <literal>NOT NULL</literal>, then this command will attempt to
      do <literal>ALTER COLUMN SET NOT NULL</literal> against each such column.
      That requires a full table scan to verify the column(s) contain no
      nulls.  In all other cases, this is a fast operation.
     </para>

     <para>
      If a constraint name is provided then the index will be renamed to match
      the constraint name.  Otherwise the constraint will be named the same as
      the index.
     </para>

     <para>
      After this command is executed, the index is <quote>owned</quote> by the
      constraint, in the same way as if the index had been built by
      a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.  In particular, dropping the constraint will make the index
      disappear too.
     </para>

     <para>
      This form is not currently supported on partitioned tables.
     </para>

     <note>
      <para>
       Adding a constraint using an existing index can be helpful in
       situations where a new constraint needs to be added without blocking
       table updates for a long time.  To do that, create the index using
       <command>CREATE INDEX CONCURRENTLY</command>, and then install it as an
       official constraint using this syntax.  See the example below.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
     <para>
      This form alters the attributes of a constraint that was previously
      created. Currently only foreign key constraints may be altered.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
      This form validates a foreign key or check constraint that was previously created
      as <literal>NOT VALID</literal>, by scanning the table to ensure there
      are no rows for which the constraint is not satisfied.
      Nothing happens if the constraint is already marked valid.
     </para>
     <para>
      Validation can be a long process on larger tables. The value of separating
      validation from initial creation is that you can defer validation to less
      busy times, or can be used to give additional time to correct pre-existing
      errors while preventing new errors. Note also that validation on its own
      does not prevent normal write commands against the table while it runs.
     </para>
     <para>
      Validation acquires only a <literal>SHARE UPDATE EXCLUSIVE</literal> lock
      on the table being altered. If the constraint is a foreign key then
      a <literal>ROW SHARE</literal> lock is also required on
      the table referenced by the constraint.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      This form drops the specified constraint on a table, along with
      any index underlying the constraint.
      If <literal>IF EXISTS</literal> is specified and the constraint
      does not exist, no error is thrown. In this case a notice is issued instead.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
      These forms configure the firing of trigger(s) belonging to the table.
      A disabled trigger is still known to the system, but is not executed
      when its triggering event occurs.  For a deferred trigger, the enable
      status is checked when the event occurs, not when the trigger function
      is actually executed.  One can disable or enable a single
      trigger specified by name, or all triggers on the table, or only
      user triggers (this option excludes internally generated constraint
      triggers such as those that are used to implement foreign key
      constraints or deferrable uniqueness and exclusion constraints).
      Disabling or enabling internally generated constraint triggers
      requires superuser privileges; it should be done with caution since
      of course the integrity of the constraint cannot be guaranteed if the
      triggers are not executed.
     </para>

     <para>
      The trigger firing mechanism is also affected by the configuration
      variable <xref linkend="guc-session-replication-role"/>. Simply enabled
      triggers (the default) will fire when the replication role is <quote>origin</quote>
      (the default) or <quote>local</quote>. Triggers configured as <literal>ENABLE
      REPLICA</literal> will only fire if the session is in <quote>replica</quote>
      mode, and triggers configured as <literal>ENABLE ALWAYS</literal> will
      fire regardless of the current replication role.
     </para>

     <para>
      The effect of this mechanism is that in the default configuration,
      triggers do not fire on replicas.  This is useful because if a trigger
      is used on the origin to propagate data between tables, then the
      replication system will also replicate the propagated data, and the
      trigger should not fire a second time on the replica, because that would
      lead to duplication.  However, if a trigger is used for another purpose
      such as creating external alerts, then it might be appropriate to set it
      to <literal>ENABLE ALWAYS</literal> so that it is also fired on
      replicas.
     </para>

     <para>
      This command acquires a <literal>SHARE ROW EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
      These forms configure the firing of rewrite rules belonging to the table.
      A disabled rule is still known to the system, but is not applied
      during query rewriting. The semantics are as for disabled/enabled
      triggers. This configuration is ignored for <literal>ON SELECT</literal> rules, which
      are always applied in order to keep views working even if the current
      session is in a non-default replication role.
     </para>

     <para>
      The rule firing mechanism is also affected by the configuration variable
      <xref linkend="guc-session-replication-role"/>, analogous to triggers as
      described above.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      These forms control the application of row security policies belonging
      to the table.  If enabled and no policies exist for the table, then a
      default-deny policy is applied.  Note that policies can exist for a table
      even if row level security is disabled - in this case, the policies will
      NOT be applied and the policies will be ignored.
      See also
      <xref linkend="sql-createpolicy"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      These forms control the application of row security policies belonging
      to the table when the user is the table owner.  If enabled, row level
      security policies will be applied when the user is the table owner.  If
      disabled (the default) then row level security will not be applied when
      the user is the table owner.
      See also
      <xref linkend="sql-createpolicy"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
      This form selects the default index for future
      <xref linkend="sql-cluster"/>
      operations.  It does not actually re-cluster the table.
     </para>
     <para>
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      This form removes the most recently used
      <xref linkend="sql-cluster"/>
      index specification from the table.  This affects
      future cluster operations that don't specify an index.
     </para>
     <para>
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITH OIDS</literal></term>
    <listitem>
     <para>
      This form adds an <literal>oid</literal> system column to the
      table (see <xref linkend="ddl-system-columns"/>).
      It does nothing if the table already has OIDs.
     </para>

     <para>
      Note that this is not equivalent to <literal>ADD COLUMN oid oid</literal>;
      that would add a normal column that happened to be named
      <literal>oid</literal>, not a system column.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      This form removes the <literal>oid</literal> system column from the
      table.  This is exactly equivalent to
      <literal>DROP COLUMN oid RESTRICT</literal>,
      except that it will not complain if there is already no
      <literal>oid</literal> column.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      This form changes the table's tablespace to the specified tablespace and
      moves the data file(s) associated with the table to the new tablespace.
      Indexes on the table, if any, are not moved; but they can be moved
      separately with additional <literal>SET TABLESPACE</literal> commands.
      All tables in the current database in a tablespace can be moved by using
      the <literal>ALL IN TABLESPACE</literal> form, which will lock all tables
      to be moved first and then move each one.  This form also supports
      <literal>OWNED BY</literal>, which will only move tables owned by the
      roles specified.  If the <literal>NOWAIT</literal> option is specified
      then the command will fail if it is unable to acquire all of the locks
      required immediately.  Note that system catalogs are not moved by this
      command, use <command>ALTER DATABASE</command> or explicit
      <command>ALTER TABLE</command> invocations instead if desired.  The
      <literal>information_schema</literal> relations are not considered part
      of the system catalogs and will be moved.
      See also
      <xref linkend="sql-createtablespace"/>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
     <para>
      This form changes the table from unlogged to logged or vice-versa
      (see <xref linkend="sql-createtable-unlogged"/>).  It cannot be applied
      to a temporary table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      This form changes one or more storage parameters for the table.  See
      <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"/>
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you might need to rewrite the table to get the desired effects.
      That can be done with <link linkend="sql-vacuum">VACUUM
      FULL</link>, <xref linkend="sql-cluster"/> or one of the forms
      of <command>ALTER TABLE</command> that forces a table rewrite.
      For planner related parameters, changes will take effect from the next
      time the table is locked so currently executing queries will not be
      affected.
     </para>

     <para>
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock will be taken for
      fillfactor, toast and autovacuum storage parameters, as well as the
      following planner related parameters:
      <varname>effective_io_concurrency</varname>, <varname>parallel_workers</varname>, <varname>seq_page_cost</varname>,
      <varname>random_page_cost</varname>, <varname>n_distinct</varname> and <varname>n_distinct_inherited</varname>.
     </para>

     <note>
      <para>
       While <command>CREATE TABLE</command> allows <literal>OIDS</literal> to be specified
       in the <literal>WITH (<replaceable
       class="parameter">storage_parameter</replaceable>)</literal> syntax,
       <command>ALTER TABLE</command> does not treat <literal>OIDS</literal> as a
       storage parameter.  Instead use the <literal>SET WITH OIDS</literal>
       and <literal>SET WITHOUT OIDS</literal> forms to change OID status.
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</literal>, a table rewrite might be
      needed to update the table entirely.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      This form adds the target table as a new child of the specified parent
      table.  Subsequently, queries against the parent will include records
      of the target table.  To be added as a child, the target table must
      already contain all the same columns as the parent (it could have
      additional columns, too).  The columns must have matching data types,
      and if they have <literal>NOT NULL</literal> constraints in the parent
      then they must also have <literal>NOT NULL</literal> constraints in the
      child.
     </para>

     <para>
      There must also be matching child-table constraints for all
      <literal>CHECK</literal> constraints of the parent, except those
      marked non-inheritable (that is, created with <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
      in the parent, which are ignored; all child-table constraints matched
      must not be marked non-inheritable.
      Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are not considered, but
      this might change in the future.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      This form removes the target table from the list of children of the
      specified parent table.
      Queries against the parent table will no longer include records drawn
      from the target table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
     <para>
      This form links the table to a composite type as though <command>CREATE
      TABLE OF</command> had formed it.  The table's list of column names and types
      must precisely match that of the composite type; the presence of
      an <literal>oid</literal> system column is permitted to differ.  The table must
      not inherit from any other table.  These restrictions ensure
      that <command>CREATE TABLE OF</command> would permit an equivalent table
      definition.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
      This form dissociates a typed table from its type.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER TO</literal></term>
    <listitem>
     <para>
      This form changes the owner of the table, sequence, view, materialized view,
      or foreign table to the specified user.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-replica-identity">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
     <para>
      This form changes the information which is written to the write-ahead log
      to identify rows which are updated or deleted.  This option has no effect
      except when logical replication is in use.  <literal>DEFAULT</literal>
      (the default for non-system tables) records the
      old values of the columns of the primary key, if any.  <literal>USING INDEX</literal>
      records the old values of the columns covered by the named index, which
      must be unique, not partial, not deferrable, and include only columns marked
      <literal>NOT NULL</literal>.  <literal>FULL</literal> records the old values of all columns
      in the row.  <literal>NOTHING</literal> records no information about the old row.
      (This is the default for system tables.)
      In all cases, no old values are logged unless at least one of the columns
      that would be logged differs between the old and new versions of the row.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      The <literal>RENAME</literal> forms change the name of a table
      (or an index, sequence, view, materialized view, or foreign table), the
      name of an individual column in a table, or the name of a constraint of
      the table.  When renaming a constraint that has an underlying index,
      the index is renamed as well.
      There is no effect on the stored data.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      This form moves the table into another schema.  Associated indexes,
      constraints, and sequences owned by table columns are moved as well.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      This form attaches an existing table (which might itself be partitioned)
      as a partition of the target table. The table can be attached
      as a partition for specific values using <literal>FOR VALUES</literal>
      or as a default partition by using <literal>DEFAULT</literal>.
      For each index in the target table, a corresponding
      one will be created in the attached table; or, if an equivalent
      index already exists, will be attached to the target table's index,
      as if <command>ALTER INDEX ATTACH PARTITION</command> had been executed.
     </para>

     <para>
      A partition using <literal>FOR VALUES</literal> uses same syntax for
      <replaceable class="parameter">partition_bound_spec</replaceable> as
      <xref linkend="sql-createtable"/>.  The partition bound specification
      must correspond to the partitioning strategy and partition key of the
      target table.  The table to be attached must have all the same columns
      as the target table and no more; moreover, the column types must also
      match.  Also, it must have all the <literal>NOT NULL</literal> and
      <literal>CHECK</literal> constraints of the target table.  Currently
      <literal>FOREIGN KEY</literal> constraints are not considered.
      <literal>UNIQUE</literal> and <literal>PRIMARY KEY</literal> constraints
      from the parent table will be created in the partition, if they don't
      already exist.
      If any of the <literal>CHECK</literal> constraints of the table being
      attached is marked <literal>NO INHERIT</literal>, the command will fail;
      such a constraint must be recreated without the <literal>NO INHERIT</literal>
      clause.
     </para>

     <para>
      If the new partition is a regular table, a full table scan is performed
      to check that no existing row in the table violates the partition
      constraint.  It is possible to avoid this scan by adding a valid
      <literal>CHECK</literal> constraint to the table that would allow only
      the rows satisfying the desired partition constraint before running this
      command.  It will be determined using such a constraint that the table
      need not be scanned to validate the partition constraint.  This does not
      work, however, if any of the partition keys is an expression and the
      partition does not accept <literal>NULL</literal> values.  If attaching
      a list partition that will not accept <literal>NULL</literal> values,
      also add <literal>NOT NULL</literal> constraint to the partition key
      column, unless it's an expression.
     </para>

     <para>
      If the new partition is a foreign table, nothing is done to verify
      that all the rows in the foreign table obey the partition constraint.
      (See the discussion in <xref linkend="sql-createforeigntable"/> about
      constraints on the foreign table.)
     </para>

     <para>
      When a table has a default partition, defining a new partition changes
      the partition constraint for the default partition. The default
      partition can't contain any rows that would need to be moved to the new
      partition, and will be scanned to verify that none are present. This
      scan, like the scan of the new partition, can be avoided if an
      appropriate <literal>CHECK</literal> constraint is present. Also like
      the scan of the new partition, it is always skipped when the default
      partition is a foreign table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DETACH PARTITION</literal> <replaceable class="parameter">partition_name</replaceable></term>
    <listitem>
     <para>
      This form detaches specified partition of the target table.  The detached
      partition continues to exist as a standalone table, but no longer has any
      ties to the table from which it was detached.  Any indexes that were
      attached to the target table's indexes are detached.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   <command>ALTER TABLE</command>更改一个现有表的定义。下文描述了
   几种形式。注意每一种形式所要求的锁级别可能不同。如果没有明确说明，将会
   持有一个<literal>ACCESS EXCLUSIVE</literal>所。当列出多个子命令时，所
   持有的锁将是子命令所要求的最严格的那一个。

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
    <listitem>
     <para>
      这种形式向该表增加一个新列，使用与
      <xref linkend="sql-createtable"/>相同的语法。如果指定了
      <literal>IF NOT EXISTS</literal>并且使用这个名字的列已经存在，则
      不会抛出错误。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      这种形式从表删除一列。涉及到该列的索引和表约束也将会被自动
      删除。如果该列的移除会导致引用它的多元统计信息仅包含单一列的数据，则该多元统计信息也将被移除。如果在该表之外有任何东西（例如外键引用或者视图）依赖
      于该列，你将需要用到<literal>CASCADE</literal>。如果指定了
      <literal>IF EXISTS</literal>但该列不存在，则不会抛出错误。
      这种情况中会发出一个提示。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
     <para>
      这种形式更改表中一列的类型。涉及到该列的索引和简单表约束将通过
      重新解析最初提供的表达式被自动转换为使用新的列类型。可选的
      <literal>COLLATE</literal>子句为新列指定一种排序规则，如果被省略，
      排序规则会是新列类型的默认排序规则。可选的<literal>USING</literal>
      子句指定如何从旧的列值计算新列值，如果被省略，默认的转换和从旧类型
      到新类型的赋值造型一样。如果没有从旧类型到新类型的隐式或者赋值造型，
      则必须提供一个<literal>USING</literal>子句。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      这些形式为一列设置或者移除默认值。默认值只在后续的
      <command>INSERT</command>或<command>UPDATE</command>命令中生效，
      它们不会导致已经在表中的行改变。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      这些形式更改一列是否被标记为允许空值或者拒绝空值。只有当该列
      不包含空值时，你才能使用<literal>SET NOT NULL</literal>。
     </para>

     <para>
      如果这个表是一个分区，对于在父表中被标记为<literal>NOT NULL</literal>的列，不能在其上执行<literal>DROP NOT NULL</literal>。要从所有的分区中删除<literal>NOT NULL</literal>约束，可以在父表上执行<literal>DROP NOT NULL</literal>。即使在父表上没有<literal>NOT NULL</literal>约束，这样的约束还是能被增加到分区上。也就是说，即便父表允许空值，子表也可以不允许空值，但反过来不行。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      这些形式更改一列是否是一个标识列，或者是更改一个已有的标识列的产生属性。详情请参考<xref linkend="sql-createtable"/>。
     </para>

     <para>
      如果<literal>DROP IDENTITY IF EXISTS</literal>被指定并且该列不是一个标识列，则不会有错误被抛出。在这种情况下会发出一个提示。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET <replaceable>sequence_option</replaceable></literal></term>
    <term><literal>RESTART</literal></term>
    <listitem>
     <para>
      这些形式修改位于一个现有标识列之下的序列。<replaceable>sequence_option</replaceable>是一个<xref linkend="sql-altersequence"/>所支持的选项，例如<literal>INCREMENT BY</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      这种形式为后续的<xref linkend="sql-analyze"/>操作设置针对每列
      的统计收集目标。目标可以被设置在范围 0 到 10000 之间，还可以
      把它设置为 -1 来恢复到使用系统默认的统计目标（
      <xref linkend="guc-default-statistics-target"/>）。更多有关
      <productname>PostgreSQL</productname>查询规划器使用统计
      信息的内容可见<xref linkend="planner-stats"/>。
     </para>
     <para>
      <literal>SET STATISTICS</literal>要求一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      这种形式设置或者重置每个属性的选项。当前，已定义的针对每个属性的
      选项只有<literal>n_distinct</literal>和<literal>n_distinct_inherited</literal>，
      它们会覆盖后续<xref linkend="sql-analyze"/>操作所得到的可区分值数量
      估计。<literal>n_distinct</literal>影响该表本身的统计信息，而
      <literal>n_distinct_inherited</literal>影响为该表外加其继承子女收集的统计信息。
      当被设置为一个正值时，<command>ANALYZE</command>将假定该列刚好包含指定
      数量的可区分非空值。当被设置为一个负值（必须大于等于 -1）时， 
      <command>ANALYZE</command>将假定可区分非空值的数量与表的尺寸成线性比例，
      确切的计数由估计的表尺寸乘以给定数字的绝对值计算得到。例如，值 -1 表示
      该列中所有的值都是可区分的，而值 -0.5 则表示每一个值平均出现两次。当表
      的尺寸随时间变化时，这会有所帮助，因为这种计算只有在查询规划时才会被
      执行。指定值为 0 将回到正常的估计可区分值数量的做法。更多有关
      <productname>PostgreSQL</productname>查询规划器使用统计
      信息的内容可见<xref linkend="planner-stats"/>。
     </para>
     <para>
      更改针对每个属性的选项要求一个
      <literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>per-column storage settings</secondary>
     </indexterm>
    </term>
    <listitem>
     <para>
      这种形式为一列设置存储模式。这会控制这列是会被保持在线内还是放在一个
      二级<acronym>TOAST</acronym>表中，以及数据是否应被压缩。对于
      <type>integer</type>之类的定长、线内、未压缩值必须使用
      <literal>PLAIN</literal>。<literal>MAIN</literal>用于线内、可压缩的
      数据。<literal>EXTERNAL</literal>用于外部的、未压缩数据。而
      <literal>EXTENDED</literal>用于外部的、压缩数据。对于大部分支持
      非-<literal>PLAIN</literal>存储的数据类型，<literal>EXTENDED</literal>
      是默认值。使用<literal>EXTERNAL</literal>将会让很大的
      <type>text</type>和<type>bytea</type>之上的子串操作运行得更快，
      但是代价是存储空间会增加。注意<literal>SET STORAGE</literal>本身并不改变
      表中的任何东西，它只是设置在未来的表更新时要追求的策略。详见
      <xref linkend="storage-toast"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
     <para>
      这种形式使用和<xref linkend="sql-createtable"/>相同的语法外加
      <literal>NOT VALID</literal>选项为一个表增加一个新的约束，该选项
      当前只被允许用于外键和 CHECK 约束。如果约束被标记为
      <literal>NOT VALID</literal>，将会跳过验证表中所有行满足该约束的
      初检，这种检查可能会很漫长。该约束仍将被强制到后续的插入和删除上
      （也就是说，在外键的情况下如果在被引用表中没有一个匹配的行，操作
      会失败；如果新行不匹配指定的检查约束，操作也会失败）。但是数据库
      不会假定约束对该表中的所有行都成立，直到通过使用<literal>VALIDATE
      CONSTRAINT</literal>选项对它进行验证。当前，分区表上的外键约束不可以被声明为<literal>NOT VALID</literal>。
     </para>

     <para>
      外键约束的增加要求在被引用表上的一个<literal>SHARE ROW EXCLUSIVE</literal>锁。
     </para>

     <para>
      当唯一或者主键约束被添加到分区表时，会有额外的限制，请参考<xref linkend="sql-createtable" />。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint_using_index</replaceable></literal></term>
    <listitem>
     <para>
      这种形式基于一个已有的唯一索引为一个表增加新的
      <literal>PRIMARY KEY</literal>或<literal>UNIQUE</literal>约束。该索引中的
      所有列将被包括在约束中。
     </para>

     <para>
      该索引不能有表达式列或者是一个部分索引。还有，它必须是一个带有
      默认排序顺序的 B-树索引。这些限制确保该索引等效于使用常规
      <literal>ADD PRIMARY KEY</literal>或者<literal>ADD UNIQUE</literal>命令
      时创建的索引。
     </para>

     <para>
      如果<literal>PRIMARY KEY</literal>被指定，并且该索引的列没有被标记
      <literal>NOT NULL</literal>，那么这个命令将尝试对每一个这样的列做
      <literal>ALTER COLUMN SET NOT NULL</literal>。这需要一次全表扫描
      来验证这些列不包含空值。在所有其他情况中，这都是一种很快的操作。
     </para>

     <para>
      如果提供了一个约束名，那么该索引将被重命名以匹配该约束名。否则
      该约束将被命名成索引的名称。
     </para>

     <para>
      这个命令被执行后，该索引被增加的约束<quote>拥有</quote>，这和用常规
      <literal>ADD PRIMARY KEY</literal>或<literal>ADD UNIQUE</literal>命令
      创建的索引一样。特别地，删掉该约束将会导致该索引也消失。
     </para>

     <para>
      当前在分区表上不支持这种形式。
     </para>

     <note>
      <para>
       如果需要增加一个新的约束但是不希望长时间阻塞表更新，那么使用现有
       索引增加约束会有所帮助。要这样做，用
       <command>CREATE INDEX CONCURRENTLY</command>创建该索引，并且
       接着使用这种语法把它安装为一个正式的约束。例子见下文。
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
     <para>
      这种形式修改之前创建的一个约束的属性。当前只能修改外键约束。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
     <para>
      这种形式验证之前创建为<literal>NOT VALID</literal>的外键或检查约束，
      它会扫描表来确保对于该约束没有行不满足约束。如果约束已经被标记为合法，
      则什么也不会发生。
     </para>
     <para>
      在大型表上的验证可能是一个长时间的处理。把约束的验证和创建分离开来让
      我们可以把验证过程推迟到系统闲时进行，或者可以得到额外的时间来更正已
      经存在的错误从而避免新的错误。还要注意验证本身并不会在运行时阻止对表
      的写命令。
     </para>
     <para>
      验证只要求被修改表上的一个<literal>SHARE UPDATE EXCLUSIVE</literal>
      锁。如果该约束是一个外键，则还会在被该约束引用的表上要求一个
      <literal>ROW SHARE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
     <para>
      这种形式在一个表上删除指定的约束，还有位于该约束之下的任何索引。如果<literal>IF EXISTS</literal>
      被指定并且该约束不存在，不会抛出错误。在这种情况下会发出一个提示。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
    <listitem>
     <para>
      这些形式配置属于该表的触发器的触发设置。系统仍然知道被禁用触发器
      的存在，但是即使它的触发事件发生也不会执行它。对于一个延迟触发器，
      会在事件发生时而不是触发器函数真正被执行时检查其启用状态。可以禁
      用或者启用用名称指定的单个触发器、表上的所有触发器、用户拥有的触
      发器（这个选项会排除内部生成的约束触发器，例如用来实现外键约束或
      可延迟唯一和排除约束）。禁用或者启用内部生成的约束触发器要求超级
      用户特权，这样做要小心因为如果这类触发器不被执行，约束的完整性当
      然无法保证。
     </para>

     <para>
      触发器引发机制也受到配置变量
      <xref linkend="guc-session-replication-role"/>的影响。当复制角色是
      <quote>origin</quote>（默认）或者<quote>local</quote>时，被简单启用的
      触发器将被触发。被配置为<literal>ENABLE REPLICA</literal>的触发
      器只有在会话处于<quote>replica</quote>模式时才将被触发。被配置为
      <literal>ENABLE ALWAYS</literal>的触发器的触发不会考虑当前复制
      角色。
     </para>

     <para>
      这种机制的效果就是，在默认配置中，触发器不会在复制体上引发。这种效果很有用，因为如果一个触发器在源头上被用来在表之间传播数据，那么复制系统也将复制被传播的数据，并且触发器不应该在复制体上引发第二次，因为那会导致重复。不过，如果一个触发器被用于另一种目的（例如创建外部告警），那么将它设置为<literal>ENABLE ALWAYS</literal>可能更加合适，这样它在复制体上也会被引发。
     </para>

     <para>
      这个命令要求一个<literal>SHARE ROW EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
    <listitem>
     <para>
      这些形式配置属于表的重写规则的触发设置。系统仍然知道一个被禁用规则的
      存在，但在查询重写时不会应用它。其语义与禁用的/启用的触发器的一样。
      对于<literal>ON SELECT</literal>规则会忽略这个配置，即使当前会话处于
      一种非默认的复制角色，这类规则总是会被应用以保持视图工作正常。
     </para>

     <para>
      规则引发机制也受到配置变量<xref linkend="guc-session-replication-role"/>的影响，这和上述的触发器类似。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      这些形式控制属于该表的行安全性策略的应用。如果被启用并且该表上
      不存在策略，则将应用一个默认否定的策略。注意即使行级安全性被禁
      用，在表上还是可以存在策略。在这种情况下，这些策略将 不 会被应用
      并且会被忽略。另见<xref linkend="sql-createpolicy"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
    <listitem>
     <para>
      这些形式控制当用户是表拥有者时表上的行安全性策略的应用。如果被启用，
      当用户是表拥有者时，行级安全性策略将被应用。如果被禁用（默认），则
      当用户是表拥有者时，行级安全性将不会被应用。另见
      <xref linkend="sql-createpolicy"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
     <para>
      这种形式为未来的<xref linkend="sql-cluster"/>操作选择默认的索引。
      它不会真正地对表进行聚簇。
     </para>
     <para>
      改变聚簇选项要求一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      这种形式从表中移除最近使用的
      <xref linkend="sql-cluster"/>索引说明。这会影响未来的不指定索引
      的聚簇操作。
     </para>
     <para>
      改变聚簇选项要求一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITH OIDS</literal></term>
    <listitem>
     <para>
      这种形式为表增加一个<literal>oid</literal>系统列（见
      <xref linkend="ddl-system-columns"/>）。如果该表已经有 OID，则它
      什么也不会做。
     </para>

     <para>
      注意这不等效于<literal>ADD COLUMN oid oid</literal>，后者只是会增加一个
      恰好名为<literal>oid</literal>的普通列而不是系统列。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      这种形式从该表移除<literal>oid</literal>系统列。这完全等效于
      <literal>DROP COLUMN oid RESTRICT</literal>，不过如果没有
      <literal>oid</literal>列它不会抱怨。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      这种形式把该表的表空间更改为指定的表空间并且把该表相关联的数据文件
      移动到新的表空间中。表上的索引（如果有）不会被移动，但是它们可以用
      额外的<literal>SET TABLESPACE</literal>命令单独移动。当前数据库在
      一个表空间中的所有表可以用<literal>ALL IN TABLESPACE</literal>形式
      移动，这将会首先锁住所有将被移动的表然后逐个移动。这种形式也支持
      <literal>OWNED BY</literal>，它将只移动指定角色所拥有的表。如果指
      定了<literal>NOWAIT</literal>选项，则命令将在无法立刻获得所有所需
      要的锁时失败。注意这个命令不移动系统目录，如果想要移动系统目录，应
      该用<command>ALTER DATABASE</command>或者显式的
      <command>ALTER TABLE</command>调用。对于这种形式来说，
      <literal>information_schema</literal>关系不被认为是系统目录的一部分，
      因此它们将会被移动。另见<xref linkend="sql-createtablespace"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
     <para>
      This form changes the table from unlogged to logged or vice-versa
      (see <xref linkend="sql-createtable-unlogged"/>).  It cannot be applied
      to a temporary table.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      这种形式为该表更改一个或者更多存储参数。可用的参数请见
      <xref linkend="sql-createtable-storage-parameters"
      endterm="sql-createtable-storage-parameters-title"/>。注意这个
      命令将不会立刻修改表内容，这取决于重写表以得到想要的结果可能需要的
      参数。可以用<link linkend="sql-vacuum">VACUUM
      FULL</link>、<xref linkend="sql-cluster"/>或者
      <command>ALTER TABLE</command>的一种形式来强制一次表重写。对于规划器相关的参数，更改将从该表下一次被锁定开始生效，因此当前执行的查询不会受到影响。
     </para>
     
     <para>
      对fillfactor、toast以及autovacuum存储参数，还有下面的规划器相关参数，将会拿取<literal>SHARE UPDATE EXCLUSIVE</literal>锁：
      <varname>effective_io_concurrency</varname>、<varname>parallel_workers</varname>、<varname>seq_page_cost</varname>、<varname>random_page_cost</varname>、<varname>n_distinct</varname>以及<varname>n_distinct_inherited</varname>。
     </para>

     <note>
      <para>
       虽然<command>CREATE TABLE</command>允许在<literal>WITH (<replaceable
       class="parameter">storage_parameter</replaceable>)</literal>语法中指定
       <literal>OIDS</literal>，但是
       <command>ALTER TABLE</command>没有把<literal>OIDS</literal>当作一个存储
       参数，而是使用<literal>SET WITH OIDS</literal>
       和<literal>SET WITHOUT OIDS</literal>形式来更改 OID 状态。
      </para>
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
     <para>
      这种形式把一个或者更多存储参数重置到它们的默认值。和
      <literal>SET</literal>一样，可能需要一次表重写来更新整个表。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      这种形式把目标表增加为指定父表的一个新子女。随后，针对父亲的查询将
      包括目标表中的记录。要被增加为一个子女，目标表必须已经包含和父表完
      全相同的列（也可以有额外的列）。这些列必须具有匹配的数据类型，并且
      如果它们在父表中具有<literal>NOT NULL</literal>约束，它们在子表中
      也必须有<literal>NOT NULL</literal>约束。
     </para>

     <para>
      也必须把子表约束与所有父表的<literal>CHECK</literal>约束进行匹配，
      不过父表中那些被标记为非可继承（也就是用<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>
      创建的）除外，它们会被忽略。所有匹配得上的子表约束不能被标记为不可
      继承。当前，<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>
      以及<literal>FOREIGN KEY</literal>约束没有被考虑，但是这种情况可能
      会在未来发生变化。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
     <para>
      这种形式把目标表从指定父表的子女列表中移除。针对父表的查询将不再包括
      来自目标表的记录。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
     <para>
      这种形式把该表链接到一种组合类型，就好像<command>CREATE
      TABLE OF</command>所做的那样。该表的列名和类型列表必须精确地匹配
      该组合类型。<literal>oid</literal>系统列的存在情况可以不同。该表必须
      不从任何其他表继承。这些限制确保
      <command>CREATE TABLE OF</command>能允许一个等价的表定义。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
     <para>
      这种形式解除一个有类型的表和其类型之间的关联。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER TO</literal></term>
    <listitem>
     <para>
      这种形式把表、序列、视图、物化视图或外部表的拥有者改为指定用户。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-replica-identity">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
     <para>
      这种形式更改被写入到预写式日志来标识被更新或删除行的信息。除非使用逻辑复制，
      这个选项将不会产生效果。<literal>DEFAULT</literal>（非系统表的默认值）记录主键列
      （如果有）的旧值。<literal>USING INDEX</literal>记录被所提到的索引所覆盖的列的
      旧值，该索引必须是唯一索引、不是部分索引、不是可延迟索引并且只包括被标记成
      <literal>NOT NULL</literal>的列。<literal>FULL</literal>记录行中所有列的旧值。
      <literal>NOTHING</literal>不记录有关旧行的任何信息（这是系统表的默认值）。在所
      有情况下，除非至少有一个要被记录的列在新旧行版本之间发生变化，将不记录旧值。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      <literal>RENAME</literal>形式更改一个表（或者一个索引、序列、视图、物化视图
      或者外部表）的名称、表中一个列的名称或者表的一个约束的名称。在重命名一个具有底层索引的约束时，该索引也会被重命名。它对已存储的数据
      没有影响。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
     <para>
      这种形式把该表移动到另一个模式中。相关的该表列拥有的索引、约束和序列也会被
      移动。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
     <para>
      这种形式把一个已有表（自身也可能被分区）作为一个分区挂接到目标表。该表可以为特定的值使用<literal>FOR VALUES</literal>挂接为分区，或者用<literal>DEFAULT</literal>挂接为一个默认分区。对于目标表中的每一个索引，在被挂接的表上都将创建一个响应的索引，如果已经存在等效的索引，该索引将被挂接到目标表的索引，就像执行了<command>ALTER INDEX ATTACH PARTITION</command>一样。
     </para>

     <para>
      一个使用<literal>FOR VALUES</literal>的分区使用与<xref linkend="sql-createtable"/>中<replaceable class="parameter">partition_bound_spec</replaceable>相同的语法。分区边界说明必须对应于目标表的分区策略以及分区键。要被挂接的表必须具有和目标表完全相同的所有列，并且不能有多出来的列，而且列的类型也必须匹配。此外，它必须有目标表上所有的<literal>NOT NULL</literal>以及<literal>CHECK</literal>约束。当前不考虑<literal>FOREIGN KEY</literal>约束。来自于父表的<literal>UNIQUE</literal>和<literal>PRIMARY KEY</literal>约束将被创建在分区上（如果它们还不存在）。如果被挂接的表上的任何<literal>CHECK</literal>约束被标记为<literal>NO INHERIT</literal>，则命令将失败，这类约束必须被重建且重建时不能有<literal>NO INHERIT</literal>子句。
     </para>

     <para>
      如果新分区是一个常规表，会执行一次全表扫描来检查表中没有现有行违背分区约束。可以通过对表增加一个有效的<literal>CHECK</literal>约束来避免这种扫描，该约束可以在运行这个命令之前仅允许满足所需分区约束的行。
      使用这样一个约束，就可以让表无需被扫描就能验证分区约束。但是，如果任一分区键是一个表达式并且该分区不接受<literal>NULL</literal>值，这种方式就无效了。如果挂接一个不接受<literal>NULL</literal>值的列表分区，还应该为分区键列增加<literal>NOT NULL</literal>约束，除非它是一个表达式。
     </para>

     <para>
      如果新分区是一个外部表，则不需要验证该外部表中的所有行遵守分区约束（有关外部表上的约束请参考<xref linkend="sql-createforeigntable"/>中的讨论）。
     </para>

     <para>
      当一个表有默认分区时，定义新分区会更改默认分区的分区约束。默认分区不能包含任何需要被移动到新分区中的行，并且将被扫描以验证不存在那样的行。如果一个合适的<literal>CHECK</literal>约束存在，这种扫描（和新分区的扫描一样）可以被避免。还是和新分区的扫描一样，当默认分区是外部表时这种扫描总是会被跳过。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DETACH PARTITION</literal> <replaceable class="parameter">partition_name</replaceable></term>
    <listitem>
     <para>
      这种形式会分离目标表的指定分区。被分离的分区继续作为独立的表存在，但是与它之前挂接的表不再有任何联系。任何被挂接到目标表索引的索引也会被分离。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   All the forms of ALTER TABLE that act on a single table, except
   <literal>RENAME</literal>, <literal>SET SCHEMA</literal>,
   <literal>ATTACH PARTITION</literal>, and
   <literal>DETACH PARTITION</literal> can be combined into
   a list of multiple alterations to be applied together.  For example, it
   is possible to add several columns and/or alter the type of several
   columns in a single command.  This is particularly useful with large
   tables, since only one pass over the table need be made.
  </para>
____________________________________________________________________________-->
  <para>
   除了<literal>RENAME</literal>、<literal>SET SCHEMA</literal>、<literal>ATTACH PARTITION</literal>和<literal>DETACH PARTITION</literal>之外，所有形式的ALTER TABLE都作用在单个表上，前面这些形式可以被组合成一个多修改的列表被一起应用。例如，可以在一个命令中增加多个列并且/或者修改多个列的类型。对于大型表来说这会特别有用，因为只需要对表做一趟操作。
  </para>

<!--==========================orignal english content==========================
  <para>
   You must own the table to use <command>ALTER TABLE</command>.
   To change the schema or tablespace of a table, you must also have
   <literal>CREATE</literal> privilege on the new schema or tablespace.
   To add the table as a new child of a parent table, you must own the parent
   table as well.  Also, to attach a table as a new partition of the table,
   you must own the table being attached.
   To alter the owner, you must also be a direct or indirect member of the new
   owning role, and that role must have <literal>CREATE</literal> privilege on
   the table's schema.  (These restrictions enforce that altering the owner
   doesn't do anything you couldn't do by dropping and recreating the table.
   However, a superuser can alter ownership of any table anyway.)
   To add a column or alter a column type or use the <literal>OF</literal>
   clause, you must also have <literal>USAGE</literal> privilege on the data
   type.
  </para>
____________________________________________________________________________-->
  <para>
   要使用<command>ALTER TABLE</command>，你必须拥有该表。要更改一个表的
   模式或者表空间，你还必须拥有新模式或表空间上的
   <literal>CREATE</literal>特权。要把一个表作为一个父表的新子表加入，
   你必须也拥有该父表。此外，要把一个表挂接为另一个表的新分区，你必须拥有被挂接的表。要更改拥有者，你还必须
   是新拥有角色的一个直接或者间接成员，并且该角色必须具有该表的模式上的
   <literal>CREATE</literal>特权（这些限制强制修改拥有者不能做一些通过删除和重
   建表做不到的事情。不过，一个超级用户怎么都能更改任何表的所有权。）。
   要增加一个列、修改一列的类型或者使用<literal>OF</literal>子句，你还必
   须具有该数据类型上的<literal>USAGE</literal>特权。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

    <variablelist>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>IF EXISTS</literal></term>
____________________________________________________________________________-->
      <term><literal>IF EXISTS</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Do not throw an error if the table does not exist. A notice is issued
        in this case.
       </para>
____________________________________________________________________________-->
       <para>
        如果表不存在则不要抛出一个错误。这种情况下会发出一个提示。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name (optionally schema-qualified) of an existing table to
        alter. If <literal>ONLY</literal> is specified before the table name, only
        that table is altered. If <literal>ONLY</literal> is not specified, the table
        and all its descendant tables (if any) are altered.  Optionally,
        <literal>*</literal> can be specified after the table name to explicitly
        indicate that descendant tables are included.
       </para>
____________________________________________________________________________-->
       <para>
        要修改的一个现有表的名称（可以是模式限定的）。如果在表名前指定了
        <literal>ONLY</literal>，则只会修改该表。如果没有指定<literal>ONLY</literal>，
        该表及其所有后代表（如果有）都会被修改。可选地，在表名后面可以指定
        <literal>*</literal>用来显式地指示包括后代表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Name of a new or existing column.
       </para>
____________________________________________________________________________-->
       <para>
        一个新列或者现有列的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">new_column_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">new_column_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        New name for an existing column.
       </para>
____________________________________________________________________________-->
       <para>
        一个现有列的新名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">new_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">new_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        New name for the table.
       </para>
____________________________________________________________________________-->
       <para>
        该表的新名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">data_type</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">data_type</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Data type of the new column, or new data type for an existing
        column.
       </para>
____________________________________________________________________________-->
       <para>
        一个新列的数据类型或者一个现有列的新数据类型。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">table_constraint</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">table_constraint</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        New table constraint for the table.
       </para>
____________________________________________________________________________-->
       <para>
        该表的新的表约束。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">constraint_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">constraint_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Name of a new or existing constraint.
       </para>
____________________________________________________________________________-->
       <para>
        一个新约束或者现有约束的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>CASCADE</literal></term>
____________________________________________________________________________-->
      <term><literal>CASCADE</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Automatically drop objects that depend on the dropped column
        or constraint (for example, views referencing the column),
        and in turn all objects that depend on those objects
        (see <xref linkend="ddl-depend"/>).
       </para>
____________________________________________________________________________-->
       <para>
        自动删除依赖于被删除列或约束的对象（例如引用该列的视图），
        并且接着删除依赖于那些对象的
        所有对象（见<xref linkend="ddl-depend"/>）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>RESTRICT</literal></term>
____________________________________________________________________________-->
      <term><literal>RESTRICT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Refuse to drop the column or constraint if there are any dependent
        objects. This is the default behavior.
       </para>
____________________________________________________________________________-->
       <para>
        如果有任何依赖对象时拒绝删除列或者约束。这是默认行为。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">trigger_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">trigger_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Name of a single trigger to disable or enable.
       </para>
____________________________________________________________________________-->
       <para>
        一个要禁用或启用的触发器的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>ALL</literal></term>
____________________________________________________________________________-->
      <term><literal>ALL</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Disable or enable all triggers belonging to the table.
        (This requires superuser privilege if any of the triggers are
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.)
       </para>
____________________________________________________________________________-->
       <para>
        禁用或者启用属于该表的所有触发器（如果有任何触发器是内部产生的约
        束触发器则需要超级用户特权，例如那些被用来实现外键约束或者可延迟
        一致性和排他约束的触发器）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>USER</literal></term>
____________________________________________________________________________-->
      <term><literal>USER</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Disable or enable all triggers belonging to the table except for
        internally generated constraint triggers such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.
       </para>
____________________________________________________________________________-->
       <para>
        禁用或者启用属于该表的所有触发器，内部产生的约束触发器（例如那些
        被用来实现外键约束或者可延迟一致性和排他约束的触发器）除外。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">index_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">index_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of an existing index.
       </para>
____________________________________________________________________________-->
       <para>
        一个现有索引的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a table storage parameter.
       </para>
____________________________________________________________________________-->
       <para>
        一个表存储参数的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">value</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
       </para>
____________________________________________________________________________-->
       <para>
        一个表存储参数的新值。根据该参数，该值可能是一个数字或者一个词。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">parent_table</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">parent_table</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A parent table to associate or de-associate with this table.
       </para>
____________________________________________________________________________-->
       <para>
        要与这个表关联或者解除关联的父表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">new_owner</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">new_owner</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The user name of the new owner of the table.
       </para>
____________________________________________________________________________-->
       <para>
        该表的新拥有者的用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">new_tablespace</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">new_tablespace</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the tablespace to which the table will be moved.
       </para>
____________________________________________________________________________-->
       <para>
        要把该表移入其中的表空间的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">new_schema</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">new_schema</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the schema to which the table will be moved.
       </para>
____________________________________________________________________________-->
       <para>
        要把该表移入其中的模式的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">partition_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">partition_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the table to attach as a new partition or to detach from this table.
       </para>
____________________________________________________________________________-->
       <para>
        要被作为新分区附着到这个表或者从这个表上分离的表的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">partition_bound_spec</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">partition_bound_spec</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The partition bound specification for a new partition.  Refer to
        <xref linkend="sql-createtable"/> for more details on the syntax of the same.
       </para>
____________________________________________________________________________-->
       <para>
        新分区的分区边界说明。更多细节请参考<xref linkend="sql-createtable"/>中相同的语法。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    The key word <literal>COLUMN</literal> is noise and can be omitted.
   </para>
____________________________________________________________________________-->
   <para>
    关键词<literal>COLUMN</literal>是噪声，可以被省略。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a column is added with <literal>ADD COLUMN</literal> and a
    non-volatile <literal>DEFAULT</literal> is specified, the default is
    evaluated at the time of the statement and the result stored in the
    table's metadata.  That value will be used for the column for all existing
    rows.  If no <literal>DEFAULT</literal> is specified, NULL is used.  In
    neither case is a rewrite of the table required.
   </para>
____________________________________________________________________________-->
   <para>
    在使用<literal>ADD COLUMN</literal>增加一列并且指定了一个非易失性<literal>DEFAULT</literal>时，默认值会在该语句执行时计算并且结果会被保存在表的元数据中。这个值将被用于所有现有行的该列。如果没有指定<literal>DEFAULT</literal>，则使用NULL。在两种情况下都不需要重写表。
   </para>

<!--==========================orignal english content==========================
   <para>
    Adding a column with a volatile <literal>DEFAULT</literal> or
    changing the type of an existing column will require the entire table and
    its indexes to be rewritten. As an exception, when changing the type of an
    existing column, if the <literal>USING</literal> clause does not change
    the column contents and the old type is either binary coercible to the new
    type or an unconstrained domain over the new type, a table rewrite is not
    needed; but any indexes on the affected columns must still be rebuilt.
    Adding or removing a system <literal>oid</literal> column also requires
    rewriting the entire table.  Table and/or index rebuilds may take a
    significant amount of time for a large table; and will temporarily require
    as much as double the disk space.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个带有非易失性<literal>DEFAULT</literal>子句的列或者更改一个现有列的类型将
    要求重写整个表及其索引。在更改一个现有列的类型时有一种例外：如果
    <literal>USING</literal>子句不更改列的内容并且旧类型在二进制上与新类型可
    强制转换或者是新类型上的一个未约束域，则不需要重写表。但是受影响列上
    的任何索引仍必须被重建。增加或者移除一个系统<literal>oid</literal>列也要求
    重写整个表。对于一个大型表，表和/或索引重建可能会消耗相当多的时间，
    并且会临时要求差不多两倍的磁盘空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    Adding a <literal>CHECK</literal> or <literal>NOT NULL</literal> constraint requires
    scanning the table to verify that existing rows meet the constraint,
    but does not require a table rewrite.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个<literal>CHECK</literal>或者<literal>NOT NULL</literal>约束要求扫描
    表以验证现有行符合该约束，但是不要求一次表重写。
   </para>

<!--==========================orignal english content==========================
   <para>
    Similarly, when attaching a new partition it may be scanned to verify that
    existing rows meet the partition constraint.
   </para>
____________________________________________________________________________-->
   <para>
    类似地，在挂接一个新分区时，它需要被扫描以验证现有行满足该分区约束。
   </para>

<!--==========================orignal english content==========================
   <para>
    The main reason for providing the option to specify multiple changes
    in a single <command>ALTER TABLE</command> is that multiple table scans or
    rewrites can thereby be combined into a single pass over the table.
   </para>
____________________________________________________________________________-->
   <para>
    提供在一个<command>ALTER TABLE</command>中指定多个更改的选项的主要
    原因就是多次表扫描或者重写可以因此被整合成一次。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>DROP COLUMN</literal> form does not physically remove
    the column, but simply makes it invisible to SQL operations.  Subsequent
    insert and update operations in the table will store a null value for the
    column. Thus, dropping a column is quick but it will not immediately
    reduce the on-disk size of your table, as the space occupied
    by the dropped column is not reclaimed.  The space will be
    reclaimed over time as existing rows are updated.  (These statements do
    not apply when dropping the system <literal>oid</literal> column; that is done
    with an immediate rewrite.)
   </para>
____________________________________________________________________________-->
   <para>
    <literal>DROP COLUMN</literal>形式不会在物理上移除列，而只是简
    单地让它对 SQL 操作不可见。后续该表中的插入和更新操作将为该列存储
    一个空值。因此，删除一个列很快，但是它不会立刻减少表所占的磁盘空间，
    因为被删除列所占用的空间还没有被回收。随着现有列被更新，空间将被逐渐
    回收（这些说法不适用于删除系统<literal>oid</literal>列的情况，那时会立刻
    使用重写来完成）。
   </para>

<!--==========================orignal english content==========================
   <para>
    To force immediate reclamation of space occupied by a dropped column,
    you can execute one of the forms of <command>ALTER TABLE</command> that
    performs a rewrite of the whole table.  This results in reconstructing
    each row with the dropped column replaced by a null value.
   </para>
____________________________________________________________________________-->
   <para>
    要强制立即回收被已删除列占据的空间，你可以执行一种能导致全表重写的
    <command>ALTER TABLE</command>形式。这种形式会导致重新构造每一个把被
    删除列替换为空值的行。
   </para>

<!--==========================orignal english content==========================
   <para>
    The rewriting forms of <command>ALTER TABLE</command> are not MVCC-safe.
    After a table rewrite, the table will appear empty to concurrent
    transactions, if they are using a snapshot taken before the rewrite
    occurred.  See <xref linkend="mvcc-caveats"/> for more details.
   </para>
____________________________________________________________________________-->
   <para>
    <command>ALTER TABLE</command>的重写形式对于 MVCC 是不安全的。
    在一次表重写之后，如果并发事务使用的是一个在重写发生前取得的
    快照，该表将对这些并发事务呈现出空表的形态。详见
    <xref linkend="mvcc-caveats"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>USING</literal> option of <literal>SET DATA TYPE</literal> can actually
    specify any expression involving the old values of the row; that is, it
    can refer to other columns as well as the one being converted.  This allows
    very general conversions to be done with the <literal>SET DATA TYPE</literal>
    syntax.  Because of this flexibility, the <literal>USING</literal>
    expression is not applied to the column's default value (if any); the
    result might not be a constant expression as required for a default.
    This means that when there is no implicit or assignment cast from old to
    new type, <literal>SET DATA TYPE</literal> might fail to convert the default even
    though a <literal>USING</literal> clause is supplied.  In such cases,
    drop the default with <literal>DROP DEFAULT</literal>, perform the <literal>ALTER
    TYPE</literal>, and then use <literal>SET DEFAULT</literal> to add a suitable new
    default.  Similar considerations apply to indexes and constraints involving
    the column.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>SET DATA TYPE</literal>的<literal>USING</literal>选项能实际指定
    涉及该列旧值的任何表达式。也就是说，它可以不但可以引用要被转换的列，
    还可以引用其他列。这允许使用<literal>SET DATA TYPE</literal>语法完成十分
    普遍的转换。由于这种灵活性，<literal>USING</literal>表达式不适合于列
    的默认值（如果有），结果可能不是一个默认值所需的常量表达式。这意味着
    在没有从旧类型到新类型的隐式或者赋值造型时，即便提供了一个
    <literal>USING</literal>子句，<literal>SET DATA TYPE</literal>还是可能无法
    转换默认值。在这种情况下，用<literal>DROP DEFAULT</literal>删除该默认值，
    执行<literal>ALTER TYPE</literal>并且接着使用<literal>SET DEFAULT</literal>增加
    一个合适的新默认值。类似的考虑也适用于涉及该列的索引和约束。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a table has any descendant tables, it is not permitted to add,
    rename, or change the type of a column in the parent table without doing
    the same to the descendants.  This ensures that the descendants always
    have columns matching the parent.  Similarly, a <literal>CHECK</literal>
    constraint cannot be renamed in the parent without also renaming it in
    all descendants, so that <literal>CHECK</literal> constraints also match
    between the parent and its descendants.  (That restriction does not apply
    to index-based constraints, however.)
    Also, because selecting from the parent also selects from its descendants,
    a constraint on the parent cannot be marked valid unless it is also marked
    valid for those descendants.  In all of these cases, <command>ALTER TABLE
    ONLY</command> will be rejected.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个表有任何后代表，在不对后代表做相同操作的情况下，不允许在父表中增加列、重命名列或者更改列的类型。这确保了后代总是具有和父表匹配的列。类似地，如果不对所有后代上的<literal>CHECK</literal>约束进行重命名，就不能在父表中重命名该<literal>CHECK</literal>约束，这样<literal>CHECK</literal>约束也能在父表及其后代之间保持匹配（不过，这个限制不适用于基于索引的约束）。此外，因为从父表中选择也会从其后代中选择，父表上的约束不能被标记为有效，除非它在那些后代上也被标记为有效。在所有这些情况下，<command>ALTER TABLE ONLY</command>都将被拒绝。
   </para>

<!--==========================orignal english content==========================
   <para>
    A recursive <literal>DROP COLUMN</literal> operation will remove a
    descendant table's column only if the descendant does not inherit
    that column from any other parents and never had an independent
    definition of the column.  A nonrecursive <literal>DROP
    COLUMN</literal> (i.e., <command>ALTER TABLE ONLY ... DROP
    COLUMN</command>) never removes any descendant columns, but
    instead marks them as independently defined rather than inherited.
    A nonrecursive <literal>DROP COLUMN</literal> command will fail for a
    partitioned table, because all partitions of a table must have the same
    columns as the partitioning root.
   </para>
____________________________________________________________________________-->
   <para>
    只有当一个后代表的列不是从任何其他父表继承而来并且没有该列的独立定义时，
    一次递归的<literal>DROP COLUMN</literal>操作才会移除该列。一次非递归
    的<literal>DROP COLUMN</literal>（即
    <command>ALTER TABLE ONLY ... DROP COLUMN</command>）不会移除
    任何后代列，而是会把它们标记成独立定义的列。对于一个分区表，一个非递归的<literal>DROP COLUMN</literal>命令将会失败，因为一个表的所有分区都必须有和分区根节点相同的列。
   </para>

<!--==========================orignal english content==========================
   <para>
    The actions for identity columns (<literal>ADD
    GENERATED</literal>, <literal>SET</literal> etc., <literal>DROP
    IDENTITY</literal>), as well as the actions
    <literal>TRIGGER</literal>, <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    and <literal>TABLESPACE</literal> never recurse to descendant tables;
    that is, they always act as though <literal>ONLY</literal> were specified.
    Adding a constraint recurses only for <literal>CHECK</literal> constraints
    that are not marked <literal>NO INHERIT</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    标识列的动作（<literal>ADD GENERATED</literal>、<literal>SET</literal>等、<literal>DROP
    IDENTITY</literal>）以及动作<literal>TRIGGER</literal>、<literal>CLUSTER</literal>、<literal>OWNER</literal>和<literal>TABLESPACE</literal>不会递归到后代表上，也就是说它们执行时总是好像指定了<literal>ONLY</literal>一样。增加约束的动作仅对没有标记为<literal>NO INHERIT</literal>的<literal>CHECK</literal>约束递归。
   </para>

<!--==========================orignal english content==========================
   <para>
    Changing any part of a system catalog table is not permitted.
   </para>
____________________________________________________________________________-->
   <para>
    不允许更改一个系统目录表的任何部分。
   </para>

<!--==========================orignal english content==========================
   <para>
    Refer to <xref linkend="sql-createtable"/> for a further description of valid
    parameters. <xref linkend="ddl"/> has further information on
    inheritance.
   </para>
____________________________________________________________________________-->
   <para>
    可用参数的进一步描述请见<xref linkend="sql-createtable"/>。
    <xref linkend="ddl"/>中有关于继承的进一步信息。
   </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   To add a column of type <type>varchar</type> to a table:
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要向一个表增加一个类型为<type>varchar</type>的列：
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To drop a column from a table:
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要从表中删除一列：
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To change the types of two existing columns in one operation:
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要在一个操作中更改两个现有列的类型：
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To change an integer column containing Unix timestamps to <type>timestamp
   with time zone</type> via a <literal>USING</literal> clause:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   通过一个<literal>USING</literal>子句更改一个包含 Unix 时间戳的整数列为
   <type>timestamp with time zone</type>：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The same, when the column has a default expression that won't automatically
   cast to the new data type:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   同样的，当该列具有一个不能自动造型成新数据类型的默认值表达式时：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To rename an existing column:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   To rename an existing column:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To rename an existing table:
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   重命名一个现有的表：
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To rename an existing constraint:
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   重命名一个现有的约束：
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a not-null constraint to a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   To remove a not-null constraint from a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为一列增加一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   从一列移除一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a check constraint to a table and all its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   向一个表及其所有子女增加一个检查约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a check constraint only to a table and not to its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   (The check constraint will not be inherited by future children, either.)
  </para>
____________________________________________________________________________-->
  <para>
   只向一个表增加一个检查约束（不为其子女增加）：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   （该检查约束也不会被未来的子女继承）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To remove a check constraint from a table and all its children:
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   从一个表及其子女移除一个检查约束：
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To remove a check constraint from one table only:
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   (The check constraint remains in place for any child tables.)
  </para>
____________________________________________________________________________-->
  <para>
   只从一个表移除一个检查约束：
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   （该检查约束仍为子女表保留在某个地方）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a foreign key constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为一个表增加一个外键约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a foreign key constraint to a table with the least impact on other work:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为一个表增加一个外键约束，并且尽量不要影响其他工作：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add a (multicolumn) unique constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为一个表增加一个（多列）唯一约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To add an automatically named primary key constraint to a table, noting
   that a table can only ever have one primary key:
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   为一个表增加一个自动命名的主键约束，注意一个表只能拥有一个主键：
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To move a table to a different tablespace:
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   把一个表移动到一个不同的表空间：
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To move a table to a different schema:
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   把一个表移动到一个不同的模式：
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To recreate a primary key constraint, without blocking updates while the
   index is rebuilt:
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>
____________________________________________________________________________-->
  <para>
   重建一个主键约束，并且在重建索引期间不阻塞更新：
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   To attach a partition to a range-partitioned table:
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
____________________________________________________________________________-->
  <para>
   要把一个分区挂接到一个范围分区表上：
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   To attach a partition to a list-partitioned table:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>
____________________________________________________________________________-->
  <para>
   要把一个分区挂接到一个列表分区表上：
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   To attach a partition to a hash-partitioned table:
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   要把一个分区挂接到一个哈希分区表上：
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   To attach a default partition to a partitioned table:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>
____________________________________________________________________________-->
  <para>
   要把一个默认分区挂接到一个分区表上：
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>

<!--==========================orignal english content==========================
  <para>
   To detach a partition from a partitioned table:
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>
____________________________________________________________________________-->
  <para>
   从一个分区表分离一个分区：
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   The forms <literal>ADD</literal> (without <literal>USING INDEX</literal>),
   <literal>DROP [COLUMN]</literal>, <literal>DROP IDENTITY</literal>, <literal>RESTART</literal>,
   <literal>SET DEFAULT</literal>, <literal>SET DATA TYPE</literal> (without <literal>USING</literal>),
   <literal>SET GENERATED</literal>, and <literal>SET <replaceable>sequence_option</replaceable></literal>
   conform with the SQL standard.  The other forms are
   <productname>PostgreSQL</productname> extensions of the SQL standard.
   Also, the ability to specify more than one manipulation in a single
   <command>ALTER TABLE</command> command is an extension.
  </para>
____________________________________________________________________________-->
  <para>
   形式<literal>ADD</literal>（没有<literal>USING INDEX</literal>）、
   <literal>DROP [COLUMN]</literal>、<literal>DROP IDENTITY</literal>、<literal>RESTART</literal>、
   <literal>SET DEFAULT</literal>、<literal>SET DATA TYPE</literal>（没有<literal>USING</literal>)、
   <literal>SET GENERATED</literal>以及<literal>SET <replaceable>sequence_option</replaceable></literal>服从SQL标准。其他形式都是<productname>PostgreSQL</productname>对SQL标准的扩展。此外，在单个<command>ALTER TABLE</command>命令中指定多个操作的能力是一种扩展。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>ALTER TABLE DROP COLUMN</command> can be used to drop the only
   column of a table, leaving a zero-column table.  This is an
   extension of SQL, which disallows zero-column tables.
  </para>
____________________________________________________________________________-->
  <para>
   <command>ALTER TABLE DROP COLUMN</command>可以被用来删除一个表的唯一的
   列，从而留下一个零列的表。这是一种 SQL 的扩展，SQL 中不允许零列的表。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
