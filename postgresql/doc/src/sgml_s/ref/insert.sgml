<!--
doc/src/sgml/ref/insert.sgml
PostgreSQL documentation
-->

<refentry id="sql-insert">
<!--==========================orignal english content==========================
 <indexterm zone="sql-insert">
  <primary>INSERT</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-insert">
  <primary>INSERT</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>INSERT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>INSERT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>INSERT</refname>
  <refpurpose>create new rows in a table</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>INSERT</refname>
  <refpurpose>在一个表中创建新行</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
INSERT INTO <replaceable class="parameter">table_name</replaceable> [ AS <replaceable class="parameter">alias</replaceable> ] [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER} VALUE ]
    { DEFAULT VALUES | VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) [, ...] | <replaceable class="parameter">query</replaceable> }
    [ ON CONFLICT [ <replaceable class="parameter">conflict_target</replaceable> ] <replaceable class="parameter">conflict_action</replaceable> ]
    [ RETURNING * | <replaceable class="parameter">output_expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]

<phrase>where <replaceable class="parameter">conflict_target</replaceable> can be one of:</phrase>

    ( { <replaceable class="parameter">index_column_name</replaceable> | ( <replaceable class="parameter">index_expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) [ WHERE <replaceable class="parameter">index_predicate</replaceable> ]
    ON CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>

<phrase>and <replaceable class="parameter">conflict_action</replaceable> is one of:</phrase>

    DO NOTHING
    DO UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
                  } [, ...]
              [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
INSERT INTO <replaceable class="parameter">table_name</replaceable> [ AS <replaceable class="parameter">alias</replaceable> ] [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER} VALUE ]
    { DEFAULT VALUES | VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) [, ...] | <replaceable class="parameter">query</replaceable> }
    [ ON CONFLICT [ <replaceable class="parameter">conflict_target</replaceable> ] <replaceable class="parameter">conflict_action</replaceable> ]
    [ RETURNING * | <replaceable class="parameter">output_expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]

<phrase>其中 <replaceable class="parameter">conflict_target</replaceable> 可以是以下之一：</phrase>

    ( { <replaceable class="parameter">index_column_name</replaceable> | ( <replaceable class="parameter">index_expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) [ WHERE <replaceable class="parameter">index_predicate</replaceable> ]
    ON CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>

<phrase>并且 <replaceable class="parameter">conflict_action</replaceable> 是以下之一：</phrase>

    DO NOTHING
    DO UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
                  } [, ...]
              [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>INSERT</command> inserts new rows into a table.
   One can insert one or more rows specified by value expressions,
   or zero or more rows resulting from a query.
  </para>
____________________________________________________________________________-->
  <para>
   <command>INSERT</command>将新行插入到一个表中。我们可以
   插入一个或者更多由值表达式指定的行，或者插入来自一个查询的零行
   或者更多行。
  </para>

<!--==========================orignal english content==========================
  <para>
   The target column names can be listed in any order.  If no list of
   column names is given at all, the default is all the columns of the
   table in their declared order; or the first <replaceable>N</replaceable> column
   names, if there are only <replaceable>N</replaceable> columns supplied by the
   <literal>VALUES</literal> clause or <replaceable>query</replaceable>.  The values
   supplied by the <literal>VALUES</literal> clause or <replaceable>query</replaceable> are
   associated with the explicit or implicit column list left-to-right.
  </para>
____________________________________________________________________________-->
  <para>
   目标列的名称可以以任意顺序列出。如果没有给出列名列表，则有两种确定
   目标列的可能性。第一种是以被声明的顺序列出该表的所有列。另一种可能
   性是，如果<literal>VALUES</literal> 子句或者<replaceable>query</replaceable>只提
   供<replaceable>N</replaceable>个列，则以被声明的顺序列出该表的前
   <replaceable>N</replaceable>列。<literal>VALUES</literal> 子句或者
   <replaceable>query</replaceable>提供的值会被从左至右关联到这些显式或者隐式
   给出的目标列。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each column not present in the explicit or implicit column list will be
   filled with a default value, either its declared default value
   or null if there is none.
  </para>
____________________________________________________________________________-->
  <para>
   每一个没有出现在显式或者隐式列列表中的列都将被默认填充，如果为该列
   声明过默认值则用默认值填充，否则用空值填充。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the expression for any column is not of the correct data type,
   automatic type conversion will be attempted.
  </para>
____________________________________________________________________________-->
  <para>
   如果任意列的表达式不是正确的数据类型，将会尝试自动类型转换。
  </para>

<!--==========================orignal english content==========================
  <para>
   <literal>ON CONFLICT</literal> can be used to specify an alternative
   action to raising a unique constraint or exclusion constraint
   violation error. (See <xref linkend="sql-on-conflict"
   endterm="sql-on-conflict-title"/> below.)
  </para>
____________________________________________________________________________-->
  <para>
   <literal>ON CONFLICT</literal>可以用来指定发生唯一约束或者排除约束
   违背错误时的替换动作（见下文的<xref linkend="sql-on-conflict"
   endterm="sql-on-conflict-title"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The optional <literal>RETURNING</literal> clause causes <command>INSERT</command>
   to compute and return value(s) based on each row actually inserted
   (or updated, if an <literal>ON CONFLICT DO UPDATE</literal> clause was
   used).  This is primarily useful for obtaining values that were
   supplied by defaults, such as a serial sequence number.  However,
   any expression using the table's columns is allowed.  The syntax of
   the <literal>RETURNING</literal> list is identical to that of the output
   list of <command>SELECT</command>.  Only rows that were successfully
   inserted or updated will be returned.  For example, if a row was
   locked but not updated because an <literal>ON CONFLICT DO UPDATE
   ... WHERE</literal> clause <replaceable
   class="parameter">condition</replaceable> was not satisfied, the
   row will not be returned.
  </para>
____________________________________________________________________________-->
  <para>
   可选的<literal>RETURNING</literal>子句让<command>INSERT</command>根据
   实际被插入（如果使用了<literal>ON CONFLICT DO UPDATE</literal>子句，
   可能是被更新）的每一行来计算和返回值。这主要用来获取由默认值提供
   的值，例如一个序列号。不过，允许在其中包括使用该表列的任何表达式。
   <literal>RETURNING</literal>列表的语法与<command>SELECT</command>的输出
   列表的相同。只有被成功地插入或者更新的行才将被返回。例如，如果一
   行被锁定但由于不满足<literal>ON CONFLICT DO UPDATE
   ... WHERE</literal> clause <replaceable
   class="parameter">condition</replaceable>没有被更新，该行将
   不被返回。
  </para>

<!--==========================orignal english content==========================
  <para>
   You must have <literal>INSERT</literal> privilege on a table in
   order to insert into it.  If <literal>ON CONFLICT DO UPDATE</literal> is
   present, <literal>UPDATE</literal> privilege on the table is also
   required.
  </para>
____________________________________________________________________________-->
  <para>
   为了向表中插入，你必须具有其上的<literal>INSERT</literal>特权。
   如果存在<literal>ON CONFLICT DO UPDATE</literal>子句，还要求该表上
   的<literal>UPDATE</literal>特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a column list is specified, you only need
   <literal>INSERT</literal> privilege on the listed columns.
   Similarly, when <literal>ON CONFLICT DO UPDATE</literal> is specified, you
   only need <literal>UPDATE</literal> privilege on the column(s) that are
   listed to be updated.  However, <literal>ON CONFLICT DO UPDATE</literal>
   also requires <literal>SELECT</literal> privilege on any column whose
   values are read in the <literal>ON CONFLICT DO UPDATE</literal>
   expressions or <replaceable>condition</replaceable>.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个列列表被指定，你只需要其中的列上的<literal>INSERT</literal>
   特权。类似地，在指定了<literal>ON CONFLICT DO UPDATE</literal>时，你只
   需要被列出要更新的列上的<literal>UPDATE</literal>特权。不过，
   <literal>ON CONFLICT DO UPDATE</literal>还要求其值被
   <literal>ON CONFLICT DO UPDATE</literal>表达式或者
   <replaceable>condition</replaceable>使用的列上的<literal>SELECT</literal>特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   Use of the <literal>RETURNING</literal> clause requires <literal>SELECT</literal>
   privilege on all columns mentioned in <literal>RETURNING</literal>.
   If you use the <replaceable
   class="parameter">query</replaceable> clause to insert rows from a
   query, you of course need to have <literal>SELECT</literal> privilege on
   any table or column used in the query.
  </para>
____________________________________________________________________________-->
  <para>
    使用<literal>RETURNING</literal>子句需要<literal>RETURNING</literal>中提到的所有列的
    <literal>SELECT</literal>权限。
    如果使用<replaceable class="parameter">query</replaceable>子句从查询中插入行，
    则当然需要对查询中使用的任何表或列具有<literal>SELECT</literal>权限。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>
  
  <refsect2 id="sql-inserting-params">
<!--==========================orignal english content==========================
   <title id="sql-inserting-params-title">Inserting</title>
____________________________________________________________________________-->
   <title id="sql-inserting-params-title">插入</title>

<!--==========================orignal english content==========================
   <para>
    This section covers parameters that may be used when only
    inserting new rows.  Parameters <emphasis>exclusively</emphasis>
    used with the <literal>ON CONFLICT</literal> clause are described
    separately.
   </para>
____________________________________________________________________________-->
   <para>
    这个小节介绍了在只插入新行时可以使用的参数。
    <emphasis>专门用于</emphasis><literal>ON CONFLICT</literal>子句的
    参数会单独介绍。
   </para>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">with_query</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">with_query</replaceable></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        The <literal>WITH</literal> clause allows you to specify one or more
        subqueries that can be referenced by name in the <command>INSERT</command>
        query. See <xref linkend="queries-with"/> and <xref linkend="sql-select"/>
        for details.
       </para>
____________________________________________________________________________-->
      <para>
       <literal>WITH</literal>子句允许指定一个或者更多子查询，在
       <command>INSERT</command>查询中可以用名称引用这些子查询。详见
       <xref linkend="queries-with"/>以及<xref linkend="sql-select"/>。
      </para>
<!--==========================orignal english content==========================
      <para>
        It is possible for the <replaceable class="parameter">query</replaceable>
        (<command>SELECT</command> statement)
        to also contain a <literal>WITH</literal> clause.  In such a case both
        sets of <replaceable>with_query</replaceable> can be referenced within
        the <replaceable class="parameter">query</replaceable>, but the
        second one takes precedence since it is more closely nested.
       </para>
____________________________________________________________________________-->
      <para>
       <replaceable class="parameter">query</replaceable>
       （<command>SELECT</command>语句）也可以包含一个
       <literal>WITH</literal>子句。在这种情况下
       <replaceable class="parameter">query</replaceable>中可以引用
       两组<replaceable>with_query</replaceable>，但是第二个优先级更
       高（因为它被嵌套更近）。
      </para>
     </listitem>
   </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><replaceable class="parameter">table_name</replaceable></term>
____________________________________________________________________________-->
     <term><replaceable class="parameter">table_name</replaceable></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
        The name (optionally schema-qualified) of an existing table.
       </para>
____________________________________________________________________________-->
      <para>
       一个已有表的名称（可以被模式限定）。
      </para>
     </listitem>
    </varlistentry>
    
    <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">alias</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A substitute name for <replaceable
        class="parameter">table_name</replaceable>.  When an alias is
        provided, it completely hides the actual name of the table.
        This is particularly useful when <literal>ON CONFLICT DO UPDATE</literal>
        targets a table named <varname>excluded</varname>, since that will otherwise
        be taken as the name of the special table representing rows proposed
        for insertion.
       </para>
____________________________________________________________________________-->
       <para>
        <replaceable class="parameter">table_name</replaceable>
        的替补名称。当提供了一个别名时，它会完全隐藏掉表的实际名称。
        当<literal>ON CONFLICT DO UPDATE</literal>的目标是一个<varname>被排除的</varname>表时这特别有用，因为那将被当作表示要被插入行的特殊表的名称。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a column in the table named by <replaceable
        class="parameter">table_name</replaceable>.  The column name
        can be qualified with a subfield name or array subscript, if
        needed.  (Inserting into only some fields of a composite
        column leaves the other fields null.)  When referencing a
        column with <literal>ON CONFLICT DO UPDATE</literal>, do not include
        the table's name in the specification of a target column.  For
        example, <literal>INSERT INTO table_name ... ON CONFLICT DO UPDATE
        SET table_name.col = 1</literal> is invalid (this follows the general
        behavior for <command>UPDATE</command>).
       </para>
____________________________________________________________________________-->
       <para>
        名为<replaceable
        class="parameter">table_name</replaceable>的表中的一个列
        的名称。如有必要，列名可以用一个子域名或者数组下标限定（指向
        一个组合列的某些列中插入会让其他域为空）。当用
        <literal>ON CONFLICT DO UPDATE</literal>引用一列时，不要在一个
        目标列的说明中国包括表名。例如，
        <literal>INSERT INTO table_name ... ON CONFLICT DO UPDATE
        SET table_name.col = 1</literal>是非法的（这遵循<command>UPDATE</command>
        的一般行为）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
____________________________________________________________________________-->
      <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Without this clause, it is an error to specify an explicit value
        (other than <literal>DEFAULT</literal>) for an identity column defined
        as <literal>GENERATED ALWAYS</literal>.  This clause overrides that
        restriction.
       </para>
____________________________________________________________________________-->
       <para>
        如果没有这个子句，为定义为<literal>GENERATED ALWAYS</literal>的标识列指定一个明确的值（不是<literal>DEFAULT</literal>）就是一种错误。这个子句推翻了这种限制。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>OVERRIDING USER VALUE</literal></term>
____________________________________________________________________________-->
      <term><literal>OVERRIDING USER VALUE</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        If this clause is specified, then any values supplied for identity
        columns defined as <literal>GENERATED BY DEFAULT</literal> are ignored
        and the default sequence-generated values are applied.
       </para>
____________________________________________________________________________-->
       <para>
        如果指定这个子句，则会忽略提供给定义为<literal>GENERATED BY DEFAULT</literal>的标识列的值，并且应用默认的由序列生成的值。
       </para>

<!--==========================orignal english content==========================
       <para>
        This clause is useful for example when copying values between tables.
        Writing <literal>INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM
        tbl1</literal> will copy from <literal>tbl1</literal> all columns that
        are not identity columns in <literal>tbl2</literal> while values for
        the identity columns in <literal>tbl2</literal> will be generated by
        the sequences associated with <literal>tbl2</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        例如，当在表之间拷贝值时，这个子句有能派上用场。<literal>INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1</literal>将从<literal>tbl1</literal>中拷贝所有在<literal>tbl2</literal>中不是标识列的列，而<literal>tbl2</literal>中标识列的值将由与<literal>tbl2</literal>关联的序列产生。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DEFAULT VALUES</literal></term>
____________________________________________________________________________-->
      <term><literal>DEFAULT VALUES</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        All columns will be filled with their default values.
        (An <literal>OVERRIDING</literal> clause is not permitted in this
        form.)
       </para>
____________________________________________________________________________-->
       <para>
        所有列都将被其默认值填充（例如这种形式下不允许<literal>OVERRIDING</literal>子句）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">expression</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An expression or value to assign to the corresponding column.
       </para>
____________________________________________________________________________-->
       <para>
        要赋予给相应列的表达式或者值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DEFAULT</literal></term>
____________________________________________________________________________-->
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The corresponding column will be filled with
        its default value.
       </para>
____________________________________________________________________________-->
       <para>
        相应的列将被其默认值填充。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">query</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A query (<command>SELECT</command> statement) that supplies the
        rows to be inserted.  Refer to the
        <xref linkend="sql-select"/>
        statement for a description of the syntax.
       </para>
____________________________________________________________________________-->
       <para>
        提供要被插入行的查询（<command>SELECT</command>语句）。
        其语法描述请参考<xref linkend="sql-select"/>语句。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">output_expression</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">output_expression</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An expression to be computed and returned by the
        <command>INSERT</command> command after each row is inserted or
        updated. The expression can use any column names of the table
        named by <replaceable
        class="parameter">table_name</replaceable>.  Write
        <literal>*</literal> to return all columns of the inserted or updated
        row(s).
       </para>
____________________________________________________________________________-->
       <para>
        在每一行被插入或更新后由<command>INSERT</command>命令计算并且返回的
        表达式。该表达式可以使用<replaceable class="parameter">table_name</replaceable>
        指定的表中的任何列。写成<literal>*</literal>可返回被插入或更新行的所有列。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">output_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">output_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        A name to use for a returned column.
       </para>
____________________________________________________________________________-->
       <para>
        要用于被返回列的名称。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </refsect2>

  <refsect2 id="sql-on-conflict">
<!--==========================orignal english content==========================
   <title id="sql-on-conflict-title"><literal>ON CONFLICT</literal> Clause</title>
____________________________________________________________________________-->
   <title id="sql-on-conflict-title"><literal>ON CONFLICT</literal> 子句</title>
<!--==========================orignal english content==========================
   <indexterm zone="sql-insert">
    <primary>UPSERT</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-insert">
    <primary>UPSERT</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="sql-insert">
    <primary>ON CONFLICT</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-insert">
    <primary>ON CONFLICT</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <para>
    The optional <literal>ON CONFLICT</literal> clause specifies an
    alternative action to raising a unique violation or exclusion
    constraint violation error.  For each individual row proposed for
    insertion, either the insertion proceeds, or, if an
    <emphasis>arbiter</emphasis> constraint or index specified by
    <parameter>conflict_target</parameter> is violated, the
    alternative <parameter>conflict_action</parameter> is taken.
    <literal>ON CONFLICT DO NOTHING</literal> simply avoids inserting
    a row as its alternative action.  <literal>ON CONFLICT DO
    UPDATE</literal> updates the existing row that conflicts with the
    row proposed for insertion as its alternative action.
   </para>
____________________________________________________________________________-->
   <para>
    可选的<literal>ON CONFLICT</literal>子句为出现唯一性违背或排除
    约束违背错误时提供另一种可供选择的动作。对于每一个要插入的行，
    不管是插入进行下去还是由<parameter>conflict_target</parameter>
    指定的一个<emphasis>仲裁者</emphasis>约束或者索引被违背，都会
    采取可供选择的<parameter>conflict_action</parameter>。
    <literal>ON CONFLICT DO NOTHING</literal>简单地把避免插入行。
    <literal>ON CONFLICT DO UPDATE</literal>则会
    更新与要插入的行冲突的已有行。
   </para>

<!--==========================orignal english content==========================
   <para>
    <parameter>conflict_target</parameter> can perform
    <emphasis>unique index inference</emphasis>.  When performing
    inference, it consists of one or more <replaceable
    class="parameter">index_column_name</replaceable> columns and/or
    <replaceable class="parameter">index_expression</replaceable>
    expressions, and an optional <replaceable class="parameter">index_predicate</replaceable>.  All <replaceable
    class="parameter">table_name</replaceable> unique indexes that,
    without regard to order, contain exactly the
    <parameter>conflict_target</parameter>-specified
    columns/expressions are inferred (chosen) as arbiter indexes.  If
    an <replaceable class="parameter">index_predicate</replaceable> is
    specified, it must, as a further requirement for inference,
    satisfy arbiter indexes.  Note that this means a non-partial
    unique index (a unique index without a predicate) will be inferred
    (and thus used by <literal>ON CONFLICT</literal>) if such an index
    satisfying every other criteria is available.  If an attempt at
    inference is unsuccessful, an error is raised.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>conflict_target</parameter>可以执行
    <emphasis>唯一索引推断</emphasis>。在执行推断时，它由一个或者多个
    <replaceable class="parameter">index_column_name</replaceable>
    列或者
    <replaceable class="parameter">index_expression</replaceable>
    表达式以及一个可选的<replaceable class="parameter">
    index_predicate</replaceable>构成。所有刚好包含
    <parameter>conflict_target</parameter>指定的列/表达式的<replaceable
    class="parameter">table_name</replaceable>唯一索引（不管顺序）都
    会被推断为（选择为）仲裁者索引。如果指定了
    <replaceable class="parameter">index_predicate</replaceable>，它
    必须满足仲裁者索引（也是推断过程的一个进一步的要求）。注意这意味着如果
    有一个满足其他条件的非部分唯一索引（没有谓词的唯一索引）可用，它将被
    推断为仲裁者（并且会被<literal>ON CONFLICT</literal>使用）。如果推断
    尝试不成功，则会发生一个错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>ON CONFLICT DO UPDATE</literal> guarantees an atomic
    <command>INSERT</command> or <command>UPDATE</command> outcome;
    provided there is no independent error, one of those two outcomes
    is guaranteed, even under high concurrency.  This is also known as
    <firstterm>UPSERT</firstterm> &mdash; <quote>UPDATE or
    INSERT</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>ON CONFLICT DO UPDATE</literal>保证一个原子的
    <command>INSERT</command>或者
    <command>UPDATE</command>结果。在没有无关错误的前提下，这两种
    结果之一可以得到保证，即使在很高的并发度也能保证。这也可以被称作
    <firstterm>UPSERT</firstterm> &mdash; <quote>UPDATE 或
    INSERT</quote>。
   </para>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">conflict_target</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">conflict_target</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies which conflicts <literal>ON CONFLICT</literal> takes
        the alternative action on by choosing <firstterm>arbiter
        indexes</firstterm>.  Either performs <emphasis>unique index
        inference</emphasis>, or names a constraint explicitly.  For
        <literal>ON CONFLICT DO NOTHING</literal>, it is optional to
        specify a <parameter>conflict_target</parameter>; when
        omitted, conflicts with all usable constraints (and unique
        indexes) are handled.  For <literal>ON CONFLICT DO
        UPDATE</literal>, a <parameter>conflict_target</parameter>
        <emphasis>must</emphasis> be provided.
       </para>
____________________________________________________________________________-->
       <para>
        通过选择<firstterm>仲裁者索引</firstterm>来指定哪些行与
        <literal>ON CONFLICT</literal>在其上采取可替代动作的行相冲突。
        要么执行<emphasis>唯一索引推断</emphasis>，要么显式命名一个
        约束。对于<literal>ON CONFLICT DO NOTHING</literal>来说，
        它对于指定一个<parameter>conflict_target</parameter>是可选的。
        在被省略时，与所有有效约束（以及唯一索引）的冲突都会被处理。对于
        <literal>ON CONFLICT DO UPDATE</literal>，<emphasis>必须</emphasis>
        提供一个<parameter>conflict_target</parameter>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">conflict_action</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">conflict_action</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        <parameter>conflict_action</parameter> specifies an
        alternative <literal>ON CONFLICT</literal> action.  It can be
        either <literal>DO NOTHING</literal>, or a <literal>DO
        UPDATE</literal> clause specifying the exact details of the
        <literal>UPDATE</literal> action to be performed in case of a
        conflict.  The <literal>SET</literal> and
        <literal>WHERE</literal> clauses in <literal>ON CONFLICT DO
        UPDATE</literal> have access to the existing row using the
        table's name (or an alias), and to rows proposed for insertion
        using the special <varname>excluded</varname> table.
        <literal>SELECT</literal> privilege is required on any column in the
        target table where corresponding <varname>excluded</varname>
        columns are read.
       </para>
____________________________________________________________________________-->
       <para>
        <parameter>conflict_action</parameter>指定一个可替换的
        <literal>ON CONFLICT</literal>动作。它可以是
        <literal>DO NOTHING</literal>，也可以是一个指定在冲突情况下
        要被执行的<literal>UPDATE</literal>动作细节的<literal>DO
        UPDATE</literal>子句。<literal>ON CONFLICT DO
        UPDATE</literal>中的<literal>SET</literal>和
        <literal>WHERE</literal>子句能够使用该表的名称（或者别名）
        访问现有的行，并且可以用特殊的<varname>被排除</varname>
        表访问要插入的行。这个动作要求<varname>被排除</varname>
        列所在目标表的任何列上的<literal>SELECT</literal>特权。
       </para>
<!--==========================orignal english content==========================
       <para>
        Note that the effects of all per-row <literal>BEFORE
        INSERT</literal> triggers are reflected in
        <varname>excluded</varname> values, since those effects may
        have contributed to the row being excluded from insertion.
       </para>
____________________________________________________________________________-->
       <para>
        注意所有行级<literal>BEFORE INSERT</literal>触发器的效果都会
        反映在<varname>被排除</varname>值中，因为那些效果可能会
        让该行避免被插入。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">index_column_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">index_column_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a <replaceable
        class="parameter">table_name</replaceable> column.  Used to
        infer arbiter indexes.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on
        <replaceable class="parameter">index_column_name</replaceable>
        is required.
       </para>
____________________________________________________________________________-->
       <para>
        一个<replaceable class="parameter">table_name</replaceable>列
        的名称。它被用来推断仲裁者索引。它遵循<command>CREATE
        INDEX</command>格式。这要求
        <replaceable class="parameter">index_column_name</replaceable>
        上的<literal>SELECT</literal>特权。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">index_expression</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">index_expression</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Similar to <replaceable
        class="parameter">index_column_name</replaceable>, but used to
        infer expressions on <replaceable
        class="parameter">table_name</replaceable> columns appearing
        within index definitions (not simple columns).  Follows
        <command>CREATE INDEX</command> format.  <literal>SELECT</literal>
        privilege on any column appearing within <replaceable
        class="parameter">index_expression</replaceable> is required.
       </para>
____________________________________________________________________________-->
       <para>
        和<replaceable
        class="parameter">index_column_name</replaceable>类似，但是
        被用来推断出现在索引定义中的<replaceable
        class="parameter">table_name</replaceable>列（非简单列）上的
        表达式。遵循<command>CREATE INDEX</command>格式。这要求
        任何出现在<replaceable
        class="parameter">index_expression</replaceable>中的列上的
        <literal>SELECT</literal>特权。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">collation</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">collation</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When specified, mandates that corresponding <replaceable
        class="parameter">index_column_name</replaceable> or
        <replaceable class="parameter">index_expression</replaceable>
        use a particular collation in order to be matched during
        inference.  Typically this is omitted, as collations usually
        do not affect whether or not a constraint violation occurs.
        Follows <command>CREATE INDEX</command> format.
       </para>
____________________________________________________________________________-->
       <para>
        指定时，强制相应的<replaceable
        class="parameter">index_column_name</replaceable>或
        <replaceable class="parameter">index_expression</replaceable>
        使用一种特定的排序规则以便在推断期间能被匹配上。通常
        会被省略，因为排序规则通常不会影响约束违背的发生。遵循
        <command>CREATE INDEX</command>格式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">opclass</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">opclass</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When specified, mandates that corresponding <replaceable
        class="parameter">index_column_name</replaceable> or
        <replaceable class="parameter">index_expression</replaceable>
        use particular operator class in order to be matched during
        inference.  Typically this is omitted,  as the
        <emphasis>equality</emphasis> semantics are often equivalent
        across a type's operator classes anyway, or because it's
        sufficient to trust that the defined unique indexes have the
        pertinent definition of equality.  Follows <command>CREATE
        INDEX</command> format.
       </para>
____________________________________________________________________________-->
       <para>
        指定时，强制相应的<replaceable
        class="parameter">index_column_name</replaceable>或
        <replaceable class="parameter">index_expression</replaceable>
        使用特定的操作符类以便在推断期间能被匹配上。通常会被省略，
        因为<emphasis>相等</emphasis>语义在一种类型的操作符类
        之间都是等价的，或者因为足以信任已定义的唯一索引具有适当的
        相等定义。遵循<command>CREATE INDEX</command>格式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">index_predicate</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">index_predicate</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Used to allow inference of partial unique indexes.  Any
        indexes that satisfy the predicate (which need not actually be
        partial indexes) can be inferred.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on any
        column appearing within <replaceable
        class="parameter">index_predicate</replaceable> is required.
       </para>
____________________________________________________________________________-->
       <para>
        用于允许推断部分唯一索引。任何满足该谓词（不一定需要真的是
        部分索引）的索引都能被推断。遵循<command>CREATE
        INDEX</command>格式。这要求任何出现在<replaceable
        class="parameter">index_predicate</replaceable>中的列上
        的<literal>SELECT</literal>特权。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">constraint_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">constraint_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Explicitly specifies an arbiter
        <emphasis>constraint</emphasis> by name, rather than inferring
        a constraint or index.
       </para>
____________________________________________________________________________-->
       <para>
        用名称显式地指定一个仲裁者<emphasis>约束</emphasis>，
        而不是推断一个约束或者索引。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">condition</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">condition</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An expression that returns a value of type
        <type>boolean</type>.  Only rows for which this expression
        returns <literal>true</literal> will be updated, although all
        rows will be locked when the <literal>ON CONFLICT DO UPDATE</literal>
        action is taken.  Note that
        <replaceable>condition</replaceable> is evaluated last, after
        a conflict has been identified as a candidate to update.
       </para>
____________________________________________________________________________-->
       <para>
        一个能返回<type>boolean</type>值的表达式。只有让这个表达式返回
        <literal>true</literal>的行才将被更新，不过在采用
        <literal>ON CONFLICT DO UPDATE</literal>动作时所有的行都会被锁定。
        注意<replaceable>condition</replaceable>会被最后计算，即一个冲突
        被标识为要更新的候选对象之后。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
<!--==========================orignal english content==========================
   <para>
    Note that exclusion constraints are not supported as arbiters with
    <literal>ON CONFLICT DO UPDATE</literal>. In all cases, only
    <literal>NOT DEFERRABLE</literal> constraints and unique indexes
    are supported as arbiters.
   </para>
____________________________________________________________________________-->
   <para>
    注意不支持把排除约束作为<literal>ON CONFLICT DO UPDATE</literal>的
    仲裁者。在所有的情况中，只支持<literal>NOT DEFERRABLE</literal>约束和
    唯一索引作为仲裁者。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>INSERT</command> with an <literal>ON CONFLICT DO UPDATE</literal>
    clause is a <quote>deterministic</quote> statement.  This means
    that the command will not be allowed to affect any single existing
    row more than once; a cardinality violation error will be raised
    when this situation arises.  Rows proposed for insertion should
    not duplicate each other in terms of attributes constrained by an
    arbiter index or constraint.
   </para>
____________________________________________________________________________-->
   <para>
    带有<literal>ON CONFLICT DO UPDATE</literal>子句的
    <command>INSERT</command>是一种<quote>确定性的</quote>
    语句。这表明不允许该命令影响任何单个现有行超过一次，如果发生则会
    发生一个基数违背错误。要插入的行不应该在仲裁者索引或约束所限制的
    属性上相重复。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that it is currently not supported for the
    <literal>ON CONFLICT DO UPDATE</literal> clause of an
    <command>INSERT</command> applied to a partitioned table to update the
    partition key of a conflicting row such that it requires the row be moved
    to a new partition.
   </para>
____________________________________________________________________________-->
   <para>
    注意，当前不支持用分区表上的<command>INSERT</command>的<literal>ON CONFLICT DO UPDATE</literal>子句更新冲突行的分区键，因为那样会让行移动到新的分区中。
   </para>
   <tip>
<!--==========================orignal english content==========================
    <para>
     It is often preferable to use unique index inference rather than
     naming a constraint directly using <literal>ON CONFLICT ON
     CONSTRAINT</literal> <replaceable class="parameter">
     constraint_name</replaceable>.  Inference will continue to work
     correctly when the underlying index is replaced by another more
     or less equivalent index in an overlapping way, for example when
     using <literal>CREATE UNIQUE INDEX ...  CONCURRENTLY</literal>
     before dropping the index being replaced.
    </para>
____________________________________________________________________________-->
    <para>
     使用唯一索引推断通常比使用<literal>ON CONFLICT ON CONSTRAINT</literal> <replaceable class="parameter">constraint_name</replaceable>直接提名一个约束更好。当底层索引被以重叠方式替换成另一个或多或少等效的索引时，推断将能继续正确地工作，例如在删除要被替换的索引之前使用<literal>CREATE UNIQUE INDEX ...  CONCURRENTLY</literal>。
    </para>
   </tip>

  </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Outputs</title>
____________________________________________________________________________-->
  <title>输出</title>

<!--==========================orignal english content==========================
  <para>
   On successful completion, an <command>INSERT</command> command returns a command
   tag of the form
<screen>
INSERT <replaceable>oid</replaceable> <replaceable class="parameter">count</replaceable>
</screen>
   The <replaceable class="parameter">count</replaceable> is the
   number of rows inserted or updated.  If <replaceable
   class="parameter">count</replaceable> is exactly one, and the
   target table has OIDs, then <replaceable
   class="parameter">oid</replaceable> is the <acronym>OID</acronym>
   assigned to the inserted row.  The single row must have been
   inserted rather than updated.  Otherwise <replaceable
   class="parameter">oid</replaceable> is zero.
  </para>
____________________________________________________________________________-->
  <para>
   成功完成时，<command>INSERT</command>命令会返回以下形式的命令标签：
<screen>
INSERT <replaceable>oid</replaceable> <replaceable class="parameter">count</replaceable>
</screen>
   <replaceable class="parameter">count</replaceable>是被插入或更新的行数。
   如果<replaceable class="parameter">count</replaceable>正好为 1 并且
   目标表具有 OID，那么
   <replaceable class="parameter">oid</replaceable>就是分配给被插入行的
   <acronym>OID</acronym>。这个单一行必须已经被插入而不是被更新。
   否则<replaceable class="parameter">oid</replaceable>为零。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the <command>INSERT</command> command contains a <literal>RETURNING</literal>
   clause, the result will be similar to that of a <command>SELECT</command>
   statement containing the columns and values defined in the
   <literal>RETURNING</literal> list, computed over the row(s) inserted or
   updated by the command.
  </para>
____________________________________________________________________________-->
  <para>
   如果<command>INSERT</command>命令包含<literal>RETURNING</literal>子句，
   其结果会类似于包含<literal>RETURNING</literal>列表中定义的列和值的
   <command>SELECT</command>语句，这些结果是由该命令在被插入或更新行上
   计算得到。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   If the specified table is a partitioned table, each row is routed to
   the appropriate partition and inserted into it.  If the specified table
   is a partition, an error will occur if one of the input rows violates
   the partition constraint.
  </para>
____________________________________________________________________________-->
  <para>
   如果指定的表是一个分区表，每一行都会被路由到合适的分区并且插入其中。如果指定的表是一个分区，如果输入行之一违背该分区的约束则将发生错误。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   Insert a single row into table <literal>films</literal>:

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   向<literal>films</literal>中插入一行：

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   In this example, the <literal>len</literal> column is
   omitted and therefore it will have the default value:

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在这个例子中，<literal>len</literal>列被省略并且因此会具有默认值：

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example uses the <literal>DEFAULT</literal> clause for
   the date columns rather than specifying a value:

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子为日期列使用<literal>DEFAULT</literal>子句而不是指定一个值：

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To insert a row consisting entirely of default values:

<programlisting>
INSERT INTO films DEFAULT VALUES;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   插入一个完全由默认值构成的行：

<programlisting>
INSERT INTO films DEFAULT VALUES;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To insert multiple rows using the multirow <command>VALUES</command> syntax:

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   用多行<command>VALUES</command>语法插入多个行：

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example inserts some rows into table
   <literal>films</literal> from a table <literal>tmp_films</literal>
   with the same column layout as <literal>films</literal>:

<programlisting>
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子从表<literal>tmp_films</literal>中获得一些行插入到表
   <literal>films</literal>中，两个表具有相同的列布局：

<programlisting>
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   This example inserts into array columns:

<programlisting>
-&minus; Create an empty 3x3 gameboard for noughts-and-crosses
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-&minus; The subscripts in the above example aren't really needed
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这个例子插入数组列：

<programlisting>
-- 为 noughts-and-crosses 游戏创建一个空的 3x3 棋盘
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-- 实际上可以不用上面例子中的下标
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Insert a single row into table <literal>distributors</literal>, returning
   the sequence number generated by the <literal>DEFAULT</literal> clause:

<programlisting>
INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   向表<literal>distributors</literal>中插入一行，返回由
   <literal>DEFAULT</literal>子句生成的序号：

<programlisting>
INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Increment the sales count of the salesperson who manages the
   account for Acme Corporation, and record the whole updated row
   along with current time in a log table:
<programlisting>
WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   增加为 Acme Corporation 管理账户的销售人员的销量，并且把整个被
   更新的行以及当前时间记录到一个日志表中：
<programlisting>
WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   Insert or update new distributors as appropriate.  Assumes a unique
   index has been defined that constrains values appearing in the
   <literal>did</literal> column.  Note that the special
   <varname>excluded</varname> table is used to reference values originally
   proposed for insertion:
<programlisting>
INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   酌情插入或者更新新的 distributor。假设已经定义了一个唯一索引来约束
   出现在<literal>did</literal>列中的值。注意，特殊的
   <varname>excluded</varname>表被用来引用原来要插入的值：
<programlisting>
INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   Insert a distributor, or do nothing for rows proposed for insertion
   when an existing, excluded row (a row with a matching constrained
   column or columns after before row insert triggers fire) exists.
   Example assumes a unique index has been defined that constrains
   values appearing in the <literal>did</literal> column:
<programlisting>
INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   插入一个 distributor，或者在一个被排除的行（具有一个匹配约束的列或者
   会让行级前（或者后）插入触发器引发的列的行）存在时不处理要插入的行。
   例子假设已经定义了一个唯一触发器来约束出现在<literal>did</literal>列
   中的值：
<programlisting>
INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   Insert or update new distributors as appropriate.  Example assumes
   a unique index has been defined that constrains values appearing in
   the <literal>did</literal> column.  <literal>WHERE</literal> clause is
   used to limit the rows actually updated (any existing row not
   updated will still be locked, though):
<programlisting>
-&minus; Don't update existing distributors based in a certain ZIP code
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-&minus; Name a constraint directly in the statement (uses associated
-&minus; index to arbitrate taking the DO NOTHING action)
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   酌情插入或者更新新的 distributor。例子假设已经定义了一个唯一触发器来
   约束出现在<literal>did</literal>列中的值。<literal>WHERE</literal>子句被用
   来限制实际被更新的行（不过，任何没有被更新的已有行仍将被锁定）：
<programlisting>
-- 根据一个特定的 ZIP 编码更新 distributors
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- 直接在语句中命名一个约束（使用相关的索引来判断是否做
-- DO NOTHING 动作）
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   Insert new distributor if possible;  otherwise
   <literal>DO NOTHING</literal>.  Example assumes a unique index has been
   defined that constrains values appearing in the
   <literal>did</literal> column on a subset of rows where the
   <literal>is_active</literal> Boolean column evaluates to
   <literal>true</literal>:
<programlisting>
-&minus; This statement could infer a partial unique index on "did"
-&minus; with a predicate of "WHERE is_active", but it could also
-&minus; just use a regular unique constraint on "did"
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;
</programlisting></para>
____________________________________________________________________________-->
  <para>
   如果可能就插入新的 distributor，否则<literal>DO NOTHING</literal>。
   例子假设已经定义了一个唯一索引，它约束让<literal>is_active</literal>
   布尔列为<literal>true</literal>的行子集上<literal>did</literal>列中的值：
<programlisting>
-- 这个语句可能推断出一个在 "did" 上带有谓词 "WHERE is_active"
-- 的部分唯一索引，但是它可能也只是使用了 "did" 上的一个常规唯一约束
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;
</programlisting>
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>INSERT</command> conforms to the SQL standard, except that
   the <literal>RETURNING</literal> clause is a
   <productname>PostgreSQL</productname> extension, as is the ability
   to use <literal>WITH</literal> with <command>INSERT</command>, and the ability to
   specify an alternative action with <literal>ON CONFLICT</literal>.
   Also, the case in
   which a column name list is omitted, but not all the columns are
   filled from the <literal>VALUES</literal> clause or <replaceable>query</replaceable>,
   is disallowed by the standard.
  </para>
____________________________________________________________________________-->
  <para>
   <command>INSERT</command>符合 SQL 标准，不过
   <literal>RETURNING</literal>子句是一种
   <productname>PostgreSQL</productname>扩展， 在
   <command>INSERT</command>中使用<literal>WITH</literal>也是，
   用<literal>ON CONFLICT</literal>指定一个替代动作也是扩展。
   还有，标准不允许省略列名列表但不通过
   <literal>VALUES</literal>子句或者<replaceable>query</replaceable>填充
   所有列的情况。
  </para>

<!--==========================orignal english content==========================
  <para>
   The SQL standard specifies that <literal>OVERRIDING SYSTEM VALUE</literal>
   can only be specified if an identity column that is generated always
   exists.  PostgreSQL allows the clause in any case and ignores it if it is
   not applicable.
  </para>
____________________________________________________________________________-->
  <para>
   SQL标准指定只有存在一个总是会生成值的标识列时才能指定<literal>OVERRIDING SYSTEM VALUE</literal>。而PostgreSQL在任何情况下都允许这个子句，并且在不适用时会忽略它。
  </para>

<!--==========================orignal english content==========================
  <para>
   Possible limitations of the <replaceable
   class="parameter">query</replaceable> clause are documented under
   <xref linkend="sql-select"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <replaceable
   class="parameter">query</replaceable>子句可能的限制在
   <xref linkend="sql-select"/>有介绍。
  </para>
 </refsect1>
</refentry>
