<!--
doc/src/sgml/ref/create_index.sgml
PostgreSQL documentation
-->

<refentry id="sql-createindex">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE INDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE INDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>define a new index</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>定义一个新索引</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">name</replaceable> ] ON [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ USING <replaceable class="parameter">method</replaceable> ]
    ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    [ WHERE <replaceable class="parameter">predicate</replaceable> ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">name</replaceable> ] ON [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ USING <replaceable class="parameter">method</replaceable> ]
    ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    [ WHERE <replaceable class="parameter">predicate</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE INDEX</command> constructs an index on the specified column(s)
   of the specified relation, which can be a table or a materialized view.
   Indexes are primarily used to enhance database performance (though
   inappropriate use can result in slower performance).
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>在指定关系的指定列上构建
   一个索引，该关系可以是一个表或者一个物化视图。索引主要被用来提升
   数据库性能（不过不当的使用会导致性能变差）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The key field(s) for the index are specified as column names,
   or alternatively as expressions written in parentheses.
   Multiple fields can be specified if the index method supports
   multicolumn indexes.
  </para>
____________________________________________________________________________-->
  <para>
   索引的键域被指定为列名或者写在圆括号中的表达式。如果索引方法支持
   多列索引，可以指定多个域。
  </para>

<!--==========================orignal english content==========================
  <para>
   An index field can be an expression computed from the values of
   one or more columns of the table row.  This feature can be used
   to obtain fast access to data based on some transformation of
   the basic data. For example, an index computed on
   <literal>upper(col)</literal> would allow the clause
   <literal>WHERE upper(col) = 'JIM'</literal> to use an index.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引域可以是一个从表行的一列或者更多列值进行计算的表达式。
   这种特性可以被用来获得对基于基本数据某种变换的数据的快速访问。
   例如，一个在<literal>upper(col)</literal>上计算的索引可以允许子句
   <literal>WHERE upper(col) = 'JIM'</literal>使用索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides the index methods
   B-tree, hash, GiST, SP-GiST, GIN, and BRIN.  Users can also define their own
   index methods, but that is fairly complicated.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了索引方法
   B-树、哈希、GiST、SP-GiST、GIN 以及 BRIN。用户也可以定义自己的索引
   方法，但是相对较复杂。
  </para>

<!--==========================orignal english content==========================
  <para>
    When the <literal>WHERE</literal> clause is present, a
    <firstterm>partial index</firstterm> is created.
    A partial index is an index that contains entries for only a portion of
    a table, usually a portion that is more useful for indexing than the
    rest of the table. For example, if you have a table that contains both
    billed and unbilled orders where the unbilled orders take up a small
    fraction of the total table and yet that is an often used section, you
    can improve performance by creating an index on just that portion.
    Another possible application is to use <literal>WHERE</literal> with
    <literal>UNIQUE</literal> to enforce uniqueness over a subset of a
    table.  See <xref linkend="indexes-partial"/> for more discussion.
  </para>
____________________________________________________________________________-->
  <para>
    当<literal>WHERE</literal>子句存在时，会创建一个
    <firstterm>部分索引</firstterm>。部分索引只包含表中一部分行的项，
    通常索引这一部分会比表的其他部分更有用。例如，如果有一个表包含了
    已付和未付订单，其中未付订单占了整个表的一小部分并且是经常被使用
    的部分，可以通过只在这一部分上创建一个索引来改进性能。另一种可能
    的应用是使用带有<literal>UNIQUE</literal>的
    <literal>WHERE</literal>在表的一个子集上强制唯一性。更多的讨论
    请见<xref linkend="indexes-partial"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
    The expression used in the <literal>WHERE</literal> clause can refer
    only to columns of the underlying table, but it can use all columns,
    not just the ones being indexed.  Presently, subqueries and
    aggregate expressions are also forbidden in <literal>WHERE</literal>.
    The same restrictions apply to index fields that are expressions.
  </para>
____________________________________________________________________________-->
  <para>
    <literal>WHERE</literal>子句中使用的表达式只能引用底层表的列，但
    它可以引用所有列而不仅仅是被索引的列。当前，
    <literal>WHERE</literal>中也禁止使用子查询和聚集表达式。同样的
    限制也适用于表达式索引中的表达式域。
  </para>

<!--==========================orignal english content==========================
  <para>
   All functions and operators used in an index definition must be
   <quote>immutable</quote>, that is, their results must depend only on
   their arguments and never on any outside influence (such as
   the contents of another table or the current time).  This restriction
   ensures that the behavior of the index is well-defined.  To use a
   user-defined function in an index expression or <literal>WHERE</literal>
   clause, remember to mark the function immutable when you create it.
  </para>
____________________________________________________________________________-->
  <para>
   所有在索引定义中使用的函数和操作符必须是<quote>不可变的</quote>，
   就是说它们的结果必须仅依赖于它们的参数而不受外在因素（例如另
   一个表的内容和当前的时间）的影响。这种限制确保了索引的行为是
   良定的。要在一个索引表达式或者<literal>WHERE</literal>子句中
   使用用户定义的函数，记住在创建函数时把它标记为不可变。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

    <variablelist>
     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>UNIQUE</literal></term>
____________________________________________________________________________-->
      <term><literal>UNIQUE</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Causes the system to check for
        duplicate values in the table when the index is created (if data
        already exist) and each time data is added. Attempts to
        insert or update data which would result in duplicate entries
        will generate an error.
       </para>
____________________________________________________________________________-->
       <para>
        导致系统在索引被创建时（如果数据已经存在）或者加入数据时
        检查重复值。会导致重复项的数据插入或者更新尝试将会产生一
        个错误。
       </para>

<!--==========================orignal english content==========================
       <para>
        Additional restrictions apply when unique indexes are applied to
        partitioned tables; see <xref linkend="sql-createtable" />.
       </para>
____________________________________________________________________________-->
       <para>
        当唯一索引被应用在分区边上时会有额外的限制，请参考<xref linkend="sql-createtable" />。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>CONCURRENTLY</literal></term>
____________________________________________________________________________-->
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        When this option is used, <productname>PostgreSQL</productname> will build the
        index without taking any locks that prevent concurrent inserts,
        updates, or deletes on the table; whereas a standard index build
        locks out writes (but not reads) on the table until it's done.
        There are several caveats to be aware of when using this option
        &mdash; see <xref linkend="sql-createindex-concurrently"
        endterm="sql-createindex-concurrently-title"/>.
       </para>
____________________________________________________________________________-->
       <para>
        当使用了这个选项时，<productname>PostgreSQL</productname>在构建索引时
        不会取得任何会阻止该表上并发插入、更新或者删除的锁。而标准的索引
        构建将会把表锁住以阻止对表的写（但不阻塞读），这种锁定会持续到索
        引创建完毕。在使用这个选项时有多个需要注意的地方 &mdash; 请见
        <xref linkend="sql-createindex-concurrently" endterm="sql-createindex-concurrently-title"/>。
       </para>
      </listitem>
     </varlistentry>
     
     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>IF NOT EXISTS</literal></term>
____________________________________________________________________________-->
      <term><literal>IF NOT EXISTS</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Do not throw an error if a relation with the same name already exists.
        A notice is issued in this case. Note that there is no guarantee that
        the existing index is anything like the one that would have been created.
        Index name is required when <literal>IF NOT EXISTS</literal> is specified.
       </para>
____________________________________________________________________________-->
       <para>
        如果一个同名关系已经存在则不要抛出错误。这种情况下会发出一个提示。
        注意着并不保证现有的索引与将要创建的索引有任何相似。当
        <literal>IF NOT EXISTS</literal>被指定时，需要指定索引名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>INCLUDE</literal></term>
____________________________________________________________________________-->
      <term><literal>INCLUDE</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The optional <literal>INCLUDE</literal> clause specifies a
        list of columns which will be included in the index
        as <firstterm>non-key</firstterm> columns.  A non-key column cannot
        be used in an index scan search qualification, and it is disregarded
        for purposes of any uniqueness or exclusion constraint enforced by
        the index.  However, an index-only scan can return the contents of
        non-key columns without having to visit the index's table, since
        they are available directly from the index entry.  Thus, addition of
        non-key columns allows index-only scans to be used for queries that
        otherwise could not use them.
       </para>
____________________________________________________________________________-->
       <para>
        可选的<literal>INCLUDE</literal>子句指定一个列的列表，其中的列将被包括在索引中作为<firstterm>非键</firstterm>列。非键列不能作为索引扫描的条件，并且该索引所强制的任何唯一性或者排除约束都不会考虑它们。不过，只用索引的扫描可以返回非键列的内容而无需访问该索引的基表，因为在索引项中就能直接拿到它们。因此，非键列的增加允许查询使用只用索引的扫描，否则就无法使用。
       </para>

<!--==========================orignal english content==========================
       <para>
        It's wise to be conservative about adding non-key columns to an
        index, especially wide columns.  If an index tuple exceeds the
        maximum size allowed for the index type, data insertion will fail.
        In any case, non-key columns duplicate data from the index's table
        and bloat the size of the index, thus potentially slowing searches.
       </para>
____________________________________________________________________________-->
       <para>
        保守地向索引中增加非键列是明智的，特别是很宽的列。如果一个索引元组超过索引类型允许的最大尺寸，数据插入将会失败。在任何情况下，非键列都会重复来自索引基表的数据并且让索引的尺寸膨胀，因此可能会拖慢搜索。
       </para>

<!--==========================orignal english content==========================
       <para>
        Columns listed in the <literal>INCLUDE</literal> clause don't need
        appropriate operator classes; the clause can include
        columns whose data types don't have operator classes defined for
        a given access method.
       </para>
____________________________________________________________________________-->
       <para>
        <literal>INCLUDE</literal>子句中列出的列不需要合适的操作符类，甚至数据类型没有为给定的访问方法定义操作符类的列都可以包括在这个子句中。
       </para>

<!--==========================orignal english content==========================
       <para>
        Expressions are not supported as included columns since they cannot be
        used in index-only scans.
       </para>
____________________________________________________________________________-->
       <para>
        不支持把表达式作为被包括列，因为它们不能被用在只用索引的扫描中。
       </para>

<!--==========================orignal english content==========================
       <para>
        Currently, only the B-tree index access method supports this feature.
        In B-tree indexes, the values of columns listed in the
        <literal>INCLUDE</literal> clause are included in leaf tuples which
        correspond to heap tuples, but are not included in upper-level
        index entries used for tree navigation.
       </para>
____________________________________________________________________________-->
       <para>
        当前，仅有B-树索引访问方法支持这一特性。在B-树索引中，<literal>INCLUDE</literal>子句中列出的列的值被包括在对应于堆元组的叶子元组中，但是不包括在用于树导航的上层索引项中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the index to be created.  No schema name can be included
        here; the index is always created in the same schema as its parent
        table.  If the name is omitted, <productname>PostgreSQL</productname> chooses a
        suitable name based on the parent table's name and the indexed column
        name(s).
       </para>
____________________________________________________________________________-->
       <para>
        要创建的索引名称。这里不能包括模式名，因为索引总是被创建在其基表所在
        的模式中。如果索引名称被省略，<productname>PostgreSQL</productname>将基于基
        表名称和被索引列名称选择一个合适的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>ONLY</literal></term>
____________________________________________________________________________-->
      <term><literal>ONLY</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Indicates not to recurse creating indexes on partitions, if the
        table is partitioned.  The default is to recurse.
       </para>
____________________________________________________________________________-->
       <para>
        如果该表是分区表，指示不要在分区上递归创建索引。默认会递归创建索引。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">table_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">table_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name (possibly schema-qualified) of the table to be indexed.
       </para>
____________________________________________________________________________-->
       <para>
        要被索引的表的名称（可以被模式限定）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">method</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">method</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the index method to be used.  Choices are
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>gist</literal>, <literal>spgist</literal>, <literal>gin</literal>, and
        <literal>brin</literal>.
        The default method is <literal>btree</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        要使用的索引方法的名称。可以选择
        <literal>btree</literal>、<literal>hash</literal>、
        <literal>gist</literal>、<literal>spgist</literal>、
        <literal>gin</literal>以及<literal>brin</literal>。
        默认方法是<literal>btree</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of a column of the table.
       </para>
____________________________________________________________________________-->
       <para>
        一个表列的名称。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">expression</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        An expression based on one or more columns of the table.  The
        expression usually must be written with surrounding parentheses,
        as shown in the syntax.  However, the parentheses can be omitted
        if the expression has the form of a function call.
       </para>
____________________________________________________________________________-->
       <para>
        一个基于一个或者更多个表列的表达式。如语法中所示，表达式通常必须
        被写在圆括号中。不过，如果该表达式是一个函数调用的形式，圆括号可
        以被省略。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">collation</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">collation</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of the collation to use for the index.  By default,
        the index uses the collation declared for the column to be
        indexed or the result collation of the expression to be
        indexed.  Indexes with non-default collations can be useful for
        queries that involve expressions using non-default collations.
       </para>
____________________________________________________________________________-->
       <para>
        要用于该索引的排序规则的名称。默认情况下，该索引使用被索引列
        的排序规则或者被索引表达式的结果排序规则。当查询涉及到使用非
        默认排序规则的表达式时，使用非默认排序规则的索引就能排上用场。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">opclass</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">opclass</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of an operator class. See below for details.
       </para>
____________________________________________________________________________-->
       <para>
        一个操作符类的名称。详见下文。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>ASC</literal></term>
____________________________________________________________________________-->
      <term><literal>ASC</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies ascending sort order (which is the default).
       </para>
____________________________________________________________________________-->
       <para>
        指定上升排序（默认）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>DESC</literal></term>
____________________________________________________________________________-->
      <term><literal>DESC</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies descending sort order.
       </para>
____________________________________________________________________________-->
       <para>
        指定下降排序。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>NULLS FIRST</literal></term>
____________________________________________________________________________-->
      <term><literal>NULLS FIRST</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies that nulls sort before non-nulls.  This is the default
        when <literal>DESC</literal> is specified.
       </para>
____________________________________________________________________________-->
       <para>
        指定把空值排序在非空值前面。在指定<literal>DESC</literal>时，
        这是默认行为。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><literal>NULLS LAST</literal></term>
____________________________________________________________________________-->
      <term><literal>NULLS LAST</literal></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        Specifies that nulls sort after non-nulls.  This is the default
        when <literal>DESC</literal> is not specified.
       </para>
____________________________________________________________________________-->
       <para>
        指定把空值排序在非空值后面。在没有指定<literal>DESC</literal>时，
        这是默认行为。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The name of an index-method-specific storage parameter.  See
        <xref linkend="sql-createindex-storage-parameters" endterm="sql-createindex-storage-parameters-title"/>
        for details.
       </para>
____________________________________________________________________________-->
       <para>
        索引方法相关的存储参数的名称。详见
        <xref linkend="sql-createindex-storage-parameters" endterm="sql-createindex-storage-parameters-title"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">tablespace_name</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">tablespace_name</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The tablespace in which to create the index.  If not specified,
        <xref linkend="guc-default-tablespace"/> is consulted, or
        <xref linkend="guc-temp-tablespaces"/> for indexes on temporary
        tables.
       </para>
____________________________________________________________________________-->
       <para>
        在其中创建索引的表空间。如果没有指定，将会使用
        <xref linkend="guc-default-tablespace"/>。或者对临时表上的索引使用
        <xref linkend="guc-temp-tablespaces"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
<!--==========================orignal english content==========================
      <term><replaceable class="parameter">predicate</replaceable></term>
____________________________________________________________________________-->
      <term><replaceable class="parameter">predicate</replaceable></term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        The constraint expression for a partial index.
       </para>
____________________________________________________________________________-->
       <para>
        部分索引的约束表达式。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  <refsect2 id="sql-createindex-storage-parameters">
<!--==========================orignal english content==========================
   <title id="sql-createindex-storage-parameters-title">Index Storage Parameters</title>
____________________________________________________________________________-->
   <title id="sql-createindex-storage-parameters-title">索引存储参数</title>

<!--==========================orignal english content==========================
   <para>
    The optional <literal>WITH</literal> clause specifies <firstterm>storage
    parameters</firstterm> for the index.  Each index method has its own set of allowed
    storage parameters.  The B-tree, hash, GiST and SP-GiST index methods all
    accept this parameter:
   </para>
____________________________________________________________________________-->
   <para>
    可选的<literal>WITH</literal>子句为索引指定<firstterm>存储参数</firstterm>。每一种
    索引方法都有自己的存储参数集合。B-树、哈希、GiST以及SP-GiST索引方法都接受这个参数：
   </para>


   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>fillfactor</literal></term>
____________________________________________________________________________-->
    <term><literal>fillfactor</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The fillfactor for an index is a percentage that determines how full
      the index method will try to pack index pages.  For B-trees, leaf pages
      are filled to this percentage during initial index build, and also
      when extending the index at the right (adding new largest key values).
      If pages
      subsequently become completely full, they will be split, leading to
      gradual degradation in the index's efficiency.  B-trees use a default
      fillfactor of 90, but any integer value from 10 to 100 can be selected.
      If the table is static then fillfactor 100 is best to minimize the
      index's physical size, but for heavily updated tables a smaller
      fillfactor is better to minimize the need for page splits.  The
      other index methods use fillfactor in different but roughly analogous
      ways; the default fillfactor varies between methods.
     </para>
____________________________________________________________________________-->
     <para>
      索引的填充因子是一个百分数，它决定索引方法将尝试填充索引页面的充满程度。对于B-树，在初始的索引构建过程中，叶子页面会被填充至该百分数，当在索引右端扩展索引（增加新的最大键值）时也会这样处理。如果页面后来被完全填满，它们就会被分裂，导致索引的效率逐渐退化。B-树使用了默认的填充因子 90，但是也可以选择为 10 到 100 的任何整数值。如果表是静态的，那么填充因子 100 是最好的，因为它可以让索引的物理尺寸最小化。但是对于更新负荷很重的表，较小的填充因子有利于最小化对页面分裂的需求。其他索引方法以不同但是大致类似的方式使用填充因子，不同方法的默认填充因子也不相同。
     </para>
    </listitem>
   </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    B-tree indexes additionally accept this parameter:
   </para>
____________________________________________________________________________-->
   <para>
    B-树索引还额外接受这个参数：
   </para>

   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>vacuum_cleanup_index_scale_factor</literal></term>
____________________________________________________________________________-->
    <term><literal>vacuum_cleanup_index_scale_factor</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
      Per-index value for <xref linkend="guc-vacuum-cleanup-index-scale-factor"/>.
    </para>
____________________________________________________________________________-->
    <para>
      <xref linkend="guc-vacuum-cleanup-index-scale-factor"/>针对每个索引的值。
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    GiST indexes additionally accept this parameter:
   </para>
____________________________________________________________________________-->
   <para>
    GiST还额外接受这个参数：
   </para>

   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>buffering</literal></term>
____________________________________________________________________________-->
    <term><literal>buffering</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
     Determines whether the buffering build technique described in
     <xref linkend="gist-buffering-build"/> is used to build the index. With
     <literal>OFF</literal> it is disabled, with <literal>ON</literal> it is enabled, and
     with <literal>AUTO</literal> it is initially disabled, but turned on
     on-the-fly once the index size reaches <xref linkend="guc-effective-cache-size"/>. The default is <literal>AUTO</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     决定是否用<xref linkend="gist-buffering-build"/>中描述的缓冲构建技术来构建索引。<literal>OFF</literal>会禁用它，<literal>ON</literal>则启用该特性，如果设置为<literal>AUTO</literal>则初始会禁用它，但是一旦索引尺寸到达<xref linkend="guc-effective-cache-size"/>就会随时打开。默认值是<literal>AUTO</literal>。
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    GIN indexes accept different parameters:
   </para>
____________________________________________________________________________-->
   <para>
    GIN索引接受不同的参数：
   </para>

   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>fastupdate</literal></term>
____________________________________________________________________________-->
    <term><literal>fastupdate</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
     This setting controls usage of the fast update technique described in
     <xref linkend="gin-fast-update"/>.  It is a Boolean parameter:
     <literal>ON</literal> enables fast update, <literal>OFF</literal> disables it.
     (Alternative spellings of <literal>ON</literal> and <literal>OFF</literal> are
     allowed as described in <xref linkend="config-setting"/>.)  The
     default is <literal>ON</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     这个设置控制<xref linkend="gin-fast-update"/>中描述的快速更新
     技术的使用。它是一个布尔参数：<literal>ON</literal>启用快速更新，
     <literal>OFF</literal>禁用之（<literal>ON</literal>和<literal>OFF</literal>的其他
     写法在<xref linkend="config-setting"/>中有介绍）。默认是
     <literal>ON</literal>。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      Turning <literal>fastupdate</literal> off via <command>ALTER INDEX</command> prevents
      future insertions from going into the list of pending index entries,
      but does not in itself flush previous entries.  You might want to
      <command>VACUUM</command> the table or call <function>gin_clean_pending_list</function>
      function afterward to ensure the pending list is emptied.
     </para>
____________________________________________________________________________-->
     <para>
      通过<command>ALTER INDEX</command>关闭<literal>fastupdate</literal>
      会阻止未来的更新进入到待处理索引项列表中，但它不会自己处理之前的
      待处理项。可以使用<command>VACUUM</command>或者调用
      <function>gin_clean_pending_list</function>确保处理完待处理列表的项。
     </para>
    </note>
    </listitem>
   </varlistentry>
   </variablelist>
   
   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>gin_pending_list_limit</literal></term>
____________________________________________________________________________-->
    <term><literal>gin_pending_list_limit</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
     Custom <xref linkend="guc-gin-pending-list-limit"/> parameter.
     This value is specified in kilobytes.
    </para>
____________________________________________________________________________-->
    <para>
     自定义<xref linkend="guc-gin-pending-list-limit"/>参数。这个值
     要以千字节来指定。
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    <acronym>BRIN</acronym> indexes accept different parameters:
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>BRIN</acronym>索引接受不同的参数：
   </para>

   <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>pages_per_range</literal></term>
____________________________________________________________________________-->
    <term><literal>pages_per_range</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
     Defines the number of table blocks that make up one block range for
     each entry of a <acronym>BRIN</acronym> index (see <xref linkend="brin-intro"/>
     for more details).  The default is <literal>128</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     定义用于每一个<acronym>BRIN</acronym>索引项的块范围由多少个表块组成（详见
     <xref linkend="brin-intro"/>）。默认是<literal>128</literal>。
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>autosummarize</literal></term>
____________________________________________________________________________-->
    <term><literal>autosummarize</literal></term>
    <listitem>
<!--==========================orignal english content==========================
    <para>
     Defines whether a summarization run is invoked for the previous page
     range whenever an insertion is detected on the next one.
    </para>
____________________________________________________________________________-->
    <para>
     定义是否只要在下一个页面上检测到插入就为前面的页面范围运行概要操作。
    </para>
    </listitem>
   </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="sql-createindex-concurrently">
<!--==========================orignal english content==========================
   <title id="sql-createindex-concurrently-title">Building Indexes Concurrently</title>
____________________________________________________________________________-->
   <title id="sql-createindex-concurrently-title">并发构建索引</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-createindex-concurrently">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-createindex-concurrently">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Creating an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</productname> locks the table to be indexed against
    writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index build is finished. This could have a severe effect if the system is
    a live production database.  Very large tables can take many hours to be
    indexed, and even for smaller tables, an index build can lock out writers
    for periods that are unacceptably long for a production system.
   </para>
____________________________________________________________________________-->
   <para>
    创建索引可能会干扰数据库的常规操作。通常
    <productname>PostgreSQL</productname>会锁住要被索引的表，让它不能被写入，
    并且用该表上的一次扫描来执行整个索引的构建。其他事务仍然可以读取表 ，
    但是如果它们尝试在该表上进行插入、更新或者删除，它们会被阻塞直到索引
    构建完成。如果系统是一个生产数据库，这可能会导致严重的后果。索引非常
    大的表可能会需要很多个小时，而且即使是较小的表，在构建索引过程中阻塞
    写入者一段时间在生产系统中也是不能接受的。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> supports building indexes without locking
    out writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</literal> option of <command>CREATE INDEX</command>.
    When this option is used,
    <productname>PostgreSQL</productname> must perform two scans of the table, and in
    addition it must wait for all existing transactions that could potentially
    modify or use the index to terminate.  Thus
    this method requires more total work than a standard index build and takes
    significantly longer to complete.  However, since it allows normal
    operations to continue while the index is built, this method is useful for
    adding new indexes in a production environment.  Of course, the extra CPU
    and I/O load imposed by the index creation might slow other operations.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持构建索引时不阻塞写入。这种方法通过
    指定<command>CREATE INDEX</command>的<literal>CONCURRENTLY</literal>选项
    实现。当使用这个选项时，<productname>PostgreSQL</productname>必须执行该表的
    两次扫描，此外它必须等待所有现有可能会修改或者使用该索引的事务终止。因此这种
    方法比起标准索引构建过程来说要做更多工作并且需要更多时间。不过，由于它
    允许在构建索引时继续普通操作，这种方式对于在生产环境中增加新索引很有用。
    当然，由索引创建带来的额外 CPU 和 I/O 开销可能会拖慢其他操作。
   </para>

<!--==========================orignal english content==========================
   <para>
    In a concurrent index build, the index is actually entered into
    the system catalogs in one transaction, then two table scans occur in
    two more transactions.  Before each table scan, the index build must
    wait for existing transactions that have modified the table to terminate.
    After the second scan, the index build must wait for any transactions
    that have a snapshot (see <xref linkend="mvcc"/>) predating the second
    scan to terminate.  Then finally the index can be marked ready for use,
    and the <command>CREATE INDEX</command> command terminates.
    Even then, however, the index may not be immediately usable for queries:
    in the worst case, it cannot be used as long as transactions exist that
    predate the start of the index build.
   </para>
____________________________________________________________________________-->
   <para>
    在并发索引构建中，索引实际上在一个事务中被录入到系统目录，然后在两个
    事务中发生两次表扫描。在每一次表扫描之前，索引构建必须等待已经修改了
    表的现有事务终止。在第二次扫描之后，索引构建必须等待任何持有早于第二
    次扫描的快照（见<xref linkend="mvcc"/>）的事务终止。然后该索引最终
    能被标记为准备好使用，并且<command>CREATE INDEX</command>命令终止。
    不过即便那样，该索引也不是立刻可以用于查询：在最坏的情况下，只要早于
    索引构建开始时存在的事务存在，该索引就无法使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a problem arises while scanning the table, such as a deadlock or a
    uniqueness violation in a unique index, the <command>CREATE INDEX</command>
    command will fail but leave behind an <quote>invalid</quote> index. This index
    will be ignored for querying purposes because it might be incomplete;
    however it will still consume update overhead. The <application>psql</application>
    <command>\d</command> command will report such an index as <literal>INVALID</literal>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default 
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 col    | integer |           |          | 
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    The recommended recovery
    method in such cases is to drop the index and try again to perform
    <command>CREATE INDEX CONCURRENTLY</command>.  (Another possibility is to rebuild
    the index with <command>REINDEX</command>.  However, since <command>REINDEX</command>
    does not support concurrent builds, this option is unlikely to seem
    attractive.)
   </para>
____________________________________________________________________________-->
   <para>
    如果在扫描表示出现问题，例如死锁或者唯一索引中的唯一性被违背，
    <command>CREATE INDEX</command>将会失败，但留下一个<quote>不可用</quote>
    的索引。这个索引会被查询所忽略，因为它可能不完整。不过它仍将消耗更新
    开销。<application>psql</application>的<command>\d</command>命令将把这类索引报告为
    <literal>INVALID</literal>：

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 col    | integer |           |          | 
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    这种情况下推荐的恢复方法是删除该索引并且尝试再次执行
    <command>CREATE INDEX CONCURRENTLY</command>（另一种可能性是用
    <command>REINDEX</command>重建该索引。不过，由于
    <command>REINDEX</command>不支持并发构建，这种选择不那么有吸引力）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Another caveat when building a unique index concurrently is that the
    uniqueness constraint is already being enforced against other transactions
    when the second table scan begins.  This means that constraint violations
    could be reported in other queries prior to the index becoming available
    for use, or even in cases where the index build eventually fails.  Also,
    if a failure does occur in the second scan, the <quote>invalid</quote> index
    continues to enforce its uniqueness constraint afterwards.
   </para>
____________________________________________________________________________-->
   <para>
    并发构建一个唯一索引时需要注意的另一点是，当第二次表扫描开始时，唯一约束
    已经被强制在其他事务上。这意味着在该索引变得可用之前，其他查询中可能就会
    报告该约束被违背，或者甚至在索引构建最终失败的情况中也是这样。还有，如果在
    第二次扫描时发生失败，<quote>无效的</quote>索引也会继续强制它的唯一性约束。
   </para>

<!--==========================orignal english content==========================
   <para>
    Concurrent builds of expression indexes and partial indexes are supported.
    Errors occurring in the evaluation of these expressions could cause
    behavior similar to that described above for unique constraint violations.
   </para>
____________________________________________________________________________-->
   <para>
    表达式索引和部分索引的并发构建也被支持。在这些表达式计算过程中发生的
    错误可能导致和上述唯一约束违背类似的行为。
   </para>

<!--==========================orignal english content==========================
   <para>
    Regular index builds permit other regular index builds on the
    same table to occur simultaneously, but only one concurrent index build
    can occur on a table at a time.  In either case, schema modification of the
    table is not allowed while the index is being built.  Another difference is
    that a regular <command>CREATE INDEX</command> command can be performed
    within a transaction block, but <command>CREATE INDEX CONCURRENTLY</command>
    cannot.
   </para>
____________________________________________________________________________-->
   <para>
    常规索引构建允许在同一个表上同时构建其他常规索引，但是在一个表上同时
    只能有一个并发索引构建发生。在两种情况下，在索引被构建时不允许表的模式修改。另一个不同是，一个常规<command>CREATE INDEX</command>
    命令可以在一个事务块中执行，但是
    <command>CREATE INDEX CONCURRENTLY</command>不行。
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
  <para>
   See <xref linkend="indexes"/> for information about when indexes can
   be used, when they are not used, and in which particular situations
   they can be useful.
  </para>
____________________________________________________________________________-->
  <para>
   关于索引何时能被使用、何时不被使用以及什么情况下它们有用的信息请
   见<xref linkend="indexes"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Currently, only the B-tree, GiST, GIN, and BRIN index methods support
   multicolumn indexes. Up to 32 fields can be specified by default.
   (This limit can be altered when building
   <productname>PostgreSQL</productname>.)  Only B-tree currently
   supports unique indexes.
  </para>
____________________________________________________________________________-->
  <para>
   当前，只有 B-树、GiST、GIN 和 BRIN 索引方法支持多列索引。默认最多可以
   索引 32 个域（可以在构建
   <productname>PostgreSQL</productname>修改这种限制）。当前
   只有 B-树支持唯一索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   An <firstterm>operator class</firstterm> can be specified for each
   column of an index. The operator class identifies the operators to be
   used by the index for that column. For example, a B-tree index on
   four-byte integers would use the <literal>int4_ops</literal> class;
   this operator class includes comparison functions for four-byte
   integers. In practice the default operator class for the column's data
   type is usually sufficient. The main point of having operator classes
   is that for some data types, there could be more than one meaningful
   ordering. For example, we might want to sort a complex-number data
   type either by absolute value or by real part. We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when creating an index.  More information about
   operator classes is in <xref linkend="indexes-opclass"/> and in <xref
   linkend="xindex"/>.
  </para>
____________________________________________________________________________-->
  <para>
   为索引的每一列可以指定一个<firstterm>操作符类</firstterm>。该操作符
   类标识要被该索引用于该列的操作符。例如，一个四字节整数上的 B-树索引
   会使用<literal>int4_ops</literal>类。这个操作符类包括了用于四字节整数
   的比较函数。实际上，通常列数据类型的默认操作符类就足够了。对某些数据
   类型指定操作符类的主要原因是，可能会有多于一种有意义的顺序。例如，
   我们可能想用绝对值或者实数部分对复数类型排序。我们可以通过为该数据
   类型定义两个操作符类来做到，并且在创建索引时选择其中合适的类。更多
   有关操作符类的信息请见<xref linkend="indexes-opclass"/>以及<xref
   linkend="xindex"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <literal>CREATE INDEX</literal> is invoked on a partitioned
   table, the default behavior is to recurse to all partitions to ensure
   they all have matching indexes.
   Each partition is first checked to determine whether an equivalent
   index already exists, and if so, that index will become attached as a
   partition index to the index being created, which will become its
   parent index.
   If no matching index exists, a new index will be created and
   automatically attached; the name of the new index in each partition
   will be determined as if no index name had been specified in the
   command.
   If the <literal>ONLY</literal> option is specified, no recursion
   is done, and the index is marked invalid.
   (<command>ALTER INDEX ... ATTACH PARTITION</command> marks the index
   valid, once all partitions acquire matching indexes.)  Note, however,
   that any partition that is created in the future using
   <command>CREATE TABLE ... PARTITION OF</command> will automatically
   have a matching index, regardless of whether <literal>ONLY</literal> is
   specified.
  </para>
____________________________________________________________________________-->
  <para>
   当在一个分区表上调用<literal>CREATE INDEX</literal>时，默认的行为是递归到所有的分区上以确保它们都具有匹配的索引。每一个分区首先会被检查是否有一个等效的索引存在，如果有则该索引将被挂接为被创建索引的一个分区索引，而被创建的索引将成为其父索引。如果不存在匹配的索引，则会创建一个新的索引并且自动进行挂接。如果命令中没有指定索引名称，每个分区中的新索引的名称将被自动决定。如果指定了<literal>ONLY</literal>选项，则不会进行递归，并且该索引会被标记为无效（一旦所有的分区都得到该索引，<command>ALTER INDEX ... ATTACH PARTITION</command>可以把该索引标记为有效）。不过，要注意不管是否指定这一选项，未来使用<command>CREATE TABLE ... PARTITION OF</command>创建的任何分区将自动有一个匹配的索引，不管有没有指定<literal>ONLY</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   For index methods that support ordered scans (currently, only B-tree),
   the optional clauses <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS
   FIRST</literal>, and/or <literal>NULLS LAST</literal> can be specified to modify
   the sort ordering of the index.  Since an ordered index can be
   scanned either forward or backward, it is not normally useful to create a
   single-column <literal>DESC</literal> index &mdash; that sort ordering is already
   available with a regular index.  The value of these options is that
   multicolumn indexes can be created that match the sort ordering requested
   by a mixed-ordering query, such as <literal>SELECT ... ORDER BY x ASC, y
   DESC</literal>.  The <literal>NULLS</literal> options are useful if you need to support
   <quote>nulls sort low</quote> behavior, rather than the default <quote>nulls
   sort high</quote>, in queries that depend on indexes to avoid sorting steps.
  </para>
____________________________________________________________________________-->
  <para>
   对于支持有序扫描的索引方法（当前只有 B-树），可以指定可选子句<literal>ASC</literal>、
   <literal>DESC</literal>、<literal>NULLS FIRST</literal>以及<literal>NULLS LAST</literal>
   来修改索引的排序顺序。由于一个有序索引能前向或者反向扫描，通常创建一个
   单列<literal>DESC</literal>索引没什么用处 &mdash; 一个常规索引已经提供了排序
   顺序。这些选项的价值是可以创建多列索引，让它的排序顺序匹配有混合排序要求
   的查询，例如<literal>SELECT ... ORDER BY x ASC, y
   DESC</literal>。如果你想要在依靠索引避免排序步骤的查询中支持
   <quote>空值排序低</quote>这种行为，<literal>NULLS</literal>选项就能派上用场，默认
   的行为是<quote>空值排序高</quote>。
  </para>

<!--==========================orignal english content==========================
  <para>
   For most index methods, the speed of creating an index is
   dependent on the setting of <xref linkend="guc-maintenance-work-mem"/>.
   Larger values will reduce the time needed for index creation, so long
   as you don't make it larger than the amount of memory really available,
   which would drive the machine into swapping.
  </para>
____________________________________________________________________________-->
  <para>
   对于大多数索引方法，索引的创建速度取决于
   <xref linkend="guc-maintenance-work-mem"/>的设置。较大的值将会减少
   索引创建所需的时间，当然不要把它设置得超过实际可用的内存量（那会迫使
   机器进行交换）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> can build indexes while
   leveraging multiple CPUs in order to process the table rows faster.
   This feature is known as <firstterm>parallel index
   build</firstterm>.  For index methods that support building indexes
   in parallel (currently, only B-tree),
   <varname>maintenance_work_mem</varname> specifies the maximum
   amount of memory that can be used by each index build operation as
   a whole, regardless of how many worker processes were started.
   Generally, a cost model automatically determines how many worker
   processes should be requested, if any.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>可以在构建索引时利用多个CPU以更快地处理表行。这种特性被称为<firstterm>并行索引构建</firstterm>。对于支持并行构建索引的索引方法（当前只有B-树），<varname>maintenance_work_mem</varname>指定每次索引构建操作整体可用的最大内存量，而不管启动了多少工作者进程。一般来说，一个代价模型（如果有）自动判断应该请求多少工作者进程。
  </para>

<!--==========================orignal english content==========================
  <para>
   Parallel index builds may benefit from increasing
   <varname>maintenance_work_mem</varname> where an equivalent serial
   index build will see little or no benefit.  Note that
   <varname>maintenance_work_mem</varname> may influence the number of
   worker processes requested, since parallel workers must have at
   least a <literal>32MB</literal> share of the total
   <varname>maintenance_work_mem</varname> budget.  There must also be
   a remaining <literal>32MB</literal> share for the leader process.
   Increasing <xref linkend="guc-max-parallel-workers-maintenance"/>
   may allow more workers to be used, which will reduce the time
   needed for index creation, so long as the index build is not
   already I/O bound.  Of course, there should also be sufficient
   CPU capacity that would otherwise lie idle.
  </para>
____________________________________________________________________________-->
  <para>
   增加<varname>maintenance_work_mem</varname>可以让并行索引构建受益，而等效的串行索引构建将无法受益或者得到很小的益处。注意<varname>maintenance_work_mem</varname>可能会影响请求的工作者进程的数量，因为并行工作者必须在总的<varname>maintenance_work_mem</varname>预算中占有至少<literal>32MB</literal>的份额。还必须有<literal>32MB</literal>的份额留给领袖进程。增加<xref linkend="guc-max-parallel-workers-maintenance"/>可以允许使用更多的工作者，这将降低索引创建所需的时间，只要索引构建不是I/O密集型的。当然，还需要有足够的CPU计算能力，否则工作者们会闲置。
  </para>

<!--==========================orignal english content==========================
  <para>
   Setting a value for <literal>parallel_workers</literal> via <xref
   linkend="sql-altertable"/> directly controls how many parallel
   worker processes will be requested by a <command>CREATE
   INDEX</command> against the table.  This bypasses the cost model
   completely, and prevents <varname>maintenance_work_mem</varname>
   from affecting how many parallel workers are requested.  Setting
   <literal>parallel_workers</literal> to 0 via <command>ALTER
   TABLE</command> will disable parallel index builds on the table in
   all cases.
  </para>
____________________________________________________________________________-->
  <para>
   通过<xref linkend="sql-altertable"/>为<literal>parallel_workers</literal>设置一个值直接控制着<command>CREATE INDEX</command>会对表请求多少并行工作者进程。这会完全绕过代价模型，并且防止<varname>maintenance_work_mem</varname>对请求多少并行工作者产生影响。通过<command>ALTER TABLE</command>将<literal>parallel_workers</literal>设置为0将禁用所有情况下的并行索引构建。
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    You might want to reset <literal>parallel_workers</literal> after
    setting it as part of tuning an index build.  This avoids
    inadvertent changes to query plans, since
    <literal>parallel_workers</literal> affects
    <emphasis>all</emphasis> parallel table scans.
   </para>
____________________________________________________________________________-->
   <para>
    在把<literal>parallel_workers</literal>用于调优一次索引构建之后，你可能想要重置<literal>parallel_workers</literal>。这可以避免对查询计划的无意更改，因为<literal>parallel_workers</literal>影响<emphasis>所有的</emphasis>并行表扫描。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   While <command>CREATE INDEX</command> with the
   <literal>CONCURRENTLY</literal> option supports parallel builds
   without special restrictions, only the first table scan is actually
   performed in parallel.
  </para>
____________________________________________________________________________-->
  <para>
   虽然带有<literal>CONCURRENTLY</literal>选项的<command>CREATE INDEX</command>支持并行构建并且没有特殊的限制，但只有第一次表扫描会实际以并行方式执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Use <xref linkend="sql-dropindex"/>
   to remove an index.
  </para>
____________________________________________________________________________-->
  <para>
   使用<xref linkend="sql-dropindex"/>可以移除一个索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Prior releases of <productname>PostgreSQL</productname> also had an
   R-tree index method.  This method has been removed because
   it had no significant advantages over the GiST method.
   If <literal>USING rtree</literal> is specified, <command>CREATE INDEX</command>
   will interpret it as <literal>USING gist</literal>, to simplify conversion
   of old databases to GiST.
  </para>
____________________________________________________________________________-->
  <para>
   以前的<productname>PostgreSQL</productname>发行也有一种 R-树
   索引方法。这种方法已经被移除，因为它比起 GiST 方法来说没有什么明显的
   优势。如果指定了<literal>USING rtree</literal>，<command>CREATE INDEX</command>
   将会把它解释为<literal>USING gist</literal>，以便把旧的数据库转换成 GiST。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   To create a unique B-tree index on the column <literal>title</literal> in
   the table <literal>films</literal>:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在表<literal>films</literal>中的列<literal>title</literal>上创建一个
   B-树索引：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a unique B-tree index on the column <literal>title</literal>
   with included columns <literal>director</literal>
   and <literal>rating</literal> in the table <literal>films</literal>:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要在表<literal>films</literal>的列<literal>title</literal>上创建一个唯一的B-树索引并且包括列<literal>director</literal>和<literal>rating</literal>：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index on the expression <literal>lower(title)</literal>,
   allowing efficient case-insensitive searches:
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   (In this example we have chosen to omit the index name, so the system
   will choose a name, typically <literal>films_lower_idx</literal>.)
  </para>
____________________________________________________________________________-->
  <para>
   在表达式<literal>lower(title)</literal>上创建一个索引来允许高效的大小写
   无关搜索：
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   （在这个例子中我们选择省略索引名称，这样系统会选择一个名字，
   通常是<literal>films_lower_idx</literal>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index with non-default collation:
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个具有非默认排序规则的索引：
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index with non-default sort ordering of nulls:
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个具有非默认空值排序顺序的索引：
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index with non-default fill factor:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个具有非默认填充因子的索引：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a <acronym>GIN</acronym> index with fast updates disabled:
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   创建一个禁用快速更新的<acronym>GIN</acronym>索引：
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index on the column <literal>code</literal> in the table
   <literal>films</literal> and have the index reside in the tablespace
   <literal>indexspace</literal>:
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在表<literal>films</literal>中的列<literal>code</literal>上创建一个而索引并且
   把索引放在表空间<literal>indexspace</literal>中：
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create a GiST index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在一个点属性上创建一个 GiST 索引，这样我们可以在转换函数的结果
   上有效地使用 box 操作符：
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To create an index without locking out writes to the table:
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>
____________________________________________________________________________-->
  <para>
   创建一个表而不排斥对表的写操作：
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE INDEX</command> is a
   <productname>PostgreSQL</productname> language extension.  There
   are no provisions for indexes in the SQL standard.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>是一种
   <productname>PostgreSQL</productname>的语言扩展。在 SQL 标准中
   没有对于索引的规定。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"/></member>
   <member><xref linkend="sql-dropindex"/></member>
  </simplelist>
 </refsect1>
</refentry>
