<!--
doc/src/sgml/ref/copy.sgml
PostgreSQL documentation
-->


<refentry id="sql-copy">
<!--==========================orignal english content==========================
 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-copy">
  <primary>COPY</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>COPY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>copy data between a file and a table</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>COPY</refname>
  <refpurpose>在一个文件和一个表之间复制数据</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>where <replaceable class="parameter">option</replaceable> can be one of:</phrase>

    FORMAT <replaceable class="parameter">format_name</replaceable>
    OIDS [ <replaceable class="parameter">boolean</replaceable> ]
    FREEZE [ <replaceable class="parameter">boolean</replaceable> ]
    DELIMITER '<replaceable class="parameter">delimiter_character</replaceable>'
    NULL '<replaceable class="parameter">null_string</replaceable>'
    HEADER [ <replaceable class="parameter">boolean</replaceable> ]
    QUOTE '<replaceable class="parameter">quote_character</replaceable>'
    ESCAPE '<replaceable class="parameter">escape_character</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">column_name</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    FORCE_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">encoding_name</replaceable>'
</synopsis>
____________________________________________________________________________-->
<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDIN }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | PROGRAM '<replaceable class="parameter">command</replaceable>' | STDOUT }
    [ [ WITH ] ( <replaceable class="parameter">option</replaceable> [, ...] ) ]

<phrase>其中 <replaceable class="parameter">option</replaceable> 可以是下列之一：</phrase>

    FORMAT <replaceable class="parameter">format_name</replaceable>
    OIDS [ <replaceable class="parameter">boolean</replaceable> ]
    FREEZE [ <replaceable class="parameter">boolean</replaceable> ]
    DELIMITER '<replaceable class="parameter">delimiter_character</replaceable>'
    NULL '<replaceable class="parameter">null_string</replaceable>'
    HEADER [ <replaceable class="parameter">boolean</replaceable> ]
    QUOTE '<replaceable class="parameter">quote_character</replaceable>'
    ESCAPE '<replaceable class="parameter">escape_character</replaceable>'
    FORCE_QUOTE { ( <replaceable class="parameter">column_name</replaceable> [, ...] ) | * }
    FORCE_NOT_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    FORCE_NULL ( <replaceable class="parameter">column_name</replaceable> [, ...] )
    ENCODING '<replaceable class="parameter">encoding_name</replaceable>'
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>COPY</command> moves data between
   <productname>PostgreSQL</productname> tables and standard file-system
   files. <command>COPY TO</command> copies the contents of a table
   <emphasis>to</emphasis> a file, while <command>COPY FROM</command> copies
   data <emphasis>from</emphasis> a file to a table (appending the data to
   whatever is in the table already).  <command>COPY TO</command>
   can also copy the results of a <command>SELECT</command> query.
  </para>
____________________________________________________________________________-->
  <para>
   <command>COPY</command>在
   <productname>PostgreSQL</productname>表和标准文件系统文件之间
   移动数据。<command>COPY TO</command>把一个表的内容复制
   <emphasis>到</emphasis>一个文件，而<command>COPY FROM</command>
   则<emphasis>从</emphasis>一个文件复制数据到一个表（把数据追加到表中原有数
   据）。<command>COPY TO</command>也能复制一个
   <command>SELECT</command>查询的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a list of columns is specified, <command>COPY</command> will
   only copy the data in the specified columns to or from the file.
   If there are any columns in the table that are not in the column list,
   <command>COPY FROM</command> will insert the default values for
   those columns.
  </para>
____________________________________________________________________________-->
  <para>
   如果指定了一个列列表，<command>COPY</command>将只把指定列的
   数据复制到文件或者从文件复制数据到指定列。如果表中有列不在列列表中，
   <command>COPY FROM</command>将会为那些列插入默认值。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>COPY</command> with a file name instructs the
   <productname>PostgreSQL</productname> server to directly read from
   or write to a file. The file must be accessible by the
   <productname>PostgreSQL</productname> user (the user ID the server
   runs as) and the name must be specified from the viewpoint of the
   server. When <literal>PROGRAM</literal> is specified, the server
   executes the given command and reads from the standard output of the
   program, or writes to the standard input of the program. The command
   must be specified from the viewpoint of the server, and be executable
   by the <productname>PostgreSQL</productname> user.  When
   <literal>STDIN</literal> or <literal>STDOUT</literal> is
   specified, data is transmitted via the connection between the
   client and the server.
  </para>
____________________________________________________________________________-->
  <para>
   带一个文件名的<command>COPY</command>指示
   <productname>PostgreSQL</productname>服务器直接从一个文件读取
   或者写入到一个文件。该文件必须是
   <productname>PostgreSQL</productname>用户（运行服务器的用户 ID）
   可访问的并且应该以服务器的视角来指定其名称。当指定了
   <literal>PROGRAM</literal>时，服务器执行给定的命令并且从该程序的标准
   输出读取或者写入到该程序的标准输入。该程序必须以服务器的视角指定，并且
   必须是<productname>PostgreSQL</productname>用户可执行的。在指定
   <literal>STDIN</literal>或者<literal>STDOUT</literal>时，数据会通过客
   户端和服务器之间的连接传输。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">table_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of an existing table.
     </para>
____________________________________________________________________________-->
     <para>
      一个现有表的名称（可以是模式限定的）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">column_name</replaceable></term>
     <listitem>
<!--==========================orignal english content==========================
     <para>
      An optional list of columns to be copied.  If no column list is
      specified, all columns of the table will be copied.
     </para>
____________________________________________________________________________-->
     <para>
      可选的要被复制的列列表。如果没有指定列列表，则该表的所有列都会被复制。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">query</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A <xref linkend="sql-select"/>, <xref linkend="sql-values"/>,
      <xref linkend="sql-insert"/>, <xref linkend="sql-update"/> or
      <xref linkend="sql-delete"/> command whose results are to be
      copied.  Note that parentheses are required around the query.
     </para>
____________________________________________________________________________-->
     <para>
      其结果要被复制的<xref linkend="sql-select"/>、
      <xref linkend="sql-values"/>、
      <xref linkend="sql-insert"/>、<xref linkend="sql-update"/>或者
      <xref linkend="sql-delete"/>命令。注意查询周围的圆括号是必要的。
     </para>
<!--==========================orignal english content==========================
     <para>
      For <command>INSERT</command>, <command>UPDATE</command> and
      <command>DELETE</command> queries a RETURNING clause must be provided,
      and the target relation must not have a conditional rule, nor
      an <literal>ALSO</literal> rule, nor an <literal>INSTEAD</literal> rule
      that expands to multiple statements.
     </para>
____________________________________________________________________________-->
     <para>
      对于<command>INSERT</command>、<command>UPDATE</command>以及
      <command>DELETE</command>查询，必须提供一个 RETURNING 子句并且
      目标关系不能具有会扩展成多条语句的条件规则、
      <literal>ALSO</literal>规则或者<literal>INSTEAD</literal>规则。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">filename</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">filename</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The path name of the input or output file.  An input file name can be
      an absolute or relative path, but an output file name must be an absolute
      path.  Windows users might need to use an <literal>E''</literal> string and
      double any backslashes used in the path name.
     </para>
____________________________________________________________________________-->
     <para>
      输入或者输出文件的路径名。一个输入文件的名称可以是一个绝对或相对路径，
      但一个输出文件的名称必须是绝对路径。Windows 用户可能需要使用一个
       <literal>E''</literal>字符串并且双写路径名称中使用的任何反斜线。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PROGRAM</literal></term>
____________________________________________________________________________-->
    <term><literal>PROGRAM</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A command to execute. In <command>COPY FROM</command>, the input is
      read from standard output of the command, and in <command>COPY TO</command>,
      the output is written to the standard input of the command.
     </para>
____________________________________________________________________________-->
     <para>
      一个要执行的命令。在<command>COPY FROM</command>中，输入
      将从该命令的标准输出读取，而在<command>COPY TO</command>中，输出会
      写入到该命令的标准输入。
     </para>
<!--==========================orignal english content==========================
     <para>
      Note that the command is invoked by the shell, so if you need to pass
      any arguments to shell command that come from an untrusted source, you
      must be careful to strip or escape any special characters that might
      have a special meaning for the shell. For security reasons, it is best
      to use a fixed command string, or at least avoid passing any user input
      in it.
     </para>
____________________________________________________________________________-->
     <para>
      注意该命令是由 shell 调用，因此如果你需要传递任何来自不可信来源的
      参数给 shell 命令，你必须小心地剥离那些可能对 shell 有特殊意义的特殊
      字符。出于安全原因，最好使用一个固定的命令字符串，或者至少避免传递
      任何用户输入到其中。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>STDIN</literal></term>
____________________________________________________________________________-->
    <term><literal>STDIN</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies that input comes from the client application.
     </para>
____________________________________________________________________________-->
     <para>
      指定输入来自客户端应用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>STDOUT</literal></term>
____________________________________________________________________________-->
    <term><literal>STDOUT</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies that output goes to the client application.
     </para>
____________________________________________________________________________-->
     <para>
      指定输出会去到客户端应用。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">boolean</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies whether the selected option should be turned on or off.
      You can write <literal>TRUE</literal>, <literal>ON</literal>, or
      <literal>1</literal> to enable the option, and <literal>FALSE</literal>,
      <literal>OFF</literal>, or <literal>0</literal> to disable it.  The
      <replaceable class="parameter">boolean</replaceable> value can also
      be omitted, in which case <literal>TRUE</literal> is assumed.
     </para>
____________________________________________________________________________-->
     <para>
      指定选中的选项是应该被关闭还是打开。可以写<literal>TRUE</literal>、
      <literal>ON</literal>或<literal>1</literal>来启用选项，写
      <literal>FALSE</literal>、<literal>OFF</literal>或<literal>0</literal>禁用它。
      <replaceable class="parameter">boolean</replaceable>值也可以被省略，
      那样会假定为<literal>TRUE</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FORMAT</literal></term>
____________________________________________________________________________-->
    <term><literal>FORMAT</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Selects the data format to be read or written:
      <literal>text</literal>,
      <literal>csv</literal> (Comma Separated Values),
      or <literal>binary</literal>.
      The default is <literal>text</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      选择要读取或者写入的数据格式：
      <literal>text</literal>、
      <literal>csv</literal>（逗号分隔值）或者<literal>binary</literal>。
      默认是<literal>text</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>OIDS</literal></term>
____________________________________________________________________________-->
    <term><literal>OIDS</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies copying the OID for each row.  (An error is raised if
      <literal>OIDS</literal> is specified for a table that does not
      have OIDs, or in the case of copying a <replaceable
      class="parameter">query</replaceable>.)
     </para>
____________________________________________________________________________-->
     <para>
      指定为每一行复制 OID（如果为一个没有 OID 的表指定了
      <literal>OIDS</literal>或者正在复制的是一个<replaceable
      class="parameter">查询</replaceable>，则会出现错误）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FREEZE</literal></term>
____________________________________________________________________________-->
    <term><literal>FREEZE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Requests copying the data with rows already frozen, just as they
      would be after running the <command>VACUUM FREEZE</command> command.
      This is intended as a performance option for initial data loading.
      Rows will be frozen only if the table being loaded has been created
      or truncated in the current subtransaction, there are no cursors
      open and there are no older snapshots held by this transaction.  It is
      currently not possible to perform a <command>COPY FREEZE</command> on
      a partitioned table.
     </para>
____________________________________________________________________________-->
     <para>
      请求复制已经完成了行冻结的数据，就好像在运行
      <command>VACUUM FREEZE</command>命令之后复制。这是为了初始
      数据载入的性能而设计的。只有被载入表已经在当前子事务中被创建
      或截断、该事务中没有游标打开并且该事务没有持有更旧的快照时，
      行才会被冻结。目前无法在分区表上执行<command>COPY FREEZE</command>。
     </para>
<!--==========================orignal english content==========================
     <para>
      Note that all other sessions will immediately be able to see the data
      once it has been successfully loaded. This violates the normal rules
      of MVCC visibility and users specifying should be aware of the
      potential problems this might cause.
     </para>
____________________________________________________________________________-->
     <para>
      注意一旦成功地载入，所有其他会话将能立即看到该数据。这违背了
      普通的 MVCC 可见性规则，指定该选项的用户应该注意这可能会导致
      的潜在问题。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>DELIMITER</literal></term>
____________________________________________________________________________-->
    <term><literal>DELIMITER</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies the character that separates columns within each row
      (line) of the file.  The default is a tab character in text format,
      a comma in <literal>CSV</literal> format.
      This must be a single one-byte character.
      This option is not allowed when using <literal>binary</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      指定分隔文件每行中各列的字符。文本格式中默认是一个制表符，
      而<literal>CSV</literal>格式中默认是一个逗号。这必须是一个单一
      的单字节字符。使用<literal>binary</literal>格式时不允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>NULL</literal></term>
____________________________________________________________________________-->
    <term><literal>NULL</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies the string that represents a null value. The default is
      <literal>\N</literal> (backslash-N) in text format, and an unquoted empty
      string in <literal>CSV</literal> format. You might prefer an
      empty string even in text format for cases where you don't want to
      distinguish nulls from empty strings.
      This option is not allowed when using <literal>binary</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      指定表示一个空值的字符串。文本格式中默认是
      <literal>\N</literal>（反斜线-N），<literal>CSV</literal>格式中默认
      是一个未加引用的空串。在你不想区分空值和空串的情况下，即使在文本
      格式中你也可能更喜欢空串。使用<literal>binary</literal>格式时不允许这
      个选项。
     </para>

     <note>
<!--==========================orignal english content==========================
      <para>
       When using <command>COPY FROM</command>, any data item that matches
       this string will be stored as a null value, so you should make
       sure that you use the same string as you used with
       <command>COPY TO</command>.
      </para>
____________________________________________________________________________-->
      <para>
       在使用<command>COPY FROM</command>时，任何匹配
       这个串的数据项将被存储为空值，因此你应该确定你使用的是和
       <command>COPY TO</command>时相同的串。
      </para>
     </note>

    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>HEADER</literal></term>
____________________________________________________________________________-->
    <term><literal>HEADER</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies that the file contains a header line with the names of each
      column in the file.  On output, the first line contains the column
      names from the table, and on input, the first line is ignored.
      This option is allowed only when using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      指定文件包含标题行，其中有每一列的名称。在输出时，第一行包含
      来自表的列名。在输入时，第一行会被忽略。只有使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>QUOTE</literal></term>
____________________________________________________________________________-->
    <term><literal>QUOTE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies the quoting character to be used when a data value is quoted.
      The default is double-quote.
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      指定一个数据值被引用时使用的引用字符。默认是双引号。
      这必须是一个单一的单字节字符。只有使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ESCAPE</literal></term>
____________________________________________________________________________-->
    <term><literal>ESCAPE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies the character that should appear before a
      data character that matches the <literal>QUOTE</literal> value.
      The default is the same as the <literal>QUOTE</literal> value (so that
      the quoting character is doubled if it appears in the data).
      This must be a single one-byte character.
      This option is allowed only when using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      指定应该出现在一个匹配<literal>QUOTE</literal>值的数据字符之前
      的字符。默认和<literal>QUOTE</literal>值一样（这样如果引用字符
      出现在数据中，它会被双写）。这必须是一个单一的单字节字符。
      只有使用<literal>CSV</literal>格式时才允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FORCE_QUOTE</literal></term>
____________________________________________________________________________-->
    <term><literal>FORCE_QUOTE</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Forces quoting to be
      used for all non-<literal>NULL</literal> values in each specified column.
      <literal>NULL</literal> output is never quoted. If <literal>*</literal> is specified,
      non-<literal>NULL</literal> values will be quoted in all columns.
      This option is allowed only in <command>COPY TO</command>, and only when
      using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      强制必须对每个指定列中的所有非<literal>NULL</literal>值使用引用。
      <literal>NULL</literal>输出不会被引用。如果指定了<literal>*</literal>，
      所有列的非<literal>NULL</literal>值都将被引用。只有在
      <command>COPY TO</command>中使用<literal>CSV</literal>格式时才允许
      这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FORCE_NOT_NULL</literal></term>
____________________________________________________________________________-->
    <term><literal>FORCE_NOT_NULL</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Do not match the specified columns' values against the null string.
      In the default case where the null string is empty, this means that
      empty values will be read as zero-length strings rather than nulls,
      even when they are not quoted.
      This option is allowed only in <command>COPY FROM</command>, and only when
      using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      不要把指定列的值与空值串匹配。在空值串就是空串的默认情况下，
      这意味着空串将被读作长度为零的字符串而不是空值（即使它们没有
      被引用）。只有在<command>COPY FROM</command>中使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>FORCE_NULL</literal></term>
____________________________________________________________________________-->
    <term><literal>FORCE_NULL</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Match the specified columns' values against the null string, even
      if it has been quoted, and if a match is found set the value to
      <literal>NULL</literal>. In the default case where the null string is empty,
      this converts a quoted empty string into NULL.
      This option is allowed only in <command>COPY FROM</command>, and only when
      using <literal>CSV</literal> format.
     </para>
____________________________________________________________________________-->
     <para>
      将指定列的值与空值串匹配（即使它已经被加上引号），并且在找到
      匹配时将该值设置为<literal>NULL</literal>。在空值串就是空串的默认
      情况下，这会把一个被引用的空串转换为 NULL。
      只有在<command>COPY FROM</command>中使用
      <literal>CSV</literal>格式时才允许这个选项。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>ENCODING</literal></term>
____________________________________________________________________________-->
    <term><literal>ENCODING</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Specifies that the file is encoded in the <replaceable
      class="parameter">encoding_name</replaceable>.  If this option is
      omitted, the current client encoding is used. See the Notes below
      for more details.
     </para>
____________________________________________________________________________-->
     <para>
      指定文件被以<replaceable
      class="parameter">encoding_name</replaceable>编码。如果省略
      这个选项，将使用当前的客户端编码。详见下文的注解。
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Outputs</title>
____________________________________________________________________________-->
  <title>输出</title>

<!--==========================orignal english content==========================
  <para>
   On successful completion, a <command>COPY</command> command returns a command
   tag of the form
<screen>
COPY <replaceable class="parameter">count</replaceable>
</screen>
   The <replaceable class="parameter">count</replaceable> is the number
   of rows copied.
  </para>
____________________________________________________________________________-->
  <para>
   在成功完成时，一个<command>COPY</command>命令会返回一个形为
<screen>
COPY <replaceable class="parameter">count</replaceable>
</screen>
   的命令标签。
   <replaceable class="parameter">count</replaceable>是被复制
   的行数。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    <application>psql</application> will print this command tag only if the command
    was not <literal>COPY ... TO STDOUT</literal>, or the
    equivalent <application>psql</application> meta-command
    <literal>\copy ... to stdout</literal>.  This is to prevent confusing the
    command tag with the data that was just printed.
   </para>
____________________________________________________________________________-->
   <para>
    如果命令不是<literal>COPY ... TO STDOUT</literal>或者等效的
    <application>psql</application>元命令<literal>\copy ... to stdout</literal>，
    <application>psql</application>将只打印这个命令标签。这是为了防止弄混
    命令标签和刚刚打印的数据。
   </para>
  </note>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    <command>COPY TO</command> can only be used with plain tables, not
    with views.  However, you can write <literal>COPY (SELECT * FROM
    <replaceable class="parameter">viewname</replaceable>) TO ...</literal>
    to copy the current contents of a view.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY TO</command>只能被用于纯粹的表，不能用于视图。
    不过你可以写<literal>COPY (SELECT * FROM
    <replaceable class="parameter">viewname</replaceable>) TO ...</literal>来拷贝一个视图的当前内容。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY FROM</command> can be used with plain, foreign, or
    partitioned tables or with views that have
    <literal>INSTEAD OF INSERT</literal> triggers.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY FROM</command>可以被用于普通表、外部表、分区表或者具有<literal>INSTEAD OF INSERT</literal>触发器的视图。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY</command> only deals with the specific table named;
    it does not copy data to or from child tables.  Thus for example
    <literal>COPY <replaceable class="parameter">table</replaceable> TO</literal>
    shows the same data as <literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</replaceable></literal>.  But <literal>COPY
    (SELECT * FROM <replaceable class="parameter">table</replaceable>) TO ...</literal>
    can be used to dump all of the data in an inheritance hierarchy.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY</command>只处理提到的表，它不会从子表复制
    数据或者复制数据到子表中。例如
    <literal>COPY <replaceable class="parameter">table</replaceable> TO</literal>
    会显示与<literal>SELECT * FROM ONLY <replaceable
    class="parameter">table</replaceable></literal>相同的数据。而<literal>COPY
    (SELECT * FROM <replaceable class="parameter">table</replaceable>) TO ...</literal>
    可以被用来转储一个继承层次中的所有数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    You must have select privilege on the table
    whose values are read by <command>COPY TO</command>, and
    insert privilege on the table into which values
    are inserted by <command>COPY FROM</command>.  It is sufficient
    to have column privileges on the column(s) listed in the command.
   </para>
____________________________________________________________________________-->
   <para>
    你必须拥有被<command>COPY TO</command>读取的表上的选择特权，
    以及被<command>COPY FROM</command>插入的表上的插入特权。
    拥有在命令中列出的列上的特权就足够了。
   </para>

<!--==========================orignal english content==========================
   <para>
    If row-level security is enabled for the table, the relevant
    <command>SELECT</command> policies will apply to <literal>COPY
    <replaceable class="parameter">table</replaceable> TO</literal> statements.
    Currently, <command>COPY FROM</command> is not supported for tables
    with row-level security. Use equivalent <command>INSERT</command>
    statements instead.
   </para>
____________________________________________________________________________-->
   <para>
    如果对表启用了行级安全性，相关的<command>SELECT</command>策略将应用于<literal>COPY
    <replaceable class="parameter">table</replaceable> TO</literal>语句。当前，有行级安全性的表不支持<command>COPY FROM</command>。不过可以使用等效的<command>INSERT</command>语句。
   </para>

<!--==========================orignal english content==========================
   <para>
    Files named in a <command>COPY</command> command are read or written
    directly by the server, not by the client application. Therefore,
    they must reside on or be accessible to the database server machine,
    not the client. They must be accessible to and readable or writable
    by the <productname>PostgreSQL</productname> user (the user ID the
    server runs as), not the client. Similarly,
    the command specified with <literal>PROGRAM</literal> is executed directly
    by the server, not by the client application, must be executable by the
    <productname>PostgreSQL</productname> user.
    <command>COPY</command> naming a file or command is only allowed to
    database superusers or users who are granted one of the default roles
    <literal>pg_read_server_files</literal>,
    <literal>pg_write_server_files</literal>,
    or <literal>pg_execute_server_program</literal>, since it allows reading
    or writing any file or running a program that the server has privileges to
    access.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY</command>命令中提到的文件会被服务器（而不是
    客户端应用）直接读取或写入。因此它们必须位于数据库服务器（不是客户
    端）的机器上或者是数据库服务器可以访问的。它们必须是
    <productname>PostgreSQL</productname>用户（运行服务器的用户 
    ID）可访问的并且是可读或者可写的。类似地，用<literal>PROGRAM</literal>
    指定的命令也会由服务器（不是客户端应用）直接执行，它也必须是
    <productname>PostgreSQL</productname>用户可以执行的。
    只允许数据库超级用户或者授予了默认角色<literal>pg_read_server_files</literal>、<literal>pg_write_server_files</literal>及<literal>pg_execute_server_program</literal>之一的用户<command>COPY</command>一个文件或者命令，
    因为它允许读取或者写入服务器有特权访问的任何文件或者运行服务器有特权访问的程序。
   </para>

<!--==========================orignal english content==========================
   <para>
    Do not confuse <command>COPY</command> with the
    <application>psql</application> instruction
    <command><link linkend="app-psql-meta-commands-copy">\copy</link></command>. <command>\copy</command> invokes
    <command>COPY FROM STDIN</command> or <command>COPY TO
    STDOUT</command>, and then fetches/stores the data in a file
    accessible to the <application>psql</application> client. Thus,
    file accessibility and access rights depend on the client rather
    than the server when <command>\copy</command> is used.
   </para>
____________________________________________________________________________-->
   <para>
    不要把<command>COPY</command>和
    <application>psql</application>指令
    <command><link linkend="app-psql-meta-commands-copy">\copy</link></command>
    弄混。<command>\copy</command>会调用
    <command>COPY FROM STDIN</command>或者<command>COPY TO
    STDOUT</command>，然后读取/存储一个
    <application>psql</application>客户端可访问的文件中的数据。
    因此，在使用<command>\copy</command>时，文件的可访
    问性和访问权利取决于客户端而不是服务器。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is recommended that the file name used in <command>COPY</command>
    always be specified as an absolute path. This is enforced by the
    server in the case of <command>COPY TO</command>, but for
    <command>COPY FROM</command> you do have the option of reading from
    a file specified by a relative path. The path will be interpreted
    relative to the working directory of the server process (normally
    the cluster's data directory), not the client's working directory.
   </para>
____________________________________________________________________________-->
   <para>
    我们推荐在<command>COPY</command>中使用的文件名总是
    指定为一个绝对路径。在<command>COPY TO</command>的
    情况下服务器会强制这一点，但是对于
    <command>COPY FROM</command>你可以选择从一个用相对
    路径指定的文件中读取。该路径将根据服务器进程（而不是客户端）
    的工作目录（通常是集簇的数据目录）解释。
   </para>

<!--==========================orignal english content==========================
   <para>
    Executing a command with <literal>PROGRAM</literal> might be restricted
    by the operating system's access control mechanisms, such as SELinux.
   </para>
____________________________________________________________________________-->
   <para>
    用<literal>PROGRAM</literal>执行一个命令可能会受到操作系统
    的访问控制机制（如 SELinux）的限制。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY FROM</command> will invoke any triggers and check
    constraints on the destination table. However, it will not invoke rules.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY FROM</command>将调用目标表上的任何触发器
    和检查约束。但是它不会调用规则。
   </para>

<!--==========================orignal english content==========================
   <para>
    For identity columns, the <command>COPY FROM</command> command will always
    write the column values provided in the input data, like
    the <command>INSERT</command> option <literal>OVERRIDING SYSTEM
    VALUE</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    对于标识列，<command>COPY FROM</command>命令将总是写上输入数据中提供的列值，这和<command>INSERT</command>的选项<literal>OVERRIDING SYSTEM VALUE</literal>的行为一样。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY</command> input and output is affected by
    <varname>DateStyle</varname>. To ensure portability to other
    <productname>PostgreSQL</productname> installations that might use
    non-default <varname>DateStyle</varname> settings,
    <varname>DateStyle</varname> should be set to <literal>ISO</literal> before
    using <command>COPY TO</command>.  It is also a good idea to avoid dumping
    data with <varname>IntervalStyle</varname> set to
    <literal>sql_standard</literal>, because negative interval values might be
    misinterpreted by a server that has a different setting for
    <varname>IntervalStyle</varname>.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY</command>输入和输出受到
    <varname>DateStyle</varname>的影响。为了确保到其他
    可能使用非默认<varname>DateStyle</varname>设置的
    <productname>PostgreSQL</productname>安装的可移植性，在使用
    <command>COPY TO</command>前应该把
    <varname>DateStyle</varname>设置为<literal>ISO</literal>。避免转储把
    <varname>IntervalStyle</varname>设置为
    <literal>sql_standard</literal>的数据也是一个好主意，因为负的区间值可能会
    被具有不同<varname>IntervalStyle</varname>设置的服务器解释错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    Input data is interpreted according to <literal>ENCODING</literal>
    option or the current client encoding, and output data is encoded
    in <literal>ENCODING</literal> or the current client encoding, even
    if the data does not pass through the client but is read from or
    written to a file directly by the server.
   </para>
____________________________________________________________________________-->
   <para>
    即使数据会被服务器直接从一个文件读取或者写入一个文件而不通过
    客户端，输入数据也会被根据<literal>ENCODING</literal>选项或者当前
    客户端编码解释，并且输出数据会被根据<literal>ENCODING</literal>或
    者当前客户端编码进行编码。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY</command> stops operation at the first error. This
    should not lead to problems in the event of a <command>COPY
    TO</command>, but the target table will already have received
    earlier rows in a <command>COPY FROM</command>. These rows will not
    be visible or accessible, but they still occupy disk space. This might
    amount to a considerable amount of wasted disk space if the failure
    happened well into a large copy operation. You might wish to invoke
    <command>VACUUM</command> to recover the wasted space.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY</command>会在第一个错误处停止操作。这在
    <command>COPY TO</command>的情况下不会导致问题，但是
    在<command>COPY FROM</command>中目标表将已经收到了一
    些行。这些行将不会变得可见或者可访问，但是它们仍然占据磁盘空间。
    如果在一次大型的复制操作中出现错误，这可能浪费相当可观的磁盘空间。
    你可能希望调用<command>VACUUM</command>来恢复被浪费的
    空间。
   </para>

<!--==========================orignal english content==========================
   <para>
    <literal>FORCE_NULL</literal> and <literal>FORCE_NOT_NULL</literal> can be used
    simultaneously on the same column. This results in converting quoted
    null strings to null values and unquoted null strings to empty strings.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>FORCE_NULL</literal>和<literal>FORCE_NOT_NULL</literal>可以被同时
    用在同一列上。这会导致把已被引用的空值串转换为空值并且把未引用的空值
    串转换为空串。
   </para>

 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>File Formats</title>
____________________________________________________________________________-->
  <title>文件格式</title>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Text Format</title>
____________________________________________________________________________-->
   <title>文本格式</title>

<!--==========================orignal english content==========================
   <para>
    When the <literal>text</literal> format is used,
    the data read or written is a text file with one line per table row.
    Columns in a row are separated by the delimiter character.
    The column values themselves are strings generated by the
    output function, or acceptable to the input function, of each
    attribute's data type.  The specified null string is used in
    place of columns that are null.
    <command>COPY FROM</command> will raise an error if any line of the
    input file contains more or fewer columns than are expected.
    If <literal>OIDS</literal> is specified, the OID is read or written as the first column,
    preceding the user data columns.
   </para>
____________________________________________________________________________-->
   <para>
    在使用<literal>text</literal>格式时，读取或写入的是一个文本文件，
    其中每一行就是表中的一行。一行中的列被定界字符分隔。列值
    本身是由输出函数产生的或者是可被输入函数接受的属于每个属性
    数据类型的字符串。在为空值的列的位置使用指定的空值串。如果
    输入文件的任何行包含比预期更多或者更少的列，
    <command>COPY FROM</command>将会抛出一个错误。如
    果指定了<literal>OIDS</literal>，在处理用户数据列志气啊，
    会从第一列读取 OID 或者把 OID 写入第一列。
   </para>

<!--==========================orignal english content==========================
   <para>
    End of data can be represented by a single line containing just
    backslash-period (<literal>\.</literal>).  An end-of-data marker is
    not necessary when reading from a file, since the end of file
    serves perfectly well; it is needed only when copying data to or from
    client applications using pre-3.0 client protocol.
   </para>
____________________________________________________________________________-->
   <para>
    数据的结束可以表示为一个只包含反斜线-点号（<literal>\.</literal>）的
    单一行。从一个文件读取时，数据结束标记并不是必要的，因为文件
    结束符就已经足够用了。只有使用 3.0 客户端协议之前的客户端应用
    复制数据时才需要它。
   </para>

<!--==========================orignal english content==========================
   <para>
    Backslash characters (<literal>\</literal>) can be used in the
    <command>COPY</command> data to quote data characters that might
    otherwise be taken as row or column delimiters. In particular, the
    following characters <emphasis>must</emphasis> be preceded by a backslash if
    they appear as part of a column value: backslash itself,
    newline, carriage return, and the current delimiter character.
   </para>
____________________________________________________________________________-->
   <para>
    反斜线字符（<literal>\</literal>）可以被用在
    <command>COPY</command>数据中来引用被用作行或者列定界符的
    字符。特别地，如果下列字符作为一个列值的一部分出现，它们
    <emphasis>必须</emphasis>被前置一个反斜线：反斜线本身、新行、回车以及
    当前的定界符字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    The specified null string is sent by <command>COPY TO</command> without
    adding any backslashes; conversely, <command>COPY FROM</command> matches
    the input against the null string before removing backslashes.  Therefore,
    a null string such as <literal>\N</literal> cannot be confused with
    the actual data value <literal>\N</literal> (which would be represented
    as <literal>\\N</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY TO</command>会不加任何反斜线返回指定的空值串。
    相反，<command>COPY FROM</command>会在移除反斜线之前把输入
    与空值串相匹配。因此，一个空值串（例如<literal>\N</literal>）不会与实
    际的数据值<literal>\N</literal>（它会被表示为<literal>\\N</literal>）搞混。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following special backslash sequences are recognized by
    <command>COPY FROM</command>:

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Sequence</entry>
       <entry>Represents</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>Backspace (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>Form feed (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>Newline (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>Carriage return (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>Tab (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>Vertical tab (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>digits</replaceable></entry>
       <entry>Backslash followed by one to three octal digits specifies
       the character with that numeric code</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>Backslash <literal>x</literal> followed by one or two hex digits specifies
       the character with that numeric code</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    Presently, <command>COPY TO</command> will never emit an octal or
    hex-digits backslash sequence, but it does use the other sequences
    listed above for those control characters.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY FROM</command>识别下列特殊的反斜线序列：

   <informaltable>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>序列</entry>
       <entry>表示</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>\b</literal></entry>
       <entry>退格 (ASCII 8)</entry>
      </row>
      <row>
       <entry><literal>\f</literal></entry>
       <entry>换页 (ASCII 12)</entry>
      </row>
      <row>
       <entry><literal>\n</literal></entry>
       <entry>新行 (ASCII 10)</entry>
      </row>
      <row>
       <entry><literal>\r</literal></entry>
       <entry>回车 (ASCII 13)</entry>
      </row>
      <row>
       <entry><literal>\t</literal></entry>
       <entry>制表 (ASCII 9)</entry>
      </row>
      <row>
       <entry><literal>\v</literal></entry>
       <entry>纵向制表 (ASCII 11)</entry>
      </row>
      <row>
       <entry><literal>\</literal><replaceable>digits</replaceable></entry>
       <entry>反斜线后跟一到三个十进制位表示该数字代码对应的字符</entry>
      </row>
      <row>
       <entry><literal>\x</literal><replaceable>digits</replaceable></entry>
       <entry>反斜线加<literal>x</literal>后跟一到三个十六进制位表示该数字代码对应的字符</entry>
      </row>
     </tbody>
    </tgroup>
   </informaltable>

    当前，<command>COPY TO</command>不会发出一个十进制或十六进制位
    反斜线序列，但是它确实把上面列出的其他序列用于那些控制字符。
   </para>

<!--==========================orignal english content==========================
   <para>
    Any other backslashed character that is not mentioned in the above table
    will be taken to represent itself.  However, beware of adding backslashes
    unnecessarily, since that might accidentally produce a string matching the
    end-of-data marker (<literal>\.</literal>) or the null string (<literal>\N</literal> by
    default).  These strings will be recognized before any other backslash
    processing is done.
   </para>
____________________________________________________________________________-->
   <para>
    任何上述表格中没有提到的其他反斜线字符将被当作表示其本身。不过，要注意
    增加不必要的反斜线，因为那可能意外地产生一个匹配数据结束标记（
    <literal>\.</literal>）或者空值串（默认是<literal>\N</literal>）的字符串。这些字符串
    将在完成任何其他反斜线处理之前被识别。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is strongly recommended that applications generating <command>COPY</command> data convert
    data newlines and carriage returns to the <literal>\n</literal> and
    <literal>\r</literal> sequences respectively.  At present it is
    possible to represent a data carriage return by a backslash and carriage
    return, and to represent a data newline by a backslash and newline.
    However, these representations might not be accepted in future releases.
    They are also highly vulnerable to corruption if the <command>COPY</command> file is
    transferred across different machines (for example, from Unix to Windows
    or vice versa).
   </para>
____________________________________________________________________________-->
   <para>
    强烈建议产生<command>COPY</command>数据的应用把数据新行和回车分别
    转换为<literal>\n</literal>和<literal>\r</literal>序列。当前可以把一个数据回车表示为
    一个反斜线和回车，把一个数据新行表示为一个反斜线和新行。不过，未来的发行
    可能不会接受这些表示。如果在不同的机器之间（例如从 Unix 到 Windows）
    传输<command>COPY</command>文件，它们也很容易受到破坏。
   </para>

<!--==========================orignal english content==========================
   <para>
    <command>COPY TO</command> will terminate each row with a Unix-style
    newline (<quote><literal>\n</literal></quote>).  Servers running on Microsoft Windows instead
    output carriage return/newline (<quote><literal>\r\n</literal></quote>), but only for
    <command>COPY</command> to a server file; for consistency across platforms,
    <command>COPY TO STDOUT</command> always sends <quote><literal>\n</literal></quote>
    regardless of server platform.
    <command>COPY FROM</command> can handle lines ending with newlines,
    carriage returns, or carriage return/newlines.  To reduce the risk of
    error due to un-backslashed newlines or carriage returns that were
    meant as data, <command>COPY FROM</command> will complain if the line
    endings in the input are not all alike.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY TO</command>将用一个 Unix 风格的新行（
    <quote><literal>\n</literal></quote>）终止每一行。运行在 Microsoft Windows
    上的服务器则会输出回车/新行（<quote><literal>\r\n</literal></quote>），不过只对
    <command>COPY</command>到一个服务器文件这样做。为了做到跨平台一致，
    <command>COPY TO STDOUT</command>总是发送<quote><literal>\n</literal></quote>而
    不管服务器平台是什么。<command>COPY FROM</command>能够处理以
    新行、回车或者回车/新行结尾的行。为了减少由作为数据的未加反斜线的新行
    或者回车带来的风险，如果输出中的行结束并不完全相似，
    <command>COPY FROM</command>将会抱怨。
   </para>
  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>CSV Format</title>
____________________________________________________________________________-->
   <title>CSV 格式</title>

<!--==========================orignal english content==========================
   <para>
    This format option is used for importing and exporting the Comma
    Separated Value (<literal>CSV</literal>) file format used by many other
    programs, such as spreadsheets. Instead of the escaping rules used by
    <productname>PostgreSQL</productname>'s standard text format, it
    produces and recognizes the common CSV escaping mechanism.
   </para>
____________________________________________________________________________-->
   <para>
    这种格式选项被用于导入和导出很多其他程序（例如电子表格）使用的逗号
    分隔值（<literal>CSV</literal>）文件格式。不同于
    <productname>PostgreSQL</productname>标准文本格式使用的转义
    规则，它产生并且识别一般的 CSV 转义机制。
   </para>

<!--==========================orignal english content==========================
   <para>
    The values in each record are separated by the <literal>DELIMITER</literal>
    character. If the value contains the delimiter character, the
    <literal>QUOTE</literal> character, the <literal>NULL</literal> string, a carriage
    return, or line feed character, then the whole value is prefixed and
    suffixed by the <literal>QUOTE</literal> character, and any occurrence
    within the value of a <literal>QUOTE</literal> character or the
    <literal>ESCAPE</literal> character is preceded by the escape character.
    You can also use <literal>FORCE_QUOTE</literal> to force quotes when outputting
    non-<literal>NULL</literal> values in specific columns.
   </para>
____________________________________________________________________________-->
   <para>
    每个记录中的值用<literal>DELIMITER</literal>字符分隔。如果值包含
    定界符字符、<literal>QUOTE</literal>字符、<literal>NULL</literal>字符串、
    一个回车或者换行字符，那么整个值会被加上<literal>QUOTE</literal>字符
    作为前缀或者后缀，并且在该值内<literal>QUOTE</literal>字符或者
    <literal>ESCAPE</literal>字符的任何一次出现之前放上转义字符。在输出
    指定列中非<literal>NULL</literal>值时，还可以使用
    <literal>FORCE_QUOTE</literal>来强制加上引用。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>CSV</literal> format has no standard way to distinguish a
    <literal>NULL</literal> value from an empty string.
    <productname>PostgreSQL</productname>'s <command>COPY</command> handles this by quoting.
    A <literal>NULL</literal> is output as the <literal>NULL</literal> parameter string
    and is not quoted, while a non-<literal>NULL</literal> value matching the
    <literal>NULL</literal> parameter string is quoted.  For example, with the
    default settings, a <literal>NULL</literal> is written as an unquoted empty
    string, while an empty string data value is written with double quotes
    (<literal>""</literal>). Reading values follows similar rules. You can
    use <literal>FORCE_NOT_NULL</literal> to prevent <literal>NULL</literal> input
    comparisons for specific columns. You can also use
    <literal>FORCE_NULL</literal> to convert quoted null string data values to
    <literal>NULL</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>CSV</literal>格式没有标准方式来区分<literal>NULL</literal>值和空字符串。
    <productname>PostgreSQL</productname>的<command>COPY</command>用引用来处理
    这种区分工作。<literal>NULL</literal>被按照<literal>NULL</literal>参数字符串输出
    并且不会被引用，而匹配<literal>NULL</literal>参数字符串的非<literal>NULL</literal>
    值会被加上引用。例如，使用默认设置时，<literal>NULL</literal>被写作一个未
    被引用的空字符串，而一个空字符串数据值会被写成带双引号（<literal>""</literal>）。
    值的读取遵循类似的规则。你可以用<literal>FORCE_NOT_NULL</literal>来防止
    对指定列的<literal>NULL</literal>输入比较。你还可以使用
    <literal>FORCE_NULL</literal>把带引用的空值字符串数据值转换成<literal>NULL</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Because backslash is not a special character in the <literal>CSV</literal>
    format, <literal>\.</literal>, the end-of-data marker, could also appear
    as a data value.  To avoid any misinterpretation, a <literal>\.</literal>
    data value appearing as a lone entry on a line is automatically
    quoted on output, and on input, if quoted, is not interpreted as the
    end-of-data marker.  If you are loading a file created by another
    application that has a single unquoted column and might have a
    value of <literal>\.</literal>, you might need to quote that value in the
    input file.
   </para>
____________________________________________________________________________-->
   <para>
    因为反斜线在<literal>CSV</literal>格式中不是一种特殊字符，数据结束标记
    <literal>\.</literal>也可以作为一个数据值出现。为了避免任何解释误会，在
    一行上作为孤项出现的<literal>\.</literal>数据值输出时会自动被引用，并且
    输入时如果被引用，则不会被解释为数据结束标记。如果正在载入一个由
    另一个应用创建的文件并且其中具有一个未被引用的列且可能具有
    <literal>\.</literal>值，你可能需要在输入文件中引用该值。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     In <literal>CSV</literal> format, all characters are significant. A quoted value
     surrounded by white space, or any characters other than
     <literal>DELIMITER</literal>, will include those characters. This can cause
     errors if you import data from a system that pads <literal>CSV</literal>
     lines with white space out to some fixed width. If such a situation
     arises you might need to preprocess the <literal>CSV</literal> file to remove
     the trailing white space, before importing the data into
     <productname>PostgreSQL</productname>.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>CSV</literal>格式中，所有字符都是有意义的。一个被空白或者其他
     非 <literal>DELIMITER</literal>字符围绕的引用值将包括那些字符。在导入
     来自用空白填充<literal>CSV</literal>行到固定长度的系统的数据时，这可能
     会导致错误。如果出现这种情况，在导入数据到
     <productname>PostgreSQL</productname>之前，你可能需要预处理该
     <literal>CSV</literal>文件以移除拖尾的空白。
    </para>
   </note>

   <note>
<!--==========================orignal english content==========================
    <para>
     CSV format will both recognize and produce CSV files with quoted
     values containing embedded carriage returns and line feeds. Thus
     the files are not strictly one line per table row like text-format
     files.
    </para>
____________________________________________________________________________-->
    <para>
     CSV 格式将识别并且产生带有包含嵌入的回车和换行的引用值的 CSV 
     文件。因此文件并不限于文本格式文件的每个表行一行的形式。
    </para>
   </note>

   <note>
<!--==========================orignal english content==========================
    <para>
     Many programs produce strange and occasionally perverse CSV files,
     so the file format is more a convention than a standard. Thus you
     might encounter some files that cannot be imported using this
     mechanism, and <command>COPY</command> might produce files that other
     programs cannot process.
    </para>
____________________________________________________________________________-->
    <para>
     很多程序会产生奇怪的甚至偶尔是不合常理的 CSV 文件，因此该文件
     格式更像是一种习惯而不是标准。因此你可能会碰到一些无法使用这种
     机制导入的文件，并且<command>COPY</command>也可能产生其他程序无
     法处理的文件。
    </para>
   </note>

  </refsect2>

  <refsect2>
<!--==========================orignal english content==========================
   <title>Binary Format</title>
____________________________________________________________________________-->
   <title>二进制格式</title>

<!--==========================orignal english content==========================
   <para>
    The <literal>binary</literal> format option causes all data to be
    stored/read as binary format rather than as text.  It is
    somewhat faster than the text and <literal>CSV</literal> formats,
    but a binary-format file is less portable across machine architectures and
    <productname>PostgreSQL</productname> versions.
    Also, the binary format is very data type specific; for example
    it will not work to output binary data from a <type>smallint</type> column
    and read it into an <type>integer</type> column, even though that would work
    fine in text format.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>binary</literal>格式选项导致所有数据被以二进制格式
    而不是文本格式存储/读取。它比文本和<literal>CSV</literal>格式要
    快一些，但是二进制格式文件在不同的机器架构和
    <productname>PostgreSQL</productname>版本之间的可移
    植性要差些。还有，二进制格式与数据格式非常相关。例如不能从
    一个<type>smallint</type>列中输出二进制数据并且把它读入到一个
    <type>integer</type>列中，虽然这样做在文本格式中是可行的。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>binary</literal> file format consists
    of a file header, zero or more tuples containing the row data, and
    a file trailer.  Headers and data are in network byte order.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>binary</literal>人间格式由一个文件头、零个或者更多个包含
    行数据的元组以及一个文件尾构成。头部和数据都以网络字节序表示。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> releases before 7.4 used a
     different binary file format.
    </para>
____________________________________________________________________________-->
    <para>
     7.4 之前的<productname>PostgreSQL</productname>发行
     使用一种不同的二进制文件格式。
    </para>
   </note>

   <refsect3>
<!--==========================orignal english content==========================
    <title>File Header</title>
____________________________________________________________________________-->
    <title>文件头</title>

<!--==========================orignal english content==========================
    <para>
     The file header consists of 15 bytes of fixed fields, followed
     by a variable-length header extension area.  The fixed fields are:

    <variablelist>
     <varlistentry>
      <term>Signature</term>
      <listitem>
       <para>
11-byte sequence <literal>PGCOPY\n\377\r\n\0</literal> &mdash; note that the zero byte
is a required part of the signature.  (The signature is designed to allow
easy identification of files that have been munged by a non-8-bit-clean
transfer.  This signature will be changed by end-of-line-translation
filters, dropped zero bytes, dropped high bits, or parity changes.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Flags field</term>
      <listitem>
       <para>
32-bit integer bit mask to denote important aspects of the file format. Bits
are numbered from 0 (<acronym>LSB</acronym>) to 31 (<acronym>MSB</acronym>).  Note that
this field is stored in network byte order (most significant byte first),
as are all the integer fields used in the file format.  Bits
16-31 are reserved to denote critical file format issues; a reader
should abort if it finds an unexpected bit set in this range. Bits 0-15
are reserved to signal backwards-compatible format issues; a reader
should simply ignore any unexpected bits set in this range. Currently
only one flag bit is defined, and the rest must be zero:
        <variablelist>
         <varlistentry>
          <term>Bit 16</term>
          <listitem>
           <para>
            if 1, OIDs are included in the data; if 0, not
           </para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Header extension area length</term>
      <listitem>
       <para>
32-bit integer, length in bytes of remainder of header, not including self.
Currently, this is zero, and the first tuple follows
immediately.  Future changes to the format might allow additional data
to be present in the header.  A reader should silently skip over any header
extension data it does not know what to do with.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     文件头由 15 字节的固定域构成，后面跟着一个变长的头部扩展区。
     固定域有：

    <variablelist>
     <varlistentry>
      <term>签名</term>
      <listitem>
       <para>
11-字节的序列<literal>PGCOPY\n\377\r\n\0</literal> &mdash; 注意
零字节是签名的一个必要的部分（该签名是为了能容易地发现文件被
无法正确处理 8 位字符编码的传输所破坏。这个签名将被行尾翻译过
滤器、删除零字节、删除高位或者奇偶修改等改变）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>标志域</term>
      <listitem>
       <para>
32-位整数位掩码，用以表示该文件格式的重要方面。位被编号为
从 0 （<acronym>LSB</acronym>）到 31（<acronym>MSB</acronym>）。
注意这个域以网络字节序存放（最高有效位在前），所有该文件格式
中使用的整数域都是这样。16-31 位被保留用来表示严重的文件格式
问题， 读取者如果在这个范围内发现预期之外的被设置位，它应该
中止。0-15 位被保留用来表示向后兼容的格式问题，读取者应该简单
地略过这个范围内任何预期之外的被设置位。当前只定义了一个标志
位，其他位必须为零：
        <variablelist>
         <varlistentry>
          <term>位 16</term>
          <listitem>
           <para>
            如果为 1，表示数据中包含 OID；如果为 0，则不包含
           </para>
          </listitem>
         </varlistentry>
        </variablelist></para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>头部扩展区长度</term>
      <listitem>
       <para>
32-为整数，表示头部剩余部分的以字节计的长度，不包括其本身。
当前，这个长度为零，并且其后就紧跟着第一个元组。未来对该
格式的更改可能会允许在头部中表示额外的数据。如果读取者不知
道要对头部扩展区数据做什么，可以安静地跳过它。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    </para>

<!--==========================orignal english content==========================
    <para>
The header extension area is envisioned to contain a sequence of
self-identifying chunks.  The flags field is not intended to tell readers
what is in the extension area.  Specific design of header extension contents
is left for a later release.
    </para>
____________________________________________________________________________-->
    <para>
头部扩展区域被预期包含一个能自我解释的块的序列。
该标志域并不想告诉读取者扩展数据是什么。详细的
头部扩展内容的设计留给后来的发行去做。
    </para>

<!--==========================orignal english content==========================
    <para>
     This design allows for both backwards-compatible header additions (add
     header extension chunks, or set low-order flag bits) and
     non-backwards-compatible changes (set high-order flag bits to signal such
     changes, and add supporting data to the extension area if needed).
    </para>
____________________________________________________________________________-->
    <para>
     这种设计允许向后兼容的头部增加（增加头部扩展块或者设置低位标志位）以及
     非向后兼容的更改（设置高位标志位来表示这类更改并且在需要时向扩展区域
     中增加支持数据）。
    </para>
   </refsect3>

   <refsect3>
<!--==========================orignal english content==========================
    <title>Tuples</title>
____________________________________________________________________________-->
    <title>元组</title>
<!--==========================orignal english content==========================
    <para>
Each tuple begins with a 16-bit integer count of the number of fields in the
tuple.  (Presently, all tuples in a table will have the same count, but that
might not always be true.)  Then, repeated for each field in the tuple, there
is a 32-bit length word followed by that many bytes of field data.  (The
length word does not include itself, and can be zero.)  As a special case,
-1 indicates a NULL field value.  No value bytes follow in the NULL case.
    </para>
____________________________________________________________________________-->
    <para>
每一个元组由一个表示元组中域数量的 16 位整数计数开始（当前，一个表中
的所有元组都应该具有相同的计数，但是这可能不会总是为真）。然后是元组
中的每一个域，它是一个 32 位的长度字，后面则跟随着这么多个字节的域数
据（长度字不包括其本身，并且可以是零）。作为一种特殊情况，-1 表示一个
NULL 域值。在 NULL 情况下，后面不会跟随值字节。
    </para>

<!--==========================orignal english content==========================
    <para>
There is no alignment padding or any other extra data between fields.
    </para>
____________________________________________________________________________-->
    <para>
在域之间没有对齐填充或者任何其他额外的数据。
    </para>

<!--==========================orignal english content==========================
    <para>
Presently, all data values in a binary-format file are
assumed to be in binary format (format code one).  It is anticipated that a
future extension might add a header field that allows per-column format codes
to be specified.
    </para>
____________________________________________________________________________-->
    <para>
当前，一个二进制格式文件中的所有数据值都被假设为二进制格式（格式代码一）。
可以预见未来的扩展可能会增加一个允许独立指定各列的格式代码的头部域。
    </para>

<!--==========================orignal english content==========================
    <para>
To determine the appropriate binary format for the actual tuple data you
should consult the <productname>PostgreSQL</productname> source, in
particular the <function>*send</function> and <function>*recv</function> functions for
each column's data type (typically these functions are found in the
<filename>src/backend/utils/adt/</filename> directory of the source
distribution).
    </para>
____________________________________________________________________________-->
    <para>
要为实际的元组数据决定合适的二进制格式，你应该参考
<productname>PostgreSQL</productname>源码，特别是用于各列
数据类型的<function>*send</function>和<function>*recv</function>函数（通常可
以在源码的<filename>src/backend/utils/adt/</filename>目录中找到
这些函数）。
    </para>

<!--==========================orignal english content==========================
    <para>
If OIDs are included in the file, the OID field immediately follows the
field-count word.  It is a normal field except that it's not included
in the field-count.  In particular it has a length word &mdash; this will allow
handling of 4-byte vs. 8-byte OIDs without too much pain, and will allow
OIDs to be shown as null if that ever proves desirable.
    </para>
____________________________________________________________________________-->
    <para>
如果文件中包含 OID，OID 域会紧跟在域计数字之后。它是一个普通域，
不过它没有被包含在域计数中。特别地，它有一个长度字 &mdash; 这将
允许容易地处理 4 字节和 8 字节 OID 的选择，并且将允许在需要时把
OID 显示为空值。
    </para>
   </refsect3>

   <refsect3>
<!--==========================orignal english content==========================
    <title>File Trailer</title>
____________________________________________________________________________-->
    <title>文件尾</title>

<!--==========================orignal english content==========================
    <para>
     The file trailer consists of a 16-bit integer word containing -1.  This
     is easily distinguished from a tuple's field-count word.
    </para>
____________________________________________________________________________-->
    <para>
     文件位由一个包含 -1 的 16 位整数字组成。这很容易与一个
     元组的域计数字区分开。
    </para>

<!--==========================orignal english content==========================
    <para>
     A reader should report an error if a field-count word is neither -1
     nor the expected number of columns.  This provides an extra
     check against somehow getting out of sync with the data.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个域计数字不是 -1 也不是期望的列数，读取者应该报告错误。
     这提供了一种针对某种数据不同步的额外检查。
    </para>
   </refsect3>
  </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   The following example copies a table to the client
   using the vertical bar (<literal>|</literal>) as the field delimiter:
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下面的例子使用竖线（<literal>|</literal>）作为域定界符把一个表复制到客户端：
<programlisting>
COPY country TO STDOUT (DELIMITER '|');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To copy data from a file into the <literal>country</literal> table:
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   从一个文件中复制数据到<literal>country</literal>表中：
<programlisting>
COPY country FROM '/usr1/proj/bray/sql/country_data';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To copy into a file just the countries whose names start with 'A':
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   只把名称以 'A' 开头的国家复制到一个文件中：
<programlisting>
COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To copy into a compressed file, you can pipe the output through an external
   compression program:
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要复制到一个压缩文件中，你可以用管道把输出导到一个外部压缩程序：
<programlisting>
COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here is a sample of data suitable for copying into a table from
   <literal>STDIN</literal>:
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
   Note that the white space on each line is actually a tab character.
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个适合于从<literal>STDIN</literal>复制到表中的数据：
<programlisting>
AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE
</programlisting>
   注意每一行上的空白实际是一个制表符。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following is the same data, output in binary format.
   The data is shown after filtering through the
   Unix utility <command>od -c</command>. The table has three columns;
   the first has type <type>char(2)</type>, the second has type <type>text</type>,
   and the third has type <type>integer</type>. All the rows have a null value
   in the third column.
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting></para>
____________________________________________________________________________-->
  <para>
   下面是用二进制格式输出的相同数据。该数据是用 Unix 工具
   <command>od -c</command>过滤后显示的。该表具有三列，
   第一列类型是<type>char(2)</type>，第二列类型是<type>text</type>，
   第三列类型是<type>integer</type>。所有行在第三列都是空值。
<programlisting>
0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377
</programlisting></para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   There is no <command>COPY</command> statement in the SQL standard.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 标准中没有<command>COPY</command>语句。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following syntax was used before <productname>PostgreSQL</productname>
   version 9.0 and is still supported:

<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>

   Note that in this syntax, <literal>BINARY</literal> and <literal>CSV</literal> are
   treated as independent keywords, not as arguments of a <literal>FORMAT</literal>
   option.
  </para>
____________________________________________________________________________-->
  <para>
   下列语法用于<productname>PostgreSQL</productname> 9.0 之前的版本，
   并且仍然被支持：

<synopsis>
COPY <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE NOT NULL <replaceable class="parameter">column_name</replaceable> [, ...] ] ] ]

COPY { <replaceable class="parameter">table_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] | ( <replaceable class="parameter">query</replaceable> ) }
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<replaceable class="parameter">delimiter</replaceable>' ]
          [ NULL [ AS ] '<replaceable class="parameter">null string</replaceable>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<replaceable class="parameter">quote</replaceable>' ]
                [ ESCAPE [ AS ] '<replaceable class="parameter">escape</replaceable>' ]
                [ FORCE QUOTE { <replaceable class="parameter">column_name</replaceable> [, ...] | * } ] ] ]
</synopsis>

   注意在这种语法中，<literal>BINARY</literal>和<literal>CSV</literal>被视作独立的关键词，
   而不是<literal>FORMAT</literal>选项的参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following syntax was used before <productname>PostgreSQL</productname>
   version 7.3 and is still supported:

<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]
</synopsis></para>
____________________________________________________________________________-->
  <para>
   下列语法用于<productname>PostgreSQL</productname> 7.3 之前的版本，
   并且仍然被支持：

<synopsis>
COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    FROM { '<replaceable class="parameter">filename</replaceable>' | STDIN }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]

COPY [ BINARY ] <replaceable class="parameter">table_name</replaceable> [ WITH OIDS ]
    TO { '<replaceable class="parameter">filename</replaceable>' | STDOUT }
    [ [USING] DELIMITERS '<replaceable class="parameter">delimiter</replaceable>' ]
    [ WITH NULL AS '<replaceable class="parameter">null string</replaceable>' ]
</synopsis></para>
 </refsect1>
</refentry>
