<!--
doc/src/sgml/ref/create_view.sgml
PostgreSQL documentation
-->

<refentry id="sql-createview">
<!--==========================orignal english content==========================
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>
____________________________________________________________________________-->
 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!--==========================orignal english content==========================
 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>define a new view</refpurpose>
 </refnamediv>
____________________________________________________________________________-->
 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>定义一个新视图</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<!--==========================orignal english content==========================
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="parameter">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
____________________________________________________________________________-->
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="parameter">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Description</title>
____________________________________________________________________________-->
  <title>描述</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE VIEW</command> defines a view of a query.  The view
   is not physically materialized. Instead, the query is run every time
   the view is referenced in a query.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE VIEW</command>定义一个查询的视图。该视图不会被
   物理上物质化。相反，在每一次有查询引用该视图时，视图的查询都会被运行。
  </para>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE OR REPLACE VIEW</command> is similar, but if a view
   of the same name already exists, it is replaced.  The new query must
   generate the same columns that were generated by the existing view query
   (that is, the same column names in the same order and with the same data
   types), but it may add additional columns to the end of the list.  The
   calculations giving rise to the output columns may be completely different.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE OR REPLACE VIEW</command>与之相似，但是如果
   已经存在一个同名视图，该视图会被替换。新查询必须产生和现有试图查询相同
   的列（也就是相同的列序、相同的列名、相同的数据类型），但是它可以在列表
   的末尾加上额外的列。产生输出列的计算可以完全不同。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a schema name is given (for example, <literal>CREATE VIEW
   myschema.myview ...</literal>) then the view is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   views exist in a special schema, so a schema name cannot be given
   when creating a temporary view. The name of the view must be
   distinct from the name of any other view, table, sequence, index or foreign table
   in the same schema.
  </para>
____________________________________________________________________________-->
  <para>
   如果给定了一个模式名（例如<literal>CREATE VIEW
   myschema.myview ...</literal>），那么该视图会被创建在指定的模式中。否则，它会
   被创建在当前模式中。临时视图存在于一个特殊模式中，因此创建临时视图时不能
   给定一个模式名。视图的名称不能与同一模式中任何其他视图、表、序列、索引或
   外部表同名。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Parameters</title>
____________________________________________________________________________-->
  <title>参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
____________________________________________________________________________-->
    <term><literal>TEMPORARY</literal>或者<literal>TEMP</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      If specified, the view is created as a temporary view.
      Temporary views are automatically dropped at the end of the
      current session.  Existing
      permanent relations with the same name are not visible to the
      current session while the temporary view exists, unless they are
      referenced with schema-qualified names.
     </para>
____________________________________________________________________________-->
     <para>
      如果被指定，视图被创建为一个临时视图。在当前会话结束时会自动
      删掉临时视图。当临时视图存在时，具有相同名称的已有永久视图对
      当前会话不可见，除非用模式限定的名称引用它们。
     </para>

<!--==========================orignal english content==========================
     <para>
      If any of the tables referenced by the view are temporary,
      the view is created as a temporary view (whether
      <literal>TEMPORARY</literal> is specified or not).
     </para>
____________________________________________________________________________-->
     <para>
      如果视图引用的任何表是临时的，视图将被创建为临时视图（不管有
      没有指定<literal>TEMPORARY</literal>）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>RECURSIVE</literal>
      <indexterm zone="sql-createview">
       <primary>RECURSIVE</primary>
       <secondary>in views</secondary>
      </indexterm>
    </term>
____________________________________________________________________________-->
    <term><literal>RECURSIVE</literal>
      <indexterm zone="sql-createview">
       <primary>RECURSIVE</primary>
       <secondary>in views</secondary>
      </indexterm>
    </term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Creates a recursive view.  The syntax
<synopsis>
CREATE RECURSIVE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS SELECT <replaceable>...</replaceable>;
</synopsis>
      is equivalent to
<synopsis>
CREATE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> AS WITH RECURSIVE <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS (SELECT <replaceable>...</replaceable>) SELECT <replaceable>column_names</replaceable> FROM <replaceable>view_name</replaceable>;
</synopsis>
      A view column name list must be specified for a recursive view.
     </para>
____________________________________________________________________________-->
     <para>
      创建一个递归视图。语法
<synopsis>
CREATE RECURSIVE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS SELECT <replaceable>...</replaceable>;
</synopsis>
      等效于
<synopsis>
CREATE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> AS WITH RECURSIVE <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS (SELECT <replaceable>...</replaceable>) SELECT <replaceable>column_names</replaceable> FROM <replaceable>view_name</replaceable>;
</synopsis>
      对于一个递归视图必须指定一个视图列名列表。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The name (optionally schema-qualified) of a view to be created.
     </para>
____________________________________________________________________________-->
     <para>
      要创建的视图的名字（可以是模式限定的）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">column_name</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      An optional list of names to be used for columns of the view.
      If not given, the column names are deduced from the query.
     </para>
____________________________________________________________________________-->
     <para>
      要用于视图列的名称列表，可选。如果没有给出，列名会根据查询
      推导。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] )</literal></term>
____________________________________________________________________________-->
    <term><literal>WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This clause specifies optional parameters for a view; the following
      parameters are supported:

      <variablelist>
       <varlistentry>
        <term><literal>check_option</literal> (<type>string</type>)</term>
        <listitem>
         <para>
          This parameter may be either <literal>local</literal> or
          <literal>cascaded</literal>, and is equivalent to specifying
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal> (see below).
          This option can be changed on existing views using <xref
          linkend="sql-alterview"/>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_barrier</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          This should be used if the view is intended to provide row-level
          security.  See <xref linkend="rules-privileges"/> for full details.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      这个子句为视图指定一些可选的参数，支持下列参数：

      <variablelist>
       <varlistentry>
        <term><literal>check_option</literal> (<type>string</type>)</term>
        <listitem>
         <para>
          这个参数可以是<literal>local</literal>或者<literal>cascaded</literal>，并且它
          等效于指定
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>（见下文）。
          可以使用<xref linkend="sql-alterview"/>在一个现有视图上修改这个选项。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_barrier</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          如果希望视图提供行级安全性，应该使用这个参数。详见
          <xref linkend="rules-privileges"/>。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><replaceable class="parameter">query</replaceable></term>
____________________________________________________________________________-->
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      A <xref linkend="sql-select"/> or
      <xref linkend="sql-values"/> command
      which will provide the columns and rows of the view.
     </para>
____________________________________________________________________________-->
     <para>
      提供视图的行和列的一个<xref linkend="sql-select"/>或者
      <xref linkend="sql-values"/>命令。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>
      <indexterm zone="sql-createview">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="sql-createview">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
    </term>
____________________________________________________________________________-->
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>
      <indexterm zone="sql-createview">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="sql-createview">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
    </term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This option controls the behavior of automatically updatable views.  When
      this option is specified, <command>INSERT</command> and <command>UPDATE</command>
      commands on the view will be checked to ensure that new rows satisfy the
      view-defining condition (that is, the new rows are checked to ensure that
      they are visible through the view).  If they are not, the update will be
      rejected.  If the <literal>CHECK OPTION</literal> is not specified,
      <command>INSERT</command> and <command>UPDATE</command> commands on the view are
      allowed to create rows that are not visible through the view.  The
      following check options are supported:

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
         <para>
          New rows are only checked against the conditions defined directly in
          the view itself.  Any conditions defined on underlying base views are
          not checked (unless they also specify the <literal>CHECK OPTION</literal>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>
         <para>
          New rows are checked against the conditions of the view and all
          underlying base views.  If the <literal>CHECK OPTION</literal> is specified,
          and neither <literal>LOCAL</literal> nor <literal>CASCADED</literal> is specified,
          then <literal>CASCADED</literal> is assumed.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
____________________________________________________________________________-->
     <para>
      这个选项控制自动可更新视图的行为。这个选项被指定时，将检查该视图上的
      <command>INSERT</command>和<command>UPDATE</command>命令以确保新行满足
      视图的定义条件（也就是，将检查新行来确保通过视图能看到它们）。如果新行
      不满足条件，更新将被拒绝。如果没有指定<literal>CHECK OPTION</literal>，
      会允许该视图上的<command>INSERT</command>和<command>UPDATE</command>命令
      创建通过该视图不可见的行。支持下列检查选项：

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
         <para>
          只根据直接定义在该视图本身的条件检查新行。任何定义在底层基视图上的
          条件都不会被检查（除非它们也指定了<literal>CHECK OPTION</literal>）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>
         <para>
          会根据该视图和所有底层基视图上的条件检查新行。如果
          <literal>CHECK OPTION</literal>被指定，并且没有指定
          <literal>LOCAL</literal>和<literal>CASCADED</literal>，则会假定为
          <literal>CASCADED</literal>。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>

<!--==========================orignal english content==========================
     <para>
      The <literal>CHECK OPTION</literal> may not be used with <literal>RECURSIVE</literal>
      views.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>CHECK OPTION</literal>不应该和<literal>RECURSIVE</literal>视图一起使用。
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that the <literal>CHECK OPTION</literal> is only supported on views that
      are automatically updatable, and do not have <literal>INSTEAD OF</literal>
      triggers or <literal>INSTEAD</literal> rules.  If an automatically updatable
      view is defined on top of a base view that has <literal>INSTEAD OF</literal>
      triggers, then the <literal>LOCAL CHECK OPTION</literal> may be used to check
      the conditions on the automatically updatable view, but the conditions
      on the base view with <literal>INSTEAD OF</literal> triggers will not be
      checked (a cascaded check option will not cascade down to a
      trigger-updatable view, and any check options defined directly on a
      trigger-updatable view will be ignored).  If the view or any of its base
      relations has an <literal>INSTEAD</literal> rule that causes the
      <command>INSERT</command> or <command>UPDATE</command> command to be rewritten, then
      all check options will be ignored in the rewritten query, including any
      checks from automatically updatable views defined on top of the relation
      with the <literal>INSTEAD</literal> rule.
     </para>
____________________________________________________________________________-->
     <para>
      注意，只有在自动可更新的、没有<literal>INSTEAD OF</literal>触发器或者
      <literal>INSTEAD</literal>规则的视图上才支持<literal>CHECK OPTION</literal>。
      如果一个自动可更新的视图被定义在一个具有<literal>INSTEAD OF</literal>
      触发器的基视图之上，那么<literal>LOCAL CHECK OPTION</literal>可以被
      用来检查该自动可更新的视图之上的条件，但具有<literal>INSTEAD OF</literal>
      触发器的基视图上的条件不会被检查（一个级联检查选项将不会级联到一个
      触发器可更新的视图，并且任何直接定义在一个触发器可更新视图上的检查
      选项将被忽略）。如果该视图或者任何基础关系具有导致
      <command>INSERT</command>或<command>UPDATE</command>命令被重写的
      <literal>INSTEAD</literal>规则，那么在被重写的查询中将忽略所有检查选项，
      包括任何来自于定义在带有<literal>INSTEAD</literal>规则的关系之上的自动
      可更新视图的检查。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

<!--==========================orignal english content==========================
   <para>
    Use the <xref linkend="sql-dropview"/>
    statement to drop views.
   </para>
____________________________________________________________________________-->
   <para>
    使用<xref linkend="sql-dropview"/>语句删除视图。
   </para>

<!--==========================orignal english content==========================
   <para>
    Be careful that the names and types of the view's columns will be
    assigned the way you want.  For example:
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    is bad form because the column name defaults to <literal>?column?</literal>;
    also, the column data type defaults to <type>text</type>, which might not
    be what you wanted.  Better style for a string literal in a view's
    result is something like:
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    要小心视图列的名称和类型将会按照你想要的方式指定。例如：
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    是不好的形式，因为列名默认为<literal>?column?</literal>，而且列的数据类型默认为<type>text</type>，这可能不是用户想要的。视图结果中一个字符串更好的风格类似于这样：
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Access to tables referenced in the view is determined by permissions of
    the view owner.  In some cases, this can be used to provide secure but
    restricted access to the underlying tables.  However, not all views are
    secure against tampering; see <xref linkend="rules-privileges"/> for
    details.  Functions called in the view are treated the same as if they had
    been called directly from the query using the view.  Therefore the user of
    a view must have permissions to call all functions used by the view.
   </para>
____________________________________________________________________________-->
   <para>
    对视图中引用的表的访问由视图拥有者的权限决定。在某些情况下，这可以
    被用来提供安全但是受限的底层表访问。不过，并非所有视图都对篡改是安
    全的，详见<xref linkend="rules-privileges"/>。在视图中调用的函数会被
    同样对待，就好像是直接在使用该视图的查询中调用它们一样。因此，一个
    视图的用户必须具有调用视图所使用的全部函数的权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    When <command>CREATE OR REPLACE VIEW</command> is used on an
    existing view, only the view's defining SELECT rule is changed.
    Other view properties, including ownership, permissions, and non-SELECT
    rules, remain unchanged.  You must own the view
    to replace it (this includes being a member of the owning role).
   </para>
____________________________________________________________________________-->
   <para>
    当<command>CREATE OR REPLACE VIEW</command>被用在一个现有视图上时，
    只有该视图的定义 SELECT 规则被改变。其他包括拥有关系、权限和非
    SELECT 规则在内的视图属性不会被更改。要替换视图，你必须拥有它（包括
    作为拥有角色的一个成员）。
   </para>

  <refsect2 id="sql-createview-updatable-views">
<!--==========================orignal english content==========================
   <title id="sql-createview-updatable-views-title">Updatable Views</title>
____________________________________________________________________________-->
   <title id="sql-createview-updatable-views-title">可更新视图</title>

<!--==========================orignal english content==========================
   <indexterm zone="sql-createview-updatable-views">
    <primary>updatable views</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="sql-createview-updatable-views">
    <primary>可更新视图</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Simple views are automatically updatable: the system will allow
    <command>INSERT</command>, <command>UPDATE</command> and <command>DELETE</command> statements
    to be used on the view in the same way as on a regular table.  A view is
    automatically updatable if it satisfies all of the following conditions:

    <itemizedlist>
     <listitem>
      <para>
       The view must have exactly one entry in its <literal>FROM</literal> list,
       which must be a table or another updatable view.
      </para>
     </listitem>

     <listitem>
      <para>
       The view definition must not contain <literal>WITH</literal>,
       <literal>DISTINCT</literal>, <literal>GROUP BY</literal>, <literal>HAVING</literal>,
       <literal>LIMIT</literal>, or <literal>OFFSET</literal> clauses at the top level.
      </para>
     </listitem>

     <listitem>
      <para>
       The view definition must not contain set operations (<literal>UNION</literal>,
       <literal>INTERSECT</literal> or <literal>EXCEPT</literal>) at the top level.
      </para>
     </listitem>

     <listitem>
      <para>
       The view's select list must not contain any aggregates, window functions
       or set-returning functions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    简单视图是自动可更新的：系统将允许在这类视图上以在常规表上相同的方式
    使用<command>INSERT</command>、<command>UPDATE</command>以及
    <command>DELETE</command>语句。如果一个视图满足以下条件，它就是自动
    可更新的：

    <itemizedlist>
     <listitem>
      <para>
       在该视图的<literal>FROM</literal>列表中刚好只有一项，并且它必须是一个
       表或者另一个可更新视图。
      </para>
     </listitem>

     <listitem>
      <para>
       视图定义的顶层不能包含<literal>WITH</literal>、<literal>DISTINCT</literal>、
       <literal>GROUP BY</literal>、<literal>HAVING</literal>、
       <literal>LIMIT</literal>或者<literal>OFFSET</literal>子句。
      </para>
     </listitem>

     <listitem>
      <para>
       视图定义的顶层不能包含集合操作（<literal>UNION</literal>、
       <literal>INTERSECT</literal>或者<literal>EXCEPT</literal>）。
      </para>
     </listitem>

     <listitem>
      <para>
       视图的选择列表不能包含任何聚集、窗口函数或者集合返回函数。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    An automatically updatable view may contain a mix of updatable and
    non-updatable columns.  A column is updatable if it is a simple reference
    to an updatable column of the underlying base relation; otherwise the
    column is read-only, and an error will be raised if an <command>INSERT</command>
    or <command>UPDATE</command> statement attempts to assign a value to it.
   </para>
____________________________________________________________________________-->
   <para>
    一个自动可更新的视图可以混合可更新列以及不可更新列。如果一个列是对底层
    基本关系中一个可更新列的简单引用，则它是可更新的。否则该列是只读的，并
    且在一个<command>INSERT</command>或者<command>UPDATE</command>语句尝试对
    它赋值时会报出一个错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the view is automatically updatable the system will convert any
    <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command> statement
    on the view into the corresponding statement on the underlying base
    relation.  <command>INSERT</command> statements that have an <literal>ON
    CONFLICT UPDATE</literal> clause are fully supported.
   </para>
____________________________________________________________________________-->
   <para>
    如果视图是自动可更新的，系统将把视图上的任何<command>INSERT</command>、
    <command>UPDATE</command>或者<command>DELETE</command>语句转换成在底层
    基本关系上的对应语句。带有<literal>ON CONFLICT UPDATE</literal>子句的
    <command>INSERT</command>语句已经被完全支持。
   </para>

<!--==========================orignal english content==========================
   <para>
    If an automatically updatable view contains a <literal>WHERE</literal>
    condition, the condition restricts which rows of the base relation are
    available to be modified by <command>UPDATE</command> and <command>DELETE</command>
    statements on the view.  However, an <command>UPDATE</command> is allowed to
    change a row so that it no longer satisfies the <literal>WHERE</literal>
    condition, and thus is no longer visible through the view.  Similarly,
    an <command>INSERT</command> command can potentially insert base-relation rows
    that do not satisfy the <literal>WHERE</literal> condition and thus are not
    visible through the view (<literal>ON CONFLICT UPDATE</literal> may
    similarly affect an existing row not visible through the view).
    The <literal>CHECK OPTION</literal> may be used to prevent
    <command>INSERT</command> and <command>UPDATE</command> commands from creating
    such rows that are not visible through the view.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个自动可更新视图包含一个<literal>WHERE</literal>条件，该条件会限制
    基本关系的哪些行可以被该视图上的<command>UPDATE</command>以及
    <command>DELETE</command>语句修改。不过，一个允许被<command>UPDATE</command>
    修改的行可能让该行不再满足<literal>WHERE</literal>条件，并且因此也不再能
    从视图中可见。类似地，一个<command>INSERT</command>命令可能插入不满足
    <literal>WHERE</literal>条件的基本关系行，并且因此从视图中也看不到这些行
    （<literal>ON CONFLICT UPDATE</literal>可能会类似地影响无法通过该视图见
    到的现有行）。
    <literal>CHECK OPTION</literal>可以被用来阻止<command>INSERT</command>和
    <command>UPDATE</command>命令创建这类从视图中无法看到的行。
   </para>

<!--==========================orignal english content==========================
   <para>
    If an automatically updatable view is marked with the
    <literal>security_barrier</literal> property then all the view's <literal>WHERE</literal>
    conditions (and any conditions using operators which are marked as <literal>LEAKPROOF</literal>)
    will always be evaluated before any conditions that a user of the view has
    added.   See <xref linkend="rules-privileges"/> for full details.  Note that,
    due to this, rows which are not ultimately returned (because they do not
    pass the user's <literal>WHERE</literal> conditions) may still end up being locked.
    <command>EXPLAIN</command> can be used to see which conditions are
    applied at the relation level (and therefore do not lock rows) and which are
    not.
   </para>
____________________________________________________________________________-->
   <para>
    如果一个自动可更新视图被标记了<literal>security_barrier</literal>属性，那么
    所有该属性的<literal>WHERE</literal>条件（以及任何使用标记为
    <literal>LEAKPROOF</literal>的操作符的条件）将在该视图使用者的任何条件
    之前计算。详见<xref linkend="rules-privileges"/>。注意正因为这样，不会
    被最终返回的行（因为它们不会通过用户的<literal>WHERE</literal>条件）可能
    仍会结束被锁定的状态。可以用<command>EXPLAIN</command>来查看
    哪些条件被应用在关系层面（并且因此不锁定行）以及哪些不会被应用在关系
    层面。
   </para>

<!--==========================orignal english content==========================
   <para>
    A more complex view that does not satisfy all these conditions is
    read-only by default: the system will not allow an insert, update, or
    delete on the view.  You can get the effect of an updatable view by
    creating <literal>INSTEAD OF</literal> triggers on the view, which must
    convert attempted inserts, etc. on the view into appropriate actions
    on other tables.  For more information see <xref
    linkend="sql-createtrigger"/>.  Another possibility is to create rules
    (see <xref linkend="sql-createrule"/>), but in practice triggers are
    easier to understand and use correctly.
   </para>
____________________________________________________________________________-->
   <para>
    一个更加复杂的不满足所有这些条件的视图默认是只读的：系统将不允许在
    该视图上的插入、更新或者删除。可以通过在该视图上创建一个
    <literal>INSTEAD OF</literal>触发器来获得可更新视图的效果，该触发器必须
    把该视图上的尝试的插入等转换成其他表上合适的动作。更多信息请见<xref
    linkend="sql-createtrigger"/>。另一种可能性是创建规则（见
    <xref linkend="sql-createrule"/>），不过实际中触发器更容易理解和正确使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that the user performing the insert, update or delete on the view
    must have the corresponding insert, update or delete privilege on the
    view.  In addition the view's owner must have the relevant privileges on
    the underlying base relations, but the user performing the update does
    not need any permissions on the underlying base relations (see
    <xref linkend="rules-privileges"/>).
   </para>
____________________________________________________________________________-->
   <para>
    注意在视图上执行插入、更新或删除的用户必须具有该视图上相应的插入、
    更新或删除特权。此外，视图的拥有者必须拥有底层基本关系上的相关特权，
    但是执行更新的用户并不需要底层基本关系上的任何权限（见
    <xref linkend="rules-privileges"/>）。
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>示例</title>

<!--==========================orignal english content==========================
  <para>
   Create a view consisting of all comedy films:

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   This will create a view containing the columns that are in the
   <literal>film</literal> table at the time of view creation.  Though
   <literal>*</literal> was used to create the view, columns added later to
   the table will not be part of the view.
  </para>
____________________________________________________________________________-->
  <para>
   创建一个由所有喜剧电影组成的视图：

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   创建的视图包含创建时<literal>film</literal>表中的列。尽管<literal>*</literal>
   被用来创建该视图，后来被加入到该表中的列不会成为该视图的组成部分。
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a view with <literal>LOCAL CHECK OPTION</literal>:

<programlisting>
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>
   This will create a view based on the <literal>comedies</literal> view, showing
   only films with <literal>kind = 'Comedy'</literal> and
   <literal>classification = 'U'</literal>. Any attempt to <command>INSERT</command> or
   <command>UPDATE</command> a row in the view will be rejected if the new row
   doesn't have <literal>classification = 'U'</literal>, but the film
   <literal>kind</literal> will not be checked.
  </para>
____________________________________________________________________________-->
  <para>
   创建带有<literal>LOCAL CHECK OPTION</literal>的视图：

<programlisting>
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>
   这将创建一个基于<literal>comedies</literal>视图的视图，只显示
   <literal>kind = 'Comedy'</literal>和<literal>classification = 'U'</literal>的电影。
   如果新行没有<literal>classification = 'U'</literal>，在该视图中的任何
   <command>INSERT</command>或<command>UPDATE</command>尝试将被拒绝，
   但是电影的<literal>kind</literal>将不会被检查。
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a view with <literal>CASCADED CHECK OPTION</literal>:

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
   This will create a view that checks both the <literal>kind</literal> and
   <literal>classification</literal> of new rows.
  </para>
____________________________________________________________________________-->
  <para>
   用<literal>CASCADED CHECK OPTION</literal>创建一个视图：

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
   这将创建一个检查新行的<literal>kind</literal>和<literal>classification</literal>
   的视图。
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a view with a mix of updatable and non-updatable columns:

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
   This view will support <command>INSERT</command>, <command>UPDATE</command> and
   <command>DELETE</command>.  All the columns from the <literal>films</literal> table will
   be updatable, whereas the computed columns <literal>country</literal> and
   <literal>avg_rating</literal> will be read-only.
  </para>
____________________________________________________________________________-->
  <para>
   创建一个由可更新列和不可更新列混合而成的视图：

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
   这个视图将支持<command>INSERT</command>、<command>UPDATE</command>
   以及<command>DELETE</command>。所有来自于<literal>films</literal>表的列都
   将是可更新的，而计算列<literal>country</literal>和<literal>avg_rating</literal>
   将是只读的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Create a recursive view consisting of the numbers from 1 to 100:
<programlisting>
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</programlisting>
   Notice that although the recursive view's name is schema-qualified in this
   <command>CREATE</command>, its internal self-reference is not schema-qualified.
   This is because the implicitly-created CTE's name cannot be
   schema-qualified.
  </para>
____________________________________________________________________________-->
  <para>
   创建一个由数字 1 到 100 组成的递归视图：
<programlisting>
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</programlisting>
   注意在这个<command>CREATE</command>中尽管递归的视图名称是方案限定的，但它内部的自引用不是方案限定的。这是因为隐式创建的CTE的名称不能是方案限定的。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>Compatibility</title>
____________________________________________________________________________-->
  <title>兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <command>CREATE OR REPLACE VIEW</command> is a
   <productname>PostgreSQL</productname> language extension.
   So is the concept of a temporary view.
   The <literal>WITH ( ... )</literal> clause is an extension as well.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE OR REPLACE VIEW</command>是一种
   <productname>PostgreSQL</productname>的语言扩展。临时
   视图的概念也是这样。<literal>WITH ( ... )</literal>子句也是一种扩展。
  </para>
 </refsect1>

 <refsect1>
<!--==========================orignal english content==========================
  <title>See Also</title>
____________________________________________________________________________-->
  <title>另见</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterview"/></member>
   <member><xref linkend="sql-dropview"/></member>
   <member><xref linkend="sql-creatematerializedview"/></member>
  </simplelist>
 </refsect1>
</refentry>
