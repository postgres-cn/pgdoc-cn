<!-- doc/src/sgml/xindex.sgml -->

<sect1 id="xindex">
<!--==========================orignal english content==========================
 <title>Interfacing Extensions To Indexes</title>
____________________________________________________________________________-->
 <title>索引的接口扩展</title>

<!--==========================orignal english content==========================
 <indexterm zone="xindex">
  <primary>index</primary>
  <secondary>for user-defined data type</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="xindex">
  <primary>index</primary>
  <secondary>for user-defined data type</secondary>
 </indexterm>

<!--==========================orignal english content==========================
  <para>
   The procedures described thus far let you define new types, new
   functions, and new operators. However, we cannot yet define an
   index on a column of a new data type.  To do this, we must define an
   <firstterm>operator class</firstterm> for the new data type.  Later in this
   section, we will illustrate this concept in an example: a new
   operator class for the B-tree index method that stores and sorts
   complex numbers in ascending absolute value order.
  </para>
____________________________________________________________________________-->
  <para>
   迄今为止已经描述的过程让我们能够定义新的类型、新的函数以及新的操作符。但是，我们还不能在一种新数据类型的列上定义索引。要做这件事情，我们必须为新数据类型定义一个<firstterm>操作符类</firstterm>。在这一小节稍后的部分，我们将用一个例子阐述这部份内容：一个用于 B-树索引方法的操作符类，它以绝对值的升序存储和排序复数。
  </para>

<!--==========================orignal english content==========================
  <para>
   Operator classes can be grouped into <firstterm>operator families</firstterm>
   to show the relationships between semantically compatible classes.
   When only a single data type is involved, an operator class is sufficient,
   so we'll focus on that case first and then return to operator families.
  </para>
____________________________________________________________________________-->
  <para>
   操作符类可以被分组成<firstterm>操作符族</firstterm>来体现语义兼容的类之间的联系。当只涉及到一种单一数据类型时，一个操作符类就足矣。因此我们将先把重点放在这种情况上，然后再回到操作符族。
  </para>

 <sect2 id="xindex-opclass">
<!--==========================orignal english content==========================
  <title>Index Methods and Operator Classes</title>
____________________________________________________________________________-->
  <title>索引方法和操作符类</title>

<!--==========================orignal english content==========================
  <para>
   The <classname>pg_am</classname> table contains one row for every
   index method (internally known as access method).  Support for
   regular access to tables is built into
   <productname>PostgreSQL</productname>, but all index methods are
   described in <classname>pg_am</classname>.  It is possible to add a
   new index access method by writing the necessary code and
   then creating an entry in <classname>pg_am</classname> &mdash; but that is
   beyond the scope of this chapter (see <xref linkend="indexam"/>).
  </para>
____________________________________________________________________________-->
  <para>
   <classname>pg_am</classname>表为每一种索引方法都包含一行（内部被称为访问方法）。<productname>PostgreSQL</productname>中内建了对表常规访问的支持，但是所有的索引方法则是在<classname>pg_am</classname>中描述。可以通过编写必要的代码并且在<classname>pg_am</classname>中创建一项来增加一种新的索引访问方法 &mdash; 但这超出了本章的范围（见<xref linkend="indexam"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The routines for an index method do not directly know anything
   about the data types that the index method will operate on.
   Instead, an <firstterm>operator
   class</firstterm><indexterm><primary>operator class</primary></indexterm>
   identifies the set of operations that the index method needs to use
   to work with a particular data type.  Operator classes are so
   called because one thing they specify is the set of
   <literal>WHERE</literal>-clause operators that can be used with an index
   (i.e., can be converted into an index-scan qualification).  An
   operator class can also specify some <firstterm>support
   function</firstterm> that are needed by the internal operations of the
   index method, but do not directly correspond to any
   <literal>WHERE</literal>-clause operator that can be used with the index.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引方法的例程并不直接了解它将要操作的数据类型。而是由一个<firstterm>操作符类</firstterm><indexterm><primary>操作符类</primary></indexterm>标识索引方法用来操作一种特定数据类型的一组操作。之所以被称为操作符类是因为它们指定的一件事情就是可以被用于一个索引的<literal>WHERE</literal>子句操作符集合（即，能被转换成一个索引扫描条件）。一个操作符类也能指定一些索引方法内部操作所需的<firstterm>支持函数</firstterm>，这些过程不能直接对应于能用于索引的任何<literal>WHERE</literal>子句操作符。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is possible to define multiple operator classes for the same
   data type and index method.  By doing this, multiple
   sets of indexing semantics can be defined for a single data type.
   For example, a B-tree index requires a sort ordering to be defined
   for each data type it works on.
   It might be useful for a complex-number data type
   to have one B-tree operator class that sorts the data by complex
   absolute value, another that sorts by real part, and so on.
   Typically, one of the operator classes will be deemed most commonly
   useful and will be marked as the default operator class for that
   data type and index method.
  </para>
____________________________________________________________________________-->
  <para>
   可以为相同的数据类型和索引方法定义多个操作符类。通过这种方式，可以为一种数据类型定义多个索引语义集合。例如，一个B-树索引要求在它要操作的每一种数据类型上都定义一个排序顺序。对一种复数数据类型来说，拥有一个可以根据复数绝对值排序的 B-树操作符类和另一个可以根据实数部分排序的操作符类可能会有用。典型地，其中一个操作符类将被认为是最常用的并且将被标记为那种数据类型和索引方法的默认操作符类。
  </para>

<!--==========================orignal english content==========================
  <para>
   The same operator class name
   can be used for several different index methods (for example, both B-tree
   and hash index methods have operator classes named
   <literal>int4_ops</literal>), but each such class is an independent
   entity and must be defined separately.
  </para>
____________________________________________________________________________-->
  <para>
   相同的操作符类名称可以被用于多个不同的索引方法（例如，B-树和哈希索引方法都有名为<literal>int4_ops</literal>的操作符类）。但是每一个这样的类都是一个独立实体并且必须被单独定义。
  </para>
 </sect2>

 <sect2 id="xindex-strategies">
<!--==========================orignal english content==========================
  <title>Index Method Strategies</title>
____________________________________________________________________________-->
  <title>索引方法策略</title>

<!--==========================orignal english content==========================
  <para>
   The operators associated with an operator class are identified by
   <quote>strategy numbers</quote>, which serve to identify the semantics of
   each operator within the context of its operator class.
   For example, B-trees impose a strict ordering on keys, lesser to greater,
   and so operators like <quote>less than</quote> and <quote>greater than or equal
   to</quote> are interesting with respect to a B-tree.
   Because
   <productname>PostgreSQL</productname> allows the user to define operators,
   <productname>PostgreSQL</productname> cannot look at the name of an operator
   (e.g., <literal>&lt;</literal> or <literal>&gt;=</literal>) and tell what kind of
   comparison it is.  Instead, the index method defines a set of
   <quote>strategies</quote>, which can be thought of as generalized operators.
   Each operator class specifies which actual operator corresponds to each
   strategy for a particular data type and interpretation of the index
   semantics.
  </para>
____________________________________________________________________________-->
  <para>
   与一个操作符类关联的操作符通过<quote>策略号</quote>标识，它被用来标识每个操作符在其操作符类中的语义。例如，B-树在键上施行了一种严格的顺序（较小到较大），因此<quote>小于</quote>和<quote>大于等于</quote>这样的操作符就是 B-树所感兴趣的。因为<productname>PostgreSQL</productname>允许用户定义操作符，<productname>PostgreSQL</productname>不能看着一个操作符（如<literal>&lt;</literal>和<literal>&gt;=</literal>）的名字并且说出它是哪一种比较。取而代之的是，索引方法定义了一个<quote>策略</quote>集合，它们可以被看成是广义的操作符。每一个操作符类会说明对于一种特定的数据类型究竟是哪个实际的操作符对应于每一种策略以及该索引语义的解释。
  </para>

<!--==========================orignal english content==========================
  <para>
   The B-tree index method defines five strategies, shown in <xref
   linkend="xindex-btree-strat-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   B-树索引方法定义了五种策略，如<xref linkend="xindex-btree-strat-table"/>所示。
  </para>

   <table tocentry="1" id="xindex-btree-strat-table">
<!--==========================orignal english content==========================
    <title>B-tree Strategies</title>
____________________________________________________________________________-->
    <title>B-树策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>less than</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>小于</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>less than or equal</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>小于等于</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>equal</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>等于</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>greater than or equal</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>大于等于</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>greater than</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>大于</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   Hash indexes support only equality comparisons, and so they use only one
   strategy, shown in <xref linkend="xindex-hash-strat-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   哈希索引只支持等值比较，因此它们只使用一种策略，如<xref linkend="xindex-hash-strat-table"/>所示。
  </para>

   <table tocentry="1" id="xindex-hash-strat-table">
<!--==========================orignal english content==========================
    <title>Hash Strategies</title>
____________________________________________________________________________-->
    <title>哈希策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>equal</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>等于</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   GiST indexes are more flexible: they do not have a fixed set of
   strategies at all.  Instead, the <quote>consistency</quote> support routine
   of each particular GiST operator class interprets the strategy numbers
   however it likes.  As an example, several of the built-in GiST index
   operator classes index two-dimensional geometric objects, providing
   the <quote>R-tree</quote> strategies shown in
   <xref linkend="xindex-rtree-strat-table"/>.  Four of these are true
   two-dimensional tests (overlaps, same, contains, contained by);
   four of them consider only the X direction; and the other four
   provide the same tests in the Y direction.
  </para>
____________________________________________________________________________-->
  <para>
   GiST 索引更加灵活：它们根本没有一个固定的策略集合。取而代之的是，每一个特定 GiST 操作符类的<quote>consistency</quote>支持例程会负责解释策略号。例如，一些内建的 GiST 索引操作符类索引二维几何对象，它们提供<xref linkend="xindex-rtree-strat-table"/>中所示的<quote>R-树</quote>策略。其中四个是真正的二维测试（重叠、相同、包含、被包含），其中四个只考虑 X 方向，其他四个提供 Y 方向上的相同测试。
  </para>

   <table tocentry="1" id="xindex-rtree-strat-table">
<!--==========================orignal english content==========================
    <title>GiST Two-Dimensional <quote>R-tree</quote> Strategies</title>
____________________________________________________________________________-->
    <title>GiST 二维<quote>R-树</quote> 策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly left of</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数严格地位于右参数的左边</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>does not extend to right of</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数不会延伸到右参数的右边</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>overlaps</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>重叠</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>does not extend to left of</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数不会延伸到右参数的左边</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly right of</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数严格地位于右参数的右边</entry>
       <entry>5</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>same</entry>
       <entry>6</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>相同</entry>
       <entry>6</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>contains</entry>
       <entry>7</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>包含</entry>
       <entry>7</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>contained by</entry>
       <entry>8</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>被包含</entry>
       <entry>8</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>does not extend above</entry>
       <entry>9</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>不会延伸到高于</entry>
       <entry>9</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly below</entry>
       <entry>10</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>严格低于</entry>
       <entry>10</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly above</entry>
       <entry>11</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>严格高于</entry>
       <entry>11</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>does not extend below</entry>
       <entry>12</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>不会延伸到低于</entry>
       <entry>12</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   SP-GiST indexes are similar to GiST indexes in flexibility: they don't have
   a fixed set of strategies. Instead the support routines of each operator
   class interpret the strategy numbers according to the operator class's
   definition. As an example, the strategy numbers used by the built-in
   operator classes for points are shown in <xref
   linkend="xindex-spgist-point-strat-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   SP-GiST 索引在灵活性上与索引相似：它们没有一个固定的策略集合。取而代之的是，每一个操作符类的支持例程负责根据该操作符类的定义解释策略号。例如，被内建操作符类用于点的策略号如<xref linkend="xindex-spgist-point-strat-table"/>中所示。
  </para>

   <table tocentry="1" id="xindex-spgist-point-strat-table">
<!--==========================orignal english content==========================
    <title>SP-GiST Point Strategies</title>
____________________________________________________________________________-->
    <title>SP-GiST 点策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly left of</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数严格地位于右参数的左边</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly right of</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>左参数严格地位于右参数的右边</entry>
       <entry>5</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>same</entry>
       <entry>6</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>相同</entry>
       <entry>6</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>contained by</entry>
       <entry>8</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>被包含</entry>
       <entry>8</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly below</entry>
       <entry>10</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>严格地低于</entry>
       <entry>10</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>strictly above</entry>
       <entry>11</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>严格地高于</entry>
       <entry>11</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   GIN indexes are similar to GiST and SP-GiST indexes, in that they don't
   have a fixed set of strategies either. Instead the support routines of
   each operator class interpret the strategy numbers according to the
   operator class's definition. As an example, the strategy numbers used by
   the built-in operator class for arrays are shown in
   <xref linkend="xindex-gin-array-strat-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   GIN 索引与 GiST 和 SP-GiST 索引类似，它们也没有一个固定的策略集合。取而代之的是，每一个操作符类的支持例程负责根据该操作符类的定义解释策略号。例如，被内建操作符类用于数组的策略号如<xref linkend="xindex-gin-array-strat-table"/>所示。
  </para>

   <table tocentry="1" id="xindex-gin-array-strat-table">
<!--==========================orignal english content==========================
    <title>GIN Array Strategies</title>
____________________________________________________________________________-->
    <title>GIN 数组策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>overlap</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>重叠</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>contains</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>包含</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>is contained by</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>被包含</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>equal</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>等于</entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   BRIN indexes are similar to GiST, SP-GiST and GIN indexes in that they
   don't have a fixed set of strategies either.  Instead the support routines
   of each operator class interpret the strategy numbers according to the
   operator class's definition. As an example, the strategy numbers used by
   the built-in <literal>Minmax</literal> operator classes are shown in
   <xref linkend="xindex-brin-minmax-strat-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   在没有固定的策略集合这一点上，BRIN 索引和 GiST、SP-GiST 和 GIN 索引是类似的。每一个操作符类的支持函数会根据操作符类的定义解释策略编号。例如，<xref linkend="xindex-brin-minmax-strat-table"/>中展示了内建的<literal>Minmax</literal>操作符类所使用的策略编号。  </para>

   <table tocentry="1" id="xindex-brin-minmax-strat-table">
<!--==========================orignal english content==========================
    <title>BRIN Minmax Strategies</title>
____________________________________________________________________________-->
    <title>BRIN 最小最大策略</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Operation</entry>
       <entry>Strategy Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>操作</entry>
       <entry>策略号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>less than</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>小于</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>less than or equal</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>小于等于</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>equal</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>等于</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>greater than or equal</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>大于等于</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>greater than</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>大于</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!--==========================orignal english content==========================
  <para>
   Notice that all the operators listed above return Boolean values.  In
   practice, all operators defined as index method search operators must
   return type <type>boolean</type>, since they must appear at the top
   level of a <literal>WHERE</literal> clause to be used with an index.
   (Some index access methods also support <firstterm>ordering operators</firstterm>,
   which typically don't return Boolean values; that feature is discussed
   in <xref linkend="xindex-ordering-ops"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   注意上文列出的所有操作符都返回布尔值。实际上，所有作为索引方法搜索操作符定义的操作符必须返回类型<type>boolean</type>，因为它们必须出现在一个<literal>WHERE</literal>子句的顶层来与一个索引一起使用（某些索引访问方法还支持<firstterm>排序操作符</firstterm>，它们通常不返回布尔值，这种特性在<xref linkend="xindex-ordering-ops"/>中讨论）。
  </para>
 </sect2>

 <sect2 id="xindex-support">
<!--==========================orignal english content==========================
  <title>Index Method Support Routines</title>
____________________________________________________________________________-->
  <title>索引方法支持例程</title>

<!--==========================orignal english content==========================
  <para>
   Strategies aren't usually enough information for the system to figure
   out how to use an index.  In practice, the index methods require
   additional support routines in order to work. For example, the B-tree
   index method must be able to compare two keys and determine whether one
   is greater than, equal to, or less than the other.  Similarly, the
   hash index method must be able to compute hash codes for key values.
   These operations do not correspond to operators used in qualifications in
   SQL commands;  they are administrative routines used by
   the index methods, internally.
  </para>
____________________________________________________________________________-->
  <para>
   对于系统来说只有策略信息通常不足以断定如何使用一种索引。实际上，为了能工作，索引方法还要求额外的支持例程。例如，B-树索引方法必须能比较两个键并且决定其中一个是否大于、等于或小于另一个。类似地，哈希索引方法必须能够为键值计算哈希码。这些操作并不对应在 SQL 命令的条件中使用的操作符。它们是索引方法在内部使用的管理例程。
  </para>

<!--==========================orignal english content==========================
  <para>
   Just as with strategies, the operator class identifies which specific
   functions should play each of these roles for a given data type and
   semantic interpretation.  The index method defines the set
   of functions it needs, and the operator class identifies the correct
   functions to use by assigning them to the <quote>support function numbers</quote>
   specified by the index method.
  </para>
____________________________________________________________________________-->
  <para>
   与策略一样，操作符类会标识哪些函数应该为一种给定的数据类型扮演这些角色以及相应的语义解释。索引方法定义它需要的函数集合，而操作符类则会通过为函数分配由索引方法说明的<quote>支持函数号</quote>来标识正确的函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   B-trees require a comparison support function,
   and allow two additional support functions to be
   supplied at the operator class author's option, as shown in <xref
   linkend="xindex-btree-support-table"/>.
   The requirements for these support functions are explained further in
   <xref linkend="btree-support-funcs"/>.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-btree-support-table"/>所示， B-树要求一个比较支持函数，并且允许在操作符类作者的选项中提供两个额外的支持函数。这些支持函数的要求在<xref linkend="btree-support-funcs"/>中会进一步解释。
  </para>

   <table tocentry="1" id="xindex-btree-support-table">
<!--==========================orignal english content==========================
    <title>B-tree Support Functions</title>
____________________________________________________________________________-->
    <title>B-树支持函数</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>
        Compare two keys and return an integer less than zero, zero, or
        greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
       </entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        比较两个键并且返回一个小于零、等于零或大于零的整数，它表示第一个键小于、等于或者大于第二个键。
       </entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        Return the addresses of C-callable sort support function(s)
        (optional)
       </entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        返回C可调用的排序支持函数的地址（可选）。
       </entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
        Compare a test value to a base value plus/minus an offset, and return
        true or false according to the comparison result (optional)
       </entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
        将一个测试值与一个基础值加上/减去一个偏移量的结果进行比较，根据比较的结果返回真或假（可选）
       </entry>
       <entry>3</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   Hash indexes require one support function, and allow a second one to be
   supplied at the operator class author's option, as shown in <xref
   linkend="xindex-hash-support-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-hash-support-table"/>所示，哈希索引要求一个支持函数，并且允许在操作符类作者的选项中提供第二个支持函数。
  </para>

   <table tocentry="1" id="xindex-hash-support-table">
<!--==========================orignal english content==========================
    <title>Hash Support Functions</title>
____________________________________________________________________________-->
    <title>哈希支持函数</title>
    <tgroup cols="2">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>Compute the 32-bit hash value for a key</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>为一个键计算32位哈希值</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>
         Compute the 64-bit hash value for a key given a 64-bit salt; if
         the salt is 0, the low 32 bits of the result must match the value
         that would have been computed by function 1
         (optional)
       </entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>
         给定一个64-位salt，计算一个键的64位哈希值。如果salt为0，结果的低32位必须匹配会由函数1计算出来的值（可选）
       </entry>
       <entry>2</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   GiST indexes have nine support functions, two of which are optional,
   as shown in <xref linkend="xindex-gist-support-table"/>.
   (For more information see <xref linkend="gist"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-gist-support-table"/>所示，GiST 索引有九个支持函数，其中两个是可选的（详见<xref linkend="gist"/>）。
  </para>

   <table tocentry="1" id="xindex-gist-support-table">
<!--==========================orignal english content==========================
    <title>GiST Support Functions</title>
____________________________________________________________________________-->
    <title>GiST 支持函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><function>consistent</function></entry>
       <entry>determine whether key satisfies the
        query qualifier</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>consistent</function></entry>
       <entry>判断键是否满足查询修饰语</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>union</function></entry>
       <entry>compute union of a set of keys</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>union</function></entry>
       <entry>计算一个键集合的联合</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>compress</function></entry>
       <entry>compute a compressed representation of a key or value
        to be indexed</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>compress</function></entry>
       <entry>计算一个要被索引的键或值的压缩表达</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>decompress</function></entry>
       <entry>compute a decompressed representation of a
        compressed key</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>decompress</function></entry>
       <entry>计算一个压缩键的解压表达</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>penalty</function></entry>
       <entry>compute penalty for inserting new key into subtree
       with given subtree's key</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>penalty</function></entry>
       <entry>计算把新键插入到带有给定子树键的子树中带来的罚值</entry>
       <entry>5</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>picksplit</function></entry>
       <entry>determine which entries of a page are to be moved
       to the new page and compute the union keys for resulting pages</entry>
       <entry>6</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>picksplit</function></entry>
       <entry>判断一个页面中的哪些项要被移动到新页面中并且计算结果页面的联合键</entry>
       <entry>6</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>equal</function></entry>
       <entry>compare two keys and return true if they are equal</entry>
       <entry>7</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>equal</function></entry>
       <entry>比较两个键并且在它们相等时返回真</entry>
       <entry>7</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>distance</function></entry>
       <entry>determine distance from key to query value (optional)</entry>
       <entry>8</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>distance</function></entry>
       <entry>判断键到查询值的距离（可选）</entry>
       <entry>8</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>fetch</function></entry>
       <entry>compute original representation of a compressed key for
       index-only scans (optional)</entry>
       <entry>9</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>fetch</function></entry>
       <entry>为只用索引扫描计算一个压缩键的原始表达（可选）</entry>
       <entry>9</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   SP-GiST indexes require five support functions, as
   shown in <xref linkend="xindex-spgist-support-table"/>.
   (For more information see <xref linkend="spgist"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-spgist-support-table"/>所示，SP-GiST 索引要求五个支持函数（详见<xref linkend="spgist"/>）。
  </para>

   <table tocentry="1" id="xindex-spgist-support-table">
<!--==========================orignal english content==========================
    <title>SP-GiST Support Functions</title>
____________________________________________________________________________-->
    <title>SP-GiST 支持函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><function>config</function></entry>
       <entry>provide basic information about the operator class</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>config</function></entry>
       <entry>提供有关该操作符类的基本信息</entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>choose</function></entry>
       <entry>determine how to insert a new value into an inner tuple</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>choose</function></entry>
       <entry>判断如何把一个新值插入到一个内元组中</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>picksplit</function></entry>
       <entry>determine how to partition a set of values</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>picksplit</function></entry>
       <entry>判断如何划分一组值</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>inner_consistent</function></entry>
       <entry>determine which sub-partitions need to be searched for a
        query</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>inner_consistent</function></entry>
       <entry>判断对于一个查询需要搜索哪一个子划分</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>leaf_consistent</function></entry>
       <entry>determine whether key satisfies the
        query qualifier</entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>leaf_consistent</function></entry>
       <entry>判断键是否满足查询修饰语</entry>
       <entry>5</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   GIN indexes have six support functions, three of which are optional,
   as shown in <xref linkend="xindex-gin-support-table"/>.
   (For more information see <xref linkend="gin"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-gin-support-table"/>所示，GIN 索引有六个支持函数，其中三个是可选的（详见<xref linkend="gin"/>）。
  </para>

   <table tocentry="1" id="xindex-gin-support-table">
<!--==========================orignal english content==========================
    <title>GIN Support Functions</title>
____________________________________________________________________________-->
    <title>GIN 支持函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><function>compare</function></entry>
       <entry>
        compare two keys and return an integer less than zero, zero,
        or greater than zero, indicating whether the first key is less than,
        equal to, or greater than the second
       </entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>compare</function></entry>
       <entry>
        比较两个键并且返回一个小于零、等于零或大于零的整数，它表示第一个键小于、等于或者大于第二个键
       </entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>extractValue</function></entry>
       <entry>extract keys from a value to be indexed</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>extractValue</function></entry>
       <entry>从一个要被索引的值中抽取键</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>extractQuery</function></entry>
       <entry>extract keys from a query condition</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>extractQuery</function></entry>
       <entry>从一个查询条件中抽取键</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>consistent</function></entry>
       <entry>
        determine whether value matches query condition (Boolean variant)
        (optional if support function 6 is present)
       </entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>consistent</function></entry>
       <entry>
        判断值是否匹配查询条件（布尔变体）（如果支持函数 6 存在则是可选的）
       </entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>comparePartial</function></entry>
       <entry>
        compare partial key from
        query and key from index, and return an integer less than zero, zero,
        or greater than zero, indicating whether GIN should ignore this index
        entry, treat the entry as a match, or stop the index scan (optional)
       </entry>
       <entry>5</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>comparePartial</function></entry>
       <entry>
        比较来自查询的部分键和来自索引的键，并且返回一个小于零、等于零或大于零的整数，表示 GIN 是否应该忽略该索引项、把该项当做一个匹配或者停止索引扫描（可选）
       </entry>
       <entry>5</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>triConsistent</function></entry>
       <entry>
        determine whether value matches query condition (ternary variant)
        (optional if support function 4 is present)
       </entry>
       <entry>6</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>triConsistent</function></entry>
       <entry>
        判断值是否匹配查询条件（三元变体）（如果支持函数 4 存在则是可选的）
       </entry>
       <entry>6</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   BRIN indexes have four basic support functions, as shown in
   <xref linkend="xindex-brin-support-table"/>; those basic functions
   may require additional support functions to be provided.
   (For more information see <xref linkend="brin-extensibility"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="xindex-brin-support-table"/>中所示，BRIN 索引具有四个基本的支持函数。这些基本函数可能会要求提供额外的支持函数（更多信息请见<xref linkend="brin-extensibility"/>）。
  </para>

   <table tocentry="1" id="xindex-brin-support-table">
<!--==========================orignal english content==========================
    <title>BRIN Support Functions</title>
____________________________________________________________________________-->
    <title>BRIN 支持函数</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Function</entry>
       <entry>Description</entry>
       <entry>Support Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>函数</entry>
       <entry>描述</entry>
       <entry>支持编号</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><function>opcInfo</function></entry>
       <entry>
        return internal information describing the indexed columns'
        summary data
       </entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>opcInfo</function></entry>
       <entry>
        返回描述被索引列的摘要数据的内部信息
       </entry>
       <entry>1</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>add_value</function></entry>
       <entry>add a new value to an existing summary index tuple</entry>
       <entry>2</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>add_value</function></entry>
       <entry>向一个现有的摘要索引元组增加一个新值</entry>
       <entry>2</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>consistent</function></entry>
       <entry>determine whether value matches query condition</entry>
       <entry>3</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>consistent</function></entry>
       <entry>判断值是否匹配查询条件</entry>
       <entry>3</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><function>union</function></entry>
       <entry>
        compute union of two summary tuples
       </entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><function>union</function></entry>
       <entry>
        计算两个摘要元组的联合
       </entry>
       <entry>4</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   
<!--==========================orignal english content==========================
  <para>
   Unlike search operators, support functions return whichever data
   type the particular index method expects; for example in the case
   of the comparison function for B-trees, a signed integer.  The number
   and types of the arguments to each support function are likewise
   dependent on the index method.  For B-tree and hash the comparison and
   hashing support functions take the same input data types as do the
   operators included in the operator class, but this is not the case for
   most GiST, SP-GiST, GIN, and BRIN support functions.
  </para>
____________________________________________________________________________-->
  <para>
   和搜索操作符不同，支持函数返回特定索引方法所期望的数据类型，例如在 B 树的比较函数中是一个有符号整数。每个支持函数的参数数量和类型也取决于索引方法。对于 B 树和哈希，比较和哈希支持函数和包括在操作符类中的操作符接收一样的输入数据类型，但是大部分 GiST、SP-GiST、GIN 和 BRIN 支持函数则不是这样。
  </para>
 </sect2>

 <sect2 id="xindex-example">
<!--==========================orignal english content==========================
  <title>An Example</title>
____________________________________________________________________________-->
  <title>一个例子</title>

<!--==========================orignal english content==========================
  <para>
   Now that we have seen the ideas, here is the promised example of
   creating a new operator class.
   (You can find a working copy of this example in
   <filename>src/tutorial/complex.c</filename> and
   <filename>src/tutorial/complex.sql</filename> in the source
   distribution.)
   The operator class encapsulates
   operators that sort complex numbers in absolute value order, so we
   choose the name <literal>complex_abs_ops</literal>.  First, we need
   a set of operators.  The procedure for defining operators was
   discussed in <xref linkend="xoper"/>.  For an operator class on
   B-trees, the operators we require are:

   <itemizedlist spacing="compact">
    <listitem><simpara>absolute-value less-than (strategy 1)</simpara></listitem>
    <listitem><simpara>absolute-value less-than-or-equal (strategy 2)</simpara></listitem>
    <listitem><simpara>absolute-value equal (strategy 3)</simpara></listitem>
    <listitem><simpara>absolute-value greater-than-or-equal (strategy 4)</simpara></listitem>
    <listitem><simpara>absolute-value greater-than (strategy 5)</simpara></listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   现在我们已经看过了基本思想，这里是创建一个新操作符类的例子（可以在源代码的<filename>src/tutorial/complex.c</filename>和<filename>src/tutorial/complex.sql</filename>中找到这个例子）。该操作符类封装了以绝对值顺序排序复数的操作符，因此我们为它取名为<literal>complex_abs_ops</literal>。首先，我们需要一个操作符集合。定义操作符的过程已经在<xref linkend="xoper"/>中讨论过。对于一个 B-树上的操作符类，我们需要的操作符有：

   <itemizedlist spacing="compact">
    <listitem><simpara>绝对值小于（策略 1）</simpara></listitem>
    <listitem><simpara>绝对值小于等于（策略 2）</simpara></listitem>
    <listitem><simpara>绝对值等于（策略 3）</simpara></listitem>
    <listitem><simpara>绝对值大于等于（策略 4）</simpara></listitem>
    <listitem><simpara>绝对值大于（策略 5）</simpara></listitem>
   </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The least error-prone way to define a related set of comparison operators
   is to write the B-tree comparison support function first, and then write the
   other functions as one-line wrappers around the support function.  This
   reduces the odds of getting inconsistent results for corner cases.
   Following this approach, we first write:

<programlisting><![CDATA[
#define Mag(c)  ((c)->x*(c)->x + (c)->y*(c)->y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag < bmag)
        return -1;
    if (amag > bmag)
        return 1;
    return 0;
}
]]>
</programlisting>

   Now the less-than function looks like:

<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0);
}
]]>
</programlisting>

   The other four functions differ only in how they compare the internal
   function's result to zero.
  </para>
____________________________________________________________________________-->
  <para>
   定义一个比较操作符的相关集合最不容易出错的方式是，先编写 B-树比较支持函数，然后编写该支持函数的包装器函数。这降低了极端情况下得到不一致结果的几率。遵照这种方法，我们首先编写：

<programlisting><![CDATA[
#define Mag(c)  ((c)->x*(c)->x + (c)->y*(c)->y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag < bmag)
        return -1;
    if (amag > bmag)
        return 1;
    return 0;
}
]]>
</programlisting>

   现在小于函数看起来像这样：

<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0);
}
]]>
</programlisting>

   其他四个函数的区别只在于它们如何比较内部函数的结果与 0。
  </para>

<!--==========================orignal english content==========================
  <para>
   Next we declare the functions and the operators based on the functions
   to SQL:

<programlisting>
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>filename</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
</programlisting>
   It is important to specify the correct commutator and negator operators,
   as well as suitable restriction and join selectivity
   functions, otherwise the optimizer will be unable to make effective
   use of the index.
  </para>
____________________________________________________________________________-->
  <para>
   接下来我们基于这些函数声明 SQL 的函数和操作符：

<programlisting>
CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<replaceable>filename</replaceable>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);
</programlisting>
   指定正确的交换子和求反器操作符很重要，合适的限制和连接选择度函数也是一样，否则优化器将无法有效地利用索引。
  </para>

<!--==========================orignal english content==========================
  <para>
   Other things worth noting are happening here:

  <itemizedlist>
   <listitem>
    <para>
     There can only be one operator named, say, <literal>=</literal>
     and taking type <type>complex</type> for both operands.  In this
     case we don't have any other operator <literal>=</literal> for
     <type>complex</type>, but if we were building a practical data
     type we'd probably want <literal>=</literal> to be the ordinary
     equality operation for complex numbers (and not the equality of
     the absolute values).  In that case, we'd need to use some other
     operator name for <function>complex_abs_eq</function>.
    </para>
   </listitem>

   <listitem>
    <para>
     Although <productname>PostgreSQL</productname> can cope with
     functions having the same SQL name as long as they have different
     argument data types, C can only cope with one global function
     having a given name.  So we shouldn't name the C function
     something simple like <filename>abs_eq</filename>.  Usually it's
     a good practice to include the data type name in the C function
     name, so as not to conflict with functions for other data types.
    </para>
   </listitem>

   <listitem>
    <para>
     We could have made the SQL name
     of the function <filename>abs_eq</filename>, relying on
     <productname>PostgreSQL</productname> to distinguish it by
     argument data types from any other SQL function of the same name.
     To keep the example simple, we make the function have the same
     names at the C level and SQL level.
    </para>
   </listitem>
  </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   其他值得注意的事情：

  <itemizedlist>
   <listitem>
    <para>
     只能有一个操作符被命名为<literal>=</literal>且两个操作数都为类型<type>complex</type>。在这种要求下，我们对于<type>complex</type>没有任何其他操作符<literal>=</literal>。但是如果我们是在构建一种实际的数据类型，我们可能想让<literal>=</literal>成为复数的普通等值操作（不是绝对值的相等）。这样，我们需要为<function>complex_abs_eq</function>使用某种其他的操作符名称。
    </para>
   </listitem>

   <listitem>
    <para>
     尽管<productname>PostgreSQL</productname>能够处理具有相同 SQL 名称的函数（只要它们具有不同的参数数据类型），但 C 只能处理具有给定名称一个全局函数。因此，我们不能简单地把 C 函数命名为<filename>abs_eq</filename>之类的东西。通常，在 C 函数名中包括数据类型的名称是一种好习惯，这样就不会与其他数据类型的函数发生冲突。
    </para>
   </listitem>

   <listitem>
    <para>
     我们可以让函数也具有<filename>abs_eq</filename>这样的 SQL 名称，而依靠<productname>PostgreSQL</productname>通过参数数据类型来区分它和其他同名 SQL 函数。为了保持例子的简洁，我们这里让 C 级别和 SQL 级别的函数具有相同的名称。
    </para>
   </listitem>
  </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The next step is the registration of the support routine required
   by B-trees.  The example C code that implements this is in the same
   file that contains the operator functions.  This is how we declare
   the function:

<programlisting>
CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下一步是注册 B-树所要求的支持例程。实现支持例程的 C 代码例子在包含操作符函数的同一文件中。我们这样来声明该函数：

<programlisting>
CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Now that we have the required operators and support routine,
   we can finally create the operator class:

<programlisting><![CDATA[
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
]]>
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   现在我们已经有了所需的操作符和支持例程，就可以最终创建操作符类：

<programlisting><![CDATA[
CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       < ,
        OPERATOR        2       <= ,
        OPERATOR        3       = ,
        OPERATOR        4       >= ,
        OPERATOR        5       > ,
        FUNCTION        1       complex_abs_cmp(complex, complex);
]]>
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   And we're done!  It should now be possible to create
   and use B-tree indexes on <type>complex</type> columns.
  </para>
____________________________________________________________________________-->
  <para>
   做好了！现在应该可以在<type>complex</type>列上创建并且使用 B-树索引了。
  </para>

<!--==========================orignal english content==========================
  <para>
   We could have written the operator entries more verbosely, as in:
<programlisting>
        OPERATOR        1       &lt; (complex, complex) ,
</programlisting>
   but there is no need to do so when the operators take the same data type
   we are defining the operator class for.
  </para>
____________________________________________________________________________-->
  <para>
   我们可以把操作符项写得更繁琐，像这样：
<programlisting>
        OPERATOR        1       &lt; (complex, complex) ,
</programlisting>
   但是当操作符操作的数据类型和正在定义的操作符类所服务的数据类型相同时可以不用这么做。
  </para>

<!--==========================orignal english content==========================
  <para>
   The above example assumes that you want to make this new operator class the
   default B-tree operator class for the <type>complex</type> data type.
   If you don't, just leave out the word <literal>DEFAULT</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   上述例子假定这个新操作符类是<type>complex</type>数据类型的默认 B-树操作符类。如果不是这样，只需要省去关键词<literal>DEFAULT</literal>。
  </para>
 </sect2>

 <sect2 id="xindex-opfamily">
<!--==========================orignal english content==========================
  <title>Operator Classes and Operator Families</title>
____________________________________________________________________________-->
  <title>操作符类和操作符族</title>

<!--==========================orignal english content==========================
  <para>
   So far we have implicitly assumed that an operator class deals with
   only one data type.  While there certainly can be only one data type in
   a particular index column, it is often useful to index operations that
   compare an indexed column to a value of a different data type.  Also,
   if there is use for a cross-data-type operator in connection with an
   operator class, it is often the case that the other data type has a
   related operator class of its own.  It is helpful to make the connections
   between related classes explicit, because this can aid the planner in
   optimizing SQL queries (particularly for B-tree operator classes, since
   the planner contains a great deal of knowledge about how to work with them).
  </para>
____________________________________________________________________________-->
  <para>
   到目前为止，我们暗地里假设一个操作符类只处理一种数据类型。虽然在一个特定的索引列中必定只有一种数据类型，但是把被索引列与一种不同数据类型的值比较的索引操作通常也很有用。还有，如果与一种操作符类相关的扩数据类型操作符有用，通常情况是其他数据类型也有其自身相关的操作符类。在相关的类之间建立起明确的联系会很有用，因为这可以帮助规划器进行 SQL 查询优化（尤其是对于 B-树操作符类，因为规划器包含了大量有关如何使用它们的知识）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To handle these needs, <productname>PostgreSQL</productname>
   uses the concept of an <firstterm>operator
   family</firstterm><indexterm><primary>operator family</primary></indexterm>.
   An operator family contains one or more operator classes, and can also
   contain indexable operators and corresponding support functions that
   belong to the family as a whole but not to any single class within the
   family.  We say that such operators and functions are <quote>loose</quote>
   within the family, as opposed to being bound into a specific class.
   Typically each operator class contains single-data-type operators
   while cross-data-type operators are loose in the family.
  </para>
____________________________________________________________________________-->
  <para>
   为了处理这些需求，<productname>PostgreSQL</productname>使用了<firstterm>操作符族</firstterm>的概念<indexterm><primary>operator family</primary></indexterm>。一个操作符族包含一个或者多个操作符类，并且也能包含属于该族整体而不属于该族中任何单一类的可索引操作符和相应的支持函数。我们说这样的操作符和函数是<quote>松散地</quote>存在于该族中，而不是被绑定在一个特定的类中。通常每个操作符类包含单一数据类型的操作符，而跨数据类型操作符则松散地存在于操作符族中。
  </para>

<!--==========================orignal english content==========================
  <para>
   All the operators and functions in an operator family must have compatible
   semantics, where the compatibility requirements are set by the index
   method.  You might therefore wonder why bother to single out particular
   subsets of the family as operator classes; and indeed for many purposes
   the class divisions are irrelevant and the family is the only interesting
   grouping.  The reason for defining operator classes is that they specify
   how much of the family is needed to support any particular index.
   If there is an index using an operator class, then that operator class
   cannot be dropped without dropping the index &mdash; but other parts of
   the operator family, namely other operator classes and loose operators,
   could be dropped.  Thus, an operator class should be specified to contain
   the minimum set of operators and functions that are reasonably needed
   to work with an index on a specific data type, and then related but
   non-essential operators can be added as loose members of the operator
   family.
  </para>
____________________________________________________________________________-->
  <para>
   一个操作符族中的所有操作符和函数必须具有兼容的语义，其中的兼容性要求由索引方法设定。你可能因此而奇怪为什么要这么麻烦地把族的特定子集单另出来成为操作符类，并且实际上（由于很多原因）这种划分与操作符之间没有什么直接的关联，只有操作符族才是实际的分组。定义操作符类的原因是，它们指定了特定索引对操作符族的依赖程度。如果一个索引使用着一个操作符类，那么不删除该索引是不能删除该操作符类的 &mdash; 但是操作符族的其他部分（即其他操作符类和松散的操作符）可以被删除。因此，一个操作符类应该包含一个索引在特定数据类型上正常工作所需要的最小操作符和函数集合，而相关但不关键的操作符可以作为操作符族的松散成员被加入。
  </para>

<!--==========================orignal english content==========================
  <para>
   As an example, <productname>PostgreSQL</productname> has a built-in
   B-tree operator family <literal>integer_ops</literal>, which includes operator
   classes <literal>int8_ops</literal>, <literal>int4_ops</literal>, and
   <literal>int2_ops</literal> for indexes on <type>bigint</type> (<type>int8</type>),
   <type>integer</type> (<type>int4</type>), and <type>smallint</type> (<type>int2</type>)
   columns respectively.  The family also contains cross-data-type comparison
   operators allowing any two of these types to be compared, so that an index
   on one of these types can be searched using a comparison value of another
   type.  The family could be duplicated by these definitions:

<programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -&minus; standard int8 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ,
  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -&minus; standard int4 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ,
  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -&minus; standard int2 comparisons
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ,
  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -&minus; cross-type comparisons int8 vs int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -&minus; cross-type comparisons int8 vs int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -&minus; cross-type comparisons int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -&minus; cross-type comparisons int4 vs int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -&minus; cross-type comparisons int2 vs int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -&minus; cross-type comparisons int2 vs int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ,

  -&minus; cross-type in_range functions
  FUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;
]]>
</programlisting>

   Notice that this definition <quote>overloads</quote> the operator strategy and
   support function numbers: each number occurs multiple times within the
   family.  This is allowed so long as each instance of a
   particular number has distinct input data types.  The instances that have
   both input types equal to an operator class's input type are the
   primary operators and support functions for that operator class,
   and in most cases should be declared as part of the operator class rather
   than as loose members of the family.
  </para>
____________________________________________________________________________-->
  <para>
   例如，<productname>PostgreSQL</productname>有一个内建的 B-树操作符族<literal>integer_ops</literal>，它包括分别用于类型<type>bigint</type> (<type>int8</type>)、<type>integer</type> (<type>int4</type>)和<type>smallint</type> (<type>int2</type>)列上索引的操作符类<literal>int8_ops</literal>、<literal>int4_ops</literal>以及<literal>int2_ops</literal>。这个族也包含跨数据类型比较操作符，它们允许对这些类型中的任意两种进行比较，这样可以通过一种类型的比较值来搜索另一种类型之上的索引。这个族可以用这些定义来重现：

<programlisting><![CDATA[
CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- 标准 int8 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ,
  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- 标准 int4 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ,
  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- 标准 int2 比较
  OPERATOR 1 < ,
  OPERATOR 2 <= ,
  OPERATOR 3 = ,
  OPERATOR 4 >= ,
  OPERATOR 5 > ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ,
  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- 跨类型比较 int8 vs int2
  OPERATOR 1 < (int8, int2) ,
  OPERATOR 2 <= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 >= (int8, int2) ,
  OPERATOR 5 > (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- 跨类型比较 int8 vs int4
  OPERATOR 1 < (int8, int4) ,
  OPERATOR 2 <= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 >= (int8, int4) ,
  OPERATOR 5 > (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- 跨类型比较 int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- 跨类型比较 int4 vs int8
  OPERATOR 1 < (int4, int8) ,
  OPERATOR 2 <= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 >= (int4, int8) ,
  OPERATOR 5 > (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- 跨类型比较 int2 vs int8
  OPERATOR 1 < (int2, int8) ,
  OPERATOR 2 <= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 >= (int2, int8) ,
  OPERATOR 5 > (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- 跨类型比较 int2 vs int4
  OPERATOR 1 < (int2, int4) ,
  OPERATOR 2 <= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 >= (int2, int4) ,
  OPERATOR 5 > (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ,

  -- 跨类型的in_range函数
  FUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,
  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;
]]>
</programlisting>

   注意这种定义<quote>重载</quote>了操作符策略和支持函数号：每一个编号在该族中出现多次。只要一个特定编号的每一个实例都有可区分的输入数据类型，就允许这样做。输入类型等于操作符类输入类型的实例是该操作符类的主要操作符和支持函数，并且在大部分情况下应该被声明为该操作符类的一部分而不是作为操作符族的松散成员存在。
  </para>

<!--==========================orignal english content==========================
  <para>
   In a B-tree operator family, all the operators in the family must sort
   compatibly, as is specified in detail in <xref linkend="btree-behavior"/>.
   For each
   operator in the family there must be a support function having the same
   two input data types as the operator.  It is recommended that a family be
   complete, i.e., for each combination of data types, all operators are
   included.  Each operator class should include just the non-cross-type
   operators and support function for its data type.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="btree-behavior"/>中的细节所述，在一个 B-树操作符族中，所有该族中的操作符必须以兼容的方式排序。对该族中的每一个操作符都必须有一个与该操作符具有相同的两个输入数据类型的支持函数。我们推荐让操作符族保持完整，即对每一种数据类型的组合都应该包括所有的操作符。每个操作符类只应该包括非跨类型操作符和用于其数据类型的支持函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   To build a multiple-data-type hash operator family, compatible hash
   support functions must be created for each data type supported by the
   family.  Here compatibility means that the functions are guaranteed to
   return the same hash code for any two values that are considered equal
   by the family's equality operators, even when the values are of different
   types.  This is usually difficult to accomplish when the types have
   different physical representations, but it can be done in some cases.
   Furthermore, casting a value from one data type represented in the operator
   family to another data type also represented in the operator family via
   an implicit or binary coercion cast must not change the computed hash value.
   Notice that there is only one support function per data type, not one
   per equality operator.  It is recommended that a family be complete, i.e.,
   provide an equality operator for each combination of data types.
   Each operator class should include just the non-cross-type equality
   operator and the support function for its data type.
  </para>
____________________________________________________________________________-->
  <para>
   为了构建一个多数据类型的哈希操作符族，必须为该族支持的每一种数据类型创建相兼容的哈希支持函数。这里的兼容性是指这些函数对于任意两个被该族中等值操作符认为相等的值会保证返回相同的哈希码，即便这些值具有不同的类型时也是如此。当这些类型具有不同的物理表示时，这通常难以实现，但是在某些情况下是可以做到的。此外，将该操作符族中一种数据类型的值通过隐式或者二进制强制造型转换成该族中另一种数据类型时，不应该改变所计算出的哈希值。注意每种数据类型只有一个支持函数，而不是每个等值操作符一个。我们推荐让操作符族保持完整，即对每一种数据类型的组合提供一个等值操作符。每个操作符类只应该包括非跨类型等值操作符和用于其数据类型的支持函数。
  </para>

<!--==========================orignal english content==========================
  <para>
   GiST, SP-GiST, and GIN indexes do not have any explicit notion of
   cross-data-type operations.  The set of operators supported is just
   whatever the primary support functions for a given operator class can
   handle.
  </para>
____________________________________________________________________________-->
  <para>
   GiST、SP-GiST 和 GIN 索引没有任何明显的跨数据类型操作的概念。它们所支持的操作符集合就是一个给定操作符类能够处理的主要支持函数。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   In BRIN, the requirements depends on the framework that provides the
   operator classes.  For operator classes based on <literal>minmax</literal>,
   the behavior required is the same as for B-tree operator families:
   all the operators in the family must sort compatibly, and casts must
   not change the associated sort ordering.
  </para>
____________________________________________________________________________-->
  <para>
   在 BRIN 中，需求取决于提供操作符类的框架。对于基于<literal>minmax</literal>的操作符类，必要的行为和 B-树操作符族相同：族中的所有操作符必须以兼容的方式排序，并且转换不能改变相关的排序顺序。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Prior to <productname>PostgreSQL</productname> 8.3, there was no concept
    of operator families, and so any cross-data-type operators intended to be
    used with an index had to be bound directly into the index's operator
    class.  While this approach still works, it is deprecated because it
    makes an index's dependencies too broad, and because the planner can
    handle cross-data-type comparisons more effectively when both data types
    have operators in the same operator family.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 8.3 之前，没有操作符族的概念，并且因此要在索引中使用的任何跨数据类型操作符必须被直接绑定到该索引的操作符类中。虽然这种方法仍然有效，但是已被废弃，因为它会让索引的依赖过于广泛，还因为当两种数据类型都在同一操作符族中有操作符时规划器可以更有效地处理跨数据类型比较。
   </para>
  </note>
 </sect2>

 <sect2 id="xindex-opclass-dependencies">
<!--==========================orignal english content==========================
  <title>System Dependencies on Operator Classes</title>
____________________________________________________________________________-->
  <title>操作符类上的系统依赖</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ordering operator</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ordering operator</primary>
   </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> uses operator classes to infer the
   properties of operators in more ways than just whether they can be used
   with indexes.  Therefore, you might want to create operator classes
   even if you have no intention of indexing any columns of your data type.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>使用操作符类来以更多方式推断操作符的属性，而不仅仅是它们是否能被用于索引。因此，即便不准备对你的数据类型的列建立索引，也可能想要创建操作符类。
  </para>

<!--==========================orignal english content==========================
  <para>
   In particular, there are SQL features such as <literal>ORDER BY</literal> and
   <literal>DISTINCT</literal> that require comparison and sorting of values.
   To implement these features on a user-defined data type,
   <productname>PostgreSQL</productname> looks for the default B-tree operator
   class for the data type.  The <quote>equals</quote> member of this operator
   class defines the system's notion of equality of values for
   <literal>GROUP BY</literal> and <literal>DISTINCT</literal>, and the sort ordering
   imposed by the operator class defines the default <literal>ORDER BY</literal>
   ordering.
  </para>
____________________________________________________________________________-->
  <para>
   特别地，<literal>ORDER BY</literal>和<literal>DISTINCT</literal>等 SQL 特性要求对值的比较和排序。为了在用户定义的数据类型上实现这些特性，<productname>PostgreSQL</productname>会为数据类型查找默认 B-树操作符类。这个操作符类的<quote>equals</quote>成员定义了用于<literal>GROUP BY</literal>和<literal>DISTINCT</literal>的值的等值概念，而该操作符类施加的排序顺序定义了默认的<literal>ORDER BY</literal>顺序。
  </para>

<!--==========================orignal english content==========================
  <para>
   If there is no default B-tree operator class for a data type, the system
   will look for a default hash operator class.  But since that kind of
   operator class only provides equality, it is only able to support grouping
   not sorting.
  </para>
____________________________________________________________________________-->
  <para>
   如果一种数据类型没有默认的 B-树操作符类，系统将查找默认的哈希操作符类。但由于这类操作符类只提供等值，所以它只能支持分组而不能支持排序。
  </para>

<!--==========================orignal english content==========================
  <para>
   When there is no default operator class for a data type, you will get
   errors like <quote>could not identify an ordering operator</quote> if you
   try to use these SQL features with the data type.
  </para>
____________________________________________________________________________-->
  <para>
   在一种数据类型没有默认操作符类时，如果尝试对该数据类型使用这些 SQL 特性，你将得到类似<quote>could not identify an ordering operator</quote>（无法标识排序操作符）的错误。
  </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     In <productname>PostgreSQL</productname> versions before 7.4,
     sorting and grouping operations would implicitly use operators named
     <literal>=</literal>, <literal>&lt;</literal>, and <literal>&gt;</literal>.  The new
     behavior of relying on default operator classes avoids having to make
     any assumption about the behavior of operators with particular names.
    </para>
____________________________________________________________________________-->
    <para>
     在版本 7.4 以前的<productname>PostgreSQL</productname>中，排序和分组操作将隐式地使用名为<literal>=</literal>、<literal>&lt;</literal>以及<literal>&gt;</literal>的操作符。新的依赖于默认操作符类的行为避免了对具有特定名字的操作符行为作出任何假设。
    </para>
   </note>

<!--==========================orignal english content==========================
  <para>
   Sorting by a non-default B-tree operator class is possible by specifying
   the class's less-than operator in a <literal>USING</literal> option,
   for example
<programlisting>
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
</programlisting>
   Alternatively, specifying the class's greater-than operator
   in <literal>USING</literal> selects a descending-order sort.
  </para>
____________________________________________________________________________-->
  <para>
   通过在一个<literal>USING</literal>选项中指定一个非默认B-树操作符类的小于操作符，可以使用该操作符进行排序，例如
<programlisting>
SELECT * FROM mytable ORDER BY somecol USING ~&lt;~;
</programlisting>
   或者，在<literal>USING</literal>中指定该操作符类的大于操作符可以选择升序的排序。
  </para>

<!--==========================orignal english content==========================
  <para>
   Comparison of arrays of a user-defined type also relies on the semantics
   defined by the type's default B-tree operator class.  If there is no
   default B-tree operator class, but there is a default hash operator class,
   then array equality is supported, but not ordering comparisons.
  </para>
____________________________________________________________________________-->
  <para>
   用户定义类型的数组的比较还依赖于该类型的默认B-树操作符类所定义的语义。如果没有默认的B-树操作符类，但有一个默认的哈希操作符类，则支持数组的相等比较，但不支持顺序的比较。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another SQL feature that requires even more data-type-specific knowledge
   is the <literal>RANGE</literal> <replaceable>offset</replaceable>
   <literal>PRECEDING</literal>/<literal>FOLLOWING</literal> framing option
   for window functions (see <xref linkend="syntax-window-functions"/>).
   For a query such as
<programlisting>
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
  FROM mytable;
</programlisting>
   it is not sufficient to know how to order by <literal>x</literal>;
   the database must also understand how to <quote>subtract 5</quote> or
   <quote>add 10</quote> to the current row's value of <literal>x</literal>
   to identify the bounds of the current window frame.  Comparing the
   resulting bounds to other rows' values of <literal>x</literal> is
   possible using the comparison operators provided by the B-tree operator
   class that defines the <literal>ORDER BY</literal> ordering &mdash; but
   addition and subtraction operators are not part of the operator class, so
   which ones should be used?  Hard-wiring that choice would be undesirable,
   because different sort orders (different B-tree operator classes) might
   need different behavior.  Therefore, a B-tree operator class can specify
   an <firstterm>in_range</firstterm> support function that encapsulates the
   addition and subtraction behaviors that make sense for its sort order.
   It can even provide more than one in_range support function, in case
   there is more than one data type that makes sense to use as the offset
   in <literal>RANGE</literal> clauses.
   If the B-tree operator class associated with the window's <literal>ORDER
   BY</literal> clause does not have a matching in_range support function,
   the <literal>RANGE</literal> <replaceable>offset</replaceable>
   <literal>PRECEDING</literal>/<literal>FOLLOWING</literal>
   option is not supported.
  </para>
____________________________________________________________________________-->
  <para>
   另一种要求更多数据类型相关知识的SQL特性是窗口函数（见<xref linkend="syntax-window-functions"/>）的<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>PRECEDING</literal>/<literal>FOLLOWING</literal>帧选项。对于这样的一个查询
<programlisting>
SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)
  FROM mytable;
</programlisting>
   不足以了解如何用<literal>x</literal>进行排序，数据库还必须理解如何对当前行的<literal>x</literal>值<quote>减5</quote>或者<quote>加10</quote>以标识当前窗口帧的边界。把得到的边界与其他行的<literal>x</literal>值用B-树操作符类提供的比较操作符（定义了<literal>ORDER BY</literal>顺序）进行比较是可能的 &mdash; 但是加和减操作符并不是该操作符类的一部分，因此应该用哪些操作符呢？硬编码的选择是不切实际的，因为不同的排序顺序（不同的B-树操作符）可能需要不同的行为。因此，一个B-树操作符类可以指定一个<firstterm>in_range</firstterm>支持函数，它封装有对排序顺序有意义的加和减行为。如果有多种数据类型可以用作<literal>RANGE</literal>子句中的偏移量，甚至可以提供多个in_range支持函数。如果与窗口的<literal>ORDER BY</literal>子句关联的B-树操作符类没有一个匹配的in_range支持函数，则不支持<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>PRECEDING</literal>/<literal>FOLLOWING</literal>选项。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another important point is that an equality operator that
   appears in a hash operator family is a candidate for hash joins,
   hash aggregation, and related optimizations.  The hash operator family
   is essential here since it identifies the hash function(s) to use.
  </para>
____________________________________________________________________________-->
  <para>
   另一个要点是，出现在一个哈希操作符族中的操作符是哈希连接、哈希聚集和相关优化的候选。这些情况下哈希操作符族就是至关重要的，因为它标识了要使用的哈希函数。
  </para>
 </sect2>

 <sect2 id="xindex-ordering-ops">
<!--==========================orignal english content==========================
  <title>Ordering Operators</title>
____________________________________________________________________________-->
  <title>排序操作符</title>

<!--==========================orignal english content==========================
  <para>
   Some index access methods (currently, only GiST) support the concept of
   <firstterm>ordering operators</firstterm>.  What we have been discussing so far
   are <firstterm>search operators</firstterm>.  A search operator is one for which
   the index can be searched to find all rows satisfying
   <literal>WHERE</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>.
   Note that nothing is promised about the order in which the matching rows
   will be returned.  In contrast, an ordering operator does not restrict the
   set of rows that can be returned, but instead determines their order.
   An ordering operator is one for which the index can be scanned to return
   rows in the order represented by
   <literal>ORDER BY</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>.
   The reason for defining ordering operators that way is that it supports
   nearest-neighbor searches, if the operator is one that measures distance.
   For example, a query like
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
   finds the ten places closest to a given target point.  A GiST index
   on the location column can do this efficiently because
   <literal>&lt;-&gt;</literal> is an ordering operator.
  </para>
____________________________________________________________________________-->
  <para>
   有些索引访问方法（当前只有 GiST）支持<firstterm>排序操作符</firstterm>的概念。到目前为止我们所讨论的都是<firstterm>搜索操作符</firstterm>。搜索索引时，会用搜索操作符来寻找所有满足
   <literal>WHERE</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>
   的行。注意被返回的匹配行的顺序是没有任何保证的。相反，一个排序操作符并不限制能被返回的行集合，而是决定它们的顺序。扫描索引时，会使用排序操作符来以
   <literal>ORDER BY</literal>
   <replaceable>indexed_column</replaceable>
   <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>
   所表示的顺序返回行。这样定义排序操作符的原因是，如果该操作符能度量距离，它就能支持最近邻搜索。例如，这样的一个查询
<programlisting><![CDATA[
SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;
]]>
</programlisting>
   寻找离一个给定目标点最近的十个位置。位置列上的 GiST 索引可以有效地完成这个查询，因为<literal>&lt;-&gt;</literal>是一个排序操作符。
  </para>

<!--==========================orignal english content==========================
  <para>
   While search operators have to return Boolean results, ordering operators
   usually return some other type, such as float or numeric for distances.
   This type is normally not the same as the data type being indexed.
   To avoid hard-wiring assumptions about the behavior of different data
   types, the definition of an ordering operator is required to name
   a B-tree operator family that specifies the sort ordering of the result
   data type.  As was stated in the previous section, B-tree operator families
   define <productname>PostgreSQL</productname>'s notion of ordering, so
   this is a natural representation.  Since the point <literal>&lt;-&gt;</literal>
   operator returns <type>float8</type>, it could be specified in an operator
   class creation command like this:
<programlisting><![CDATA[
OPERATOR 15    <-> (point, point) FOR ORDER BY float_ops
]]>
</programlisting>
   where <literal>float_ops</literal> is the built-in operator family that includes
   operations on <type>float8</type>.  This declaration states that the index
   is able to return rows in order of increasing values of the
   <literal>&lt;-&gt;</literal> operator.
  </para>
____________________________________________________________________________-->
  <para>
   搜索操作符必须返回布尔结果，排序操作符通常返回某种其他类型，例如浮点、数字或者距离。这种类型通常不同于被索引的数据类型。为了避免硬编码有关不同数据类型行为的假设，需要定义一个排序操作符来提名一个 B-树操作符族指定结果数据类型的排序顺序。正如我们在前一节介绍的，B-树操作符族定义了<productname>PostgreSQL</productname>的顺序概念，因此这是一种自然的表达。由于点<literal>&lt;-&gt;</literal>操作符返回<type>float8</type>，可以在一个操作符类创建命令中这样指定它：
<programlisting><![CDATA[
OPERATOR 15    <-> (point, point) FOR ORDER BY float_ops
]]>
</programlisting>
   其中<literal>float_ops</literal>是包括<type>float8</type>上操作的内建操作符族。这种声明说明该索引能够以<literal>&lt;-&gt;</literal>操作符的递增值顺序返回行。
  </para>
 </sect2>

 <sect2 id="xindex-opclass-features">
<!--==========================orignal english content==========================
  <title>Special Features of Operator Classes</title>
____________________________________________________________________________-->
  <title>操作符类的特性</title>

<!--==========================orignal english content==========================
  <para>
   There are two special features of operator classes that we have
   not discussed yet, mainly because they are not useful
   with the most commonly used index methods.
  </para>
____________________________________________________________________________-->
  <para>
   有两个操作符类的特性我们还没有讨论，主要是因为它们对于最常用的索引方法不太有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally, declaring an operator as a member of an operator class
   (or family) means that the index method can retrieve exactly the set of rows
   that satisfy a <literal>WHERE</literal> condition using the operator.  For example:
<programlisting>
SELECT * FROM table WHERE integer_column &lt; 4;
</programlisting>
   can be satisfied exactly by a B-tree index on the integer column.
   But there are cases where an index is useful as an inexact guide to
   the matching rows.  For example, if a GiST index stores only bounding boxes
   for geometric objects, then it cannot exactly satisfy a <literal>WHERE</literal>
   condition that tests overlap between nonrectangular objects such as
   polygons.  Yet we could use the index to find objects whose bounding
   box overlaps the bounding box of the target object, and then do the
   exact overlap test only on the objects found by the index.  If this
   scenario applies, the index is said to be <quote>lossy</quote> for the
   operator.  Lossy index searches are implemented by having the index
   method return a <firstterm>recheck</firstterm> flag when a row might or might
   not really satisfy the query condition.  The core system will then
   test the original query condition on the retrieved row to see whether
   it should be returned as a valid match.  This approach works if
   the index is guaranteed to return all the required rows, plus perhaps
   some additional rows, which can be eliminated by performing the original
   operator invocation.  The index methods that support lossy searches
   (currently, GiST, SP-GiST and GIN) allow the support functions of individual
   operator classes to set the recheck flag, and so this is essentially an
   operator-class feature.
  </para>
____________________________________________________________________________-->
  <para>
   通常，把一个操作符声明为一个操作符类（或操作符族）的成员意味着该索引方法能够使用该操作符准确地检索满足<literal>WHERE</literal>条件的行集。例如：
<programlisting>
SELECT * FROM table WHERE integer_column &lt; 4;
</programlisting>
   恰好可以被该整数列上一个 B-树索引满足。但是也有情况下索引只是作为匹配行的非精确向导。例如，如果一个 GiST 索引只存储几何对象的边界框，那么它无法精确地满足测试非矩形对象（如多边形）之间相交的<literal>WHERE</literal>条件。但是我们可以使用该索引来寻找边界框与目标对象的边界框相交的对象，并且只在通过该索引找到的对象上做精确的相交测试。如果适用于这种场景，该索引被称为对该操作符是<quote>有损的</quote>。有损索引搜索通过在一行可能满足或者不满足该查询条件时返回一个<firstterm>recheck</firstterm>标志来实现。核心系统将接着在检索到的行上测试原始查询条件来看它是否应该被作为一个合法匹配返回。如果索引被保证能返回所有所需的行外加一些额外的行，这种方法就能有效，因为那些额外的行可以通过执行原始的操作符调用来消除。支持有损搜索的索引方法（当前有 GiST、SP-GiST 和 GIN）允许个别操作符类的支持函数设置 recheck 标志，因此这也是一种操作符类的重要特性。
  </para>

<!--==========================orignal english content==========================
  <para>
   Consider again the situation where we are storing in the index only
   the bounding box of a complex object such as a polygon.  In this
   case there's not much value in storing the whole polygon in the index
   entry &mdash; we might as well store just a simpler object of type
   <type>box</type>.  This situation is expressed by the <literal>STORAGE</literal>
   option in <command>CREATE OPERATOR CLASS</command>: we'd write something like:

<programlisting>
CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
</programlisting>

   At present, only the GiST, GIN and BRIN index methods support a
   <literal>STORAGE</literal> type that's different from the column data type.
   The GiST <function>compress</function> and <function>decompress</function> support
   routines must deal with data-type conversion when <literal>STORAGE</literal>
   is used.  In GIN, the <literal>STORAGE</literal> type identifies the type of
   the <quote>key</quote> values, which normally is different from the type
   of the indexed column &mdash; for example, an operator class for
   integer-array columns might have keys that are just integers.  The
   GIN <function>extractValue</function> and <function>extractQuery</function> support
   routines are responsible for extracting keys from indexed values.
   BRIN is similar to GIN: the <literal>STORAGE</literal> type identifies the
   type of the stored summary values, and operator classes' support
   procedures are responsible for interpreting the summary values
   correctly.
  </para>
____________________________________________________________________________-->
  <para>
   再次考虑在索引中只存储复杂对象（如多边形）的边界框的情况。在这种情况下，把整个多边形存储在索引项中没有很大价值 &mdash; 我们也可以只存储一个更简单的<type>box</type>类型对象。这种情况通过<command>CREATE OPERATOR CLASS</command>中的<literal>STORAGE</literal>选项表示：

<programlisting>
CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;
</programlisting>

   当前，只有 GiST、GIN 和 BRIN 索引方法支持不同于列数据类型的<literal>STORAGE</literal>类型。在使用<literal>STORAGE</literal>时，GiST 的支持例程<function>compress</function>和<function>decompress</function>必须处理数据类型转换。在 GIN 中，<literal>STORAGE</literal>类型标识<quote>key</quote>值的类型，它通常不同于被索引列的类型 &mdash; 例如，一个用于整数数组列的操作符类可能具有整数键值。GIN 的支持例程<function>extractValue</function>和<function>extractQuery</function>负责从被索引值中抽取键。BRIN 类似于 GIN：<literal>STORAGE</literal>类型标识被存储的摘要值的类型，而操作符类的支持过程负责正确解释摘要值。
  </para>
 </sect2>

</sect1>
