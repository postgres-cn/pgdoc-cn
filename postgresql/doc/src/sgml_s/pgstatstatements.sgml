<!-- doc/src/sgml/pgstatstatements.sgml -->

<sect1 id="pgstatstatements" xreflabel="pg_stat_statements">
<!--==========================orignal english content==========================
 <title>pg_stat_statements</title>
____________________________________________________________________________-->
 <title>pg_stat_statements</title>

<!--==========================orignal english content==========================
 <indexterm zone="pgstatstatements">
  <primary>pg_stat_statements</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgstatstatements">
  <primary>pg_stat_statements</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>pg_stat_statements</filename> module provides a means for
  tracking execution statistics of all SQL statements executed by a server.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>pg_stat_statements</filename>模块提供一种方法追踪一个服务器所执行的所有 SQL 语句的执行统计信息。
 </para>

<!--==========================orignal english content==========================
 <para>
  The module must be loaded by adding <literal>pg_stat_statements</> to
  <xref linkend="guc-shared-preload-libraries"> in
  <filename>postgresql.conf</>, because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
 </para>
____________________________________________________________________________-->
 <para>
  该模块必须通过在<filename>postgresql.conf</filename>的<xref linkend="guc-shared-preload-libraries"/>中增加<literal>pg_stat_statements</literal>来载入，因为它需要额外的共享内存。这意味着增加或移除该模块需要一次服务器重启。
 </para>
 
<!--==========================orignal english content==========================
 <para>
   When <filename>pg_stat_statements</filename> is loaded, it tracks
   statistics across all databases of the server.  To access and manipulate
   these statistics, the module provides a view, <structname>pg_stat_statements</>,
   and the utility functions <function>pg_stat_statements_reset</> and
   <function>pg_stat_statements</>.  These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_stat_statements</>.
 </para>
____________________________________________________________________________-->
 <para>
   当<filename>pg_stat_statements</filename>被载入时，它会跟踪该服务器
   的所有数据库的统计信息。该模块提供了一个视图
   <structname>pg_stat_statements</structname>以及函数<function>pg_stat_statements_reset</function>
   和<function>pg_stat_statements</function>用于访问和操纵这些统计信息。这些视图
   和函数不是全局可用的，但是可以用<command>CREATE EXTENSION pg_stat_statements</command>
   为特定数据库启用它们。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>The <structname>pg_stat_statements</structname> View</title>
____________________________________________________________________________-->
  <title><structname>pg_stat_statements</structname>视图</title>

<!--==========================orignal english content==========================
  <para>
   The statistics gathered by the module are made available via a
   view named <structname>pg_stat_statements</>.  This view
   contains one row for each distinct database ID, user ID and query
   ID (up to the maximum number of distinct statements that the module
   can track).  The columns of the view are shown in
   <xref linkend="pgstatstatements-columns">.
  </para>
____________________________________________________________________________-->
  <para>
   由该模块收集的统计信息可以通过一个名为
   <structname>pg_stat_statements</structname>的视图使用。这个视图为每
   一个可区分的数据库 ID、用户 ID 和查询 ID（最多到该模块可以追
   踪的可区分语句的数量）的组合都包含一行。该视图的列如
   <xref linkend="pgstatstatements-columns"/>中所示。
  </para>

  <table id="pgstatstatements-columns">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_statements</> Columns</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_statements</structname>列</title>

   <tgroup cols="4">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>userid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>OID of user who executed the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>userid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <entry>执行该语句的用户的 OID</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>OID of database in which the statement was executed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>在其中执行该语句的数据库的 OID</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>queryid</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Internal hash code, computed from the statement's parse tree</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>queryid</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>内部哈希码，从语句的解析树计算得来</entry>
     </row>

<!--==========================orignal english content==========================
    <row>
      <entry><structfield>query</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>Text of a representative statement</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry><structfield>query</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>语句的文本形式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>calls</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Number of times executed</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>calls</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>被执行的次数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>total_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>Total time spent in the statement, in milliseconds</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>total_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费的总时间，以毫秒计</entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><structfield>min_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>Minimum time spent in the statement, in milliseconds</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>min_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费的最小时间，以毫秒计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>max_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>Maximum time spent in the statement, in milliseconds</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>max_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费的最大时间，以毫秒计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>mean_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>Mean time spent in the statement, in milliseconds</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>mean_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费的平均时间，以毫秒计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>stddev_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>Population standard deviation of time spent in the statement, in milliseconds</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>stddev_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>在该语句中花费时间的总体标准偏差，以毫秒计</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>rows</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of rows retrieved or affected by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>rows</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句检索或影响的行总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>shared_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of shared block cache hits by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>shared_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句造成的共享块缓冲命中总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>shared_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of shared blocks read by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>shared_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的共享块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>shared_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of shared blocks dirtied by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>shared_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句弄脏的共享块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>shared_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of shared blocks written by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>shared_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的共享块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of local block cache hits by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_blks_hit</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句造成的本地块缓冲命中总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of local blocks read by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的本地块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of local blocks dirtied by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_blks_dirtied</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句弄脏的本地块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>local_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of local blocks written by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>local_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的本地块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>temp_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of temp blocks read by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>temp_blks_read</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句读取的临时块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>temp_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>Total number of temp blocks written by the statement</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>temp_blks_written</structfield></entry>
      <entry><type>bigint</type></entry>
      <entry></entry>
      <entry>该语句写入的临时块的总数</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>blk_read_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        Total time the statement spent reading blocks, in milliseconds
        (if <xref linkend="guc-track-io-timing"> is enabled, otherwise zero)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>blk_read_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        该语句花在读取块上的总时间，以毫秒计（如果<xref linkend="guc-track-io-timing"/>被启用，否则为零）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structfield>blk_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        Total time the statement spent writing blocks, in milliseconds
        (if <xref linkend="guc-track-io-timing"> is enabled, otherwise zero)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structfield>blk_write_time</structfield></entry>
      <entry><type>double precision</type></entry>
      <entry></entry>
      <entry>
        该语句花在写入块上的总时间，以毫秒计（如果<xref linkend="guc-track-io-timing"/>被启用，否则为零）
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   For security reasons, only superusers and members of the
   <literal>pg_read_all_stats</literal> role are allowed to see the SQL text and
   <structfield>queryid</structfield> of queries executed by other users.
   Other users can see the statistics, however, if the view has been installed
   in their database.
  </para>
____________________________________________________________________________-->
  <para>
   由于安全性原因，只有超级用户和<literal>pg_read_all_stats</literal>
   角色的成员被允许看到其他用户执行的查询
   的 SQL 文本或者<structfield>queryid</structfield>。
   不过，如果该视图被安装在其他用户的数据库中，那么他们就能够看见统
   计信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   Plannable queries (that is, <command>SELECT</>, <command>INSERT</>,
   <command>UPDATE</>, and <command>DELETE</>) are combined into a single
   <structname>pg_stat_statements</> entry whenever they have identical query
   structures according to an internal hash calculation.  Typically, two
   queries will be considered the same for this purpose if they are
   semantically equivalent except for the values of literal constants
   appearing in the query.  Utility commands (that is, all other commands)
   are compared strictly on the basis of their textual query strings, however.
  </para>
____________________________________________________________________________-->
  <para>
   只要可规划的查询（即<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>以及<command>DELETE</command>）根据一种内部哈希计算具有相同的查询结构，它们就会被组合到一个单一的<structname>pg_stat_statements</structname>项。通常，对于这里的目的，如果两个查询除了查询中的文本常量值之外在语义上等效，它们将会被认为是相同的。不过，功能性命令（即所有其他命令）会严格地以它们的文本查询字符串为基础进行比较。
  </para>

<!--==========================orignal english content==========================
  <para>
   When a constant's value has been ignored for purposes of matching the query
   to other queries, the constant is replaced by a parameter symbol, such
   as <literal>$1</literal>, in the <structname>pg_stat_statements</>
   display.
   The rest of the query text is that of the first query that had the
   particular <structfield>queryid</> hash value associated with the
   <structname>pg_stat_statements</> entry.
  </para>
____________________________________________________________________________-->
  <para>
   当为了把一个查询与其他查询匹配，常数值会被忽略，
   在<structname>pg_stat_statements</structname>显示中它会被一个参数符号，
   比如<literal>$1</literal>所替换。查询文本的剩余部分就是具有与该<structname>pg_stat_statements</structname>项相关的特定<structfield>queryid</structfield>哈希值的第一个查询的文本。
  </para>

<!--==========================orignal english content==========================
  <para>
   In some cases, queries with visibly different texts might get merged into a
   single <structname>pg_stat_statements</> entry.  Normally this will happen
   only for semantically equivalent queries, but there is a small chance of
   hash collisions causing unrelated queries to be merged into one entry.
   (This cannot happen for queries belonging to different users or databases,
   however.)
  </para>
____________________________________________________________________________-->
  <para>
   在某些情况中，具有明显不同文本的查询可能会被融合到一个单一的<structname>pg_stat_statements</structname>项。通常这只会发生在语义等价的查询身上，但是也有很小的机会因为哈希碰撞的原因导致无关的查询被融合到一个项中（不过，对于属于不同用户或数据库的查询来说不会发生这种情况）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since the <structfield>queryid</> hash value is computed on the
   post-parse-analysis representation of the queries, the opposite is
   also possible: queries with identical texts might appear as
   separate entries, if they have different meanings as a result of
   factors such as different <varname>search_path</> settings.
  </para>
____________________________________________________________________________-->
  <para>
   由于<structfield>queryid</structfield>哈希值是根据查询被解析和分析后的表达计算的，对立的情况也可能存在：如果具有相同文本的查询由于参数（如不同的<varname>search_path</varname>设置）的原因而具有不同的含义，它们就可能作为不同的项存在。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Consumers of <structname>pg_stat_statements</> may wish to use
   <structfield>queryid</> (perhaps in combination with
   <structfield>dbid</> and <structfield>userid</>) as a more stable
   and reliable identifier for each entry than its query text.
   However, it is important to understand that there are only limited
   guarantees around the stability of the <structfield>queryid</> hash
   value.  Since the identifier is derived from the
   post-parse-analysis tree, its value is a function of, among other
   things, the internal object identifiers appearing in this representation.
   This has some counterintuitive implications.  For example,
   <filename>pg_stat_statements</> will consider two apparently-identical
   queries to be distinct, if they reference a table that was dropped
   and recreated between the executions of the two queries.
   The hashing process is also sensitive to differences in
   machine architecture and other facets of the platform.
   Furthermore, it is not safe to assume that <structfield>queryid</>
   will be stable across major versions of <productname>PostgreSQL</>.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_statements</structname>的使用者可能希望使用
   <structfield>queryid</structfield>（也许会与<structfield>dbid</structfield>和<structfield>userid</structfield>组合）作为一个项比查询文本更稳定和可靠的标识符。但是，有一点很重要的是，对于<structfield>queryid</structfield>哈希值稳定性只有有限的保障。因为该标识符是从解析分析后的树得来的，它的值是以这种形式出现的内部对象标识符的函数。这有一些违背直觉的含义。例如，如果有两个查询引用了同一个表，但是该表在两次查询之间被删除并且重建，显然这两个查询是完全一致的，但是<filename>pg_stat_statements</filename>将把它们认为是不同的。哈希处理也对机器架构以及平台的其他方面的差别很敏感。更进一步，认为<productname>PostgreSQL</productname>的不同主版本之间<structfield>queryid</structfield>将会保持稳定是不安全的。
  </para>

<!--==========================orignal english content==========================
  <para>
   As a rule of thumb, <structfield>queryid</> values can be assumed to be
   stable and comparable only so long as the underlying server version and
   catalog metadata details stay exactly the same.  Two servers
   participating in replication based on physical WAL replay can be expected
   to have identical <structfield>queryid</> values for the same query.
   However, logical replication schemes do not promise to keep replicas
   identical in all relevant details, so <structfield>queryid</> will
   not be a useful identifier for accumulating costs across a set of logical
   replicas.  If in doubt, direct testing is recommended.
  </para>
____________________________________________________________________________-->
  <para>
   根据经验，只有在底层服务器版本以及目录元数据细节保持完全相同时，<structfield>queryid</structfield>值才能被假定为稳定并且可比。两台参与到基于物理 WAL 重放的复制中的服务器会对相同的查询给出一样的<structfield>queryid</structfield>值。但是，逻辑复制模式并不保证在所有相关细节上都保持完全一样的复制，因此在逻辑复制机之间计算代价时，<structfield>queryid</structfield>并非是一个有用的标识符。如果有疑问，推荐直接进行测试。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter symbols used to replace constants in
   representative query texts start from the next number after the
   highest <literal>$</><replaceable>n</> parameter in the original query
   text, or <literal>$1</> if there was none.  It's worth noting that in
   some cases there may be hidden parameter symbols that affect this
   numbering.  For example, <application>PL/pgSQL</> uses hidden parameter
   symbols to insert values of function local variables into queries, so that
   a <application>PL/pgSQL</> statement like <literal>SELECT i + 1 INTO j</>
   would have representative text like <literal>SELECT i + $2</>.
  </para>
____________________________________________________________________________-->
  <para>
   代表性查询文本中用于替换常量的参数符号从原始查询文本中最高的
   <literal>$</literal><replaceable>n</replaceable>参数之后的下一个数字开始，
   如果没有则为<literal>$1</literal>。值得注意的是，在某些情况下，
   可能存在影响编号的隐藏参数符号。例如，<application>PL/pgSQL</application>
   使用隐藏参数符号将函数局部变量的值插入到查询中，以便像
   <literal>SELECT i + 1 INTO j</literal>的<application>PL/pgSQL</application>
   语句将具有像<literal>SELECT i + $2</literal>这样的代表性文本。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   The representative query texts are kept in an external disk file, and do
   not consume shared memory.  Therefore, even very lengthy query texts can
   be stored successfully.  However, if many long query texts are
   accumulated, the external file might grow unmanageably large.  As a
   recovery method if that happens, <filename>pg_stat_statements</> may
   choose to discard the query texts, whereupon all existing entries in
   the <structname>pg_stat_statements</> view will show
   null <structfield>query</> fields, though the statistics associated with
   each <structfield>queryid</> are preserved.  If this happens, consider
   reducing <varname>pg_stat_statements.max</varname> to prevent
   recurrences.
  </para>
____________________________________________________________________________-->
  <para>
   有代表性的查询文本被保存在一个外部磁盘文件中，并且不会消耗共享内存。
   因此，即便是很长的查询文本也能被成功的存储下来。不过，如果累积了很多
   长的查询文本，该外部文件也会增长到很大。作为一种恢复方法，如果这样的
   情况发生，<filename>pg_stat_statements</filename>可能会选择丢弃这些查询文本，
   于是<structname>pg_stat_statements</structname>视图中的所有现有项将会显示空的
   <structfield>query</structfield>域，不过与每个<structfield>queryid</structfield>相关联的
   统计信息会被保留下来。如果发生这种情况，可以考虑减小
   <varname>pg_stat_statements.max</varname>来防止复发。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Functions</title>
____________________________________________________________________________-->
  <title>函数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
   <term>
     <function>pg_stat_statements_reset() returns void</function>
     <indexterm>
      <primary>pg_stat_statements_reset</primary>
     </indexterm>
    </term>
____________________________________________________________________________-->
   <term>
     <function>pg_stat_statements_reset() 返回 void</function>
   <indexterm>
    <primary>pg_stat_statements_reset</primary>
   </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <function>pg_stat_statements_reset</function> discards all statistics
      gathered so far by <filename>pg_stat_statements</>.
      By default, this function can only be executed by superusers.
     </para>
____________________________________________________________________________-->
     <para>
      <function>pg_stat_statements_reset</function>抛弃目前由<filename>pg_stat_statements</filename>收集的所有统计信息。默认情况下，这个函数只能被超级用户执行。
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <function>pg_stat_statements(showtext boolean) returns setof record</function>
     <indexterm>
      <primary>pg_stat_statements</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>
____________________________________________________________________________-->
    <term>
     <function>pg_stat_statements(showtext boolean) returns setof record</function>
     <indexterm>
      <primary>pg_stat_statements</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      The <structname>pg_stat_statements</structname> view is defined in
      terms of a function also named <function>pg_stat_statements</>.
      It is possible for clients to call
      the <function>pg_stat_statements</function> function directly, and by
      specifying <literal>showtext := false</literal> have query text be
      omitted (that is, the <literal>OUT</literal> argument that corresponds
      to the view's <structfield>query</> column will return nulls).  This
      feature is intended to support external tools that might wish to avoid
      the overhead of repeatedly retrieving query texts of indeterminate
      length.  Such tools can instead cache the first query text observed
      for each entry themselves, since that is
      all <filename>pg_stat_statements</> itself does, and then retrieve
      query texts only as needed.  Since the server stores query texts in a
      file, this approach may reduce physical I/O for repeated examination
      of the <structname>pg_stat_statements</structname> data.
     </para>
____________________________________________________________________________-->
     <para>
      <structname>pg_stat_statements</structname>视图按照一个也叫
      <function>pg_stat_statements</function>的函数来定义。客户端可以直接调用
      <function>pg_stat_statements</function>函数，并且通过指定
      <literal>showtext := false</literal>来忽略查询文本（即，对应于视图的
      <structfield>query</structfield>列的<literal>OUT</literal>参数将返回空值）。
      这个特性是为了支持不想重复接收长度不定的查询文本的外部工具而设计的。
      这类工具可以转而自行缓存第一个观察到的查询文本，因为这就是
      <filename>pg_stat_statements</filename>自己所做的全部工作，并且只在需要的
      时候检索查询文本。因为服务器会把查询文本存储在一个文件中，这种方法可
      以降低重复检查<structname>pg_stat_statements</structname>数据的
      物理 I/O。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Configuration Parameters</title>
____________________________________________________________________________-->
  <title>配置参数</title>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <varname>pg_stat_statements.max</varname> (<type>integer</type>)
    </term>
____________________________________________________________________________-->
    <term>
     <varname>pg_stat_statements.max</varname> (<type>integer</type>)
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <varname>pg_stat_statements.max</varname> is the maximum number of
      statements tracked by the module (i.e., the maximum number of rows
      in the <structname>pg_stat_statements</> view).  If more distinct
      statements than that are observed, information about the least-executed
      statements is discarded.
      The default value is 5000.
      This parameter can only be set at server start.
     </para>
____________________________________________________________________________-->
     <para>
      <varname>pg_stat_statements.max</varname>是由该模块跟踪的语句的最大数目（即<structname>pg_stat_statements</structname>视图中行的最大数量）。如果观测到的可区分的语句超过这个数量，最少被执行的语句的信息将会被丢弃。默认值为 5000。这个参数只能在服务器启动时设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <varname>pg_stat_statements.track</varname> (<type>enum</type>)
    </term>
____________________________________________________________________________-->
    <term>
     <varname>pg_stat_statements.track</varname> (<type>enum</type>)
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <varname>pg_stat_statements.track</varname> controls which statements
      are counted by the module.
      Specify <literal>top</> to track top-level statements (those issued
      directly by clients), <literal>all</> to also track nested statements
      (such as statements invoked within functions), or <literal>none</> to
      disable statement statistics collection.
      The default value is <literal>top</>.
      Only superusers can change this setting.
     </para>
____________________________________________________________________________-->
     <para>
      <varname>pg_stat_statements.track</varname>控制哪些语句会被该模块计数。指定<literal>top</literal>可以跟踪顶层语句（那些直接由客户端发出的语句），指定<literal>all</literal>还可以跟踪嵌套的语句（例如在函数中调用的语句），指定<literal>none</literal>可以禁用语句统计信息收集。默认值是<literal>top</literal>。
      只有超级用户能够改变这个设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <varname>pg_stat_statements.track_utility</varname> (<type>boolean</type>)
    </term>
____________________________________________________________________________-->
    <term>
     <varname>pg_stat_statements.track_utility</varname> (<type>boolean</type>)
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <varname>pg_stat_statements.track_utility</varname> controls whether
      utility commands are tracked by the module.  Utility commands are
      all those other than <command>SELECT</>, <command>INSERT</>,
      <command>UPDATE</> and <command>DELETE</>.
      The default value is <literal>on</>.
      Only superusers can change this setting.
     </para>
____________________________________________________________________________-->
     <para>
      <varname>pg_stat_statements.track_utility</varname>控制该模块是否会跟踪工具命令。工具命令是除了<command>SELECT</command>、<command>INSERT</command>、
      <command>UPDATE</command>和<command>DELETE</command>之外所有的其他命令。默认值是<literal>on</literal>。
      只有超级用户能够改变这个设置。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term>
     <varname>pg_stat_statements.save</varname> (<type>boolean</type>)
    </term>
____________________________________________________________________________-->
    <term>
     <varname>pg_stat_statements.save</varname> (<type>boolean</type>)
    </term>

    <listitem>
<!--==========================orignal english content==========================
     <para>
      <varname>pg_stat_statements.save</varname> specifies whether to
      save statement statistics across server shutdowns.
      If it is <literal>off</> then statistics are not saved at
      shutdown nor reloaded at server start.
      The default value is <literal>on</>.
      This parameter can only be set in the <filename>postgresql.conf</>
      file or on the server command line.
     </para>
____________________________________________________________________________-->
     <para>
      <varname>pg_stat_statements.save</varname>指定是否在服务器关闭之后还保存语句统计信息。如果被设置为<literal>off</literal>，那么关闭后不保存统计信息并且在服务器启动时也不会重新载入统计信息。默认值为<literal>on</literal>。这个参数只能在<filename>postgresql.conf</filename>文件中或者在服务器命令行上设置。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   The module requires additional shared memory proportional to
   <varname>pg_stat_statements.max</varname>.  Note that this
   memory is consumed whenever the module is loaded, even if
   <varname>pg_stat_statements.track</> is set to <literal>none</>.
  </para>
____________________________________________________________________________-->
  <para>
   该模块要求与<varname>pg_stat_statements.max</varname>成比例的额外共享内存。注意只要该模块被载入就会消耗这么多的内存，即便<varname>pg_stat_statements.track</varname>被设置为<literal>none</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   These parameters must be set in <filename>postgresql.conf</>.
   Typical usage might be:

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

pg_stat_statements.max = 10000
pg_stat_statements.track = all
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   这些参数必须在<filename>postgresql.conf</filename>中设置。典型的用法可能是：

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements'

pg_stat_statements.max = 10000
pg_stat_statements.track = all
</programlisting>
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Sample Output</title>
____________________________________________________________________________-->
  <title>示例输出</title>

<!--==========================orignal english content==========================
<screen>
bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
query       | UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2;
calls       | 3000
total_time  | 9609.00100000002
rows        | 2836
hit_percent | 99.9778970000200936
-[ RECORD 2 ]-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
query       | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2;
calls       | 3000
total_time  | 8015.156
rows        | 2990
hit_percent | 99.9731126579631345
-[ RECORD 3 ]-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
query       | copy pgbench_accounts from stdin
calls       | 1
total_time  | 310.624
rows        | 100000
hit_percent | 0.30395136778115501520
-[ RECORD 4 ]-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
query       | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2;
calls       | 3000
total_time  | 271.741999999997
rows        | 3000
hit_percent | 93.7968855088209426
-[ RECORD 5 ]-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
query       | alter table pgbench_accounts add primary key (aid)
calls       | 1
total_time  | 81.42
rows        | 0
hit_percent | 34.4947735191637631
</screen>
____________________________________________________________________________-->
<screen>
bench=# SELECT pg_stat_statements_reset();

$ pgbench -i bench
$ pgbench -c10 -t300 bench

bench=# \x
bench=# SELECT query, calls, total_time, rows, 100.0 * shared_blks_hit /
               nullif(shared_blks_hit + shared_blks_read, 0) AS hit_percent
          FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5;
-[ RECORD 1 ]---------------------------------------------------------------------
query       | UPDATE pgbench_branches SET bbalance = bbalance + $1 WHERE bid = $2;
calls       | 3000
total_time  | 9609.00100000002
rows        | 2836
hit_percent | 99.9778970000200936
-[ RECORD 2 ]---------------------------------------------------------------------
query       | UPDATE pgbench_tellers SET tbalance = tbalance + $1 WHERE tid = $2;
calls       | 3000
total_time  | 8015.156
rows        | 2990
hit_percent | 99.9731126579631345
-[ RECORD 3 ]---------------------------------------------------------------------
query       | copy pgbench_accounts from stdin
calls       | 1
total_time  | 310.624
rows        | 100000
hit_percent | 0.30395136778115501520
-[ RECORD 4 ]---------------------------------------------------------------------
query       | UPDATE pgbench_accounts SET abalance = abalance + $1 WHERE aid = $2;
calls       | 3000
total_time  | 271.741999999997
rows        | 3000
hit_percent | 93.7968855088209426
-[ RECORD 5 ]---------------------------------------------------------------------
query       | alter table pgbench_accounts add primary key (aid)
calls       | 1
total_time  | 81.42
rows        | 0
hit_percent | 34.4947735191637631
</screen>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Authors</title>
____________________________________________________________________________-->
  <title>作者</title>

<!--==========================orignal english content==========================
  <para>
   Takahiro Itagaki <email>itagaki.takahiro@oss.ntt.co.jp</email>.
   Query normalization added by Peter Geoghegan <email>peter@2ndquadrant.com</email>.
  </para>
____________________________________________________________________________-->
  <para>
   Takahiro Itagaki <email>itagaki.takahiro@oss.ntt.co.jp</email>。Peter Geoghegan <email>peter@2ndquadrant.com</email>为它加入了查询正规化的功能。
  </para>
 </sect2>

</sect1>
