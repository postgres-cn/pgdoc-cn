<!-- doc/src/sgml/typeconv.sgml -->

<chapter id="typeconv">
<!--==========================orignal english content==========================
<title>Type Conversion</title>
____________________________________________________________________________-->
<title>类型转换</title>

<!--==========================orignal english content==========================
<indexterm zone="typeconv">
 <primary>data type</primary>
 <secondary>conversion</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv">
 <primary>数据类型</primary>
 <secondary>转换</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
<acronym>SQL</acronym> statements can, intentionally or not, require
the mixing of different data types in the same expression.
<productname>PostgreSQL</productname> has extensive facilities for
evaluating mixed-type expressions.
</para>
____________________________________________________________________________-->
<para>
<acronym>SQL</acronym>语句可能（有意无意地）要求在同一表达式里混合不同的数据类型。 <productname>PostgreSQL</productname>在计算混合类型表达式方面有许多功能。
</para>

<!--==========================orignal english content==========================
<para>
In many cases a user does not need
to understand the details of the type conversion mechanism.
However, implicit conversions done by <productname>PostgreSQL</productname>
can affect the results of a query.  When necessary, these results
can be tailored by using <emphasis>explicit</emphasis> type conversion.
</para>
____________________________________________________________________________-->
<para>
在大多数情况下，用户不需要明白类型转换机制的细节。但是，由<productname>PostgreSQL</productname>进行的隐式类型转换会对查询的结果产生影响。必要时这些结果可以被使用<emphasis>显式</emphasis>类型转换来调整。
</para>

<!--==========================orignal english content==========================
<para>
This chapter introduces the <productname>PostgreSQL</productname>
type conversion mechanisms and conventions.
Refer to the relevant sections in <xref linkend="datatype"/> and <xref linkend="functions"/>
for more information on specific data types and allowed functions and
operators.
</para>
____________________________________________________________________________-->
<para>
本章介绍<productname>PostgreSQL</productname>类型转换的机制和习惯。 关于特定的类型和允许的函数及操作符的进一步信息，请参考<xref linkend="datatype"/>和<xref linkend="functions"/>里的相关章节。
</para>

<sect1 id="typeconv-overview">
<!--==========================orignal english content==========================
<title>Overview</title>
____________________________________________________________________________-->
<title>概述</title>

<!--==========================orignal english content==========================
<para>
<acronym>SQL</acronym> is a strongly typed language. That is, every data item
has an associated data type which determines its behavior and allowed usage.
<productname>PostgreSQL</productname> has an extensible type system that is
more general and flexible than other <acronym>SQL</acronym> implementations.
Hence, most type conversion behavior in <productname>PostgreSQL</productname>
is governed by general rules rather than by <foreignphrase>ad hoc</foreignphrase>
heuristics.  This allows the use of mixed-type expressions even with
user-defined types.
</para>
____________________________________________________________________________-->
<para>
<acronym>SQL</acronym>是一种强类型语言。也就是说，每个数据项都有一个相关的数据类型，数据类型决定其行为和允许的用法。 <productname>PostgreSQL</productname>有一个可扩展的类型系统，该系统比其它<acronym>SQL</acronym>实现更具通用和灵活。因而，<productname>PostgreSQL</productname>中大多数类型转换行为是由通用规则来管理的，而不是<foreignphrase>ad hoc</foreignphrase>启发式规则。这种做法允许使用混合类型表达式，即便是其中包含用户定义的类型。
</para>

<!--==========================orignal english content==========================
<para>
The <productname>PostgreSQL</productname> scanner/parser divides lexical
elements into five fundamental categories: integers, non-integer numbers,
strings, identifiers, and key words.  Constants of most non-numeric types are
first classified as strings. The <acronym>SQL</acronym> language definition
allows specifying type names with strings, and this mechanism can be used in
<productname>PostgreSQL</productname> to start the parser down the correct
path. For example, the query:

<screen>
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Origin | (0,0)
(1 row)
</screen>

has two literal constants, of type <type>text</type> and <type>point</type>.
If a type is not specified for a string literal, then the placeholder type
<type>unknown</type> is assigned initially, to be resolved in later
stages as described below.
</para>
____________________________________________________________________________-->
<para>
<productname>PostgreSQL</productname>扫描器/解析器只将词法元素分解成五个基本种类：整数、非整数数字、字符串、标识符、关键字。大多数非数字类型常量首先被分类为字符串。<acronym>SQL</acronym>语言定义允许将类型名指定为字符串， 这个机制被<productname>PostgreSQL</productname>用于保证解析器沿着正确的方向运行。例如，查询：

<screen>
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)
</screen>

有两个文字常量，类型分别为<type>text</type>和<type>point</type>。如果一个串文字没有指定类型，初始将被分配一个占位符类型<type>unknown</type>，该类型将在下文描述的后续阶段被解析。
</para>

<!--==========================orignal english content==========================
<para>
There are four fundamental <acronym>SQL</acronym> constructs requiring
distinct type conversion rules in the <productname>PostgreSQL</productname>
parser:

<variablelist>
<varlistentry>
<term>
Function calls
</term>
<listitem>
<para>
Much of the <productname>PostgreSQL</productname> type system is built around a
rich set of functions. Functions can have one or more arguments.
Since <productname>PostgreSQL</productname> permits function
overloading, the function name alone does not uniquely identify the function
to be called; the parser must select the right function based on the data
types of the supplied arguments.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Operators
</term>
<listitem>
<para>
<productname>PostgreSQL</productname> allows expressions with
prefix and postfix unary (one-argument) operators,
as well as binary (two-argument) operators.  Like functions, operators can
be overloaded, so the same problem of selecting the right operator
exists.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
Value Storage
</term>
<listitem>
<para>
<acronym>SQL</acronym> <command>INSERT</command> and <command>UPDATE</command> statements place the results of
expressions into a table. The expressions in the statement must be matched up
with, and perhaps converted to, the types of the target columns.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>UNION</literal>, <literal>CASE</literal>, and related constructs
</term>
<listitem>
<para>
Since all query results from a unionized <command>SELECT</command> statement
must appear in a single set of columns, the types of the results of each
<command>SELECT</command> clause must be matched up and converted to a uniform set.
Similarly, the result expressions of a <literal>CASE</literal> construct must be
converted to a common type so that the <literal>CASE</literal> expression as a whole
has a known output type.  The same holds for <literal>ARRAY</literal> constructs,
and for the <function>GREATEST</function> and <function>LEAST</function> functions.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>
在<acronym>SQL</acronym>解析器里，有四种基本的<acronym>SQL</acronym>结构要求独立的类型转换规则：

<variablelist>
<varlistentry>
<term>
函数调用
</term>
<listitem>
<para>
<productname>PostgreSQL</productname>类型系统的大部分建立在一套丰富的函数上。 函数可以有一个或多个参数。由于<productname>PostgreSQL</productname>允许函数重载， 所以函数名自身并不唯一地标识将要被调用的函数，解析器必须根据提供的参数类型选择正确的函数。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
操作符
</term>
<listitem>
<para>
<productname>PostgreSQL</productname>允许带有前缀和后缀一元（单目）操作符的表达式，也允许二元（两个参数）操作符。像函数一样，操作符也可以被重载，因此操作符的选择也有同样的问题。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
值存储
</term>
<listitem>
<para>
<acronym>SQL</acronym> <command>INSERT</command>和<command>UPDATE</command>语句将表达式的结果放 入表中。语句中的表达式类型必须和目标列的类型一致（或者可以被转换为一致）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>UNION</literal>、<literal>CASE</literal>和相关结构
</term>
<listitem>
<para>
因为来自一个联合的<command>SELECT</command>语句中的所有查询结果必须在一个列集中显示，所以每个 <command>SELECT</command>子句的结果类型必须能相互匹配并被转换成一个统一的集合。类似地，一个 <literal>CASE</literal>结构的结果表达式必须被转换成一种公共的类型，这样<literal>CASE</literal>表达式作为整体才 有一种已知的输出类型。同样的要求也存在于<literal>ARRAY</literal>结构以及<function>GREATEST</function>和<function>LEAST</function>函数中。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<!--==========================orignal english content==========================
<para>
The system catalogs store information about which conversions, or
<firstterm>casts</firstterm>, exist between which data types, and how to
perform those conversions.  Additional casts can be added by the user
with the <xref linkend="sql-createcast"/>
command.  (This is usually
done in conjunction with defining new data types.  The set of casts
between built-in types has been carefully crafted and is best not
altered.)
</para>
____________________________________________________________________________-->
<para>
系统目录存储有关哪些数据类型之间存在哪种转换（或<firstterm>造型</firstterm>）以及如何执行这些转换的相关信息。额外的造型可以由用户通过<xref linkend="sql-createcast"/>命令增加（这个通常和定义一种新的数据类型一起完成。 内建的类型转换集已经经过了仔细的雕琢，最好不要去更改它们）。
</para>

<!--==========================orignal english content==========================
<indexterm>
 <primary>data type</primary>
 <secondary>category</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm>
 <primary>数据类型</primary>
 <secondary>分类</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
An additional heuristic provided by the parser allows improved determination
of the proper casting behavior among groups of types that have implicit casts.
Data types are divided into several basic <firstterm>type
categories</firstterm>, including <type>boolean</type>, <type>numeric</type>,
<type>string</type>, <type>bitstring</type>, <type>datetime</type>,
<type>timespan</type>, <type>geometric</type>, <type>network</type>, and
user-defined.  (For a list see <xref linkend="catalog-typcategory-table"/>;
but note it is also possible to create custom type categories.)  Within each
category there can be one or more <firstterm>preferred types</firstterm>, which
are preferred when there is a choice of possible types.  With careful selection
of preferred types and available implicit casts, it is possible to ensure that
ambiguous expressions (those with multiple candidate parsing solutions) can be
resolved in a useful way.
</para>
____________________________________________________________________________-->
<para>
解析器提供了一种额外的启发式规则，它允许在具有隐式造型的类型组中恰当造型行为的改进决定。 数据类型被分为几个基本的<firstterm>类型分类</firstterm>，包括<type>boolean</type>、<type>numeric</type>、<type>string</type>、<type>bitstring</type>、<type>datetime</type>、<type>timespan</type>、<type>geometric</type>、<type>network</type>和用户自定义（可参阅<xref linkend="catalog-typcategory-table"/>中的列表；但需要注意的是 也可以创建自定义的类型分类）。在每个分类中，可以有一个或多个<firstterm>首选类型</firstterm>， 当存在类型选择时，这个是更好的选择。利用精心选择的首选类型和可用的隐式造型， 我们可以确保有歧义的表达式（那些有多个候选解析方案的表达式）可以用一种有用的方式来处理。
</para>

<!--==========================orignal english content==========================
<para>
All type conversion rules are designed with several principles in mind:

<itemizedlist>
<listitem>
<para>
Implicit conversions should never have surprising or unpredictable outcomes.
</para>
</listitem>

<listitem>
<para>
There should be no extra overhead in the parser or executor
if a query does not need implicit type conversion.
That is, if a query is well-formed and the types already match, then the query should execute
without spending extra time in the parser and without introducing unnecessary implicit conversion
calls in the query.
</para>
</listitem>

<listitem>
<para>
Additionally, if a query usually requires an implicit conversion for a function, and
if then the user defines a new function with the correct argument types, the parser
should use this new function and no longer do implicit conversion to use the old function.
</para>
</listitem>
</itemizedlist>
</para>
____________________________________________________________________________-->
<para>
所有类型转换规则都是建立在下面几个基本原则上的：

<itemizedlist>
<listitem>
<para>
隐式转换决不能有意外的或不可预见的输出。
</para>
</listitem>

<listitem>
<para>
如果一个查询不需要隐式类型转换，解析器或执行器不应该有额外的开销。也就是说，如果一个查询是结构良好的并且类型已经匹配，则查询不应该在解析器里耗费额外的时间执行，也不会在查询中引入不必要的隐式类型转换调用。
</para>
</listitem>

<listitem>
<para>
另外，如果一个查询通常要求为某个函数进行隐式类型转换，而用户定义了一个有正确参数类型的新函数， 解析器应该使用新函数并不再做隐式转换来使用旧函数。
</para>
</listitem>
</itemizedlist>
</para>

</sect1>

<sect1 id="typeconv-oper">
<!--==========================orignal english content==========================
<title>Operators</title>
____________________________________________________________________________-->
<title>操作符</title>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-oper">
 <primary>operator</primary>
 <secondary>type resolution in an invocation</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-oper">
 <primary>操作符</primary>
 <secondary>一次调用中的类型决定</secondary>
</indexterm>

<!--==========================orignal english content==========================
  <para>
   The specific operator that is referenced by an operator expression
   is determined using the following procedure.
   Note that this procedure is indirectly affected
   by the precedence of the operators involved, since that will determine
   which sub-expressions are taken to be the inputs of which operators.
   See <xref linkend="sql-precedence"/> for more information.
  </para>
____________________________________________________________________________-->
  <para>
   被一个操作符表达式引用的特定操作符由下列过程决定。注意这个过程会被所涉及的操作符的优先级间接地影响，因为这将决定哪些子表达式被用作哪个操作符的输入。详见<xref linkend="sql-precedence"/>。
  </para>

<procedure>
<!--==========================orignal english content==========================
<title>Operator Type Resolution</title>
____________________________________________________________________________-->
<title>操作符类型决定</title>

<step id="op-resol-select" performance="required">
<!--==========================orignal english content==========================
<para>
Select the operators to be considered from the
<classname>pg_operator</classname> system catalog.  If a non-schema-qualified
operator name was used (the usual case), the operators
considered are those with the matching name and argument count that are
visible in the current search path (see <xref linkend="ddl-schemas-path"/>).
If a qualified operator name was given, only operators in the specified
schema are considered.
</para>
____________________________________________________________________________-->
<para>
从系统目录<classname>pg_operator</classname>中选出要考虑的操作符。如果使用了一个不带模式限定的操作符 名（常见的情况），那么操作符被认为是那些在当前搜索路径中可见并有匹配的名字和参数个数的操作符（参见<xref linkend="ddl-schemas-path"/>）。如果给出一个被限定的操作符名，那么只考虑指定模式中的操作符。
</para>

<substeps>
<step performance="optional">
<!--==========================orignal english content==========================
<para>
If the search path finds multiple operators with identical argument types,
only the one appearing earliest in the path is considered.  Operators with
different argument types are considered on an equal footing regardless of
search path position.
</para>
____________________________________________________________________________-->
<para>
如果搜索路径找到了多个有相同参数类型的操作符，那么只考虑最早出现在路径中的那一个。 但是不同参数类型的操作符将被平等看待，而不管它们在路径中的位置如何。
</para>
</step>
</substeps>
</step>

<step id="op-resol-exact-match" performance="required">
<!--==========================orignal english content==========================
<para>
Check for an operator accepting exactly the input argument types.
If one exists (there can be only one exact match in the set of
operators considered), use it.  Lack of an exact match creates a security
hazard when calling, via qualified name
  <footnote id="op-qualified-security">
   <!-&minus; If you edit this, consider editing func-qualified-security. -&minus;>
   <para>
    The hazard does not arise with a non-schema-qualified name, because a
    search path containing schemas that permit untrusted users to create
    objects is not a <link linkend="ddl-schemas-patterns">secure schema usage
    pattern</link>.
   </para>
  </footnote>
(not typical), any operator found in a schema that permits untrusted users to
create objects.  In such situations, cast arguments to force an exact match.
</para>
____________________________________________________________________________-->
<para>
查找一个正好接受输入参数类型的操作符。如果找到一个（在一组被考虑的操作符中，可能只存在一个正好匹配的），则使用之。在通过限定名称（非典型）调用在一个允许不可信用户创建对象的方案中找到的任意操作符时，精确匹配的缺失会导致安全性危害
  <footnote id="op-qualified-security">
   <!-- If you edit this, consider editing func-qualified-security. -->
   <para>
    对非方案限定的名称，不会出现这种危害，因为包含允许不可信用户创建对象的方案的搜索路径不是一种<link linkend="ddl-schemas-patterns">安全的方案使用模式</link>。
   </para>
  </footnote>
。在这样的情况下，应该造型参数以便强制一次精确匹配。
</para>

<substeps>
<step id="op-resol-exact-unknown" performance="optional">
<!--==========================orignal english content==========================
<para>
If one argument of a binary operator invocation is of the <type>unknown</type> type,
then assume it is the same type as the other argument for this check.
Invocations involving two <type>unknown</type> inputs, or a unary operator
with an <type>unknown</type> input, will never find a match at this step.
</para>
____________________________________________________________________________-->
<para>
如果一个二元操作符调用中的一个参数是<type>unknown</type>类型，则在本次检查中假设它与另一个参数类型相同。 对于涉及两个<type>unknown</type>输入的调用或者带有一个<type>unknown</type>输入的一元操作符，在这一步将永远找不到一个匹配。
</para>
</step>
<step id="op-resol-exact-domain" performance="optional">
<!--==========================orignal english content==========================
<para>
If one argument of a binary operator invocation is of the <type>unknown</type>
type and the other is of a domain type, next check to see if there is an
operator accepting exactly the domain's base type on both sides; if so, use it.
</para>
____________________________________________________________________________-->
<para>
如果一个二元操作符调用的其中一个参数是<type>unknown</type>类型
而另一个是一种域类型，下一次检查会看看是否有一个操作符正好在两边都
接受该域的基类型，如果有就使用它。
</para>
</step>
</substeps>
</step>

<step id="op-resol-best-match" performance="required">
<!--==========================orignal english content==========================
<para>
Look for the best match.
</para>
____________________________________________________________________________-->
<para>
寻找最优匹配。
</para>
<substeps>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Discard candidate operators for which the input types do not match
and cannot be converted (using an implicit conversion) to match.
<type>unknown</type> literals are
assumed to be convertible to anything for this purpose.  If only one
candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
抛弃那些输入类型不匹配并且也不能被转换成匹配的候选操作符。
<type>unknown</type>文字被假定为可以为这个目的被转换为
任何东西。如果只剩下一个候选操作符，则使用之，否则继续下一
步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
If any input argument is of a domain type, treat it as being of the
domain's base type for all subsequent steps.  This ensures that domains
act like their base types for purposes of ambiguous-operator resolution.
</para>
____________________________________________________________________________-->
<para>
如果任何输入参数是一种域类型，对所有后续步骤都把它当做是该
域的基类型。这确保在做有歧义的操作符解析时，域的举止像它们
的基类型。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Run through all candidates and keep those with the most exact matches
on input types.  Keep all candidates if none have exact matches.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
遍历所有候选操作符，保留那些在输入类型上的匹配最准确的。如果没有一个操作符能准确匹配，则保留所有候选。如果只剩下一个候选操作符，则使用之，否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Run through all candidates and keep those that accept preferred types (of the
input data type's type category) at the most positions where type conversion
will be required.
Keep all candidates if none accept preferred types.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
遍历所有候选操作符，保留那些在最多个需要类型转换的位置上接受首选类型（属于输入数据类型的类型分类）的操作符。如果没有接受首选类型的操作符，则保留所有候选。如果只剩下一个候选操作符，则使用之， 否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
If any input arguments are <type>unknown</type>, check the type
categories accepted at those argument positions by the remaining
candidates.  At each position, select the <type>string</type> category
if any
candidate accepts that category.  (This bias towards string is appropriate
since an unknown-type literal looks like a string.) Otherwise, if
all the remaining candidates accept the same type category, select that
category; otherwise fail because the correct choice cannot be deduced
without more clues.  Now discard
candidates that do not accept the selected type category.  Furthermore,
if any candidate accepts a preferred type in that category,
discard candidates that accept non-preferred types for that argument.
Keep all candidates if none survive these tests.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
如果有任何输入参数是<type>unknown</type>类型，检查被剩余候选操作符在那些参数位置上接受的类型分类。 在每一个位置，如果任何候选接受该分类，则选择<type>string</type>分类（这种对字符串的偏爱是合适的， 因为未知类型的文本确实像字符串)。否则，如果所有剩下的候选操作符都接受相同的类型 分类，则选择该分类；否则抛出一个错误（因为在没有更多线索的条件下无法作出正确 的推断）。现在抛弃不接受选定的类型分类的候选操作符。然后，如果任意候选操作符接受那个分类中的首选类型， 则抛弃那些在该参数位置接受非首选类型的候选操作符。如果没有候选操作符能通过这些测试则保留全部候选者。如果只剩下一个候选者，则使用之；否则继续下一步。
</para>
</step>
<step id="op-resol-last-unknown" performance="required">
<!--==========================orignal english content==========================
<para>
If there are both <type>unknown</type> and known-type arguments, and all
the known-type arguments have the same type, assume that the
<type>unknown</type> arguments are also of that type, and check which
candidates can accept that type at the <type>unknown</type>-argument
positions.  If exactly one candidate passes this test, use it.
Otherwise, fail.
</para>
____________________________________________________________________________-->
<para>
如果既有<type>unknown</type>参数也有已知类型的参数，并且所有已知类型参数具有相同的类型，则假定该<type>unknown</type>参数也是那种类型的，并且检查哪些候选操作符可以在该<type>unknown</type>参数的位置上接受那个类型。如果正好有一个候选者通过了这个测试，则使用之；否则失败。
</para>
</step>
</substeps>
</step>
</procedure>

<!--==========================orignal english content==========================
<para>
Some examples follow.
</para>
____________________________________________________________________________-->
<para>
下面是一些例子。
</para>

<example>
<!--==========================orignal english content==========================
<title>Factorial Operator Type Resolution</title>
____________________________________________________________________________-->
<title>阶乘操作符类型决定</title>

<!--==========================orignal english content==========================
<para>
There is only one factorial operator (postfix <literal>!</literal>)
defined in the standard catalog, and it takes an argument of type
<type>bigint</type>.
The scanner assigns an initial type of <type>integer</type> to the argument
in this query expression:
<screen>
SELECT 40 ! AS "40 factorial";

                   40 factorial
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 815915283247897734345611269596115894272000000000
(1 row)
</screen>

So the parser does a type conversion on the operand and the query
is equivalent to:

<screen>
SELECT CAST(40 AS bigint) ! AS "40 factorial";
</screen>
</para>
____________________________________________________________________________-->
<para>
在标准目录中只有一个被定义的阶乘操作符（后缀<literal>!</literal>），它接受一个类型为<type>bigint</type>的参数。在下面这个查询表达式中，扫描器会为该参数分配一个初始类型<type>integer</type>：
<screen>
SELECT 40 ! AS "40 factorial";

                   40 factorial
--------------------------------------------------
 815915283247897734345611269596115894272000000000
(1 row)
</screen>

因此，解析器在操作数上做了一个类型转换，该查询等价于：

<screen>
SELECT CAST(40 AS bigint) ! AS "40 factorial";
</screen>
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>String Concatenation Operator Type Resolution</title>
____________________________________________________________________________-->
<title>字符串连接操作符类型决定</title>

<!--==========================orignal english content==========================
<para>
A string-like syntax is used for working with string types and for
working with complex extension types.
Strings with unspecified type are matched with likely operator candidates.
</para>
____________________________________________________________________________-->
<para>
一个类字符串的语法被用来处理字符串类型和处理复杂的扩展类型。未指定类型的字符串与可能的候选操作符匹配。
</para>

<!--==========================orignal english content==========================
<para>
An example with one unspecified argument:
<screen>
SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 abcdef
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
一个未指定参数的例子：
<screen>
SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)
</screen>
</para>

<!--==========================orignal english content==========================
<para>
In this case the parser looks to see if there is an operator taking <type>text</type>
for both arguments. Since there is, it assumes that the second argument should
be interpreted as type <type>text</type>.
</para>
____________________________________________________________________________-->
<para>
在这种情况下，解析器查看是否有一个操作符的两个参数都使用<type>text</type>。既然有，那么它假设第二个参数应被解释为<type>text</type>类型。
</para>

<!--==========================orignal english content==========================
<para>
Here is a concatenation of two values of unspecified types:
<screen>
SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 abcdef
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
下面是两个未指定类型的值的连接：
<screen>
SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)
</screen>
</para>

<!--==========================orignal english content==========================
<para>
In this case there is no initial hint for which type to use, since no types
are specified in the query. So, the parser looks for all candidate operators
and finds that there are candidates accepting both string-category and
bit-string-category inputs.  Since string category is preferred when available,
that category is selected, and then the
preferred type for strings, <type>text</type>, is used as the specific
type to resolve the unknown-type literals as.
</para>
____________________________________________________________________________-->
<para>
在这种情况下，没有对于使用哪种类型的初始提示，因为在查询中没有指定类型。 因此，解析器查找所有的候选操作符并找到候选者同时接受字符串分类和位串分类的输入。 因为字符串分类在可用时是首选的，该分类会被选中，并且接下来字符串的首选类型（<type>text</type>）会被用作解决未知类型文字的指定类型。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Absolute-Value and Negation Operator Type Resolution</title>
____________________________________________________________________________-->
<title>绝对值与否定操作符类型决定</title>

<!--==========================orignal english content==========================
<para>
The <productname>PostgreSQL</productname> operator catalog has several
entries for the prefix operator <literal>@</literal>, all of which implement
absolute-value operations for various numeric data types.  One of these
entries is for type <type>float8</type>, which is the preferred type in
the numeric category.  Therefore, <productname>PostgreSQL</productname>
will use that entry when faced with an <type>unknown</type> input:
<screen>
SELECT @ '-4.5' AS "abs";
 abs
-&minus;-&minus;-
 4.5
(1 row)
</screen>
Here the system has implicitly resolved the unknown-type literal as type
<type>float8</type> before applying the chosen operator.  We can verify that
<type>float8</type> and not some other type was used:
<screen>
SELECT @ '-4.5e500' AS "abs";

ERROR:  "-4.5e500" is out of range for type double precision
</screen>
</para>
____________________________________________________________________________-->
<para>
<productname>PostgreSQL</productname>操作符目录中有几个对于前缀操作符<literal>@</literal>的条目， 这些都现实了针对各种数字数据类型的绝对值操作。其中之一用于<type>float8</type>类型，它是在数字分类中的首选类型。 因此，<productname>PostgreSQL</productname>将在遇到一个<type>unknown</type>输入时使用它：
<screen>
SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)
</screen>
在这里，系统在应用所选操作符之前已经隐式地解决了将未知类型文字作为<type>float8</type>类型。 我们可以验证我们使用的是<type>float8</type>而不是别的类型：
<screen>
SELECT @ '-4.5e500' AS "abs";

ERROR:  "-4.5e500" is out of range for type double precision
</screen>
</para>

<!--==========================orignal english content==========================
<para>
On the other hand, the prefix operator <literal>~</literal> (bitwise negation)
is defined only for integer data types, not for <type>float8</type>.  So, if we
try a similar case with <literal>~</literal>, we get:
<screen>
SELECT ~ '20' AS "negation";

ERROR:  operator is not unique: ~ "unknown"
HINT:  Could not choose a best candidate operator. You might need to add
explicit type casts.
</screen>
This happens because the system cannot decide which of the several
possible <literal>~</literal> operators should be preferred.  We can help
it out with an explicit cast:
<screen>
SELECT ~ CAST('20' AS int8) AS "negation";

 negation
-&minus;-&minus;-&minus;-&minus;-&minus;
      -21
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
另一方面，前缀符<literal>~</literal>（按位取反）只为整数数据类型定义，而没有为<type>float8</type>定义。因此，如果我们尝试一个与使用<literal>~</literal>类似的情况，我们会得到：
<screen>
SELECT ~ '20' AS "negation";

ERROR:  operator is not unique: ~ "unknown"
HINT:  Could not choose a best candidate operator. You might need to add
explicit type casts.
</screen>
这是因为系统不能决定在几个可能的<literal>~</literal>符号中应该选择哪一个。我们可以用一个显式造型来帮助它：
<screen>
SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)
</screen>
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Array Inclusion Operator Type Resolution</title>
____________________________________________________________________________-->
<title>数组包含操作符类型决定</title>

<!--==========================orignal english content==========================
<para>
Here is another example of resolving an operator with one known and one
unknown input:
<screen>
SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-&minus;-&minus;-&minus;-&minus;-&minus;-
 t
(1 row)
</screen>
The <productname>PostgreSQL</productname> operator catalog has several
entries for the infix operator <literal>&lt;@</literal>, but the only two that
could possibly accept an integer array on the left-hand side are
array inclusion (<type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>)
and range inclusion (<type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>).
Since none of these polymorphic pseudo-types (see <xref
linkend="datatype-pseudo"/>) are considered preferred, the parser cannot
resolve the ambiguity on that basis.
However, <xref linkend="op-resol-last-unknown"/> tells
it to assume that the unknown-type literal is of the same type as the other
input, that is, integer array.  Now only one of the two operators can match,
so array inclusion is selected.  (Had range inclusion been selected, we would
have gotten an error, because the string does not have the right format to be
a range literal.)
</para>
____________________________________________________________________________-->
<para>
这里是另一个决定带有一个已知和一个未知输入的操作符的例子：
<screen>
SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)
</screen>
<productname>PostgreSQL</productname>操作符目录有一些条目用于中缀操作符<literal>&lt;@</literal>，但是仅有的两个可以在左手边接受一个整数数组的是数组包含（<type>anyarray</type> <literal>&lt;@</literal> <type>anyarray</type>）和范围包含（<type>anyelement</type> <literal>&lt;@</literal> <type>anyrange</type>）。因为这些多态伪类型（见<xref linkend="datatype-pseudo"/>）中没有一个被认为是首选的，解析器不能以此为基础来解决歧义。不过，<xref linkend="op-resol-last-unknown"/>告诉它假定位置类型的文字和其他输入的类型相同，即整数数组。现在这两个操作符中只有一个可以匹配，因此数组包含被选择（如果选择范围包含，我们将得到一个错误，因为该字符串没有成为一个范围文字的正确格式）。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Custom Operator on a Domain Type</title>
____________________________________________________________________________-->
<title>域类型上的自定义操作符</title>

<!--==========================orignal english content==========================
<para>
Users sometimes try to declare operators applying just to a domain type.
This is possible but is not nearly as useful as it might seem, because the
operator resolution rules are designed to select operators applying to the
domain's base type.  As an example consider
<screen>
CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';
</screen>
This query will not use the custom operator.  The parser will first see if
there is a <type>mytext</type> <literal>=</literal> <type>mytext</type> operator
(<xref linkend="op-resol-exact-unknown"/>), which there is not;
then it will consider the domain's base type <type>text</type>, and see if
there is a <type>text</type> <literal>=</literal> <type>text</type> operator
(<xref linkend="op-resol-exact-domain"/>), which there is;
so it resolves the <type>unknown</type>-type literal as <type>text</type> and
uses the <type>text</type> <literal>=</literal> <type>text</type> operator.
The only way to get the custom operator to be used is to explicitly cast
the literal:
<screen>
SELECT * FROM mytable WHERE val = text 'foo';
</screen>
so that the <type>mytext</type> <literal>=</literal> <type>text</type> operator is found
immediately according to the exact-match rule.  If the best-match rules
are reached, they actively discriminate against operators on domain types.
If they did not, such an operator would create too many ambiguous-operator
failures, because the casting rules always consider a domain as castable
to or from its base type, and so the domain operator would be considered
usable in all the same cases as a similarly-named operator on the base type.
</para>
____________________________________________________________________________-->
<para>
用户有时会尝试声明只适用于一种域类型的操作符。这是可能的，
但是远非它看起来那么有用，因为操作符解析规则被设计为选择
适用于域的基类型的操作符。考虑这个例子：
<screen>
CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';
</screen>
这个查询将不会使用自定义操作符。解析器将首先看看是否有一个
<type>mytext</type> <literal>=</literal> <type>mytext</type>操作符（
<xref linkend="op-resol-exact-unknown"/>），当然这里没有；
然后它将会考虑该域的基类型<type>text</type>，并且看看是否有一
个<type>text</type> <literal>=</literal> <type>text</type>操作符（
<xref linkend="op-resol-exact-domain"/>），这里也没有；因
此它会把<type>unknown</type>-类型文字解析为<type>text</type>
并使用<type>text</type> <literal>=</literal> <type>text</type>操作符。
让自定义操作符能被使用的唯一方法是显式地转换改文字：
<screen>
SELECT * FROM mytable WHERE val = text 'foo';
</screen>
这样根据准确匹配规则会立即找到
<type>mytext</type> <literal>=</literal> <type>text</type>操作符。如果
到达最佳匹配规则，它们会积极地排斥域类型上的操作符。如果它
们没有，这样一个操作符将创建太多歧义操作符失败，因为转换规
则总是认为一个域可以和它的基类型相互转换，并且因此该域操作
符在所有与该基类型上的一个类似命名的操作符相同的情况中都被
认为可用。
</para>
</example>

</sect1>

<sect1 id="typeconv-func">
<!--==========================orignal english content==========================
<title>Functions</title>
____________________________________________________________________________-->
<title>函数</title>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-func">
 <primary>function</primary>
 <secondary>type resolution in an invocation</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-func">
 <primary>函数</primary>
 <secondary>一次调用中的类型决定</secondary>
</indexterm>

<!--==========================orignal english content==========================
  <para>
   The specific function that is referenced by a function call
   is determined using the following procedure.
  </para>
____________________________________________________________________________-->
  <para>
   被一个函数调用引用的特定函数使用下面的过程来决定。
  </para>

<procedure>
<!--==========================orignal english content==========================
<title>Function Type Resolution</title>
____________________________________________________________________________-->
<title>函数类型决定</title>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Select the functions to be considered from the
<classname>pg_proc</classname> system catalog.  If a non-schema-qualified
function name was used, the functions
considered are those with the matching name and argument count that are
visible in the current search path (see <xref linkend="ddl-schemas-path"/>).
If a qualified function name was given, only functions in the specified
schema are considered.
</para>
____________________________________________________________________________-->
<para>
从<classname>pg_proc</classname>系统目录中选择要被考虑的函数。 如果使用一个非模式限定的函数名称，那么函数被认为是那些在当前搜索路径中可见并有匹配的名字和参数个数的函数（参见<xref linkend="ddl-schemas-path"/>）。如果给出一个被限定的函数名，那么只考虑指定模式中的函数。
</para>

<substeps>
<step performance="optional">
<!--==========================orignal english content==========================
<para>
If the search path finds multiple functions of identical argument types,
only the one appearing earliest in the path is considered.  Functions of
different argument types are considered on an equal footing regardless of
search path position.
</para>
____________________________________________________________________________-->
<para>
如果搜索路径发现多个参数类型相同的函数，那么只考虑最早在搜索路径中出现的那个。 不同参数类型的函数被平等对待，不受在搜索路径中位置的影响。
</para>
</step>
<step performance="optional">
<!--==========================orignal english content==========================
<para>
If a function is declared with a <literal>VARIADIC</literal> array parameter, and
the call does not use the <literal>VARIADIC</literal> keyword, then the function
is treated as if the array parameter were replaced by one or more occurrences
of its element type, as needed to match the call.  After such expansion the
function might have effective argument types identical to some non-variadic
function.  In that case the function appearing earlier in the search path is
used, or if the two functions are in the same schema, the non-variadic one is
preferred.
</para>
____________________________________________________________________________-->
<para>
如果使用一个<literal>VARIADIC</literal>数组参数声明一个函数，并且调用不使用关键字<literal>VARIADIC</literal>， 那么该函数就好像其数组参数被它的元素类型的一次或多次出现所替换，根据需要去匹配调用。 这样的扩展之后，函数可能会有和非可变函数相同的参数类型。在这种情况下，在搜索路径中出现比较早的函数将被使用，或者如果两个函数在相同的模式中时首选非可变的那一个。
</para>
<!--==========================orignal english content==========================
<para>
This creates a security hazard when calling, via qualified name
  <footnote id="func-qualified-security">
   <!-&minus; If you edit this, consider editing op-qualified-security. -&minus;>
   <para>
    The hazard does not arise with a non-schema-qualified name, because a
    search path containing schemas that permit untrusted users to create
    objects is not a <link linkend="ddl-schemas-patterns">secure schema usage
    pattern</link>.
   </para>
  </footnote>,
a variadic function found in a schema that permits untrusted users to create
objects.  A malicious user can take control and execute arbitrary SQL
functions as though you executed them.  Substitute a call bearing
the <literal>VARIADIC</literal> keyword, which bypasses this hazard.  Calls
populating <literal>VARIADIC "any"</literal> parameters often have no
equivalent formulation containing the <literal>VARIADIC</literal> keyword.  To
issue those calls safely, the function's schema must permit only trusted users
to create objects.
</para>
____________________________________________________________________________-->
<para>
在通过限定名称调用在一个允许不可信用户创建对象的方案中找到的可变函数时，会导致安全性危害
  <footnote id="func-qualified-security">
   <!-- If you edit this, consider editing op-qualified-security. -->
   <para>
    对非方案限定的名称，不会出现这种危害，因为包含允许不可信用户创建对象的方案的搜索路径不是一种<link linkend="ddl-schemas-patterns">安全的方案使用模式</link>。
   </para>
  </footnote>。
恶意用户可以拿到控制权并且执行任意SQL函数（就好像你在执行它们一样）。将涉及<literal>VARIADIC</literal>关键词的调用替换掉就可以绕过这种危害。涉及到<literal>VARIADIC "any"</literal>参数的调用通常没有等效的包含<literal>VARIADIC</literal>关键词的形式。为了安全地发出那些调用，函数的方案必须只允许可信用户创建对象。
</para>
</step>
<step performance="optional">
<!--==========================orignal english content==========================
<para>
Functions that have default values for parameters are considered to match any
call that omits zero or more of the defaultable parameter positions.  If more
than one such function matches a call, the one appearing earliest in the
search path is used.  If there are two or more such functions in the same
schema with identical parameter types in the non-defaulted positions (which is
possible if they have different sets of defaultable parameters), the system
will not be able to determine which to prefer, and so an <quote>ambiguous
function call</quote> error will result if no better match to the call can be
found.
</para>
____________________________________________________________________________-->
<para>
考虑使用有默认参数值的函数来匹配任何省略了零个或者多个可默认参数位置的调用。如果有超出一个的这种函数匹配一个调用，那么使用最早出现在搜索路径中的那个。如果同一个模式中在同一个非默认位置上有两个或者更多这样的函数（如果它们有 不同的默认参数设置，这是可能的），系统将不能确定去选择哪一个，并且如果不能找到该调用更好的匹配，将会导致一个<quote>有歧义的函数调用</quote> 错误。
</para>
<!--==========================orignal english content==========================
<para>
This creates an availability hazard when calling, via qualified
name<footnoteref linkend="func-qualified-security"/>, any function found in a
schema that permits untrusted users to create objects.  A malicious user can
create a function with the name of an existing function, replicating that
function's parameters and appending novel parameters having default values.
This precludes new calls to the original function.  To forestall this hazard,
place functions in schemas that permit only trusted users to create objects.
</para>
____________________________________________________________________________-->
<para>
在通过限定名称<footnoteref linkend="func-qualified-security"/>调用在一个允许不可信用户创建对象的方案中找到的任意函数时，会导致可用性危害。恶意用户可以用一个已有函数的名称创建一个函数，复制该函数的参数并且追加新的具有默认值的参数。这会妨碍对原始函数的新调用。为了防止这种危害，应将函数放在仅允许可信用户创建对象的方案中。
</para>
</step>
</substeps>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Check for a function accepting exactly the input argument types.
If one exists (there can be only one exact match in the set of
functions considered), use it.  Lack of an exact match creates a security
hazard when calling, via qualified
name<footnoteref linkend="func-qualified-security"/>, a function found in a
schema that permits untrusted users to create objects.  In such situations,
cast arguments to force an exact match.  (Cases involving <type>unknown</type>
will never find a match at this step.)
</para>
____________________________________________________________________________-->
<para>
检查一个函数正好接受输入参数类型。如果存在一个（在所考虑的一组函数中只能有一个准确匹配），则使用之。在通过限定名称<footnoteref linkend="func-qualified-security"/>调用在一个允许不可信用户创建对象的方案中找到的函数时，精确匹配的缺失会导致安全性危害。在这样的情况下，应该造型参数以便强制一次精确匹配（在该步骤中，涉及<type>unknown</type>的情况将永远找不到一个匹配）。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
If no exact match is found, see if the function call appears
to be a special type conversion request.  This happens if the function call
has just one argument and the function name is the same as the (internal)
name of some data type.  Furthermore, the function argument must be either
an unknown-type literal, or a type that is binary-coercible to the named
data type, or a type that could be converted to the named data type by
applying that type's I/O functions (that is, the conversion is either to or
from one of the standard string types).  When these conditions are met,
the function call is treated as a form of <literal>CAST</literal> specification.
  <footnote>
   <para>
    The reason for this step is to support function-style cast specifications
    in cases where there is not an actual cast function.  If there is a cast
    function, it is conventionally named after its output type, and so there
    is no need to have a special case.  See
    <xref linkend="sql-createcast"/>
    for additional commentary.
   </para>
  </footnote>
</para>
____________________________________________________________________________-->
<para>
如果没有发现准确匹配，那么查看函数调用是否作为一个特定的类型转换请求出现。 如果函数调用仅有一个参数并且函数名和一些数据类型的（内部）名称相同，那么该情况将会发生。 并且，该函数参数必须是一个未知类型的文字，或者是一个可以被二进制强制转换到命名数据类型的类型， 或者是一个可以通过应用其I/O函数被转换为命名数据类型的类型（也就是，转换是转到标准字符串类型或者从标准字符串类型转来）。当满足这些条件的时候，函数调用被当做<literal>CAST</literal>声明的一种形式来对待。
  <footnote>
   <para>
    这一步的原因是在没有一个实际的造型函数的情况下支持函数风格的造型声明。如果有一个造型函数，它被按惯例以其输出类型命名，并且不需要有特殊情况。更多信息请见<xref linkend="sql-createcast"/>。
   </para>
  </footnote>
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Look for the best match.
</para>
____________________________________________________________________________-->
<para>
查找最佳匹配。
</para>
<substeps>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Discard candidate functions for which the input types do not match
and cannot be converted (using an implicit conversion) to match.
<type>unknown</type> literals are
assumed to be convertible to anything for this purpose.  If only one
candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
如果候选函数的输入类型不匹配并且不能通过转换（使用一个隐式转换）达到匹配，则丢弃它。为了这个目的，<type>unknown</type>文字被假定可被转换成任何东西。如果仅有一个候选项，则使用之；否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
If any input argument is of a domain type, treat it as being of the
domain's base type for all subsequent steps.  This ensures that domains
act like their base types for purposes of ambiguous-function resolution.
</para>
____________________________________________________________________________-->
<para>
如果任何输入参数是一种域类型，在所有后续步骤中都把它当做
该域的基类型。这确保在做有歧义的操作符解析时，域的举止像它们
的基类型。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Run through all candidates and keep those with the most exact matches
on input types.  Keep all candidates if none have exact matches.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
遍历所有候选函数并保留那些最匹配输入类型的。如果没有准确匹配，则保留所有候选项。 如果仅有一个候选项，则使用之；否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
Run through all candidates and keep those that accept preferred types (of the
input data type's type category) at the most positions where type conversion
will be required.
Keep all candidates if none accept preferred types.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
遍历所有候选函数并保留那些在最多要求类型转换的位置上接受首选类型（属于输入数据类型的类型分类）的候选项。如果没有接受首选类型的候选项，则保留所有候选项。如果仅有一个候选项，则使用之；否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
If any input arguments are <type>unknown</type>, check the type categories
accepted
at those argument positions by the remaining candidates.  At each position,
select the <type>string</type> category if any candidate accepts that category.
(This bias towards string
is appropriate since an unknown-type literal looks like a string.)
Otherwise, if all the remaining candidates accept the same type category,
select that category; otherwise fail because
the correct choice cannot be deduced without more clues.
Now discard candidates that do not accept the selected type category.
Furthermore, if any candidate accepts a preferred type in that category,
discard candidates that accept non-preferred types for that argument.
Keep all candidates if none survive these tests.
If only one candidate remains, use it; else continue to the next step.
</para>
____________________________________________________________________________-->
<para>
如果任何输入参数是<type>unknown</type>，那么检查那些被剩余候选项在那些参数位置上接受的类型分类。在每一个位置上，如果任何候选项接受该分类则选择<type>string</type>分类 （这个偏向于字符串是恰当的，因为一个未知类型文字看起来像字符）。 否则，如果所有剩余的候选项接受相同的类型分类，那么选择那个分类； 否则将失败，因为缺乏更多线索来推断出正确的选择。现在，丢弃不接受被选中类型分类的候选项。此外，如果任何候选项接受那个分类中的一个首选类型，则丢弃对该参数接受非首选类型的候选项。如果没有候选项能通过这些测试，则保留所有候选项。如果只剩下一个候选项，则使用之；否则继续下一步。
</para>
</step>
<step performance="required">
<!--==========================orignal english content==========================
<para>
If there are both <type>unknown</type> and known-type arguments, and all
the known-type arguments have the same type, assume that the
<type>unknown</type> arguments are also of that type, and check which
candidates can accept that type at the <type>unknown</type>-argument
positions.  If exactly one candidate passes this test, use it.
Otherwise, fail.
</para>
____________________________________________________________________________-->
<para>
如果既有<type>unknown</type>参数也有已知类型的参数，并且所有已知类型参数具有相同的类型，则假定该<type>unknown</type>参数也是那种类型的，并且检查哪些候选函数可以在该<type>unknown</type>参数的位置上接受那个类型。如果正好有一个候选者通过了这个测试，则使用之；否则失败。
</para>
</step>
</substeps>
</step>
</procedure>

<!--==========================orignal english content==========================
<para>
Note that the <quote>best match</quote> rules are identical for operator and
function type resolution.
Some examples follow.
</para>
____________________________________________________________________________-->
<para>
注意，对于操作符和函数类型决定来说<quote>最优匹配</quote>规则是完全相同的。下面是一些例子。
</para>

<example>
<!--==========================orignal english content==========================
<title>Rounding Function Argument Type Resolution</title>
____________________________________________________________________________-->
<title>圆整函数参数类型决定</title>

<!--==========================orignal english content==========================
<para>
There is only one <function>round</function> function that takes two
arguments; it takes a first argument of type <type>numeric</type> and
a second argument of type <type>integer</type>.
So the following query automatically converts
the first argument of type <type>integer</type> to
<type>numeric</type>:

<screen>
SELECT round(4, 4);

 round
-&minus;-&minus;-&minus;-&minus;
 4.0000
(1 row)
</screen>

That query is actually transformed by the parser to:
<screen>
SELECT round(CAST (4 AS numeric), 4);
</screen>
</para>
____________________________________________________________________________-->
<para>
只有一个带有两个参数的<function>圆整</function>函数； 它采用第一个参数类型为<type>numeric</type>和第二个参数类型为<type>integer</type>。这样下面的查询自动将第一个类型为<type>integer</type>参数转换为<type>numeric</type>：

<screen>
SELECT round(4, 4);

 round
--------
 4.0000
(1 row)
</screen>

该查询实际上被解析器转换为：
<screen>
SELECT round(CAST (4 AS numeric), 4);
</screen>
</para>

<!--==========================orignal english content==========================
<para>
Since numeric constants with decimal points are initially assigned the
type <type>numeric</type>, the following query will require no type
conversion and therefore might be slightly more efficient:
<screen>
SELECT round(4.0, 4);
</screen>
</para>
____________________________________________________________________________-->
<para>
因为包含小数点的数字常数初始会被分配类型<type>numeric</type>，下面的查询将不需要类型转换并因此可能会稍稍高效一些：<screen>
SELECT round(4.0, 4);
</screen>
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Variadic Function Resolution</title>
____________________________________________________________________________-->
<title>可变函数决定</title>

<!--==========================orignal english content==========================
<para>
<screen>
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION
</screen>

This function accepts, but does not require, the VARIADIC keyword.  It
tolerates both integer and numeric arguments:

<screen>
SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
                1 |                1 |                1
(1 row)
</screen>

However, the first and second calls will prefer more-specific functions, if
available:

<screen>
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
                3 |                2 |                1
(1 row)
</screen>

Given the default configuration and only the first function existing, the
first and second calls are insecure.  Any user could intercept them by
creating the second or third function.  By matching the argument type exactly
and using the <literal>VARIADIC</literal> keyword, the third call is secure.
</para>
____________________________________________________________________________-->
<para>
<screen>
CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION
</screen>

这个函数接受（但不要求）VARIADIC关键词。它能同时容忍integer以numeric参数：

<screen>
SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                1 |                1 |                1
(1 row)
</screen>

不过，如果可以，第一个和第二个调用将更喜欢更明确的函数：

<screen>
CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                3 |                2 |                1
(1 row)
</screen>

如果给定默认的配置并且只有第一个函数存在，则第一个和第二个调用是不安全的。任何用户都可以通过创建第二个或者第三个函数来截断它们。通过精确匹配参数类型并且使用<literal>VARIADIC</literal>关键词，第三个调用是安全的。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Substring Function Type Resolution</title>
____________________________________________________________________________-->
<title>子串函数类型决定</title>

<!--==========================orignal english content==========================
<para>
There are several <function>substr</function> functions, one of which
takes types <type>text</type> and <type>integer</type>.  If called
with a string constant of unspecified type, the system chooses the
candidate function that accepts an argument of the preferred category
<literal>string</literal> (namely of type <type>text</type>).

<screen>
SELECT substr('1234', 3);

 substr
-&minus;-&minus;-&minus;-&minus;
     34
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
有几个<function>substr</function>函数，其中一个用于<type>text</type>和<type>integer</type>类型。如果使用一个未指定类型的字符常量调用，那么系统选择接受一个首选分类<literal>string</literal>（也就是<type>text</type>类型）的参数的候选函数。

<screen>
SELECT substr('1234', 3);

 substr
--------
     34
(1 row)
</screen>
</para>

<!--==========================orignal english content==========================
<para>
If the string is declared to be of type <type>varchar</type>, as might be the case
if it comes from a table, then the parser will try to convert it to become <type>text</type>:
<screen>
SELECT substr(varchar '1234', 3);

 substr
-&minus;-&minus;-&minus;-&minus;
     34
(1 row)
</screen>

This is transformed by the parser to effectively become:
<screen>
SELECT substr(CAST (varchar '1234' AS text), 3);
</screen>
</para>
____________________________________________________________________________-->
<para>
如果字符串被声明为类型<type>varchar</type>（如果它来自于一个表就会这样），那么解析器将尝试转换它为<type>text</type>：
<screen>
SELECT substr(varchar '1234', 3);

 substr
--------
     34
(1 row)
</screen>

解析器所作的转换：
<screen>
SELECT substr(CAST (varchar '1234' AS text), 3);
</screen>
</para>
<!--==========================orignal english content==========================
<para>
<note>
<para>
The parser learns from the <structname>pg_cast</structname> catalog that
<type>text</type> and <type>varchar</type>
are binary-compatible, meaning that one can be passed to a function that
accepts the other without doing any physical conversion.  Therefore, no
type conversion call is really inserted in this case.
</para>
</note>
</para>
____________________________________________________________________________-->
<para>
<note>
<para>
解析器从<structname>pg_cast</structname>目录中知道<type>text</type>和<type>varchar</type>是二进制可兼容的， 意思是其中一个可以被传递给接受另一种类型的函数而不需要做任何物理转换。因此，在这种情况下不会真正使用类型转换调用。
</para>
</note>
</para>

<!--==========================orignal english content==========================
<para>
And, if the function is called with an argument of type <type>integer</type>,
the parser will try to convert that to <type>text</type>:
<screen>
SELECT substr(1234, 3);
ERROR:  function substr(integer, integer) does not exist
HINT:  No function matches the given name and argument types. You might need
to add explicit type casts.
</screen>

This does not work because <type>integer</type> does not have an implicit cast
to <type>text</type>.  An explicit cast will work, however:
<screen>
SELECT substr(CAST (1234 AS text), 3);

 substr
-&minus;-&minus;-&minus;-&minus;
     34
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
并且，如果该函数使用一个<type>integer</type>类型的参数调用，那么解析器将尝试将它转换为<type>text</type>：
<screen>
SELECT substr(1234, 3);
ERROR:  function substr(integer, integer) does not exist
HINT:  No function matches the given name and argument types. You might need
to add explicit type casts.
</screen>

由于<type>integer</type>类型没有到<type>text</type>的一个隐式造型，这将不会工作。但是一次显式造型则可以工作：
<screen>
SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)
</screen>
</para>
</example>

</sect1>

<sect1 id="typeconv-query">
<!--==========================orignal english content==========================
<title>Value Storage</title>
____________________________________________________________________________-->
<title>值存储</title>

<!--==========================orignal english content==========================
  <para>
   Values to be inserted into a table are converted to the destination
   column's data type according to the
   following steps.
  </para>
____________________________________________________________________________-->
  <para>
   将被插入到一个表的值会按照下列步骤被转换到目标列的数据类型。
  </para>

<procedure>
<!--==========================orignal english content==========================
<title>Value Storage Type Conversion</title>
____________________________________________________________________________-->
<title>值存储类型转换</title>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Check for an exact match with the target.
</para>
____________________________________________________________________________-->
<para>
检查一个与目标的准确匹配。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Otherwise, try to convert the expression to the target type.  This is possible
if an <firstterm>assignment cast</firstterm> between the two types is registered in the
<structname>pg_cast</structname> catalog (see <xref linkend="sql-createcast"/>).
Alternatively, if the expression is an unknown-type literal, the contents of
the literal string will be fed to the input conversion routine for the target
type.
</para>
____________________________________________________________________________-->
<para>
否则，尝试转换表达式为目标类型。如果在两种类型之间的一个
<firstterm>赋值造型</firstterm>已经被注册在<structname>pg_cast</structname>
目录（见<xref linkend="sql-createcast"/>）中，
这是可能的。或者，如果该表达式是一个未知类型的文字，
则该文字串的内容将被提供给目标类型的输入转换例程。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Check to see if there is a sizing cast for the target type.  A sizing
cast is a cast from that type to itself.  If one is found in the
<structname>pg_cast</structname> catalog, apply it to the expression before storing
into the destination column.  The implementation function for such a cast
always takes an extra parameter of type <type>integer</type>, which receives
the destination column's <structfield>atttypmod</structfield> value (typically its
declared length, although the interpretation of <structfield>atttypmod</structfield>
varies for different data types), and it may take a third <type>boolean</type>
parameter that says whether the cast is explicit or implicit.  The cast
function
is responsible for applying any length-dependent semantics such as size
checking or truncation.
</para>
____________________________________________________________________________-->
<para>
检查是否有一个用于目标类型的尺寸调整造型。尺寸调整造型是一个从该类型到其自身的造型。 如果在<structname>pg_cast</structname>目录中找到一个，那么把表达式存储到目标列中之前把它应用到表达式。这样一个造型的实现函数总是采用一个额外的<type>integer</type>类型的参数，它接收目标列的<structfield>atttypmod</structfield>值（通常是它被声明的长度，尽管对于不同数据类型<structfield>atttypmod</structfield>有不同的解释），并且它可能采用第三个<type>boolean</type>参数来说明造型是显式的还是隐式的。该造型函数负责应用任何长度相关的语义，例如尺寸检查或截断。
</para>
</step>

</procedure>

<example>
<!--==========================orignal english content==========================
<title><type>character</type> Storage Type Conversion</title>
____________________________________________________________________________-->
<title><type>character</type>存储类型转换</title>

<!--==========================orignal english content==========================
<para>
For a target column declared as <type>character(20)</type> the following
statement shows that the stored value is sized correctly:

<screen>
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 abcdef               |           20
(1 row)
</screen>
</para>
____________________________________________________________________________-->
<para>
对于一个声明为<type>character(20)</type>的目标列，下面的语句展示了被存储的值如何被正确地调整尺寸：

<screen>
CREATE TABLE vv (v character(20));
INSERT INTO vv SELECT 'abc' || 'def';
SELECT v, octet_length(v) FROM vv;

          v           | octet_length
----------------------+--------------
 abcdef               |           20
(1 row)
</screen>
</para>

<!--==========================orignal english content==========================
<para>
What has really happened here is that the two unknown literals are resolved
to <type>text</type> by default, allowing the <literal>||</literal> operator
to be resolved as <type>text</type> concatenation.  Then the <type>text</type>
result of the operator is converted to <type>bpchar</type> (<quote>blank-padded
char</quote>, the internal name of the <type>character</type> data type) to match the target
column type.  (Since the conversion from <type>text</type> to
<type>bpchar</type> is binary-coercible, this conversion does
not insert any real function call.)  Finally, the sizing function
<literal>bpchar(bpchar, integer, boolean)</literal> is found in the system catalog
and applied to the operator's result and the stored column length.  This
type-specific function performs the required length check and addition of
padding spaces.
</para>
____________________________________________________________________________-->
<para>
实际发生的事情是两个未知文字被默认决定为<type>text</type>，允许<literal>||</literal>操作符被决定为<type>text</type>连接。 然后操作符的<type>text</type>结果被转换成<type>bpchar</type>（<quote>空白填充字符</quote>，<type>character</type>数据类型的内部名称）来匹配目标列类型（由于从<type>text</type>到<type>bpchar</type>的转换是二进制强制的，这个转换不会插入任何实际的函数调用）。最后，尺寸调整函数<literal>bpchar(bpchar, integer, boolean)</literal>被从系统目录中找到并应用到操作符的结果和存储的列长度上。这个类型相关的函数执行必要的长度检查并增加填充的空间。
</para>
</example>
</sect1>

<sect1 id="typeconv-union-case">
<!--==========================orignal english content==========================
<title><literal>UNION</literal>, <literal>CASE</literal>, and Related Constructs</title>
____________________________________________________________________________-->
<title><literal>UNION</literal>、<literal>CASE</literal>和相关结构</title>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>UNION</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>UNION</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>CASE</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>CASE</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>ARRAY</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>ARRAY</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>VALUES</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>VALUES</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>GREATEST</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>GREATEST</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-union-case">
 <primary>LEAST</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-union-case">
 <primary>LEAST</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
SQL <literal>UNION</literal> constructs must match up possibly dissimilar
types to become a single result set.  The resolution algorithm is
applied separately to each output column of a union query.  The
<literal>INTERSECT</literal> and <literal>EXCEPT</literal> constructs resolve
dissimilar types in the same way as <literal>UNION</literal>.  The
<literal>CASE</literal>, <literal>ARRAY</literal>, <literal>VALUES</literal>,
<function>GREATEST</function> and <function>LEAST</function> constructs use the identical
algorithm to match up their component expressions and select a result
data type.
</para>
____________________________________________________________________________-->
<para>
SQL <literal>UNION</literal>结构必须使可能不相似的类型匹配成为一个单一的结果集。该决定算法被独立地应用到一个联合查询的每个输出列。<literal>INTERSECT</literal>和<literal>EXCEPT</literal>采用和<literal>UNION</literal>相同的方法来决定不相似的类型。<literal>CASE</literal>、<literal>ARRAY</literal>、<literal>VALUES</literal>、<function>GREATEST</function>和<function>LEAST</function>结构使用相同的算法来使它们的组成表达式匹配并选择一种结果数据类型。
</para>

<procedure>
<!--==========================orignal english content==========================
<title>Type Resolution for <literal>UNION</literal>, <literal>CASE</literal>,
and Related Constructs</title>
____________________________________________________________________________-->
<title><literal>UNION</literal>、<literal>CASE</literal>和相关结构的类型决定</title>

<step performance="required">
<!--==========================orignal english content==========================
<para>
If all inputs are of the same type, and it is not <type>unknown</type>,
resolve as that type.
</para>
____________________________________________________________________________-->
<para>
如果所有的输入为相同类型，并且不是<type>unknown</type>，那么就决定是该类型。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
If any input is of a domain type, treat it as being of the
domain's base type for all subsequent steps.
  <footnote>
   <para>
    Somewhat like the treatment of domain inputs for operators and
    functions, this behavior allows a domain type to be preserved through
    a <literal>UNION</literal> or similar construct, so long as the user is
    careful to ensure that all inputs are implicitly or explicitly of that
    exact type.  Otherwise the domain's base type will be preferred.
   </para>
  </footnote>
</para>
____________________________________________________________________________-->
<para>
如果任何输入是一种域类型，在所有后续步骤中都把它当做
该域的基类型。
  <footnote>
   <para>
    多少有些类似于对待用于操作符和函数的域输入的方式，这种行为允许
    一种域类型能通过一个<literal>UNION</literal>或相似的结构保留下来，
    只要用户小心地确保所有的输入都是（显式地或隐式地）准确类型。否
    则会优先选择该域的基类型。
   </para>
  </footnote>
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
If all inputs are of type <type>unknown</type>, resolve as type
<type>text</type> (the preferred type of the string category).
Otherwise, <type>unknown</type> inputs are ignored for the purposes
of the remaining rules.
</para>
____________________________________________________________________________-->
<para>
如果所有的输入为<type>unknown</type>类型，则决定为<type>text</type>（字符串分类的首选类型）类型。否则，为了剩余规则，<type>unknown</type>输入会被忽略。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
If the non-unknown inputs are not all of the same type category, fail.
</para>
____________________________________________________________________________-->
<para>
如果非未知输入不全是相同的类型分类，则失败。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Choose the first non-unknown input type which is a preferred type in
that category, if there is one.
</para>
____________________________________________________________________________-->
<para>
如果有的话，选择第一个在其分类中作为首选类型的非未知输入类型。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Otherwise, choose the last non-unknown input type that allows all the
preceding non-unknown inputs to be implicitly converted to it.  (There
always is such a type, since at least the first type in the list must
satisfy this condition.)
</para>
____________________________________________________________________________-->
<para>
否则，选择最后的非未知输入类型，它允许所有在前面的非未知输入被隐式地转换为它（总有这样的一种类型，因为至少在列表中的第一个类型必须满足这个条件）。
</para>
</step>

<step performance="required">
<!--==========================orignal english content==========================
<para>
Convert all inputs to the selected type.  Fail if there is not a
conversion from a given input to the selected type.
</para>
____________________________________________________________________________-->
<para>
转换所有的输入为选定的类型。如果没有一个从给定输入到选定类型的转换将会失败。
</para>
</step>
</procedure>

<!--==========================orignal english content==========================
<para>
Some examples follow.
</para>
____________________________________________________________________________-->
<para>
下面是一些例子。
</para>

<example>
<!--==========================orignal english content==========================
<title>Type Resolution with Underspecified Types in a Union</title>
____________________________________________________________________________-->
<title>联合中未指定类型的类型决定</title>

<!--==========================orignal english content==========================
<para>
<screen>
SELECT text 'a' AS "text" UNION SELECT 'b';

 text
-&minus;-&minus;-&minus;
 a
 b
(2 rows)
</screen>
Here, the unknown-type literal <literal>'b'</literal> will be resolved to type <type>text</type>.
</para>
____________________________________________________________________________-->
<para>
<screen>
SELECT text 'a' AS "text" UNION SELECT 'b';

 text
------
 a
 b
(2 rows)
</screen>
这里，未知类型文字<literal>'b'</literal>将被决定为类型<type>text</type>。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Type Resolution in a Simple Union</title>
____________________________________________________________________________-->
<title>简单联合中的类型决定</title>

<!--==========================orignal english content==========================
<para>
<screen>
SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
-&minus;-&minus;-&minus;-&minus;-
       1
     1.2
(2 rows)
</screen>
The literal <literal>1.2</literal> is of type <type>numeric</type>,
and the <type>integer</type> value <literal>1</literal> can be cast implicitly to
<type>numeric</type>, so that type is used.
</para>
____________________________________________________________________________-->
<para>
<screen>
SELECT 1.2 AS "numeric" UNION SELECT 1;

 numeric
---------
       1
     1.2
(2 rows)
</screen>
文字<literal>1.2</literal>是<type>numeric</type>类型，且<type>integer</type>值<literal>1</literal>可以被隐式地造型为<type>numeric</type>，因此使用<type>numeric</type>类型。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Type Resolution in a Transposed Union</title>
____________________________________________________________________________-->
<title>可换位联合中的类型决定</title>

<!--==========================orignal english content==========================
<para>
<screen>
SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
-&minus;-&minus;-&minus;
    1
  2.2
(2 rows)
</screen>
Here, since type <type>real</type> cannot be implicitly cast to <type>integer</type>,
but <type>integer</type> can be implicitly cast to <type>real</type>, the union
result type is resolved as <type>real</type>.
</para>
____________________________________________________________________________-->
<para>
<screen>
SELECT 1 AS "real" UNION SELECT CAST('2.2' AS REAL);

 real
------
    1
  2.2
(2 rows)
</screen>
这里，由于类型<type>real</type>被能被隐式地造型为<type>integer</type>，而<type>integer</type>可以被隐式地造型为<type>real</type>，联合结果类型被决定为<type>real</type>。
</para>
</example>

<example>
<!--==========================orignal english content==========================
<title>Type Resolution in a Nested Union</title>
____________________________________________________________________________-->
<title>嵌套合并中的类型决定</title>

<!--==========================orignal english content==========================
<para>
<screen>
SELECT NULL UNION SELECT NULL UNION SELECT 1;

ERROR:  UNION types text and integer cannot be matched
</screen>
This failure occurs because <productname>PostgreSQL</productname> treats
multiple <literal>UNION</literal>s as a nest of pairwise operations;
that is, this input is the same as
<screen>
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
</screen>
The inner <literal>UNION</literal> is resolved as emitting
type <type>text</type>, according to the rules given above.  Then the
outer <literal>UNION</literal> has inputs of types <type>text</type>
and <type>integer</type>, leading to the observed error.  The problem
can be fixed by ensuring that the leftmost <literal>UNION</literal>
has at least one input of the desired result type.
</para>
____________________________________________________________________________-->
<para>
<screen>
SELECT NULL UNION SELECT NULL UNION SELECT 1;

ERROR:  UNION types text and integer cannot be matched
</screen>
这个失败发生的原因是<productname>PostgreSQL</productname>把多个<literal>UNION</literal>当作是成对操作的嵌套，也就是说上面的输入等同于：
<screen>
(SELECT NULL UNION SELECT NULL) UNION SELECT 1;
</screen>
根据上面给定的规则，内层的<literal>UNION</literal>被确定为类型<type>text</type>。然后外层的<literal>UNION</literal>的输入是类型<type>text</type>和<type>integer</type>，这就导致了上面看到的错误。通过确保最左边的<literal>UNION</literal>至少有一个输入类型为想要的结果类型，就可以修正这个问题。
</para>

<!--==========================orignal english content==========================
<para>
<literal>INTERSECT</literal> and <literal>EXCEPT</literal> operations are
likewise resolved pairwise.  However, the other constructs described in this
section consider all of their inputs in one resolution step.
</para>
____________________________________________________________________________-->
<para>
<literal>INTERSECT</literal>和<literal>EXCEPT</literal>操作也被当作成对操作。不过，这一节中描述的其他结构会在一个决定步骤中考虑所有的输入。
</para>
</example>
</sect1>

<sect1 id="typeconv-select">
<!--==========================orignal english content==========================
<title><literal>SELECT</literal> Output Columns</title>
____________________________________________________________________________-->
<title><literal>SELECT</literal>的输出列</title>

<!--==========================orignal english content==========================
<indexterm zone="typeconv-select">
 <primary>SELECT</primary>
 <secondary>determination of result type</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="typeconv-select">
 <primary>SELECT</primary>
 <secondary>determination of result type</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
The rules given in the preceding sections will result in assignment
of non-<type>unknown</type> data types to all expressions in a SQL query,
except for unspecified-type literals that appear as simple output
columns of a <command>SELECT</command> command.  For example, in

<screen>
SELECT 'Hello World';
</screen>

there is nothing to identify what type the string literal should be
taken as.  In this situation <productname>PostgreSQL</productname> will fall back
to resolving the literal's type as <type>text</type>.
</para>
____________________________________________________________________________-->
<para>
前面的小节中给出的规则将会导致对SQL查询中的所有表达式分配非<type>unknown</type>数据类型，不过作为<command>SELECT</command>命令的简单输出列出现的未指定类型的文本除外。例如，在

<screen>
SELECT 'Hello World';
</screen>

中没有标识该字符串应该取何种类型。在这种情况下，<productname>PostgreSQL</productname>将会退而求其次将其类型决定为<type>text</type>。
</para>

<!--==========================orignal english content==========================
<para>
When the <command>SELECT</command> is one arm of a <literal>UNION</literal>
(or <literal>INTERSECT</literal> or <literal>EXCEPT</literal>) construct, or when it
appears within <command>INSERT ... SELECT</command>, this rule is not applied
since rules given in preceding sections take precedence.  The type of an
unspecified-type literal can be taken from the other <literal>UNION</literal> arm
in the first case, or from the destination column in the second case.
</para>
____________________________________________________________________________-->
<para>
当<command>SELECT</command>处于<literal>UNION</literal>（或者<literal>INTERSECT</literal>，或者<literal>EXCEPT</literal>）结构的一边或者出现在<command>INSERT ... SELECT</command>中时，这条规则就不适用了，因为在前面小节中给出的规则会优先。在第一种情况下未指定类型文本的类型将从<literal>UNION</literal>的另一边取得，而在第二种情况下未指定类型文本的类型将从目标列取得。
</para>

<!--==========================orignal english content==========================
<para>
<literal>RETURNING</literal> lists are treated the same as <command>SELECT</command>
output lists for this purpose.
</para>
____________________________________________________________________________-->
<para>
出于这样的目的，<literal>RETURNING</literal>列表采用和<command>SELECT</command>输出列表同样的方式对待。
</para>

<note>
<!--==========================orignal english content==========================
 <para>
  Prior to <productname>PostgreSQL</productname> 10, this rule did not exist, and
  unspecified-type literals in a <command>SELECT</command> output list were
  left as type <type>unknown</type>.  That had assorted bad consequences,
  so it's been changed.
 </para>
____________________________________________________________________________-->
 <para>
  在<productname>PostgreSQL</productname> 10之前，这条规则还不存在，<command>SELECT</command>输出列表中未指定类型的文本的类型会被留成<type>unknown</type>。这样做会导致各种不好的后果，因此新版本中做出了改变。
 </para>
</note>

</sect1>
</chapter>
