<!-- doc/src/sgml/indexam.sgml -->

<chapter id="indexam">
<!--==========================orignal english content==========================
 <title>Index Access Method Interface Definition</title>
____________________________________________________________________________-->
 <title>索引访问方法接口定义</title>

<!--==========================orignal english content==========================
  <para>
   This chapter defines the interface between the core
   <productname>PostgreSQL</productname> system and <firstterm>index access
   methods</firstterm>, which manage individual index types.  The core system
   knows nothing about indexes beyond what is specified here, so it is
   possible to develop entirely new index types by writing add-on code.
  </para>
____________________________________________________________________________-->
  <para>
   本章定义核心<productname>PostgreSQL</productname>系统和管理个别索引类型的<firstterm>索引访问方法</firstterm>之间的接口。除 了在这里指定的内容之外，核心系统对索引一无所知，因此可以通过编写附加代码来开发全新的索引类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   All indexes in <productname>PostgreSQL</productname> are what are known
   technically as <firstterm>secondary indexes</firstterm>; that is, the index is
   physically separate from the table file that it describes.  Each index
   is stored as its own physical <firstterm>relation</firstterm> and so is described
   by an entry in the <structname>pg_class</structname> catalog.  The contents of an
   index are entirely under the control of its index access method.  In
   practice, all index access methods divide indexes into standard-size
   pages so that they can use the regular storage manager and buffer manager
   to access the index contents.  (All the existing index access methods
   furthermore use the standard page layout described in <xref
   linkend="storage-page-layout"/>, and most use the same format for index
   tuple headers; but these decisions are not forced on an access method.)
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中所有的索引在技术上都叫做<firstterm>二级索引</firstterm>。也就是说，索引在物理上与它描述的表文件分离。每个索引被存储为它自己的物理<firstterm>关系</firstterm>并且被<structname>pg_class</structname>目录中的一个项所描述。一个索引的内容完全受到其索引访问方法控制。实际上，所有索引访问方法都把索引划分成标准大小的页面， 这样它们就可以使用常规的存储管理器和缓冲区管理器来访问索引内容（所有现有的索引访问方法还使用<xref linkend="storage-page-layout"/>中描述的标准页面布局，并且大部分都使用相同的索引元组头部格式；但是这些决定都不是强制在访问方法上的）。
  </para>

<!--==========================orignal english content==========================
  <para>
   An index is effectively a mapping from some data key values to
   <firstterm>tuple identifiers</firstterm>, or <acronym>TIDs</acronym>, of row versions
   (tuples) in the index's parent table.  A TID consists of a
   block number and an item number within that block (see <xref
   linkend="storage-page-layout"/>).  This is sufficient
   information to fetch a particular row version from the table.
   Indexes are not directly aware that under MVCC, there might be multiple
   extant versions of the same logical row; to an index, each tuple is
   an independent object that needs its own index entry.  Thus, an
   update of a row always creates all-new index entries for the row, even if
   the key values did not change.  (HOT tuples are an exception to this
   statement; but indexes do not deal with those, either.)  Index entries for
   dead tuples are reclaimed (by vacuuming) when the dead tuples themselves
   are reclaimed.
  </para>
____________________________________________________________________________-->
  <para>
   索引实际上是一些数据键值与索引父表中行版本（元组）的<firstterm>元组标识符</firstterm>或<acronym>TIDs</acronym>之间的映射。一个 TID 由一个块号和一个块内的项编号组成（见<xref linkend="storage-page-layout"/>）。 这对于从表中取一个特定行就足够了。索引并不直接知道在 MVCC下，同一个逻辑行可能有多个现存的版本；对于索引而言，每个 行都是一个独立的对象，都需要自己的索引项。因此，对一行的更新总是为该行创建全新的索引项，即使键值没有改变（HOT 元组对这段陈述来说是个异常，但是索引也不会处理这些）。死亡元组的索引项将在随着死亡元组的回收而被回收（通过清理）。
  </para>

 <sect1 id="index-api">
<!--==========================orignal english content==========================
  <title>Basic API Structure for Indexes</title>
____________________________________________________________________________-->
  <title>索引的基本 API 结构</title>

<!--==========================orignal english content==========================
  <para>
   Each index access method is described by a row in the
   <link linkend="catalog-pg-am"><structname>pg_am</structname></link>
   system catalog.  The <structname>pg_am</structname> entry
   specifies a name and a <firstterm>handler function</firstterm> for the access
   method.  These entries can be created and deleted using the
   <xref linkend="sql-create-access-method"/> and
   <xref linkend="sql-drop-access-method"/> SQL commands.
  </para>
____________________________________________________________________________-->
  <para>
   每一个索引访问方法都由<link linkend="catalog-pg-am"><structname>pg_am</structname></link>系统目录中的一行所描述。<structname>pg_am</structname>项为该访问方法指定了名称和一个<firstterm>处理器函数</firstterm>。这些项可以用<xref linkend="sql-create-access-method"/>和<xref linkend="sql-drop-access-method"/> SQL 命令创建和删除。
  </para>

<!--==========================orignal english content==========================
  <para>
   An index access method handler function must be declared to accept a
   single argument of type <type>internal</type> and to return the
   pseudo-type <type>index_am_handler</type>.  The argument is a dummy value that
   simply serves to prevent handler functions from being called directly from
   SQL commands.  The result of the function must be a palloc'd struct of
   type <structname>IndexAmRoutine</structname>, which contains everything
   that the core code needs to know to make use of the index access method.
   The <structname>IndexAmRoutine</structname> struct, also called the access
   method's <firstterm>API struct</firstterm>, includes fields specifying assorted
   fixed properties of the access method, such as whether it can support
   multicolumn indexes.  More importantly, it contains pointers to support
   functions for the access method, which do all of the real work to access
   indexes.  These support functions are plain C functions and are not
   visible or callable at the SQL level.  The support functions are described
   in <xref linkend="index-functions"/>.
  </para>
____________________________________________________________________________-->
  <para>
   一个索引访问方法的处理器函数必须被声明为接受单一的类型为<type>internal</type>类型的参数并且返回伪类型<type>index_am_handler</type>。该参数是一个无用值，它只是被用来防止从 SQL 命令直接调用处理器函数。该函数的结果必须是一个已经 palloc 过的<structname>IndexAmRoutine</structname>类型结构，它包含核心代码使用该索引访问方法所需的所有信息。<structname>IndexAmRoutine</structname>结构（也被称为访问方法的<firstterm>API 结构</firstterm>）中的域指定了该访问方法的各种固定性质，例如它是否支持多列索引。更重要的是，它包含用于该访问方法的支持函数的指针，这些函数会完成真正访问索引的工作。这些支持函数是纯 C 函数，并且在 SQL 层面不可见也不可调用。支持函数在<xref linkend="index-functions"/>中介绍。
  </para>

<!--==========================orignal english content==========================
  <para>
   The structure <structname>IndexAmRoutine</structname> is defined thus:
<programlisting>
typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Total number of strategies (operators) by which we can traverse/search
     * this AM.  Zero if AM does not have a fixed set of strategy assignments.
     */
    uint16      amstrategies;
    /* total number of support functions that this AM uses */
    uint16      amsupport;
    /* does AM support ORDER BY indexed column's value? */
    bool        amcanorder;
    /* does AM support ORDER BY result of an operator on indexed column? */
    bool        amcanorderbyop;
    /* does AM support backward scanning? */
    bool        amcanbackward;
    /* does AM support UNIQUE indexes? */
    bool        amcanunique;
    /* does AM support multi-column indexes? */
    bool        amcanmulticol;
    /* does AM require scans to have a constraint on the first index column? */
    bool        amoptionalkey;
    /* does AM handle ScalarArrayOpExpr quals? */
    bool        amsearcharray;
    /* does AM handle IS NULL/IS NOT NULL quals? */
    bool        amsearchnulls;
    /* can index storage data type differ from column data type? */
    bool        amstorage;
    /* can an index of this type be clustered on? */
    bool        amclusterable;
    /* does AM handle predicate locks? */
    bool        ampredlocks;
    /* does AM support parallel scan? */
    bool        amcanparallel;
    /* does AM support columns included with clause INCLUDE? */
    bool        amcaninclude;
    /* type of data stored in index, or InvalidOid if variable */
    Oid         amkeytype;

    /* interface functions */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* can be NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* can be NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* can be NULL */
    amgetbitmap_function amgetbitmap;   /* can be NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* can be NULL */
    amrestrpos_function amrestrpos;     /* can be NULL */

    /* interface functions to support parallel index scans */
    amestimateparallelscan_function amestimateparallelscan;    /* can be NULL */
    aminitparallelscan_function aminitparallelscan;    /* can be NULL */
    amparallelrescan_function amparallelrescan;    /* can be NULL */
} IndexAmRoutine;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <structname>IndexAmRoutine</structname>结构定义如下：
<programlisting>
typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Total number of strategies (operators) by which we can traverse/search
     * this AM.  Zero if AM does not have a fixed set of strategy assignments.
     */
    uint16      amstrategies;
    /* total number of support functions that this AM uses */
    uint16      amsupport;
    /* does AM support ORDER BY indexed column's value? */
    bool        amcanorder;
    /* does AM support ORDER BY result of an operator on indexed column? */
    bool        amcanorderbyop;
    /* does AM support backward scanning? */
    bool        amcanbackward;
    /* does AM support UNIQUE indexes? */
    bool        amcanunique;
    /* does AM support multi-column indexes? */
    bool        amcanmulticol;
    /* does AM require scans to have a constraint on the first index column? */
    bool        amoptionalkey;
    /* does AM handle ScalarArrayOpExpr quals? */
    bool        amsearcharray;
    /* does AM handle IS NULL/IS NOT NULL quals? */
    bool        amsearchnulls;
    /* can index storage data type differ from column data type? */
    bool        amstorage;
    /* can an index of this type be clustered on? */
    bool        amclusterable;
    /* does AM handle predicate locks? */
    bool        ampredlocks;
    /* does AM support parallel scan? */
    bool        amcanparallel;
    /* does AM support columns included with clause INCLUDE? */
    bool        amcaninclude;
    /* type of data stored in index, or InvalidOid if variable */
    Oid         amkeytype;

    /* interface functions */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* can be NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* can be NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* can be NULL */
    amgetbitmap_function amgetbitmap;   /* can be NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* can be NULL */
    amrestrpos_function amrestrpos;     /* can be NULL */

    /* interface functions to support parallel index scans */
    amestimateparallelscan_function amestimateparallelscan;    /* can be NULL */
    aminitparallelscan_function aminitparallelscan;    /* can be NULL */
    amparallelrescan_function amparallelrescan;    /* can be NULL */
} IndexAmRoutine;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   To be useful, an index access method must also have one or more
   <firstterm>operator families</firstterm> and
   <firstterm>operator classes</firstterm> defined in
   <link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>,
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>,
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>, and
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>.
   These entries allow the planner
   to determine what kinds of query qualifications can be used with
   indexes of this access method.  Operator families and classes are described
   in <xref linkend="xindex"/>, which is prerequisite material for reading
   this chapter.
  </para>
____________________________________________________________________________-->
  <para>
   要想真正有用，一个索引访问方法还必须有一个或多个定义在<link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>、
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>、
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>和
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>中的<firstterm>操作符族</firstterm>和<firstterm>操作符类</firstterm>。这些项允许规划器判断哪种查询条件适用于这个索引访问方法的索引。操作符族和类在<xref linkend="xindex"/>中描述，它是阅读本章所需的前导材料。
  </para>

<!--==========================orignal english content==========================
  <para>
   An individual index is defined by a
   <link linkend="catalog-pg-class"><structname>pg_class</structname></link>
   entry that describes it as a physical relation, plus a
   <link linkend="catalog-pg-index"><structname>pg_index</structname></link>
   entry that shows the logical content of the index &mdash; that is, the set
   of index columns it has and the semantics of those columns, as captured by
   the associated operator classes.  The index columns (key values) can be
   either simple columns of the underlying table or expressions over the table
   rows.  The index access method normally has no interest in where the index
   key values come from (it is always handed precomputed key values) but it
   will be very interested in the operator class information in
   <structname>pg_index</structname>.  Both of these catalog entries can be
   accessed as part of the <structname>Relation</structname> data structure that is
   passed to all operations on the index.
  </para>
____________________________________________________________________________-->
  <para>
   一个独立的索引是由一个<link linkend="catalog-pg-class"><structname>pg_class</structname></link>项定义的，该项描述索引为一个物理关系。还要加上一个<link linkend="catalog-pg-index"><structname>pg_index</structname></link>项来显示索引的逻辑内容 &mdash; 也就是说，它所拥有的索引列集以及这些列的语义是被相关操作符类刻画的。索引列（键值）可以是底层表的 简单列，也可以是该表行上的表达式。索引访问方法通常不关心索引的键值来自那里（它总是操作预计算过的键值），但是它会对<structname>pg_index</structname>中的操作符类信息很感兴趣。所有这些目录项都可以被当作<structname>关系</structname>数据结构的一部分访问，这个数据结构会被传递给索引上的所有操作。
  </para>

<!--==========================orignal english content==========================
  <para>
   Some of the flag fields of <structname>IndexAmRoutine</structname> have nonobvious
   implications.  The requirements of <structfield>amcanunique</structfield>
   are discussed in <xref linkend="index-unique-checks"/>.
   The <structfield>amcanmulticol</structfield> flag asserts that the
   access method supports multicolumn indexes, while
   <structfield>amoptionalkey</structfield> asserts that it allows scans
   where no indexable restriction clause is given for the first index column.
   When <structfield>amcanmulticol</structfield> is false,
   <structfield>amoptionalkey</structfield> essentially says whether the
   access method supports full-index scans without any restriction clause.
   Access methods that support multiple index columns <emphasis>must</emphasis>
   support scans that omit restrictions on any or all of the columns after
   the first; however they are permitted to require some restriction to
   appear for the first index column, and this is signaled by setting
   <structfield>amoptionalkey</structfield> false.
   One reason that an index AM might set
   <structfield>amoptionalkey</structfield> false is if it doesn't index
   null values.  Since most indexable operators are
   strict and hence cannot return true for null inputs,
   it is at first sight attractive to not store index entries for null values:
   they could never be returned by an index scan anyway.  However, this
   argument fails when an index scan has no restriction clause for a given
   index column.  In practice this means that
   indexes that have <structfield>amoptionalkey</structfield> true must
   index nulls, since the planner might decide to use such an index
   with no scan keys at all.  A related restriction is that an index
   access method that supports multiple index columns <emphasis>must</emphasis>
   support indexing null values in columns after the first, because the planner
   will assume the index can be used for queries that do not restrict
   these columns.  For example, consider an index on (a,b) and a query with
   <literal>WHERE a = 4</literal>.  The system will assume the index can be
   used to scan for rows with <literal>a = 4</literal>, which is wrong if the
   index omits rows where <literal>b</literal> is null.
   It is, however, OK to omit rows where the first indexed column is null.
   An index access method that does index nulls may also set
   <structfield>amsearchnulls</structfield>, indicating that it supports
   <literal>IS NULL</literal> and <literal>IS NOT NULL</literal> clauses as search
   conditions.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>IndexAmRoutine</structname>中的有些标志域的含义并不那么直观。<structfield>amcanunique</structfield>的要求在<xref linkend="index-unique-checks"/>中讨论。<structfield>amcanmulticol</structfield>标志断言该索引访问方法支持多列索引， <structfield>amoptionalkey</structfield>断言它允许对那种在第一个索引列上没有给出可索引限制子句的扫描。如果<structfield>amcanmulticol</structfield>为假，那么<structfield>amoptionalkey</structfield>实际上说的是该访问方法是否允许不带限制子句的全索引扫描。 那些支持多索引列的访问方法<emphasis>必须</emphasis>支持那些在省略了除第一个列之外的任何或所有其它列上约束的扫描；不过，它们被允许去要求在第一个列上出现一些限制，并且这一点是以把<structfield>amoptionalkey</structfield>设置为假作为标志的。一个索引 AM 可能将<structfield>amoptionalkey</structfield>设置为假的一种原因是，如果它不索引空值。因为大多数可索引的操作符都是严格的并且因此不能对空输入返回真，所以不为空值存储索引项咋看上去很吸引人：因为它们不 可能被一个索引扫描返回。不过，当一个索引扫描对于一个给定索引列上没有约束子句时，这种讨论就不成立了。实际上，这意 味着设置了<structfield>amoptionalkey</structfield>为真的索引必须索引空值，因为规划器可能会决定在根本没有扫描键的时候使用这样的索引。一个相关的限制是一个支持 多索引列的索引访问方法<emphasis>必须</emphasis>支持索引第一列之后的列中的空值，因 为规划器会认为这个索引可以用于在那些列上没有限制的查询。例如，考虑一个在(a,b)上的索引和一个有<literal>WHERE a = 4</literal>的查询。系统会认为该索引可以用于扫描 <literal>a = 4</literal>的行， 如果索引忽略了 b 为空的行，那么就是错误的。不过，忽略那些在第一个索引列上值为空的行是 OK 的。一个索引空的索引访问方法可能也会设置<structfield>amsearchnulls</structfield>，表明它支持将<literal>IS NULL</literal>和<literal>IS NOT NULL</literal>子句作为搜索条件。
  </para>

 </sect1>

 <sect1 id="index-functions">
<!--==========================orignal english content==========================
  <title>Index Access Method Functions</title>
____________________________________________________________________________-->
  <title>索引访问方法函数</title>

<!--==========================orignal english content==========================
  <para>
   The index construction and maintenance functions that an index access
   method must provide in <structname>IndexAmRoutine</structname> are:
  </para>
____________________________________________________________________________-->
  <para>
   索引访问方法必须在<structname>IndexAmRoutine</structname>中提供的索引构造和维护函数有：
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   Build a new index.  The index relation has been physically created,
   but is empty.  It must be filled in with whatever fixed data the
   access method requires, plus entries for all tuples already existing
   in the table.  Ordinarily the <function>ambuild</function> function will call
   <function>IndexBuildHeapScan()</function> to scan the table for existing tuples
   and compute the keys that need to be inserted into the index.
   The function must return a palloc'd struct containing statistics about
   the new index.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
IndexBuildResult *
ambuild (Relation heapRelation,
         Relation indexRelation,
         IndexInfo *indexInfo);
</programlisting>
   创建一个新索引。索引关系已经被物理创建，但是是空的。必须用索引访问方法要求的固定数据填充它，外加所有已经在表里的行的项。通常，<function>ambuild</function>函数会调用<function>IndexBuildHeapScan()</function>来扫描表以获取现有元组并计算需要被插入到索引的键。该函数必须返回一个已分配内存的结构，其中包含关于新索引的统计信息。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
ambuildempty (Relation indexRelation);
</programlisting>
   Build an empty index, and write it to the initialization fork (<symbol>INIT_FORKNUM</symbol>)
   of the given relation.  This method is called only for unlogged indexes; the
   empty index written to the initialization fork will be copied over the main
   relation fork on each server restart.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
ambuildempty (Relation indexRelation);
</programlisting>
   构建一个空索引，并且把它写入到给定关系的初始化分叉中（
   <symbol>INIT_FORKNUM</symbol>）。只会为不做日志的索引调用这个方法，被写入到
   初始化分叉的空索引在每次服务器启动时将被复制到主关系分叉中。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          IndexInfo *indexInfo);
</programlisting>
   Insert a new tuple into an existing index.  The <literal>values</literal> and
   <literal>isnull</literal> arrays give the key values to be indexed, and
   <literal>heap_tid</literal> is the TID to be indexed.
   If the access method supports unique indexes (its
   <structfield>amcanunique</structfield> flag is true) then
   <literal>checkUnique</literal> indicates the type of uniqueness check to
   perform.  This varies depending on whether the unique constraint is
   deferrable; see <xref linkend="index-unique-checks"/> for details.
   Normally the access method only needs the <literal>heapRelation</literal>
   parameter when performing uniqueness checking (since then it will have to
   look into the heap to verify tuple liveness).
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
bool
aminsert (Relation indexRelation,
          Datum *values,
          bool *isnull,
          ItemPointer heap_tid,
          Relation heapRelation,
          IndexUniqueCheck checkUnique,
          IndexInfo *indexInfo);
</programlisting>
   向现有索引插入一个新元组。<literal>values</literal>和<literal>isnull</literal>数组给出需要被索引的键值，而<literal>heap_tid</literal>是要被索引的 TID。 如果该访问方法支持唯一索引（它的<structfield>amcanunique</structfield>标志为真），那么<literal>checkUnique</literal>指示要执行的唯一性检查类型。这根据唯一约束是否为可推迟的而变化，详见<xref linkend="index-unique-checks"/>。通常在执行唯一性检查时访问方法仅需要<literal>heapRelation</literal>参数（因为那时它将不得不到堆中验证元组的存活性）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The function's Boolean result value is significant only when
   <literal>checkUnique</literal> is <literal>UNIQUE_CHECK_PARTIAL</literal>.
   In this case a true result means the new entry is known unique, whereas
   false means it might be non-unique (and a deferred uniqueness check must
   be scheduled).  For other cases a constant false result is recommended.
  </para>
____________________________________________________________________________-->
  <para>
   该函数的布尔结果值仅仅在<literal>checkUnique</literal>为<literal>UNIQUE_CHECK_PARTIAL</literal>时才有意义。这种情况下一个“真”结果意味着这个新项是已知唯一的，反之“假”结果意味着它可能不 是唯一的（并且一个延迟的唯一性校验必须是预定的）。对于其他情况，建议使用一个常量“假”结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   Some indexes might not index all tuples.  If the tuple is not to be
   indexed, <function>aminsert</function> should just return without doing anything.
  </para>
____________________________________________________________________________-->
  <para>
   有些索引可能不会索引所有元组。如果元组不被索引，<function>aminsert</function>应该仅返回而什么都不做。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the index AM wishes to cache data across successive index insertions
   within a SQL statement, it can allocate space
   in <literal>indexInfo-&gt;ii_Context</literal> and store a pointer to the
   data in <literal>indexInfo-&gt;ii_AmCache</literal> (which will be NULL
   initially).
  </para>
____________________________________________________________________________-->
  <para>
   如果索引AM希望在SQL语句中连续的索引插入之间缓冲数据，它可以在<literal>indexInfo-&gt;ii_Context</literal>中分配空间并且在<literal>indexInfo-&gt;ii_AmCache</literal>（初始为NULL）中存放一个指向该数据的指针。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   Delete tuple(s) from the index.  This is a <quote>bulk delete</quote> operation
   that is intended to be implemented by scanning the whole index and checking
   each entry to see if it should be deleted.
   The passed-in <literal>callback</literal> function must be called, in the style
   <literal>callback(<replaceable>TID</replaceable>, callback_state) returns bool</literal>,
   to determine whether any particular index entry, as identified by its
   referenced TID, is to be deleted.  Must return either NULL or a palloc'd
   struct containing statistics about the effects of the deletion operation.
   It is OK to return NULL if no information needs to be passed on to
   <function>amvacuumcleanup</function>.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
IndexBulkDeleteResult *
ambulkdelete (IndexVacuumInfo *info,
              IndexBulkDeleteResult *stats,
              IndexBulkDeleteCallback callback,
              void *callback_state);
</programlisting>
   从索引中删除元组。这是一个<quote>批量删除</quote>操作，它的意图是通过扫描整个索引并检查每个项看它是否需要被删除。被传递进来的<literal>callback</literal>函数必须被调用（调用风格是：<literal>callback(<replaceable>TID</replaceable>, callback_state) returns bool</literal>）来判断任何其引用的 TID 标识的索引项是否需要删除。必须返回 NULL 或者是一个 palloc 过的、 包含删除操作效果的统计信息的结构。如果不需要向<function>amvacuumcleanup</function>传递信息，返回 NULL 也是 OK 的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Because of limited <varname>maintenance_work_mem</varname>,
   <function>ambulkdelete</function> might need to be called more than once when many
   tuples are to be deleted.  The <literal>stats</literal> argument is the result
   of the previous call for this index (it is NULL for the first call within a
   <command>VACUUM</command> operation).  This allows the AM to accumulate statistics
   across the whole operation.  Typically, <function>ambulkdelete</function> will
   modify and return the same struct if the passed <literal>stats</literal> is not
   null.
  </para>
____________________________________________________________________________-->
  <para>
   由于<varname>maintenance_work_mem</varname>被限制，在删除多行的时候<function>ambulkdelete</function>可能需要被调用多次。<literal>stats</literal>参数是对这个索引上一次调用的结果（在一个<command>VACUUM</command>操作中第一次调用时是 NULL）。这将允许 AM 在整个操作过程中积累统计信息。典型的，如果被传递的<literal>stats</literal>非空，<function>ambulkdelete</function>将会修改并返回相同的结构。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   Clean up after a <command>VACUUM</command> operation (zero or more
   <function>ambulkdelete</function> calls).  This does not have to do anything
   beyond returning index statistics, but it might perform bulk cleanup
   such as reclaiming empty index pages.  <literal>stats</literal> is whatever the
   last <function>ambulkdelete</function> call returned, or NULL if
   <function>ambulkdelete</function> was not called because no tuples needed to be
   deleted.  If the result is not NULL it must be a palloc'd struct.
   The statistics it contains will be used to update <structname>pg_class</structname>,
   and will be reported by <command>VACUUM</command> if <literal>VERBOSE</literal> is given.
   It is OK to return NULL if the index was not changed at all during the
   <command>VACUUM</command> operation, but otherwise correct stats should
   be returned.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
IndexBulkDeleteResult *
amvacuumcleanup (IndexVacuumInfo *info,
                 IndexBulkDeleteResult *stats);
</programlisting>
   在一个<command>VACUUM</command>操作（零个或更多次<function>ambulkdelete</function>调用）后清空。虽然不必做任何返回索引统计信息之外的事情，但是它可能执行批量清理，例如回收空索引页面。<literal>stats</literal>是最后一次<function>ambulkdelete</function> 调用返回的东西或者 NULL（如果没有元组需要删除而未调用<function>ambulkdelete</function>）。如果结果不是 NULL，那么它必须是一个已经被 palloc 的结构。它包含的统计信息将用于更新<structname>pg_class</structname>并且由<command>VACUUM</command>报 告（如果给出了<literal>VERBOSE</literal>）。如果索引在<command>VACUUM</command>操作期间根本没有改变，那么返回 NULL 也是可以的，否则必须返回正确的统计信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   As of <productname>PostgreSQL</productname> 8.4,
   <function>amvacuumcleanup</function> will also be called at completion of an
   <command>ANALYZE</command> operation.  In this case <literal>stats</literal> is always
   NULL and any return value will be ignored.  This case can be distinguished
   by checking <literal>info-&gt;analyze_only</literal>.  It is recommended
   that the access method do nothing except post-insert cleanup in such a
   call, and that only in an autovacuum worker process.
  </para>
____________________________________________________________________________-->
  <para>
   从<productname>PostgreSQL</productname> 8.4 开始，<function>amvacuumcleanup</function>将也会在一个<command>ANALYZE</command>操作结束时被调用。这种情况中<literal>stats</literal>总是 NULL 并且任何返回值都将会被忽略。这种情况可以通过检测<literal>info-&gt;analyze_only</literal>来区分。我们建议，在这样的调用中访问方法除了做插入后的清理之外什么也不做，并且那是仅仅是在一个自动清理工作者进程中。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
bool
amcanreturn (Relation indexRelation, int attno);
</programlisting>
   Check whether the index can support <link
   linkend="indexes-index-only-scans"><firstterm>index-only scans</firstterm></link> on
   the given column, by returning the indexed column values for an index entry
   in the form of an <structname>IndexTuple</structname>.  The attribute number
   is 1-based, i.e. the first column's attno is 1. Returns true if supported,
   else false.  If the access method does not support index-only scans at all,
   the <structfield>amcanreturn</structfield> field in its <structname>IndexAmRoutine</structname>
   struct can be set to NULL.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
bool
amcanreturn (Relation indexRelation, int attno);
</programlisting>
   通过返回型为一个<structname>IndexTuple</structname>的索引项的被索引列值，检查索引是否能在给定列上支持<link linkend="indexes-index-only-scans"><firstterm>只用索引的扫描</firstterm></link>。属性编号从 1 开始编号，即第一列的 attno 是 1。如果支持返回 TRUE，否则返回 FALSE。如果访问方法 完全不支持只用索引的扫描，其<structname>IndexAmRoutine</structname>结构中的<structfield>amcanreturn</structfield>域可以被设置为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>
   Estimate the costs of an index scan.  This function is described fully
   in <xref linkend="index-cost-estimation"/>, below.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>
   估计一次索引扫描的开销。这个函数在下面的<xref linkend="index-cost-estimation"/>中有完整的讨论。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   Parse and validate the reloptions array for an index.  This is called only
   when a non-null reloptions array exists for the index.
   <parameter>reloptions</parameter> is a <type>text</type> array containing entries of the
   form <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>.
   The function should construct a <type>bytea</type> value, which will be copied
   into the <structfield>rd_options</structfield> field of the index's relcache entry.
   The data contents of the <type>bytea</type> value are open for the access
   method to define; most of the standard access methods use struct
   <structname>StdRdOptions</structname>.
   When <parameter>validate</parameter> is true, the function should report a suitable
   error message if any of the options are unrecognized or have invalid
   values; when <parameter>validate</parameter> is false, invalid entries should be
   silently ignored.  (<parameter>validate</parameter> is false when loading options
   already stored in <structname>pg_catalog</structname>; an invalid entry could only
   be found if the access method has changed its rules for options, and in
   that case ignoring obsolete entries is appropriate.)
   It is OK to return NULL if default behavior is wanted.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
bytea *
amoptions (ArrayType *reloptions,
           bool validate);
</programlisting>
   分析和验证一个索引的 reloptions 数组。仅当一个索引存在非空 reloptions 数组时才会被调用。<parameter>reloptions</parameter>是一个<type>text</type>数组，包含<replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>形式的项。 该函数应当构建一个<type>bytea</type>值，该值将被拷贝进索引的 relcache 项的<structfield>rd_options</structfield>域。<type>bytea</type>值的数据内容是开放由访问方法定义的， 大部分的标准访问方法都使用<structname>StdRdOptions</structname>结构。当<parameter>validate</parameter>为真时，如果任何一个选项都不可识别或者含有非法值，该函数都应当报告一个适当的错误消息；当<parameter>validate</parameter>为假时，非法 项应该被安静地忽略（当正在载入的选项已经在<structname>pg_catalog</structname>中时， <parameter>validate</parameter>为假；仅在访问方法已经改变了选项的规则时才可能找 到非法项，并且在此情况下忽略废弃的项是合适的）。如果想要默认行为，那么返回 NULL 也 OK。
  </para>
  
<!--==========================orignal english content==========================
  <para>
<programlisting>
bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);
</programlisting>
   The <function>amproperty</function> method allows index access methods to override
   the default behavior of <function>pg_index_column_has_property</function>
   and related functions.
   If the access method does not have any special behavior for index property
   inquiries, the <structfield>amproperty</structfield> field in
   its <structname>IndexAmRoutine</structname> struct can be set to NULL.
   Otherwise, the <function>amproperty</function> method will be called with
   <parameter>index_oid</parameter> and <parameter>attno</parameter> both zero for
   <function>pg_indexam_has_property</function> calls,
   or with <parameter>index_oid</parameter> valid and <parameter>attno</parameter> zero for
   <function>pg_index_has_property</function> calls,
   or with <parameter>index_oid</parameter> valid and <parameter>attno</parameter> greater than
   zero for <function>pg_index_column_has_property</function> calls.
   <parameter>prop</parameter> is an enum value identifying the property being tested,
   while <parameter>propname</parameter> is the original property name string.
   If the core code does not recognize the property name
   then <parameter>prop</parameter> is <literal>AMPROP_UNKNOWN</literal>.
   Access methods can define custom property names by
   checking <parameter>propname</parameter> for a match (use <function>pg_strcasecmp</function>
   to match, for consistency with the core code); for names known to the core
   code, it's better to inspect <parameter>prop</parameter>.
   If the <structfield>amproperty</structfield> method returns <literal>true</literal> then
   it has determined the property test result: it must set <literal>*res</literal>
   to the boolean value to return, or set <literal>*isnull</literal>
   to <literal>true</literal> to return a NULL.  (Both of the referenced variables
   are initialized to <literal>false</literal> before the call.)
   If the <structfield>amproperty</structfield> method returns <literal>false</literal> then
   the core code will proceed with its normal logic for determining the
   property test result.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
bool
amproperty (Oid index_oid, int attno,
            IndexAMProperty prop, const char *propname,
            bool *res, bool *isnull);
</programlisting>
   <function>amproperty</function>方法允许索引方法覆盖<function>pg_index_column_has_property</function>和相关函数的默认行为。如果访问方法对于索引性质查询没有指定特殊的行为，其<structname>IndexAmRoutine</structname>结构的<structfield>amproperty</structfield>域可以被设置为 NULL。否则，对于<function>pg_indexam_has_property</function>调用会使用均为 0 的<parameter>index_oid</parameter>和<parameter>attno</parameter>参数来调用<function>amproperty</function>方法；对于<function>pg_index_has_property</function>调用会使用有效的<parameter>index_oid</parameter>和为 0 的<parameter>attno</parameter>参数来调用<function>amproperty</function>方法；对于<function>pg_index_column_has_property</function>调用会使用有效的<parameter>index_oid</parameter>以及大于零的<parameter>attno</parameter>参数来调用<function>amproperty</function>方法。<parameter>prop</parameter>是用于标识被测试性质的枚举值，而<parameter>propname</parameter>是原始的性质名称字符串。如果核心代码不能识别该性质名称，则<parameter>prop</parameter>为<literal>AMPROP_UNKNOWN</literal>。访问方法可以通过检查<parameter>propname</parameter>是否匹配（为与核心代码一致，使用<function>pg_strcasecmp</function>来匹配）来定义自定义性质名称；对于核心代码已知的名称，最好检查<parameter>prop</parameter>。
   如果<structfield>amproperty</structfield>方法返回<literal>true</literal>则表示它已经确定了性质测试的结果：它必定会设置<literal>*res</literal>为要返回的布尔值，如果要返回 NULL 则设置<literal>*isnull</literal>为<literal>true</literal>（两个被引用的变量在调用之前要被初始化为<literal>false</literal>）。如果<structfield>amproperty</structfield>方法返回<literal>false</literal>则核心代码将会用其通常的逻辑来确定性质测试的结果。
  </para>

<!--==========================orignal english content==========================
  <para>
   Access methods that support ordering operators should
   implement <literal>AMPROP_DISTANCE_ORDERABLE</literal> property testing, as the
   core code does not know how to do that and will return NULL.  It may
   also be advantageous to implement <literal>AMPROP_RETURNABLE</literal> testing,
   if that can be done more cheaply than by opening the index and calling
   <structfield>amcanreturn</structfield>, which is the core code's default behavior.
   The default behavior should be satisfactory for all other standard
   properties.
  </para>
____________________________________________________________________________-->
  <para>
   支持排序操作符的访问方法应该实现<literal>AMPROP_DISTANCE_ORDERABLE</literal>性质测试，因为核心代码不知道如何做该测试并且会返回 NULL。如果有比打开索引并调用<structfield>amcanreturn</structfield>（这是核心代码的默认行为）更廉价的方法来做<literal>AMPROP_RETURNABLE</literal>测试，最好也实现它。默认行为应该对所有其他标准性质是符合要求的。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
bool
amvalidate (Oid opclassoid);
</programlisting>
   Validate the catalog entries for the specified operator class, so far as
   the access method can reasonably do that.  For example, this might include
   testing that all required support functions are provided.
   The <function>amvalidate</function> function must return false if the opclass is
   invalid.  Problems should be reported with <function>ereport</function> messages.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
bool
amvalidate (Oid opclassoid);
</programlisting>
   只要访问方法能够，为指定的操作符类验证系统目录项。例如，这可能包括所有所需支持函数所提供的测试。如果该 opclass 不合法，<function>amvalidate</function>函数必须返回假。所存在的问题应由<function>ereport</function>消息报告。
  </para>

<!--==========================orignal english content==========================
  <para>
   The purpose of an index, of course, is to support scans for tuples matching
   an indexable <literal>WHERE</literal> condition, often called a
   <firstterm>qualifier</firstterm> or <firstterm>scan key</firstterm>.  The semantics of
   index scanning are described more fully in <xref linkend="index-scanning"/>,
   below.  An index access method can support <quote>plain</quote> index scans,
   <quote>bitmap</quote> index scans, or both.  The scan-related functions that an
   index access method must or may provide are:
  </para>
____________________________________________________________________________-->
  <para>
   当然，索引的目的是支持扫描那些匹配一个可索引<literal>WHERE</literal>情况的元组，常常也被称为<firstterm>限定词</firstterm>或<firstterm>扫描键</firstterm>。索引扫描的语义在下面的<xref linkend="index-scanning"/>中有完整的描述。一个索引访问方法可以支持<quote>普通</quote>索引扫描、<quote>位图</quote>索引扫描或者两者。一个索引访问方法必须或可能提供的与扫描相关的函数是：
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</programlisting>
   Prepare for an index scan.  The <literal>nkeys</literal> and <literal>norderbys</literal>
   parameters indicate the number of quals and ordering operators that will be
   used in the scan; these may be useful for space allocation purposes.
   Note that the actual values of the scan keys aren't provided yet.
   The result must be a palloc'd struct.
   For implementation reasons the index access method
   <emphasis>must</emphasis> create this struct by calling
   <function>RelationGetIndexScan()</function>.  In most cases
   <function>ambeginscan</function> does little beyond making that call and perhaps
   acquiring locks;
   the interesting parts of index-scan startup are in <function>amrescan</function>.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
IndexScanDesc
ambeginscan (Relation indexRelation,
             int nkeys,
             int norderbys);
</programlisting>
   为一个索引扫描做准备。<literal>nkeys</literal>和<literal>norderbys</literal>参数说明要被用在扫描中的条件和排序操作符的数目，它们可以用于空间分配目的。注意扫描键的实际值还没有被提供。结果必须是一个 palloc 过的结构。由于实现的原因，索引访问方法<emphasis>必须</emphasis>通过调用<function>RelationGetIndexScan()</function>来创建这个结构。在大多数情况中，<function>ambeginscan</function>除了做这个调用和获取锁之外不会做很多工作，索引扫描启动中有趣的部分在<function>amrescan</function>中。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</programlisting>
   Start or restart an index scan, possibly with new scan keys.  (To restart
   using previously-passed keys, NULL is passed for <literal>keys</literal> and/or
   <literal>orderbys</literal>.)  Note that it is not allowed for
   the number of keys or order-by operators to be larger than
   what was passed to <function>ambeginscan</function>.  In practice the restart
   feature is used when a new outer tuple is selected by a nested-loop join
   and so a new key comparison value is needed, but the scan key structure
   remains the same.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
amrescan (IndexScanDesc scan,
          ScanKey keys,
          int nkeys,
          ScanKey orderbys,
          int norderbys);
</programlisting>
   开始或者重新开始一个索引扫描，可能使用的是一个新的扫描键（要想使用之前传递的键重新开始，给<literal>keys</literal> 和/或<literal>orderbys</literal>传递 NULL）。请注意，使用的键或排序操作符的个数不能大于传递给<function>ambeginscan</function>的个数。实际上这个重新开始特性的使用场景是：在一个嵌套循环连接选取了一个新的 outer 元组时，因此需要一个新的键比较值，但扫描键结构仍然保持相同。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   Fetch the next tuple in the given scan, moving in the given
   direction (forward or backward in the index).  Returns true if a tuple was
   obtained, false if no matching tuples remain.  In the true case the tuple
   TID is stored into the <literal>scan</literal> structure.  Note that
   <quote>success</quote> means only that the index contains an entry that matches
   the scan keys, not that the tuple necessarily still exists in the heap or
   will pass the caller's snapshot test.  On success, <function>amgettuple</function>
   must also set <literal>scan-&gt;xs_recheck</literal> to true or false.
   False means it is certain that the index entry matches the scan keys.
   true means this is not certain, and the conditions represented by the
   scan keys must be rechecked against the heap tuple after fetching it.
   This provision supports <quote>lossy</quote> index operators.
   Note that rechecking will extend only to the scan conditions; a partial
   index predicate (if any) is never rechecked by <function>amgettuple</function>
   callers.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
boolean
amgettuple (IndexScanDesc scan,
            ScanDirection direction);
</programlisting>
   在给定扫描中取下一个元组，向给定方向移动（在索引中向前或者向后）。如果取到了元组，则返回 TRUE，如果取到匹配的元组，返回 FALSE。在 TRUE 的情况中，该元组的 TID 被存储在<literal>scan</literal>结构中。请注意<quote>成功</quote>只 意味着索引包含一个匹配扫描键的项，并不意味该元组仍然在堆中存在， 或者是能够通过调用者的快照测试。在成功时，<function>amgettuple</function>也必须把<literal>scan-&gt;xs_recheck</literal>设 置成 TRUE 或者 FALSE。FALSE 意味着它确定索引项匹配扫描键。TRUE 意味着它并不确定，而且必须在取得堆元组之后对它重新检查扫描键表示的条件。 这条规定支持<quote>有损的</quote>索引操作符。注意重新检查仅仅对扫描条件扩展；一个部分索引谓语（如果有）从不被<function>amgettuple</function>调用者重新检查。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the index supports <link linkend="indexes-index-only-scans">index-only
   scans</link> (i.e., <function>amcanreturn</function> returns true for it),
   then on success the AM must also check <literal>scan-&gt;xs_want_itup</literal>,
   and if that is true it must return the originally indexed data for the
   index entry.  The data can be returned in the form of an
   <structname>IndexTuple</structname> pointer stored at <literal>scan-&gt;xs_itup</literal>,
   with tuple descriptor <literal>scan-&gt;xs_itupdesc</literal>; or in the form of
   a <structname>HeapTuple</structname> pointer stored at <literal>scan-&gt;xs_hitup</literal>,
   with tuple descriptor <literal>scan-&gt;xs_hitupdesc</literal>.  (The latter
   format should be used when reconstructing data that might possibly not fit
   into an <structname>IndexTuple</structname>.)  In either case,
   management of the data referenced by the pointer is the access method's
   responsibility.  The data must remain good at least until the next
   <function>amgettuple</function>, <function>amrescan</function>, or <function>amendscan</function>
   call for the scan.
  </para>
____________________________________________________________________________-->
  <para>
   如果索引支持<link linkend="indexes-index-only-scans">只用索引扫描</link>（即<function>amcanreturn</function>对它返回 TRUE），则在成功时 AM 也必须检查<literal>scan-&gt;xs_want_itup</literal>，并且如果检查为真它必须返回索引项的原始被索引数据。该数据的返回形式可以是一个存储在<literal>scan-&gt;xs_itup</literal>中的<structname>IndexTuple</structname>指针外加元组描述符<literal>scan-&gt;xs_itupdesc</literal>，或者是一个存储在<literal>scan-&gt;xs_hitup</literal>中的<structname>HeapTuple</structname>指针外加元组描述符<literal>scan-&gt;xs_hitupdesc</literal>（在重构可能无法放在一个<structname>IndexTuple</structname>中的数据时，应该使用后一种格式）。不管是哪种形式，访问方法应该负责管理好指针引用的数据。至少在为扫描下一次调用<function>amgettuple</function>、<function>amrescan</function>或<function>amendscan</function>之前，该数据必须是完好的。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <function>amgettuple</function> function need only be provided if the access
   method supports <quote>plain</quote> index scans.  If it doesn't, the
   <structfield>amgettuple</structfield> field in its <structname>IndexAmRoutine</structname>
   struct must be set to NULL.
  </para>
____________________________________________________________________________-->
  <para>
   如果访问方法支持<quote>普通</quote>索引扫描，只需要提供<function>amgettuple</function>函数。如果不支持，它的<structname>IndexAmRoutine</structname>结构的<structfield>amgettuple</structfield>域必须被设置为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</programlisting>
   Fetch all tuples in the given scan and add them to the caller-supplied
   <type>TIDBitmap</type> (that is, OR the set of tuple IDs into whatever set is already
   in the bitmap).  The number of tuples fetched is returned (this might be
   just an approximate count, for instance some AMs do not detect duplicates).
   While inserting tuple IDs into the bitmap, <function>amgetbitmap</function> can
   indicate that rechecking of the scan conditions is required for specific
   tuple IDs.  This is analogous to the <literal>xs_recheck</literal> output parameter
   of <function>amgettuple</function>.  Note: in the current implementation, support
   for this feature is conflated with support for lossy storage of the bitmap
   itself, and therefore callers recheck both the scan conditions and the
   partial index predicate (if any) for recheckable tuples.  That might not
   always be true, however.
   <function>amgetbitmap</function> and
   <function>amgettuple</function> cannot be used in the same index scan; there
   are other restrictions too when using <function>amgetbitmap</function>, as explained
   in <xref linkend="index-scanning"/>.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
int64
amgetbitmap (IndexScanDesc scan,
             TIDBitmap *tbm);
</programlisting>
   在给定扫描中取所有元组并且把它们添加到调用者提供的<type>TIDBitmap</type>中（即，把元组 ID 的集合 OR 到已经存在于位图中的东西里面）。返回被取得的元组的数量（这可能仅仅是一个近似计数，例如一些 AM 不会去重）。在把元组 ID 插入到位图时，<function>amgetbitmap</function>可以指明对指定元组 ID 要求重新检查扫描条件。这与<function>amgettuple</function>的 <literal>xs_recheck</literal>输出参数类似。注意：在当前的实现中，这个特性的支持是和对位图本身有损存储的支持合并在一起的，并且调用者会对可重新检查的元组检查扫描条件和部分索引谓词（如果有）。但是，那不会总是真的。<function>amgetbitmap</function>和<function>amgettuple</function>不能被用于同一个索引扫描；正如<xref linkend="index-scanning"/>中所解释的，在使用<function>amgetbitmap</function>时也有其他的限制条件。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <function>amgetbitmap</function> function need only be provided if the access
   method supports <quote>bitmap</quote> index scans.  If it doesn't, the
   <structfield>amgetbitmap</structfield> field in its <structname>IndexAmRoutine</structname>
   struct must be set to NULL.
  </para>
____________________________________________________________________________-->
  <para>
   如果访问方法支持<quote>bitmap</quote>索引扫描，则仅需要提供<function>amgetbitmap</function>函数。如果不支持，它的<structname>IndexAmRoutine</structname>结构中的<structfield>amgetbitmap</structfield>域必须被设置为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
amendscan (IndexScanDesc scan);
</programlisting>
   End a scan and release resources.  The <literal>scan</literal> struct itself
   should not be freed, but any locks or pins taken internally by the
   access method must be released, as well as any other memory allocated
   by <function>ambeginscan</function> and other scan-related functions.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
amendscan (IndexScanDesc scan);
</programlisting>
   结束扫描并释放资源。不应该释放<literal>scan</literal>结构本身，但访问方法内部使用的任何锁或者 pin 都应该被释放，
   以及<function>ambeginscan</function>和其他扫描相关函数分配的任何其他内存。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
ammarkpos (IndexScanDesc scan);
</programlisting>
   Mark current scan position.  The access method need only support one
   remembered scan position per scan.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
ammarkpos (IndexScanDesc scan);
</programlisting>
   标记当前扫描位置。访问方法只需要支持每个扫描里面有一个被标记的扫描位置。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   The <function>ammarkpos</function> function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the <structfield>ammarkpos</structfield> field in its <structname>IndexAmRoutine</structname>
   struct may be set to NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <function>ammarkpos</function>函数只有在访问方法支持有序扫描时才需要提供。如果不支持，则访问方法的<structname>IndexAmRoutine</structname>结构的<structfield>ammarkpos</structfield>域可以设置为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
amrestrpos (IndexScanDesc scan);
</programlisting>
   Restore the scan to the most recently marked position.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
amrestrpos (IndexScanDesc scan);
</programlisting>
   把扫描恢复到最近标记的位置。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <function>amrestrpos</function> function need only be provided if the access
   method supports ordered scans.  If it doesn't,
   the <structfield>amrestrpos</structfield> field in its <structname>IndexAmRoutine</structname>
   struct may be set to NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <function>amrestrpos</function>函数只有在访问方法支持有序扫描时才需要提供。如果不支持，则访问方法的<structname>IndexAmRoutine</structname>结构的<structfield>amrestrpos</structfield>域可以设置为 NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   In addition to supporting ordinary index scans, some types of index
   may wish to support <firstterm>parallel index scans</firstterm>, which allow
   multiple backends to cooperate in performing an index scan.  The
   index access method should arrange things so that each cooperating
   process returns a subset of the tuples that would be performed by
   an ordinary, non-parallel index scan, but in such a way that the
   union of those subsets is equal to the set of tuples that would be
   returned by an ordinary, non-parallel index scan.  Furthermore, while
   there need not be any global ordering of tuples returned by a parallel
   scan, the ordering of that subset of tuples returned within each
   cooperating backend must match the requested ordering.  The following
   functions may be implemented to support parallel index scans:
  </para>
____________________________________________________________________________-->
  <para>
   除了支持普通的索引扫描之外，某些类型的索引可能希望支持<firstterm>并行索引扫描</firstterm>，这种方式允许多个后端合作来执行一次索引扫描。索引访问方法应该安排好各种事情，这样每个参与合作的进程才能返回原本会由普通非并行索引扫描执行得到的元组的一个子集，但是得到的那些子集的并集应该等于普通非并行索引扫描得到的元组集合。此外，虽然不需要并行扫描返回的元组有任何全局顺序，但每个参与合作的后端中返回的元组子集的顺序必须匹配所要求的顺序。必须实现下列函数才能支持并行索引扫描：
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
Size
amestimateparallelscan (void);
</programlisting>
   Estimate and return the number of bytes of dynamic shared memory which
   the access method will be needed to perform a parallel scan.  (This number
   is in addition to, not in lieu of, the amount of space needed for
   AM-independent data in <structname>ParallelIndexScanDescData</structname>.)
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
Size
amestimateparallelscan (void);
</programlisting>
   估算并且返回访问方法执行一次并行扫描所需要的动态共享内存的字节数（这个数字是对<structname>ParallelIndexScanDescData</structname>中访问方法无关的数据所需空间量的补充而不是替代）。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is not necessary to implement this function for access methods which
   do not support parallel scans or for which the number of additional bytes
   of storage required is zero.
  </para>
____________________________________________________________________________-->
  <para>
   对于不支持并行扫描或者额外存储需求的的字节数为零的访问方法，无需实现这个函数。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
aminitparallelscan (void *target);
</programlisting>
   This function will be called to initialize dynamic shared memory at the
   beginning of a parallel scan.  <parameter>target</parameter> will point to at least
   the number of bytes previously returned by
   <function>amestimateparallelscan</function>, and this function may use that
   amount of space to store whatever data it wishes.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
aminitparallelscan (void *target);
</programlisting>
   在一次并行扫描的开头将调用这个函数来初始化动态共享内存。<parameter>target</parameter>将指向一段动态共享内存空间，其大小至少为之前<function>amestimateparallelscan</function>返回的字节数，并且这个函数可以使用这部分空间来存放它希望存放的任何数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   It is not necessary to implement this function for access methods which
   do not support parallel scans or in cases where the shared memory space
   required needs no initialization.
  </para>
____________________________________________________________________________-->
  <para>
   对于不支持并行扫描或者不要求初始化共享内存空间的情况，无需实现这个函数。
  </para>

<!--==========================orignal english content==========================
  <para>
<programlisting>
void
amparallelrescan (IndexScanDesc scan);
</programlisting>
   This function, if implemented, will be called when a parallel index scan
   must be restarted.  It should reset any shared state set up by
   <function>aminitparallelscan</function> such that the scan will be restarted from
   the beginning.
  </para>
____________________________________________________________________________-->
  <para>
<programlisting>
void
amparallelrescan (IndexScanDesc scan);
</programlisting>
   如果实现了这个函数，当并行索引扫描必须被重启时，将会调用这个函数。它应该重置由<function>aminitparallelscan</function>建立的任何共享状态，这样扫描将会被重头重新开始。
  </para>

 </sect1>

 <sect1 id="index-scanning">
<!--==========================orignal english content==========================
  <title>Index Scanning</title>
____________________________________________________________________________-->
  <title>索引扫描</title>

<!--==========================orignal english content==========================
  <para>
   In an index scan, the index access method is responsible for regurgitating
   the TIDs of all the tuples it has been told about that match the
   <firstterm>scan keys</firstterm>.  The access method is <emphasis>not</emphasis> involved in
   actually fetching those tuples from the index's parent table, nor in
   determining whether they pass the scan's time qualification test or other
   conditions.
  </para>
____________________________________________________________________________-->
  <para>
   在一个索引扫描中，索引访问方法负责提供它拿到的匹配<firstterm>扫描键</firstterm>的所有元组的TID。访问方法<emphasis>不</emphasis>会涉及从索引的父表中实际取得那些元组，也不会涉及判断它们是否通过了扫描的时间条件测试或者是其它条件。
  </para>

<!--==========================orignal english content==========================
  <para>
   A scan key is the internal representation of a <literal>WHERE</literal> clause of
   the form <replaceable>index_key</replaceable> <replaceable>operator</replaceable>
   <replaceable>constant</replaceable>, where the index key is one of the columns of the
   index and the operator is one of the members of the operator family
   associated with that index column.  An index scan has zero or more scan
   keys, which are implicitly ANDed &mdash; the returned tuples are expected
   to satisfy all the indicated conditions.
  </para>
____________________________________________________________________________-->
  <para>
   一个扫描键是一个<literal>WHERE</literal>子句的内部表示，<literal>WHERE</literal>子句的形式是<replaceable>index_key</replaceable> <replaceable>operator</replaceable> <replaceable>constant</replaceable>，其中索引键字索引中的一个列，而操作符是和该索引列相关联的操作符族的一个成员。一个索引扫描拥有零个或者多个扫描键，它们是隐式 AND 关系 &mdash; 返回的元组被认为满足所有列出的条件。
  </para>

<!--==========================orignal english content==========================
  <para>
   The access method can report that the index is <firstterm>lossy</firstterm>, or
   requires rechecks, for a particular query.  This implies that the index
   scan will return all the entries that pass the scan key, plus possibly
   additional entries that do not.  The core system's index-scan machinery
   will then apply the index conditions again to the heap tuple to verify
   whether or not it really should be selected.  If the recheck option is not
   specified, the index scan must return exactly the set of matching entries.
  </para>
____________________________________________________________________________-->
  <para>
   对于一个特定查询，访问方法可能报告索引是<firstterm>有损的</firstterm>或者要求重新检查。这就暗示着该索引扫 描会返回所有通过扫描键的项，外加上一些可能没通过扫描键的项。核心系统的索引扫描机制然后就会再次在堆元组上应用索引条件来验证它是否真地应该被选择。如果没有指定重新检查选项，索引扫描必须返回准确的匹配项集合。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that it is entirely up to the access method to ensure that it
   correctly finds all and only the entries passing all the given scan keys.
   Also, the core system will simply hand off all the <literal>WHERE</literal>
   clauses that match the index keys and operator families, without any
   semantic analysis to determine whether they are redundant or
   contradictory.  As an example, given
   <literal>WHERE x &gt; 4 AND x &gt; 14</literal> where <literal>x</literal> is a b-tree
   indexed column, it is left to the b-tree <function>amrescan</function> function
   to realize that the first scan key is redundant and can be discarded.
   The extent of preprocessing needed during <function>amrescan</function> will
   depend on the extent to which the index access method needs to reduce
   the scan keys to a <quote>normalized</quote> form.
  </para>
____________________________________________________________________________-->
  <para>
   请注意，确保找到所有（只有）通过所有给定扫描键的条目的工作完全由访问方法负责。还有，核心系统将只是简单地 放过所有匹配扫描键和操作符族的<literal>WHERE</literal>子句，而不会做任何语义分析来判断它们是否冗余或者矛盾。例如，给定<literal>WHERE x &gt; 4 AND x &gt; 14</literal>（其中<literal>x</literal>是一个 B-树 索引列，它被留给 B-树 <function>amrescan</function>函数来发现第一个扫描键是冗余并且可以被丢弃。<function>amrescan</function>期间需要的预处理的范围将取决于索引访问方法需要什么来把扫描键缩减为一种<quote>正规化的</quote>形式。
  </para>

<!--==========================orignal english content==========================
  <para>
   Some access methods return index entries in a well-defined order, others
   do not.  There are actually two different ways that an access method can
   support sorted output:

    <itemizedlist>
     <listitem>
      <para>
       Access methods that always return entries in the natural ordering
       of their data (such as btree) should set
       <structfield>amcanorder</structfield> to true.
       Currently, such access methods must use btree-compatible strategy
       numbers for their equality and ordering operators.
      </para>
     </listitem>
     <listitem>
      <para>
       Access methods that support ordering operators should set
       <structfield>amcanorderbyop</structfield> to true.
       This indicates that the index is capable of returning entries in
       an order satisfying <literal>ORDER BY</literal> <replaceable>index_key</replaceable>
       <replaceable>operator</replaceable> <replaceable>constant</replaceable>.  Scan modifiers
       of that form can be passed to <function>amrescan</function> as described
       previously.
      </para>
     </listitem>
    </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   一些访问方法按照一个良定义的顺序来返回索引项，其他的则不会。实际上一个访问方法可以有两种不同的方式支持排序输出：

    <itemizedlist>
     <listitem>
      <para>
       总是按数据的自然序返回项的访问方法应该设置<structfield>amcanorder</structfield>为真。当前，这样的访问方法必须对它们的等值和排序操作符使用b-tree兼容的策略号。
      </para>
     </listitem>
     <listitem>
      <para>
       支持排序操作符的访问方法应该设置<structfield>amcanorderbyop</structfield>为真。这表示索引有能力按照满足<literal>ORDER BY</literal> <replaceable>index_key</replaceable> <replaceable>operator</replaceable> <replaceable>constant</replaceable>的一种顺序返回项。如前所述，这种形式的扫描修饰符可以被传递给<function>amrescan</function>。
      </para>
     </listitem>
    </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The <function>amgettuple</function> function has a <literal>direction</literal> argument,
   which can be either <literal>ForwardScanDirection</literal> (the normal case)
   or  <literal>BackwardScanDirection</literal>.  If the first call after
   <function>amrescan</function> specifies <literal>BackwardScanDirection</literal>, then the
   set of matching index entries is to be scanned back-to-front rather than in
   the normal front-to-back direction, so <function>amgettuple</function> must return
   the last matching tuple in the index, rather than the first one as it
   normally would.  (This will only occur for access
   methods that set <structfield>amcanorder</structfield> to true.)  After the
   first call, <function>amgettuple</function> must be prepared to advance the scan in
   either direction from the most recently returned entry.  (But if
   <structfield>amcanbackward</structfield> is false, all subsequent
   calls will have the same direction as the first one.)
  </para>
____________________________________________________________________________-->
  <para>
   <function>amgettuple</function>函数有一个<literal>direction</literal>参数，它可以是 <literal>ForwardScanDirection</literal>（正常情况）或者<literal>BackwardScanDirection</literal>。如果<function>amrescan</function>之后的第一次调用指定了<literal>BackwardScanDirection</literal>，那么匹配条件的索引项集合是从后向前扫描的，而 不是通常的从前向后扫描，因此<function>amgettuple</function>必须返回索引中最后一个匹配元组，而不是通常情况下的第一个（这只对设置了<structfield>amcanorder</structfield>为真访问方法发生）。在第一次调用后，<function>amgettuple</function>必须被准备好从最近被返回项的位置按照任何一种方向推进扫描（但是如果<structfield>amcanbackward</structfield>为假，所有后续调用将使用第一次相同的方向）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Access methods that support ordered scans must support <quote>marking</quote> a
   position in a scan and later returning to the marked position.  The same
   position might be restored multiple times.  However, only one position need
   be remembered per scan; a new <function>ammarkpos</function> call overrides the
   previously marked position.  An access method that does not support ordered
   scans need not provide <function>ammarkpos</function> and <function>amrestrpos</function>
   functions in <structname>IndexAmRoutine</structname>; set those pointers to NULL
   instead.
  </para>
____________________________________________________________________________-->
  <para>
   支持排序扫描的访问方法必须支持在扫描里<quote>标记</quote>一个位置并且随后返回到这个标记过的位置。同一个位置可能会被重复多次还原。但是，每个扫描中只有一个位置需要被记住；一个新的<function>ammarkpos</function>调用将重写之前标记的位置。一个不支持排序扫描的访问方法无需在<structname>IndexAmRoutine</structname>中提供<function>ammarkpos</function>和<function>amrestrpos</function>函数，把这些指针设置为 NULL 即可。
  </para>

<!--==========================orignal english content==========================
  <para>
   Both the scan position and the mark position (if any) must be maintained
   consistently in the face of concurrent insertions or deletions in the
   index.  It is OK if a freshly-inserted entry is not returned by a scan that
   would have found the entry if it had existed when the scan started, or for
   the scan to return such an entry upon rescanning or backing
   up even though it had not been returned the first time through.  Similarly,
   a concurrent delete might or might not be reflected in the results of a scan.
   What is important is that insertions or deletions not cause the scan to
   miss or multiply return entries that were not themselves being inserted or
   deleted.
  </para>
____________________________________________________________________________-->
  <para>
   扫描位置和标记位置（如果存在)）都必须在面对索引中的并发插入和删除时保持一致性。如果一个新插入的项并未被一个扫描返回（如果该扫描开始的时候该项已经存在，该扫描将已经找到该项），或者说扫描通过重新扫描或者反向扫描返回这样一个项（即使它第一次没有返回这样一个项），这些情况都是可以接受的。类似的还有，一个并发的删除可能或不可能被反映在一个扫描的结果中。重要的是，插入或者删除不会导致扫描错过或者多次返回本身不是被插入或者删除的项。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the index stores the original indexed data values (and not some lossy
   representation of them), it is useful to
   support <link linkend="indexes-index-only-scans">index-only scans</link>, in
   which the index returns the actual data not just the TID of the heap tuple.
   This will only avoid I/O if the visibility map shows that the TID is on an
   all-visible page; else the heap tuple must be visited anyway to check
   MVCC visibility.  But that is no concern of the access method's.
  </para>
____________________________________________________________________________-->
  <para>
   如果索引存储原始被索引的数据值（并且不是它们的某种有损表示），它可用来支持<link linkend="indexes-index-only-scans">只用索引的扫描</link>，着这种扫描中索引返回的就是实际的数据而不只是堆元组的 TID。这只有在可见性映射显示该 TID 位于一个全部可见的页面时才能避免 I/O；否则必须访问堆元组来检查 MVCC 可见性。但是这就不用访问方法操心了。
  </para>

<!--==========================orignal english content==========================
  <para>
   Instead of using <function>amgettuple</function>, an index scan can be done with
   <function>amgetbitmap</function> to fetch all tuples in one call.  This can be
   noticeably more efficient than <function>amgettuple</function> because it allows
   avoiding lock/unlock cycles within the access method.  In principle
   <function>amgetbitmap</function> should have the same effects as repeated
   <function>amgettuple</function> calls, but we impose several restrictions to
   simplify matters.  First of all, <function>amgetbitmap</function> returns all
   tuples at once and marking or restoring scan positions isn't
   supported. Secondly, the tuples are returned in a bitmap which doesn't
   have any specific ordering, which is why <function>amgetbitmap</function> doesn't
   take a <literal>direction</literal> argument.  (Ordering operators will never be
   supplied for such a scan, either.)
   Also, there is no provision for index-only scans with
   <function>amgetbitmap</function>, since there is no way to return the contents of
   index tuples.
   Finally, <function>amgetbitmap</function>
   does not guarantee any locking of the returned tuples, with implications
   spelled out in <xref linkend="index-locking"/>.
  </para>
____________________________________________________________________________-->
  <para>
   除了使用<function>amgettuple</function>，一个索引扫描可以通过<function>amgetbitmap</function>在一次调用中取得所有元组来完成。这样做可能会比<function>amgettuple</function>有显著的效率提升，因为它可以避免在访问方法内的加锁/解锁循环。原则上<function>amgetbitmap</function>应该和重复调用<function>amgettuple</function>的效果相同， 不过我们强加了一些限制来简化这件事。首先，<function>amgetbitmap</function>一次返回 所有元组并且标记并且不支持标记或恢复扫描位置。第二，在一个位图中返回的元组没有任何指定的顺序，这也是为什么<function>amgetbitmap</function>没有一个<literal>direction</literal>参数的原因（排序操作符也将永远不会提供给这种扫描）。还有，对于使用<function>amgetbitmap</function>的只用索引扫描没有规定，因为没有办法返回索引元组的内容。最后，如<xref linkend="index-locking"/>中所说的，<function>amgetbitmap</function>不保证被返回元组上的任何锁。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that it is permitted for an access method to implement only
   <function>amgetbitmap</function> and not <function>amgettuple</function>, or vice versa,
   if its internal implementation is unsuited to one API or the other.
  </para>
____________________________________________________________________________-->
  <para>
   注意如果访问方法的内部实现不适合一个 API 或其他 API，允许一个访问方法只实现<function>amgetbitmap</function>而不实现<function>amgettuple</function>，或者反过来。
  </para>

 </sect1>

 <sect1 id="index-locking">
<!--==========================orignal english content==========================
  <title>Index Locking Considerations</title>
____________________________________________________________________________-->
  <title>索引锁定考虑</title>

<!--==========================orignal english content==========================
  <para>
   Index access methods must handle concurrent updates
   of the index by multiple processes.
   The core <productname>PostgreSQL</productname> system obtains
   <literal>AccessShareLock</literal> on the index during an index scan, and
   <literal>RowExclusiveLock</literal> when updating the index (including plain
   <command>VACUUM</command>).  Since these lock types do not conflict, the access
   method is responsible for handling any fine-grained locking it might need.
   An exclusive lock on the index as a whole will be taken only during index
   creation, destruction, or <command>REINDEX</command>.
  </para>
____________________________________________________________________________-->
  <para>
   索引访问方法必须支持多个进程对索引的并发更新。在索引扫描期间，核心<productname>PostgreSQL</productname>系统在索引上获取 <literal>AccessShareLock</literal>，并且在更新索引时（包括普通<command>VACUUM</command>）获取<literal>RowExclusiveLock</literal>。因为这些锁类型不会冲突，所以访问方法负责处理它可能需要的任何细粒度锁。把索引作为一个整体的排他锁只会在索引创建、删除或<command>REINDEX</command>时被使用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Building an index type that supports concurrent updates usually requires
   extensive and subtle analysis of the required behavior.  For the b-tree
   and hash index types, you can read about the design decisions involved in
   <filename>src/backend/access/nbtree/README</filename> and
   <filename>src/backend/access/hash/README</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   创建一个支持并发更新的索引类型通常要求对所需的行为进行广泛并且细致的分析。对于b-tree 和哈希索引类型，你可以阅读<filename>src/backend/access/nbtree/README</filename>和<filename>src/backend/access/hash/README</filename>中的设计决策。
  </para>

<!--==========================orignal english content==========================
  <para>
   Aside from the index's own internal consistency requirements, concurrent
   updates create issues about consistency between the parent table (the
   <firstterm>heap</firstterm>) and the index.  Because
   <productname>PostgreSQL</productname> separates accesses
   and updates of the heap from those of the index, there are windows in
   which the index might be inconsistent with the heap.  We handle this problem
   with the following rules:

    <itemizedlist>
     <listitem>
      <para>
       A new heap entry is made before making its index entries.  (Therefore
       a concurrent index scan is likely to fail to see the heap entry.
       This is okay because the index reader would be uninterested in an
       uncommitted row anyway.  But see <xref linkend="index-unique-checks"/>.)
      </para>
     </listitem>
     <listitem>
      <para>
       When a heap entry is to be deleted (by <command>VACUUM</command>), all its
       index entries must be removed first.
      </para>
     </listitem>
     <listitem>
      <para>
       An index scan must maintain a pin
       on the index page holding the item last returned by
       <function>amgettuple</function>, and <function>ambulkdelete</function> cannot delete
       entries from pages that are pinned by other backends.  The need
       for this rule is explained below.
      </para>
     </listitem>
    </itemizedlist>

   Without the third rule, it is possible for an index reader to
   see an index entry just before it is removed by <command>VACUUM</command>, and
   then to arrive at the corresponding heap entry after that was removed by
   <command>VACUUM</command>.
   This creates no serious problems if that item
   number is still unused when the reader reaches it, since an empty
   item slot will be ignored by <function>heap_fetch()</function>.  But what if a
   third backend has already re-used the item slot for something else?
   When using an MVCC-compliant snapshot, there is no problem because
   the new occupant of the slot is certain to be too new to pass the
   snapshot test.  However, with a non-MVCC-compliant snapshot (such as
   <literal>SnapshotAny</literal>), it would be possible to accept and return
   a row that does not in fact match the scan keys.  We could defend
   against this scenario by requiring the scan keys to be rechecked
   against the heap row in all cases, but that is too expensive.  Instead,
   we use a pin on an index page as a proxy to indicate that the reader
   might still be <quote>in flight</quote> from the index entry to the matching
   heap entry.  Making <function>ambulkdelete</function> block on such a pin ensures
   that <command>VACUUM</command> cannot delete the heap entry before the reader
   is done with it.  This solution costs little in run time, and adds blocking
   overhead only in the rare cases where there actually is a conflict.
  </para>
____________________________________________________________________________-->
  <para>
   除了索引自己内部的一致性要求之外，并发更新带来了一些父表（<firstterm>堆</firstterm>）和索引之 间的一致性问题。因为 <productname>PostgreSQL</productname>是把堆的访问和 更新与索引的访问和更新分开的，所以存在一些窗口期，在其间索引可能会与堆不一致。我们用下面的规则处理这样的问题：

    <itemizedlist>
     <listitem>
      <para>
       一个新堆项在其索引项之前被制作（因此并发的索引扫描很可能看不到堆项。这么做应该是可以的，因为索引的读取者对未提交的行不感兴趣。见<xref linkend="index-unique-checks"/>）。
      </para>
     </listitem>
     <listitem>
      <para>
       当一个堆项要被删除（通过<command>VACUUM</command>）时，它的所有索引项都必须首先删除。
      </para>
     </listitem>
     <listitem>
      <para>
       一次索引扫描必须在保存有<function>amgettuple</function>最后返回项的索引页面上维护一个 pin， 并且<function>ambulkdelete</function>不能从页面中删除被其他后端加 pin 的项。下面会解释需要这条规则的原因。
      </para>
     </listitem>
    </itemizedlist>

   没有第三条规则，那么一个索引读取者是可以在一条索引项被<command>VACUUM</command>删除之前看到它的，并且然后在<command>VACUUM</command>删除它之后找到其对应的堆项。如果读取者到达该项时，该项编号仍然没有被使用，那么这种 情况不会导致严重的问题，因为空的项槽位会被<function>heap_fetch()</function>忽略。 但是如果第三个后端已经为其它什么东西重用了这个项槽位又会怎样？在使用 MVCC  兼容的快照时，那么就不会有问题，因为槽位的新占据者太新了以至于无法通过快照测试。但是，对于非 MVCC 兼容的快照（例如 <literal>SnapshotAny</literal>），那么就有可能接受并返回一个实际上并不匹配扫描键的行。可以通过要求扫描键在所有情况下都在堆行上重新检查来避免这种情况，但是这种方法开销太大了。取而 代之的是，通过在索引页面上使用一个 pin 作为一个代理来表示，读取者可能还处于从索引项到匹配的堆项的<quote>过程中</quote>。用<function>ambulkdelete</function>来操作这样一个 pin 上的块确保<command>VACUUM</command>无法在读取者完成之前删除堆项。这种解决方案在运行时只有一点开销，而只是在真有一个冲突的非常罕见情况下才导致阻塞开销。
  </para>

<!--==========================orignal english content==========================
  <para>
   This solution requires that index scans be <quote>synchronous</quote>: we have
   to fetch each heap tuple immediately after scanning the corresponding index
   entry.  This is expensive for a number of reasons.  An
   <quote>asynchronous</quote> scan in which we collect many TIDs from the index,
   and only visit the heap tuples sometime later, requires much less index
   locking overhead and can allow a more efficient heap access pattern.
   Per the above analysis, we must use the synchronous approach for
   non-MVCC-compliant snapshots, but an asynchronous scan is workable
   for a query using an MVCC snapshot.
  </para>
____________________________________________________________________________-->
  <para>
   这个解决方法要求索引扫描是<quote>同步的</quote>：我们不得不在扫描完对应的索引项之后马上去取每个堆元组。这样的方案开销比较大，原因有多个。而一个<quote>异步的</quote>扫描可以先从索引里收集很多 TID ，并且在稍后的某个时间只访问堆元组，这样要求更少的索引锁定负荷并且能够允许一种更高效的堆访问模式。但是按照上面的分析，在非 MVCC 兼容的快照上我们必须使用同步方法，而异步扫描则适合于使用 MVCC 快照的查询。
  </para>

<!--==========================orignal english content==========================
  <para>
   In an <function>amgetbitmap</function> index scan, the access method does not
   keep an index pin on any of the returned tuples.  Therefore
   it is only safe to use such scans with MVCC-compliant snapshots.
  </para>
____________________________________________________________________________-->
  <para>
   在一个<function>amgetbitmap</function>索引扫描中，访问方法不会在任何被返回的元组上保持一个索引 pin。因此只有把这种扫描与 MVCC 兼容的快照一起使用才是安全的。
  </para>

<!--==========================orignal english content==========================
  <para>
   When the <structfield>ampredlocks</structfield> flag is not set, any scan using that
   index access method within a serializable transaction will acquire a
   nonblocking predicate lock on the full index.  This will generate a
   read-write conflict with the insert of any tuple into that index by a
   concurrent serializable transaction.  If certain patterns of read-write
   conflicts are detected among a set of concurrent serializable
   transactions, one of those transactions may be canceled to protect data
   integrity.  When the flag is set, it indicates that the index access
   method implements finer-grained predicate locking, which will tend to
   reduce the frequency of such transaction cancellations.
  </para>
____________________________________________________________________________-->
  <para>
   当<structfield>ampredlocks</structfield>标志没有被设置时，在一个可序列化事务中使用该索引访问方法的任何扫描将在整个索引上获取一个非阻塞的谓词锁。这将和一个并发可序列化事务中项索引中插入任何元组发生读-写冲突。如果在一组并发可序列化事务之间检测到特定模式的读-写冲突，其中一个事务可能会被取消来保护数据完整性。当该标志被设置，它表示该索引访问方法实现了细粒度的谓词锁，这将有望缩减这种事务取消的频率。
  </para>

 </sect1>

 <sect1 id="index-unique-checks">
<!--==========================orignal english content==========================
  <title>Index Uniqueness Checks</title>
____________________________________________________________________________-->
  <title>索引唯一性检查</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> enforces SQL uniqueness constraints
   using <firstterm>unique indexes</firstterm>, which are indexes that disallow
   multiple entries with identical keys.  An access method that supports this
   feature sets <structfield>amcanunique</structfield> true.
   (At present, only b-tree supports it.)  Columns listed in the
   <literal>INCLUDE</literal> clause are not considered when enforcing
   uniqueness.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>使用<firstterm>唯一索引</firstterm>来强制 SQL 唯一性约束，唯一 索引实际上是不允许多个项有相同键的索引。一个支持这个特性的访问方法要 设置<structfield>amcanunique</structfield>为真（目前，只有 b-tree 支持它）。在强制唯一性时不会考虑<literal>INCLUDE</literal>子句中列出的列。
  </para>

<!--==========================orignal english content==========================
  <para>
   Because of MVCC, it is always necessary to allow duplicate entries to
   exist physically in an index: the entries might refer to successive
   versions of a single logical row.  The behavior we actually want to
   enforce is that no MVCC snapshot could include two rows with equal
   index keys.  This breaks down into the following cases that must be
   checked when inserting a new row into a unique index:

    <itemizedlist>
     <listitem>
      <para>
       If a conflicting valid row has been deleted by the current transaction,
       it's okay.  (In particular, since an UPDATE always deletes the old row
       version before inserting the new version, this will allow an UPDATE on
       a row without changing the key.)
      </para>
     </listitem>
     <listitem>
      <para>
       If a conflicting row has been inserted by an as-yet-uncommitted
       transaction, the would-be inserter must wait to see if that transaction
       commits.  If it rolls back then there is no conflict.  If it commits
       without deleting the conflicting row again, there is a uniqueness
       violation.  (In practice we just wait for the other transaction to
       end and then redo the visibility check in toto.)
      </para>
     </listitem>
     <listitem>
      <para>
       Similarly, if a conflicting valid row has been deleted by an
       as-yet-uncommitted transaction, the would-be inserter must wait
       for that transaction to commit or abort, and then repeat the test.
      </para>
     </listitem>
    </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   因为 MVCC，必须允许重复的项在物理上存在于索引之中：这些项可能指向某个单一逻辑行的后继版本。实际想强制的行为是，任何 MVCC 快照都不能包含两个具有相同索引键的行。在向一个唯一索引中插入一个新行时需要被检查的情况可分解成：

    <itemizedlist>
     <listitem>
      <para>
       如果一个有冲突的合法行已被当前事务删除，这是可以的（特别是因为一个  UPDATE 总是在插入新版本之前删除旧版本，这样就允许一个行上的UPDATE 不改变键）。
      </para>
     </listitem>
     <listitem>
      <para>
       如果一个有冲突的行已经被还未提交的事务插入，那么准备插入的事务必须等待看看前面那个事务是否提交。如果它回滚额不会有冲突。如果它提交并且没有删除存在冲突的行，则有一个唯一性违背（实际上我们只是等待那个其他事务结束，然后在全部事务里重做可见性检查）。
      </para>
     </listitem>
     <listitem>
      <para>
       类似的，如果一个有冲突的有效行被一个准备提交的事务删除，那么另外一个准备插入的事务必须等待该事务提交或者退出，然后重做测试。
      </para>
     </listitem>
    </itemizedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Furthermore, immediately before reporting a uniqueness violation
   according to the above rules, the access method must recheck the
   liveness of the row being inserted.  If it is committed dead then
   no violation should be reported.  (This case cannot occur during the
   ordinary scenario of inserting a row that's just been created by
   the current transaction.  It can happen during
   <command>CREATE UNIQUE INDEX CONCURRENTLY</command>, however.)
  </para>
____________________________________________________________________________-->
  <para>
   此外，在根据上述规则报告唯一性违背之前，访问方法必须重新检查刚被插入的行的存活性。如果已经因为事务的提交而死亡，那么不应当报告任何违背（这种情况不可能出现在插入在同一事务中创建的行的普通场景中。但是在<command>CREATE UNIQUE INDEX CONCURRENTLY</command>的过程中是可能发生的）。
  </para>

<!--==========================orignal english content==========================
  <para>
   We require the index access method to apply these tests itself, which
   means that it must reach into the heap to check the commit status of
   any row that is shown to have a duplicate key according to the index
   contents.  This is without a doubt ugly and non-modular, but it saves
   redundant work: if we did a separate probe then the index lookup for
   a conflicting row would be essentially repeated while finding the place to
   insert the new row's index entry.  What's more, there is no obvious way
   to avoid race conditions unless the conflict check is an integral part
   of insertion of the new index entry.
  </para>
____________________________________________________________________________-->
  <para>
   要求索引访问方法自己应用这些测试，这就意味着它必须到达堆来查看那些根据 索引内容有重复键的任意行的提交状态。这无疑是丑陋并且非模块化的，但是这样可以节约重复的工作：如果我们进行一次独立的探测，那么查找一个冲突行的索引查找本质上将在查找插入新行索引项位置时被重复。此外，没有很明显的方法来避免竞争情况，除非冲突检查是插入新索引项动作的一部分。
  </para>

<!--==========================orignal english content==========================
  <para>
   If the unique constraint is deferrable, there is additional complexity:
   we need to be able to insert an index entry for a new row, but defer any
   uniqueness-violation error until end of statement or even later.  To
   avoid unnecessary repeat searches of the index, the index access method
   should do a preliminary uniqueness check during the initial insertion.
   If this shows that there is definitely no conflicting live tuple, we
   are done.  Otherwise, we schedule a recheck to occur when it is time to
   enforce the constraint.  If, at the time of the recheck, both the inserted
   tuple and some other tuple with the same key are live, then the error
   must be reported.  (Note that for this purpose, <quote>live</quote> actually
   means <quote>any tuple in the index entry's HOT chain is live</quote>.)
   To implement this, the <function>aminsert</function> function is passed a
   <literal>checkUnique</literal> parameter having one of the following values:

    <itemizedlist>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_NO</literal> indicates that no uniqueness checking
       should be done (this is not a unique index).
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_YES</literal> indicates that this is a non-deferrable
       unique index, and the uniqueness check must be done immediately, as
       described above.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_PARTIAL</literal> indicates that the unique
       constraint is deferrable. <productname>PostgreSQL</productname>
       will use this mode to insert each row's index entry.  The access
       method must allow duplicate entries into the index, and report any
       potential duplicates by returning false from <function>aminsert</function>.
       For each row for which false is returned, a deferred recheck will
       be scheduled.
      </para>

      <para>
       The access method must identify any rows which might violate the
       unique constraint, but it is not an error for it to report false
       positives. This allows the check to be done without waiting for other
       transactions to finish; conflicts reported here are not treated as
       errors and will be rechecked later, by which time they may no longer
       be conflicts.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_EXISTING</literal> indicates that this is a deferred
       recheck of a row that was reported as a potential uniqueness violation.
       Although this is implemented by calling <function>aminsert</function>, the
       access method must <emphasis>not</emphasis> insert a new index entry in this
       case.  The index entry is already present.  Rather, the access method
       must check to see if there is another live index entry.  If so, and
       if the target row is also still live, report error.
      </para>

      <para>
       It is recommended that in a <literal>UNIQUE_CHECK_EXISTING</literal> call,
       the access method further verify that the target row actually does
       have an existing entry in the index, and report error if not.  This
       is a good idea because the index tuple values passed to
       <function>aminsert</function> will have been recomputed.  If the index
       definition involves functions that are not really immutable, we
       might be checking the wrong area of the index.  Checking that the
       target row is found in the recheck verifies that we are scanning
       for the same tuple values as were used in the original insertion.
      </para>
     </listitem>
    </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   如果唯一约束是可延迟的，就存在额外的复杂性：我们需要能够为一个新行插入一个索引项，但是推迟任何唯一性违背错误直到语句结束或者更晚。为了避免对索引不必要的重复搜索，索引访问方法应该在初始插入过程中做一次初步的唯一性检查。如果显示绝对不会有冲突的活元组，就可以完成。否则，我们计划一次重新检查，它将在强制约束的时候发生。在重新检查时，如果具有相同键的被插入元组和某个其他元组都活着，则必须报告错误（注意为了这个目的，“活着”实际意味着“在索引项的 HOT 链上的任何元组都活着”）。要实现这一点，需要给 aminsert 传递一个 checkUnique 参数，其中包含下列值之一：

    <itemizedlist>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_NO</literal>表明不需要做唯一性检测（这不是一个唯一索引）。
      </para>
     </listitem>
     <listitem>
      <para>
       如上所述，<literal>UNIQUE_CHECK_YES</literal>表明有一个不可延迟的唯 一索引，并且必须立即做唯一性检测。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_PARTIAL</literal>表明唯一性约束是可延迟的。<productname>PostgreSQL</productname>将会用这个模式来插入每一行的索引项。访问方法必须允许重复的项进入索引，并且通过从	<function>aminsert</function>返回 FALSE 来报告任何可能的重复。对于返回 FALSE 的每一行，将计划一个延迟的重新检查。
      </para>

      <para>
       访问方法必须能够标识任何可能违反唯一约束的行，但是对它来说假阳性报告不是错误。这样就允许检查不用等到其他事务都结束；这里报告的冲突不会被当做错误来看待，并且随后将会被重新检查，而到那时它们可能不再是冲突了。
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>UNIQUE_CHECK_EXISTING</literal>表明这是一个行的延迟重新检查，该行被报告为一个潜在的唯一性违背。尽管这会通过调用<function>aminsert</function>来实现，在这种情况下这个访问方法<emphasis>不</emphasis>能插入一个新索引项。该索引项已经存在。 当然，访问方法必须检查是否有另一个活着的索引项。如果有，并且如果目标行也仍然存活，那么报告错误。
      </para>

      <para>
       我们推荐，在一个<literal>UNIQUE_CHECK_EXISTING</literal>调用中，访问方法进一步验证目标行真的在索引中有一个现有的项，并且如果不是这样就报错。这是个好主意，因为被传到<function>aminsert</function>的索引元组值将已经被重新计算过。如果索引定义涉及不是真正不变的函数，我们可能正在检查索引的错误区域。对重新检查中找到的目标行的检查会验证我们正在扫描之前被用于原始插入的同一元组值。
      </para>
     </listitem>
    </itemizedlist>
  </para>

 </sect1>

 <sect1 id="index-cost-estimation">
<!--==========================orignal english content==========================
  <title>Index Cost Estimation Functions</title>
____________________________________________________________________________-->
  <title>索引开销估计函数</title>

<!--==========================orignal english content==========================
  <para>
   The <function>amcostestimate</function> function is given information describing
   a possible index scan, including lists of WHERE and ORDER BY clauses that
   have been determined to be usable with the index.  It must return estimates
   of the cost of accessing the index and the selectivity of the WHERE
   clauses (that is, the fraction of parent-table rows that will be
   retrieved during the index scan).  For simple cases, nearly all the
   work of the cost estimator can be done by calling standard routines
   in the optimizer; the point of having an <function>amcostestimate</function> function is
   to allow index access methods to provide index-type-specific knowledge,
   in case it is possible to improve on the standard estimates.
  </para>
____________________________________________________________________________-->
  <para>
   <function>amcostestimate</function>函数被给定描述一个可能的索引扫描的信息，包括决定在索引中使用的 WHERE 和 ORDER BY 子句的列表。它必须返回访问该索引的开销估计以及 WHERE 子句的选择度（也就是说，在索引扫描期间将检索的行在父表中所占据的比例）。对于简单情况，几乎开销估计器的所有工作都可以通过调用优化器中的标准过程完成；有<function>amcostestimate</function>函数的目的是允许索引访问方法提供和索引类型相关的知识，这种情况下可以改进标准的估计。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each <function>amcostestimate</function> function must have the signature:

<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>

   The first three parameters are inputs:

   <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>
       The planner's information about the query being processed.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
       The index access path being considered.  All fields except cost and
       selectivity values are valid.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>
       The number of repetitions of the index scan that should be factored
       into the cost estimates.  This will typically be greater than one when
       considering a parameterized scan for use in the inside of a nestloop
       join.  Note that the cost estimates should still be for just one scan;
       a larger <parameter>loop_count</parameter> means that it may be appropriate
       to allow for some caching effects across multiple scans.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   每个<function>amcostestimate</function>函数的签名必须是：

<programlisting>
void
amcostestimate (PlannerInfo *root,
                IndexPath *path,
                double loop_count,
                Cost *indexStartupCost,
                Cost *indexTotalCost,
                Selectivity *indexSelectivity,
                double *indexCorrelation,
                double *indexPages);
</programlisting>

   前三个参数是输入参数：

   <variablelist>
    <varlistentry>
     <term><parameter>root</parameter></term>
     <listitem>
      <para>
       规划器的有关正在被处理的查询的信息。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>path</parameter></term>
     <listitem>
      <para>
       被考虑的索引访问路径。其中除了开销和选择度值之外的域都有效。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>loop_count</parameter></term>
     <listitem>
      <para>
       应该被开销估计所考虑的索引扫描重复次数。当考虑用在一个嵌套循环连接中的参数化扫描时，这个参数通常会大于 1 。注意代价估计应该仍然是对于一次扫描的，一个更大的<parameter>loop_count</parameter>意味着可能在多次扫描间允许一些缓冲效果比较合适。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   The last five parameters are pass-by-reference outputs:

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>
       Set to cost of index start-up processing
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>
       Set to total cost of index processing
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>
       Set to index selectivity
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>
       Set to correlation coefficient between index scan order and
       underlying table's order
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexPages</parameter></term>
     <listitem>
      <para>
       Set to number of index leaf pages
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
____________________________________________________________________________-->
  <para>
   后四个参数是传引用的输出参数：

   <variablelist>
    <varlistentry>
     <term><parameter>*indexStartupCost</parameter></term>
     <listitem>
      <para>
       设置为索引启动处理的开销。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexTotalCost</parameter></term>
     <listitem>
      <para>
       设置为索引处理的总开销。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexSelectivity</parameter></term>
     <listitem>
      <para>
       设置为索引的选择度。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexCorrelation</parameter></term>
     <listitem>
      <para>
       设置为索引扫描顺序和下层的表的顺序之间的相关性。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>*indexPages</parameter></term>
     <listitem>
      <para>
       设置为索引叶子页的数量
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that cost estimate functions must be written in C, not in SQL or
   any available procedural language, because they must access internal
   data structures of the planner/optimizer.
  </para>
____________________________________________________________________________-->
  <para>
   请注意开销估计函数必须用 C 编写，而不能用 SQL 或者任何可用的过程语言，因为它们必须访问规划器/优化器的内部数据结构。
  </para>

<!--==========================orignal english content==========================
  <para>
   The index access costs should be computed using the parameters used by
   <filename>src/backend/optimizer/path/costsize.c</filename>: a sequential
   disk block fetch has cost <varname>seq_page_cost</varname>, a nonsequential fetch
   has cost <varname>random_page_cost</varname>, and the cost of processing one index
   row should usually be taken as <varname>cpu_index_tuple_cost</varname>.  In
   addition, an appropriate multiple of <varname>cpu_operator_cost</varname> should
   be charged for any comparison operators invoked during index processing
   (especially evaluation of the indexquals themselves).
  </para>
____________________________________________________________________________-->
  <para>
   索引访问开销应该采用被<filename>src/backend/optimizer/path/costsize.c</filename>使用的参数进行计算：一次顺序磁盘块获取的开销是<varname>seq_page_cost</varname>、一次非顺序获取的开销是<varname>random_page_cost</varname>并且处理一个索引行的开销通常应该是<varname>cpu_index_tuple_cost</varname>。另外，在索引处理期间（尤其是索引条件本身的计算）调用的任何比较操作符都会耗费<varname>cpu_operator_cost</varname>倍数的开销。
  </para>

<!--==========================orignal english content==========================
  <para>
   The access costs should include all disk and CPU costs associated with
   scanning the index itself, but <emphasis>not</emphasis> the costs of retrieving or
   processing the parent-table rows that are identified by the index.
  </para>
____________________________________________________________________________-->
  <para>
   访问开销应该包括所有与扫描索引本身相关的磁盘和 CPU 开销，但是<emphasis>不</emphasis>包括检索或者处理被索引标识出来的父表行的开销。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <quote>start-up cost</quote> is the part of the total scan cost that
   must be expended before we can begin to fetch the first row.  For most
   indexes this can be taken as zero, but an index type with a high start-up
   cost might want to set it nonzero.
  </para>
____________________________________________________________________________-->
  <para>
   <quote>启动开销</quote>是整个扫描开销中的一部分：在能够开始取第一行之前必须花掉的开销。对于大多数索引这个开销是零，但 是那些启动开销很大的索引类型不会把它设置为零。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <parameter>indexSelectivity</parameter> should be set to the estimated fraction of the parent
   table rows that will be retrieved during the index scan.  In the case
   of a lossy query, this will typically be higher than the fraction of
   rows that actually pass the given qual conditions.
  </para>
____________________________________________________________________________-->
  <para>
   <parameter>indexSelectivity</parameter>应该设置成在索引扫描期间，父表行被检索的估计比例。在一个有损查询的情况下，这个值通常高于实际通过 给定查询条件的行的比例。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <parameter>indexCorrelation</parameter> should be set to the correlation (ranging between
   -1.0 and 1.0) between the index order and the table order.  This is used
   to adjust the estimate for the cost of fetching rows from the parent
   table.
  </para>
____________________________________________________________________________-->
  <para>
   <parameter>indexCorrelation</parameter>应该被设置成索引顺序和表顺序之间的相关性（范围从 -1.0 到 1.0）。这个数值被用于调整从父表中取出行的开销估计。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <parameter>indexPages</parameter> should be set to the number of leaf pages.
   This is used to estimate the number of workers for parallel index scan.
  </para>
____________________________________________________________________________-->
  <para>
   <parameter>indexPages</parameter>应该被设置为叶子页面的数量。它会被用来估算并行索引扫描用到的工作者的数目。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <parameter>loop_count</parameter> is greater than one, the returned numbers
   should be averages expected for any one scan of the index.
  </para>
____________________________________________________________________________-->
  <para>
   当<parameter>loop_count</parameter>大于一时，返回的数应该是该索引任何一次扫描的平均期望值。
  </para>

  <procedure>
<!--==========================orignal english content==========================
   <title>Cost Estimation</title>
____________________________________________________________________________-->
   <title>开销估计</title>
<!--==========================orignal english content==========================
   <para>
    A typical cost estimator will proceed as follows:
   </para>
____________________________________________________________________________-->
   <para>
    一个典型的开销估计器会像下面这样进行处理：
   </para>

   <step>
<!--==========================orignal english content==========================
    <para>
     Estimate and return the fraction of parent-table rows that will be visited
     based on the given qual conditions.  In the absence of any index-type-specific
     knowledge, use the standard optimizer function <function>clauselist_selectivity()</function>:

<programlisting>
*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     基于给出的条件情况，估计并返回父表行将被访问的比例。如果缺乏索引类型相关的知识，那么使用标准的优化器函数<function>clauselist_selectivity()</function>：

<programlisting>
*indexSelectivity = clauselist_selectivity(root, path-&gt;indexquals,
                                           path-&gt;indexinfo-&gt;rel-&gt;relid,
                                           JOIN_INNER, NULL);
</programlisting>
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Estimate the number of index rows that will be visited during the
     scan.  For many index types this is the same as <parameter>indexSelectivity</parameter> times
     the number of rows in the index, but it might be more.  (Note that the
     index's size in pages and rows is available from the
     <literal>path-&gt;indexinfo</literal> struct.)
    </para>
____________________________________________________________________________-->
    <para>
     估计在扫描过程中将被访问的索引行数。对于许多索引类型，这个等于<parameter>indexSelectivity</parameter>乘以索引中的行数，但是可能更多（请注意，页面和行中的索引尺寸从<literal>path-&gt;indexinfo</literal>结构中获得）。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Estimate the number of index pages that will be retrieved during the scan.
     This might be just <parameter>indexSelectivity</parameter> times the index's size in pages.
    </para>
____________________________________________________________________________-->
    <para>
     估计在扫描中将检索的索引页面数量。这个可能就是<parameter>indexSelectivity</parameter>乘以索引的总页面数。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Compute the index access cost.  A generic estimator might do this:

<programlisting>
/*
 * Our generic assumption is that the index pages will be read
 * sequentially, so they cost seq_page_cost each, not random_page_cost.
 * Also, we charge for evaluation of the indexquals at each index row.
 * All the costs are assumed to be paid incrementally during the scan.
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     However, the above does not account for amortization of index reads
     across repeated index scans.
    </para>
____________________________________________________________________________-->
    <para>
     计算索引访问开销。一个通用的估计器可能会：

<programlisting>
/*
 * Our generic assumption is that the index pages will be read
 * sequentially, so they cost seq_page_cost each, not random_page_cost.
 * Also, we charge for evaluation of the indexquals at each index row.
 * All the costs are assumed to be paid incrementally during the scan.
 */
cost_qual_eval(&amp;index_qual_cost, path-&gt;indexquals, root);
*indexStartupCost = index_qual_cost.startup;
*indexTotalCost = seq_page_cost * numIndexPages +
    (cpu_index_tuple_cost + index_qual_cost.per_tuple) * numIndexTuples;
</programlisting>

     不过，上面没有考虑重复索引扫描间的索引读分期补偿（amortization）。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Estimate the index correlation.  For a simple ordered index on a single
     field, this can be retrieved from pg_statistic.  If the correlation
     is not known, the conservative estimate is zero (no correlation).
    </para>
____________________________________________________________________________-->
    <para>
     估计索引的相关性。对于一个简单的在单列有序索引，这个值可以从 pg_statistic 中检索。如果相关性是未知，那么保守的估计是零（没有相关性）。
    </para>
   </step>
  </procedure>

<!--==========================orignal english content==========================
  <para>
   Examples of cost estimator functions can be found in
   <filename>src/backend/utils/adt/selfuncs.c</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   开销估计器函数的例子可以在<filename>src/backend/utils/adt/selfuncs.c</filename>中找到。
  </para>
 </sect1>
</chapter>
