<!-- doc/src/sgml/protocol.sgml -->

<chapter id="protocol">
<!--==========================orignal english content==========================
 <title>Frontend/Backend Protocol</title>
____________________________________________________________________________-->
 <title>前端/后端协议</title>

<!--==========================orignal english content==========================
 <indexterm zone="protocol">
  <primary>protocol</primary>
  <secondary>frontend-backend</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="protocol">
  <primary>协议</primary>
  <secondary>前端-后端</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> uses a message-based protocol
  for communication between frontends and backends (clients and servers).
  The protocol is supported over <acronym>TCP/IP</acronym> and also over
  Unix-domain sockets.  Port number 5432 has been registered with IANA as
  the customary TCP port number for servers supporting this protocol, but
  in practice any non-privileged port number can be used.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>使用一种基于消息的协议用于前端和后端（服务器和客户机）之间通讯。该协议是在<acronym>TCP/IP</acronym>和Unix 域套接字上实现的。端口号 5432 已经在IANA 注册为支持这种协议的服务器的常用端口，但实际上任何非特权端口号都可以使用。
 </para>

<!--==========================orignal english content==========================
 <para>
  This document describes version 3.0 of the protocol, implemented in
  <productname>PostgreSQL</productname> 7.4 and later.  For descriptions
  of the earlier protocol versions, see previous releases of the
  <productname>PostgreSQL</productname> documentation.  A single server
  can support multiple protocol versions.  The initial startup-request
  message tells the server which protocol version the client is attempting to
  use.  If the major version requested by the client is not supported by
  the server, the connection will be rejected (for example, this would occur
  if the client requested protocol version 4.0, which does not exist as of
  this writing).  If the minor version requested by the client is not
  supported by the server (e.g. the client requests version 3.1, but the
  server supports only 3.0), the server may either reject the connection or
  may respond with a NegotiateProtocolVersion message containing the highest
  minor protocol version which it supports.  The client may then choose either
  to continue with the connection using the specified protocol version or
  to abort the connection.
 </para>
____________________________________________________________________________-->
 <para>
  这份文档描述了版本3.0的协议，它在<productname>PostgreSQL</productname>版本 7.4 和以后的版本中实现。对于以前版本协议的描述，请参考以前版本的<productname>PostgreSQL</productname>文档。一台服务器能够支持多种协议版本。初始的启动请求消息告诉服务器客户端尝试使用哪个协议版本。如果客户端请求的主版本不被服务器支持，连接将被拒绝（例如，如果客户端请求的协议版本是4.0就会发生这种情况，因为在写作这份文档时，4.0根本还不存在）。如果客户端请求的次版本不被服务器支持（例如客户端请求版本3.1，但服务器仅支持3.0），服务器可能会拒绝该连接或者用一个包含它支持的最高次协议版本的NegotiateProtocolVersion消息进行响应。然后客户端可以选择使用指定的协议版本继续连接或者中止连接。
 </para>

<!--==========================orignal english content==========================
  <para>
   In order to serve multiple clients efficiently, the server launches
   a new <quote>backend</quote> process for each client.
   In the current implementation, a new child
   process is created immediately after an incoming connection is detected.
   This is transparent to the protocol, however.  For purposes of the
   protocol, the terms <quote>backend</quote> and <quote>server</quote> are
   interchangeable; likewise <quote>frontend</quote> and <quote>client</quote>
   are interchangeable.
  </para>
____________________________________________________________________________-->
  <para>
   为了可以有效地为多个客户端提供服务，服务器为每个客户端派生一个新的<quote>后端</quote>进程。 在目前的实现里，在检测到新来的连接请求后，马上创建一个新的子进程。 不过，这些是对协议透明的。对于协议而言，术语<quote>后端</quote>和<quote>服务器</quote>是可以互换的； 类似的还有<quote>前端</quote>和<quote>客户端</quote>也是可以互换的。
  </para>

 <sect1 id="protocol-overview">
<!--==========================orignal english content==========================
  <title>Overview</title>
____________________________________________________________________________-->
  <title>概述</title>

<!--==========================orignal english content==========================
  <para>
   The protocol has separate phases for startup and normal operation.
   In the startup phase, the frontend opens a connection to the server
   and authenticates itself to the satisfaction of the server.  (This might
   involve a single message, or multiple messages depending on the
   authentication method being used.)  If all goes well, the server then sends
   status information to the frontend, and finally enters normal operation.
   Except for the initial startup-request message, this part of the
   protocol is driven by the server.
  </para>
____________________________________________________________________________-->
  <para>
   协议在启动和正常操作过程中有不同的阶段。在启动阶段里，前端打开一个到服务器的连接并且认证自身以满足服务器（这可能涉及到一条或多条消息，取决于使用的认证方法）。 如果一切正常，服务器就发送状态信息给前端，并最后进入正常操作。除了最初的启动请求消息之外，协议的这个部分是服务器驱动的。
  </para>

<!--==========================orignal english content==========================
  <para>
   During normal operation, the frontend sends queries and
   other commands to the backend, and the backend sends back query results
   and other responses.  There are a few cases (such as <command>NOTIFY</command>)
   wherein the
   backend will send unsolicited messages, but for the most part this portion
   of a session is driven by frontend requests.
  </para>
____________________________________________________________________________-->
  <para>
   在正常操作中，前端发送查询和其它命令到后端，然后后端返回查询结果和其它响应。在少数几种情况（比如<command>NOTIFY</command>）中，后端会发送未被请求的消息，但这个会话中的绝大多部分都是由前端请求驱动的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Termination of the session is normally by frontend choice, but can be
   forced by the backend in certain cases.  In any case, when the backend
   closes the connection, it will roll back any open (incomplete) transaction
   before exiting.
  </para>
____________________________________________________________________________-->
  <para>
   会话的终止通常是由前端来选择的，但是也可以在某些情况下由后端强制执行。不管在那种情况下，如果后端关闭连接，那么它将在退出之前回滚所有打开的（未完成的）事务。
  </para>

<!--==========================orignal english content==========================
  <para>
   Within normal operation, SQL commands can be executed through either of
   two sub-protocols.  In the <quote>simple query</quote> protocol, the frontend
   just sends a textual query string, which is parsed and immediately
   executed by the backend.  In the <quote>extended query</quote> protocol,
   processing of queries is separated into multiple steps: parsing,
   binding of parameter values, and execution.  This offers flexibility
   and performance benefits, at the cost of extra complexity.
  </para>
____________________________________________________________________________-->
  <para>
   在正常操作中，SQL命令可以通过两个子协议中的任何一个执行。 在<quote>简单查询</quote>协议中，前端只是发送一个文本查询串， 然后后端马上分析并执行它。在<quote>扩展查询</quote>协议中， 查询的处理被分割为多个步骤：分析、参数值绑定和执行。这样就可以提供灵活性和性能的改进，但代价是额外的复杂性。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normal operation has additional sub-protocols for special operations
   such as <command>COPY</command>.
  </para>
____________________________________________________________________________-->
  <para>
   正常操作还有用于类似<command>COPY</command>这样的额外的子协议。
  </para>

 <sect2 id="protocol-message-concepts">
<!--==========================orignal english content==========================
  <title>Messaging Overview</title>
____________________________________________________________________________-->
  <title>消息概貌</title>

<!--==========================orignal english content==========================
  <para>
   All communication is through a stream of messages.  The first byte of a
   message identifies the message type, and the next four bytes specify the
   length of the rest of the message (this length count includes itself, but
   not the message-type byte).  The remaining contents of the message are
   determined by the message type.  For historical reasons, the very first
   message sent by the client (the startup message) has no initial
   message-type byte.
  </para>
____________________________________________________________________________-->
  <para>
   所有通讯都是通过一个消息流进行的。消息的第一个字节标识消息类型， 然后后面跟着的四个字节声明消息剩下部分的长度（这个长度包括长度域自身，但是不包括消息类型字节）。 剩下的消息内容由消息类型决定。由于历史原因，客户端发送的最初的消息（启动消息）不包含消息类型字节。
  </para>

<!--==========================orignal english content==========================
  <para>
   To avoid losing synchronization with the message stream, both servers and
   clients typically read an entire message into a buffer (using the byte
   count) before attempting to process its contents.  This allows easy
   recovery if an error is detected while processing the contents.  In
   extreme situations (such as not having enough memory to buffer the
   message), the receiver can use the byte count to determine how much
   input to skip before it resumes reading messages.
  </para>
____________________________________________________________________________-->
  <para>
   为了避免失去与消息流的同步，服务器和客户端通常都是把整个消息读取到一个缓冲区里（使用字节计数）， 然后才试图处理其内容。这样在处理内容的过程时如果发现错误，就比较容易恢复。 在非常极端的情况下（比如说没有足够的内存缓冲消息），接收端可以使用字节计数来判断它在继续读取消息之前需要跳过多少输入。
  </para>

<!--==========================orignal english content==========================
  <para>
   Conversely, both servers and clients must take care never to send an
   incomplete message.  This is commonly done by marshaling the entire message
   in a buffer before beginning to send it.  If a communications failure
   occurs partway through sending or receiving a message, the only sensible
   response is to abandon the connection, since there is little hope of
   recovering message-boundary synchronization.
  </para>
____________________________________________________________________________-->
  <para>
   反之，服务器和客户端都需要注意决不能发送一条不完整的消息。保证这一点的方法通常是在发送整条信息之前先在一个缓冲区里整理整条消息。 如果在发送或者接受一条消息的中间发生了通讯错误，那么唯一合理的响应是放弃连接，因为恢复消息边界同步的希望很小。
  </para>
 </sect2>

  <sect2 id="protocol-query-concepts">
<!--==========================orignal english content==========================
   <title>Extended Query Overview</title>
____________________________________________________________________________-->
   <title>扩展查询概述</title>

<!--==========================orignal english content==========================
   <para>
    In the extended-query protocol, execution of SQL commands is divided
    into multiple steps.  The state retained between steps is represented
    by two types of objects: <firstterm>prepared statements</firstterm> and
    <firstterm>portals</firstterm>.  A prepared statement represents the result of
    parsing and semantic analysis of a textual query string.
    A prepared statement is not in itself ready to execute, because it might
    lack specific values for <firstterm>parameters</firstterm>.  A portal represents
    a ready-to-execute or already-partially-executed statement, with any
    missing parameter values filled in.  (For <command>SELECT</command> statements,
    a portal is equivalent to an open cursor, but we choose to use a different
    term since cursors don't handle non-<command>SELECT</command> statements.)
   </para>
____________________________________________________________________________-->
   <para>
    在扩展查询协议中，SQL命令的执行是分割成多个步骤的。步骤与步骤之间保存的状态是由两类的对象代表的：<firstterm>预备语句</firstterm>（prepared statements）和<firstterm>入口</firstterm>（portals）。 一个预备语句代表一个文本查询字符串的经过分析、语意解析以及规划之后的结果。一个预备语句不代表它已经可以被执行，因为它可能还缺乏 <firstterm>参数</firstterm>的值。 一个入口代表一个已经可以执行的或者已经被部分执行过的语句，所有缺失的参数值都已经填充到位了（对于<command>SELECT</command>语句，入口等效于一个打开的游标， 但我们使用不同的术语是因为游标不能处理非<command>SELECT</command>语句）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The overall execution cycle consists of a <firstterm>parse</firstterm> step,
    which creates a prepared statement from a textual query string; a
    <firstterm>bind</firstterm> step, which creates a portal given a prepared
    statement and values for any needed parameters; and an
    <firstterm>execute</firstterm> step that runs a portal's query.  In the case of
    a query that returns rows (<command>SELECT</command>, <command>SHOW</command>, etc),
    the execute step can be told to fetch only
    a limited number of rows, so that multiple execute steps might be needed
    to complete the operation.
   </para>
____________________________________________________________________________-->
   <para>
    完整的执行周期包括一个<firstterm>分析</firstterm>步骤， 它从一个文本的查询字符串里创建一个预备语句； 一个<firstterm>绑定</firstterm>步骤， 它用一个预备语句和任何所需的参数值创建一个入口；以及一个<firstterm>执行</firstterm>步骤，它运行一个入口中的查询。如果查询会返回数据行（<command>SELECT</command>、<command>SHOW</command>等）， 执行步骤会被告知只抓取有限的一些行，这样就可能需要多个执行步骤来完成操作。
   </para>

<!--==========================orignal english content==========================
   <para>
    The backend can keep track of multiple prepared statements and portals
    (but note that these exist only within a session, and are never shared
    across sessions).  Existing prepared statements and portals are
    referenced by names assigned when they were created.  In addition,
    an <quote>unnamed</quote> prepared statement and portal exist.  Although these
    behave largely the same as named objects, operations on them are optimized
    for the case of executing a query only once and then discarding it,
    whereas operations on named objects are optimized on the expectation
    of multiple uses.
   </para>
____________________________________________________________________________-->
   <para>
    后端可以跟踪多个预备语句和入口（但是要注意，这些只存在于一个会话内部，不能在会话之间共享）。现有的预备语句和入口都是用创建它们的时候赋予的名字引用的。 另外，还存在一个<quote>未命名</quote> 的预备语句和入口。 尽管它们的行为和命名对象大部分相同，但是它们是针对只执行一次然后就抛弃的查询而优化的， 而在命名对象上的操作是针对多次使用而优化的。
   </para>
  </sect2>

  <sect2 id="protocol-format-codes">
<!--==========================orignal english content==========================
   <title>Formats and Format Codes</title>
____________________________________________________________________________-->
   <title> 格式和格式代码</title>

<!--==========================orignal english content==========================
   <para>
    Data of a particular data type might be transmitted in any of several
    different <firstterm>formats</firstterm>.  As of <productname>PostgreSQL</productname> 7.4
    the only supported formats are <quote>text</quote> and <quote>binary</quote>,
    but the protocol makes provision for future extensions.  The desired
    format for any value is specified by a <firstterm>format code</firstterm>.
    Clients can specify a format code for each transmitted parameter value
    and for each column of a query result.  Text has format code zero,
    binary has format code one, and all other format codes are reserved
    for future definition.
   </para>
____________________________________________________________________________-->
   <para>
    特定数据类型的数据可以用几种不同的<firstterm>格式</firstterm>中的任意一种来传递。 从<productname>PostgreSQL</productname> 7.4开始，只支持<quote>文本</quote>和<quote>二进制</quote>两种格式， 但是协议为未来的扩展提供了的手段。任意值要求的格式用一个<firstterm>格式代码</firstterm>声明。 客户端可以为每个传输的参数值和查询结果的每个列指定一个格式代码。 文本的格式代码是零，二进制的格式代码是一，所有其它的格式代码都保留给将来定义。
   </para>

<!--==========================orignal english content==========================
   <para>
    The text representation of values is whatever strings are produced
    and accepted by the input/output conversion functions for the
    particular data type.  In the transmitted representation, there is
    no trailing null character; the frontend must add one to received
    values if it wants to process them as C strings.
    (The text format does not allow embedded nulls, by the way.)
   </para>
____________________________________________________________________________-->
   <para>
    文本形式的数值是特定数据类型的输入/输出转换函数生成或接受的任何字符串。在传输形式上，字符串没有末尾空字符；如果前端要想把收到的值当作C字符串处理，那么必须自己加上一个（顺便说一下，文本格式不允许嵌入空字符）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Binary representations for integers use network byte order (most
    significant byte first).  For other data types consult the documentation
    or source code to learn about the binary representation.  Keep in mind
    that binary representations for complex data types might change across
    server versions; the text format is usually the more portable choice.
   </para>
____________________________________________________________________________-->
   <para>
    整数的二进制形式采用网络字节序（高位在前）。对于其它数据类型，请参考文档或者源代码获取其二进制形式的信息。请注意，复杂数据类型的二进制形式可能在不同服务器版本之间变化； 文本格式通常是最具有移植性的选择。
   </para>
  </sect2>
 </sect1>

 <sect1 id="protocol-flow">
<!--==========================orignal english content==========================
  <title>Message Flow</title>
____________________________________________________________________________-->
  <title>消息流</title>

<!--==========================orignal english content==========================
  <para>
   This section describes the message flow and the semantics of each
   message type.  (Details of the exact representation of each message
   appear in <xref linkend="protocol-message-formats"/>.)  There are
   several different sub-protocols depending on the state of the
   connection: start-up, query, function call,
   <command>COPY</command>, and termination.  There are also special
   provisions for asynchronous operations (including notification
   responses and command cancellation), which can occur at any time
   after the start-up phase.
  </para>
____________________________________________________________________________-->
  <para>
   本节描述消息流以及每种消息类型的语意（每种信息的准确形式在<xref linkend="protocol-message-formats"/>里）。根据连接的状态不同，存在几种不同的子协议： 启动、查询、函数调用、<command>COPY</command>和终止。还有特殊的规定用于一步操作（包括通知响应和命令取消），这些可能在启动阶段过后的任何时间产生。
  </para>

  <sect2>
<!--==========================orignal english content==========================
   <title>Start-up</title>
____________________________________________________________________________-->
   <title>启动</title>

<!--==========================orignal english content==========================
   <para>
    To begin a session, a frontend opens a connection to the server and sends
    a startup message.  This message includes the names of the user and of the
    database the user wants to connect to; it also identifies the particular
    protocol version to be used.  (Optionally, the startup message can include
    additional settings for run-time parameters.)
    The server then uses this information and
    the contents of its configuration files (such as
    <filename>pg_hba.conf</filename>) to determine
    whether the connection is provisionally acceptable, and what additional
    authentication is required (if any).
   </para>
____________________________________________________________________________-->
   <para>
    要开始一个会话，前端打开一个与服务器的连接并且发送一个启动消息。这个消息包括用户名以及用户希望连接的数据库名； 它还标识要使用的特定的协议版本（启动信息可以有选择地包括运行时参数的额外设置）。服务器然后就使用这些信息及服务器配置文件的内容 （比如 <filename>pg_hba.conf</filename>）来判断这个连接是否可以接受以及需要什么样的额外的认证（如果需要）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The server then sends an appropriate authentication request message,
    to which the frontend must reply with an appropriate authentication
    response message (such as a password).
    For all authentication methods except GSSAPI, SSPI and SASL, there is at
    most one request and one response. In some methods, no response
    at all is needed from the frontend, and so no authentication request
    occurs. For GSSAPI, SSPI and SASL, multiple exchanges of packets may be
    needed to complete the authentication.
   </para>
____________________________________________________________________________-->
   <para>
    然后服务器就发送合适的认证请求信息，前端必须用合适的认证响应信息来响应（比如一个口令）。对于除了GSSAPI、SSPI和SASL之外的所有认证方式都至少有一个请求和一个响应。在有些方法中前端不需要发出任何响应，并且因此就不会由任何认证请求发生。对于GSSAPI、SSPI和SASL，可能需要多个包的交换才能完成认证。
   </para>

<!--==========================orignal english content==========================
   <para>
    The authentication cycle ends with the server either rejecting the
    connection attempt (ErrorResponse), or sending AuthenticationOk.
   </para>
____________________________________________________________________________-->
   <para>
    认证周期要么以服务器的拒绝连接（ErrorResponse）结束， 要么以AuthenticationOK 结束。
   </para>

<!--==========================orignal english content==========================
   <para>
    The possible messages from the server in this phase are:

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        The connection attempt has been rejected.
        The server then immediately closes the connection.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
        The authentication exchange is successfully completed.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
        The frontend must now take part in a Kerberos V5
        authentication dialog (not described here, part of the
        Kerberos specification) with the server.  If this is
        successful, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse. This is no
        longer supported.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
        The frontend must now send a PasswordMessage containing the
        password in clear-text form.  If
        this is the correct password, the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
        The frontend must now send a PasswordMessage containing the
        password (with user name) encrypted via MD5, then encrypted
        again using the 4-byte random salt specified in the
        AuthenticationMD5Password message.  If this is the correct
        password, the server responds with an AuthenticationOk,
        otherwise it responds with an ErrorResponse.  The actual
        PasswordMessage can be computed in SQL as <literal>concat('md5',
        md5(concat(md5(concat(password, username)), random-salt)))</literal>.
        (Keep in mind the <function>md5()</function> function returns its
        result as a hex string.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential</term>
      <listitem>
       <para>
        This response is only possible for local Unix-domain connections
        on platforms that support SCM credential messages.  The frontend
        must issue an SCM credential message and then send a single data
        byte.  (The contents of the data byte are uninteresting; it's
        only used to ensure that the server waits long enough to receive
        the credential message.)  If the credential is acceptable,
        the server responds with an
        AuthenticationOk, otherwise it responds with an ErrorResponse.
        (This message type is only issued by pre-9.1 servers.  It may
        eventually be removed from the protocol specification.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        The frontend must now initiate a GSSAPI negotiation. The frontend
        will send a GSSResponse message with the first part of the GSSAPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        The frontend must now initiate a SSPI negotiation. The frontend
        will send a GSSResponse with the first part of the SSPI
        data stream in response to this. If further messages are needed,
        the server will respond with AuthenticationGSSContinue.
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        This message contains the response data from the previous step
        of GSSAPI or SSPI negotiation (AuthenticationGSS, AuthenticationSSPI
        or a previous AuthenticationGSSContinue). If the GSSAPI
        or SSPI data in this message
        indicates more data is needed to complete the authentication,
        the frontend must send that data as another GSSResponse message. If
        GSSAPI or SSPI authentication is completed by this message, the server
        will next send AuthenticationOk to indicate successful authentication
        or ErrorResponse to indicate failure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>
        The frontend must now initiate a SASL negotiation, using one of the
        SASL mechanisms listed in the message. The frontend will send a
        SASLInitialResponse with the name of the selected mechanism, and the
        first part of the SASL data stream in response to this. If further
        messages are needed, the server will respond with
        AuthenticationSASLContinue. See <xref linkend="sasl-authentication"/>
        for details.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>
        This message contains challenge data from the previous step of SASL
        negotiation (AuthenticationSASL, or a previous
        AuthenticationSASLContinue). The frontend must respond with a
        SASLResponse message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLFinal</term>
      <listitem>
       <para>
        SASL authentication has completed with additional mechanism-specific
        data for the client. The server will next send AuthenticationOk to
        indicate successful authentication, or an ErrorResponse to indicate
        failure. This message is sent only if the SASL mechanism specifies
        additional data to be sent from server to client at completion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NegotiateProtocolVersion</term>
      <listitem>
       <para>
        The server does not support the minor protocol version requested
        by the client, but does support an earlier version of the protocol;
        this message indicates the highest supported minor version.  This
        message will also be sent if the client requested unsupported protocol
        options (i.e. beginning with <literal>_pq_.</literal>) in the
        startup packet.  This message will be followed by an ErrorResponse or
        a message indicating the success or failure of authentication.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    这个阶段来自服务器可能消息是：

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        连接请求被拒绝。然后服务器马上关闭连接。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationOk</term>
      <listitem>
       <para>
        认证交换成功完成。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationKerberosV5</term>
      <listitem>
       <para>
        现在前端必须与服务器进行一次Kerberos V5认证对话（在这里没有描述，Kerberos规范的一部分）。 如果对话成功，服务器响应一个AuthenticationOk，否则它响应一个ErrorResponse。这已经不再被支持。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationCleartextPassword</term>
      <listitem>
       <para>
        现在前端必须以明文形式发送一个包含口令的PasswordMessage。如果这是正确的口令，服务器用一个 AuthenticationOk，否则它响应一个ErrorResponse。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationMD5Password</term>
      <listitem>
       <para>
        现在前端必须发送一个PasswordMessage，其中包含口令，且口令先用用户名做MD5加密，然后使用在AuthenticationMD5Password消息里指定的4字节盐粒加密。 如果这是正确口令，服务器用一个AuthenticationOk 响应，否则它用一个ErrorResponse 响应。实际的PasswordMessage可以用SQL来计算：<literal>concat('md5',        md5(concat(md5(concat(password, username)), random-salt)))</literal>（记住<function>md5()</function>函数返回的结果是一个十六进制串）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSCMCredential</term>
      <listitem>
       <para>
        这个响应只用于在支持SCM信任消息的平台上的本地Unix域连接。前端必须发出一条SCM信任消息然后发送一个数据字节（数据字节的内容并没有意义； 它只被用于确保服务器等待足够长的时间来接受信任信息）。如果信任是可以接受的， 那么服务器用AuthenticationOk响应，否则用ErrorResponse响应（该消息只在9.1之前的服务器中发出。它可能最终会从协议规范中被删除）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationGSS</term>
      <listitem>
       <para>
        前端必须现在开始一次GSSAPI谈判。前端将发送一个带有GSSAPI数据流第一部分的GSSResponse消息来响应。如果需要进一步的消息，服务器将会响应AuthenticationGSSContinue。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSSPI</term>
      <listitem>
       <para>
        前端必须现在开始一次SSPI谈判。前端将发送一个带有SSPI数据流第一部分的GSSResponse来响应。如果需要进一步的消息，服务器将会响应AuthenticationGSSContinue。
       </para>
      </listitem>

     </varlistentry>
     <varlistentry>
      <term>AuthenticationGSSContinue</term>
      <listitem>
       <para>
        这个消息包含对于前一步的GSSAPI或SSPI谈判（AuthenticationGSS、AuthenticationSSPI或者前一个AuthenticationGSSContinue）的响应数据。如果这个消息中的GSSAPI或SSPI数据指示需要更多数据来完成认证，前端必须将所需的数据作为另一个GSSResponse发送。如果这个消息就能完成GSSAPI或SSPI认证，服务器将接着发送AuthenticationOk来指示成功认证，或者发送ErrorResponse来指示失败。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASL</term>
      <listitem>
       <para>
        前端现在必须发起一次SASL协商，使用该消息中列出的一种SASL机制。前端将用选中机制的名字发送一个SASLInitialResponse，并且SASL数据流的第一部分对应于此。如果需要进一步的消息，服务器将用AuthenticationSASLContinue回复。详见<xref linkend="sasl-authentication"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLContinue</term>
      <listitem>
       <para>
        这个消息包含从SASL协商（AuthenticationSASL或者一个之前的AuthenticationSASLContinue）的前一步中得到的挑战数据。前端必须用一个SASLResponse消息响应。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>AuthenticationSASLFinal</term>
      <listitem>
       <para>
        已经用额外的与机制相关的数据为该客户端完成SASL认证。服务器接下来将发送AuthenticationOk来表示认证成功，或者发送ErrorResponse表示失败。只有在SASL机制指定要在完成时从服务器发送额外数据到客户端的情况下才会发送这个消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NegotiateProtocolVersion</term>
      <listitem>
       <para>
        服务器不支持客户端请求的次协议版本，但是支持该协议更早的一个版本，这个消息会指出受支持的最高次版本。如果客户端在启动包中请求了不受支持的协议选项（例如以<literal>_pq_.</literal>开始），则这个消息也会被发出。这个消息后面将会跟着一个ErrorResponse或者一个指示认证成功或失败的消息。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    If the frontend does not support the authentication method
    requested by the server, then it should immediately close the
    connection.
   </para>
____________________________________________________________________________-->
   <para>
    如果前端不支持服务器要求的认证方式，那么它应该马上关闭连接。
   </para>

<!--==========================orignal english content==========================
   <para>
    After having received AuthenticationOk, the frontend must wait
    for further messages from the server.  In this phase a backend process
    is being started, and the frontend is just an interested bystander.
    It is still possible for the startup attempt
    to fail (ErrorResponse) or the server to decline support for the requested
    minor protocol version (NegotiateProtocolVersion), but in the normal case
    the backend will send some ParameterStatus messages, BackendKeyData, and
    finally ReadyForQuery.
   </para>
____________________________________________________________________________-->
   <para>
    在收到AuthenticationOk包之后，前端必须等待来自服务器的进一步消息。在这个阶段会启动一个后端进程， 而前端只是一个感兴趣的旁观者。启动尝试仍有可能失败（ErrorResponse），服务器也有可能拒绝支持所请求的次协议版本（NegotiateProtocolVersion），但是通常情况下，后端将发送一些ParameterStatus消息、BackendKeyData以及最后的ReadyForQuery。
   </para>

<!--==========================orignal english content==========================
   <para>
    During this phase the backend will attempt to apply any additional
    run-time parameter settings that were given in the startup message.
    If successful, these values become session defaults.  An error causes
    ErrorResponse and exit.
   </para>
____________________________________________________________________________-->
   <para>
    在这个阶段，后端将尝试应用任何在启动消息里给出的额外的运行时参数设置。如果成功，这些值将成为会话的缺省值。错误将导致ErrorResponse并退出。
   </para>

<!--==========================orignal english content==========================
   <para>
    The possible messages from the backend in this phase are:

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
        This message provides secret-key data that the frontend must
        save if it wants to be able to issue cancel requests later.
        The frontend should not respond to this message, but should
        continue listening for a ReadyForQuery message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
        This message informs the frontend about the current (initial)
         setting of backend parameters, such as <xref
         linkend="guc-client-encoding"/> or <xref linkend="guc-datestyle"/>.
         The frontend can ignore this message, or record the settings
         for its future use; see <xref linkend="protocol-async"/> for
         more details.  The frontend should not respond to this
         message, but should continue listening for a ReadyForQuery
         message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Start-up is completed.  The frontend can now issue commands.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        Start-up failed.  The connection is closed after sending this
        message.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        A warning message has been issued.  The frontend should
        display the message but continue listening for ReadyForQuery
        or ErrorResponse.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    这个阶段来自后端的可能消息是：

    <variablelist>
     <varlistentry>
      <term>BackendKeyData</term>
      <listitem>
       <para>
        这个消息提供了密钥数据，前端如果想要在稍后发出取消请求，则必须保存这个数据。前端不应该响应这个信息，但是应该继续侦听等待ReadyForQuery消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ParameterStatus</term>
      <listitem>
       <para>
        这个消息告诉前端有关后端参数的当前（初始）设置，比如<xref linkend="guc-client-encoding"/>或者<xref linkend="guc-datestyle"/>等。前端可以忽略这些信息，或者记录其设置用于将来使用； 参阅<xref linkend="protocol-async"/>获取更多细节。前端不应该响应这些信息， 而是应该继续侦听ReadyForQuery消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        启动成功，前端现在可以发出命令。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        启动失败，在发送完这个消息之后连接被关闭。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发出了一个警告信息。前端应该显示这个信息，但是要继续监听ReadyForQuery或ErrorResponse。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The ReadyForQuery message is the same one that the backend will
    issue after each command cycle.  Depending on the coding needs of
    the frontend, it is reasonable to consider ReadyForQuery as
    starting a command cycle, or to consider ReadyForQuery as ending the
    start-up phase and each subsequent command cycle.
   </para>
____________________________________________________________________________-->
   <para>
    后端在每个命令周期后都会发出一个相同的ReadyForQuery消息。 出于前端的编码需要，前端可以合理地认为ReadyForQuery是一个命令周期的开始，或者认为ReadyForQuery 是启动阶段和每个随后命令周期的结束， 具体是那种情况取决于前端的编码需要。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Simple Query</title>
____________________________________________________________________________-->
   <title> 简单查询</title>

<!--==========================orignal english content==========================
   <para>
    A simple query cycle is initiated by the frontend sending a Query message
    to the backend.  The message includes an SQL command (or commands)
    expressed as a text string.
    The backend then sends one or more response
    messages depending on the contents of the query command string,
    and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new command.
    (It is not actually necessary for the frontend to wait for
    ReadyForQuery before issuing another command, but the frontend must
    then take responsibility for figuring out what happens if the earlier
    command fails and already-issued later commands succeed.)
   </para>
____________________________________________________________________________-->
   <para>
    一个简单查询周期是由前端发送一条Query消息给后端进行初始化的。这条消息包含一个用文本字符串表达的 SQL 命令（或者一些命令）。 后端根据查询命令串的内容发送一条或者更多条响应消息给前端，并且最后是一条ReadyForQuery响应消息。ReadyForQuery通知前端它可以安全地发送新命令了 （实际上前端不必在发送其它命令之前等待ReadyForQuery，但是这样一来，前端必须能发现较早发出的命令失败而稍后发出的命令成功的情况）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The possible response messages from the backend are:

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
        An SQL command completed normally.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
        The backend is ready to copy data from the frontend to a
        table; see <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
        The backend is ready to copy data from a table to the
        frontend; see <xref linkend="protocol-copy"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
        Indicates that rows are about to be returned in response to
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
        The contents of this message describe the column layout of the rows.
        This will be followed by a DataRow message for each row being returned
        to the frontend.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
        One of the set of rows returned by
        a <command>SELECT</command>, <command>FETCH</command>, etc query.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
        An empty query string was recognized.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        An error has occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Processing of the query string is complete.  A separate
        message is sent to indicate this because the query string might
        contain multiple SQL commands.  (CommandComplete marks the
        end of processing one SQL command, not the whole string.)
        ReadyForQuery will always be sent, whether processing
        terminates successfully or with an error.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        A warning message has been issued in relation to the query.
        Notices are in addition to other responses, i.e., the backend
        will continue processing the command.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    来自后端的可能的消息是：

    <variablelist>
     <varlistentry>
      <term>CommandComplete</term>
      <listitem>
       <para>
        一个SQL命令正常结束。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyInResponse</term>
      <listitem>
       <para>
        后端已经准备好从前端拷贝数据到一个表里面去，参见<xref linkend="protocol-copy"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>CopyOutResponse</term>
      <listitem>
       <para>
        后端已经准备好从一个表里拷贝数据到前端，参见<xref linkend="protocol-copy"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>RowDescription</term>
      <listitem>
       <para>
        表示为了响应一个<command>SELECT</command>、<command>FETCH</command>等查询， 将要返回行。这条消息的内容描述了行的列布局。这条消息后面将跟着DataRow消息，每个DataRow消息包含一个要被返回的行。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>DataRow</term>
      <listitem>
       <para>
        <command>SELECT</command>、<command>FETCH</command>等查询返回的结果集中的一行。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>EmptyQueryResponse</term>
      <listitem>
       <para>
        识别了一个空的查询字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        出错了。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        查询字符串的处理完成。发送一个独立的消息来标识这种情况是因为查询字符串可能包含多个SQL命令（CommandComplete只是标记一条SQL命令处理完毕，而不是整个查询字符串处理完毕）。不管是处理成功结束还是产生错误，ReadyForQuery总会被发送。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发送了一个与查询有关的警告信息。提示信息是附加在其他响应上的，也就是说，后端将继续处理该命令。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The response to a <command>SELECT</command> query (or other queries that
    return row sets, such as <command>EXPLAIN</command> or <command>SHOW</command>)
    normally consists of RowDescription, zero or more
    DataRow messages, and then CommandComplete.
    <command>COPY</command> to or from the frontend invokes special protocol
    as described in <xref linkend="protocol-copy"/>.
    All other query types normally produce only
    a CommandComplete message.
   </para>
____________________________________________________________________________-->
   <para>
    对SELECT查询（或其它返回行集的查询，比如<command>EXPLAIN</command>或<command>SHOW</command>）的响应通常包含 RowDescription、零个或者多个 DataRow 消息以及最后的 CommandComplete。 <command>COPY</command>到前端或者从前端<command>COPY</command>会调用<xref linkend="protocol-copy"/>里描述的特殊协议。所有其他查询类型通常只产生一个CommandComplete消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    Since a query string could contain several queries (separated by
    semicolons), there might be several such response sequences before the
    backend finishes processing the query string.  ReadyForQuery is issued
    when the entire string has been processed and the backend is ready to
    accept a new query string.
   </para>
____________________________________________________________________________-->
   <para>
    因为查询字符串可能包含若干个查询（用分号分隔），所以在后端完成查询字符串的处理之前可能有好几个这样的响应序列。如果整个字符串已经处理完，后端已经准备好接受新查询字符串的时候则发出 ReadyForQuery消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a completely empty (no contents other than whitespace) query string
    is received, the response is EmptyQueryResponse followed by ReadyForQuery.
   </para>
____________________________________________________________________________-->
   <para>
    如果收到一个完全空（除了空白之外没有内容）的查询字符串，那么响应是一条EmptyQueryResponse后面跟着ReadyForQuery。
   </para>

<!--==========================orignal english content==========================
   <para>
    In the event of an error, ErrorResponse is issued followed by
    ReadyForQuery.  All further processing of the query string is aborted by
    ErrorResponse (even if more queries remained in it).  Note that this
    might occur partway through the sequence of messages generated by an
    individual query.
   </para>
____________________________________________________________________________-->
   <para>
    在出现错误的时候，发出一个ErrorResponse消息，后面跟着ReadyForQuery。查询字符串的所有进一步的处理都被ErrorResponse中止（即使里面还有查询）。请注意这些事情可能在处理一个查询产生的消息序列的中途发生。
   </para>

<!--==========================orignal english content==========================
   <para>
    In simple Query mode, the format of retrieved values is always text,
    except when the given command is a <command>FETCH</command> from a cursor
    declared with the <literal>BINARY</literal> option.  In that case, the
    retrieved values are in binary format.  The format codes given in
    the RowDescription message tell which format is being used.
   </para>
____________________________________________________________________________-->
   <para>
    在简单查询模式中，检索出来的值的格式总是文本，除非给出的命令是在一个使用<literal>BINARY</literal>选项声明的游标上<command>FETCH</command>。 在这种情况下，检索出来的值是二进制格式的。在 RowDescription消息里给出的格式代码将告诉我们用了那种格式。
   </para>

<!--==========================orignal english content==========================
   <para>
    A frontend must be prepared to accept ErrorResponse and
    NoticeResponse messages whenever it is expecting any other type of
    message.  See also <xref linkend="protocol-async"/> concerning messages
    that the backend might generate due to outside events.
   </para>
____________________________________________________________________________-->
   <para>
    前端在等待其他类型的消息时必须准备接收ErrorResponse和NoticeResponse消息。 参阅 <xref linkend="protocol-async"/>来了解后端因为外部事件可能生成的消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    Recommended practice is to code frontends in a state-machine style
    that will accept any message type at any time that it could make sense,
    rather than wiring in assumptions about the exact sequence of messages.
   </para>
____________________________________________________________________________-->
   <para>
    我们建议的方法是把前端代码写成状态机的风格，它可以在任何时刻接受任何有意义的消息类型，而不是假设消息的序列总是准确。
   </para>

   <sect3 id="protocol-flow-multi-statement">
<!--==========================orignal english content==========================
    <title>Multiple Statements in a Simple Query</title>
____________________________________________________________________________-->
    <title>一个简单查询中的多条语句</title>

<!--==========================orignal english content==========================
    <para>
     When a simple Query message contains more than one SQL statement
     (separated by semicolons), those statements are executed as a single
     transaction, unless explicit transaction control commands are included
     to force a different behavior.  For example, if the message contains
<programlisting>
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</programlisting>
     then the divide-by-zero failure in the <command>SELECT</command> will force
     rollback of the first <command>INSERT</command>.  Furthermore, because
     execution of the message is abandoned at the first error, the second
     <command>INSERT</command> is never attempted at all.
    </para>
____________________________________________________________________________-->
    <para>
     当一个简单查询消息中包含多于一条SQL语句（被分号分隔）时，那些语句会被当做一个事务中执行，除非其中包括显式事务控制命令来强制不同的行为。例如，如果消息包括
<programlisting>
INSERT INTO mytable VALUES(1);
SELECT 1/0;
INSERT INTO mytable VALUES(2);
</programlisting>
     则<command>SELECT</command>中的除零失败将强制回滚第一个<command>INSERT</command>。进而，因为该消息的执行在第一个错误时就被放弃，第二个<command>INSERT</command>根本都不会被尝试。
    </para>

<!--==========================orignal english content==========================
    <para>
     If instead the message contains
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
     then the first <command>INSERT</command> is committed by the
     explicit <command>COMMIT</command> command.  The second <command>INSERT</command>
     and the <command>SELECT</command> are still treated as a single transaction,
     so that the divide-by-zero failure will roll back the
     second <command>INSERT</command>, but not the first one.
    </para>
____________________________________________________________________________-->
    <para>
     如果该消息包含的是
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELECT 1/0;
</programlisting>
     那么第一个<command>INSERT</command>会被这个显式的<command>COMMIT</command>命令提交。第二个<command>INSERT</command>以及<command>SELECT</command>仍会被当作一个单一事务，这样除零失败将回滚第二个<command>INSERT</command>，但不会回滚第一个。
    </para>

<!--==========================orignal english content==========================
    <para>
     This behavior is implemented by running the statements in a
     multi-statement Query message in an <firstterm>implicit transaction
     block</firstterm> unless there is some explicit transaction block for them to
     run in.  The main difference between an implicit transaction block and
     a regular one is that an implicit block is closed automatically at the
     end of the Query message, either by an implicit commit if there was no
     error, or an implicit rollback if there was an error.  This is similar
     to the implicit commit or rollback that happens for a statement
     executed by itself (when not in a transaction block).
    </para>
____________________________________________________________________________-->
    <para>
     这种行为通过在一个<firstterm>隐式事务块</firstterm>中的一个多语句Query消息中运行那些语句来实现，除非它们运行在某个显式事务块中。隐式事务块与常规事务块之间的区别在于隐式块会在Query消息结束时自动被关闭，或者是在没有错误的情况下由一个隐式提交关闭，或者是在有错误时由一个隐式的回滚关闭。这类似于一个语句自己执行（当不在事务块中时）时发生的隐式提交或回滚。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the session is already in a transaction block, as a result of
     a <command>BEGIN</command> in some previous message, then the Query message
     simply continues that transaction block, whether the message contains
     one statement or several.  However, if the Query message contains
     a <command>COMMIT</command> or <command>ROLLBACK</command> closing the existing
     transaction block, then any following statements are executed in an
     implicit transaction block.
     Conversely, if a <command>BEGIN</command> appears in a multi-statement Query
     message, then it starts a regular transaction block that will only be
     terminated by an explicit <command>COMMIT</command> or <command>ROLLBACK</command>,
     whether that appears in this Query message or a later one.
     If the <command>BEGIN</command> follows some statements that were executed as
     an implicit transaction block, those statements are not immediately
     committed; in effect, they are retroactively included into the new
     regular transaction block.
    </para>
____________________________________________________________________________-->
    <para>
     如果会话已经在一个事务块中，作为前面某个消息中<command>BEGIN</command>的结果，那么Query消息会简单地继续那个事务块，不管该消息包含一个语句还是多个语句。不过，如果该Query消息包含一个关闭现有事务块的<command>COMMIT</command>或者<command>ROLLBACK</command>，那么任何接下来的语句都会在一个隐式事务块中被执行。反过来，如果在多语句Query消息中出现一个<command>BEGIN</command>，那么它会开始一个常规事务块，这个常规事务块将只能被一个显式的<command>COMMIT</command>或者<command>ROLLBACK</command>终止，不管这两种命令是出现在这个Query消息还是后面的一个Query消息中。如果<command>BEGIN</command>跟在一些作为隐式事务块执行的语句后面，那些语句不会被立刻提交。实际上，它们会被包括到新的常规事务块中。
    </para>

<!--==========================orignal english content==========================
    <para>
     A <command>COMMIT</command> or <command>ROLLBACK</command> appearing in an implicit
     transaction block is executed as normal, closing the implicit block;
     however, a warning will be issued since a <command>COMMIT</command>
     or <command>ROLLBACK</command> without a previous <command>BEGIN</command> might
     represent a mistake.  If more statements follow, a new implicit
     transaction block will be started for them.
    </para>
____________________________________________________________________________-->
    <para>
     出现在一个隐式事务块中的<command>COMMIT</command>或者<command>ROLLBACK</command>会被正常执行并且关闭该隐式块。不过，由于没有先前的<command>BEGIN</command>配对的<command>COMMIT</command>或者<command>ROLLBACK</command>表示一种错误，所以将会发出一个警告。如果后面还有更多语句，将会为它们开始一个新的隐式事务块。
    </para>

<!--==========================orignal english content==========================
    <para>
     Savepoints are not allowed in an implicit transaction block, since
     they would conflict with the behavior of automatically closing the
     block upon any error.
    </para>
____________________________________________________________________________-->
    <para>
     在隐式事务块中不允许保存点，因为它们会与发生错误时自动关闭块的行为发生冲突。
    </para>

<!--==========================orignal english content==========================
    <para>
     Remember that, regardless of any transaction control commands that may
     be present, execution of the Query message stops at the first error.
     Thus for example given
<programlisting>
BEGIN;
SELECT 1/0;
ROLLBACK;
</programlisting>
     in a single Query message, the session will be left inside a failed
     regular transaction block, since the <command>ROLLBACK</command> is not
     reached after the divide-by-zero error.  Another <command>ROLLBACK</command>
     will be needed to restore the session to a usable state.
    </para>
____________________________________________________________________________-->
    <para>
     记住，不管任何事务控制命令存不存在，Query消息的执行会在第一个错误时停止。因此，对于下面的在一个Query消息中的例子
<programlisting>
BEGIN;
SELECT 1/0;
ROLLBACK;
</programlisting>
     会话中将留下一个失败的常规事务块，因为在出现除零错误后不会到达<command>ROLLBACK</command>。将需要另一个<command>ROLLBACK</command>把会话恢复到一种可用的状态。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another behavior of note is that initial lexical and syntactic
     analysis is done on the entire query string before any of it is
     executed.  Thus simple errors (such as a misspelled keyword) in later
     statements can prevent execution of any of the statements.  This
     is normally invisible to users since the statements would all roll
     back anyway when done as an implicit transaction block.  However,
     it can be visible when attempting to do multiple transactions within a
     multi-statement Query.  For instance, if a typo turned our previous
     example into
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;
</programlisting>
     then none of the statements would get run, resulting in the visible
     difference that the first <command>INSERT</command> is not committed.
     Errors detected at semantic analysis or later, such as a misspelled
     table or column name, do not have this effect.
    </para>
____________________________________________________________________________-->
    <para>
     另一种要注意的行为是，最初的词法和语法分析是在整个查询字符串被执行之前进行的。因此后面的语句中的简单错误（例如拼写错误的关键词）可能会阻止任何语句的执行。这通常对用户是不可见的，因为在当作一个隐式事务块执行时，这些语句不管怎样都会全部被回滚。不过，在尝试于一个多语句Query中执行多个事务时，这种现象可能是可见的。例如，如果一个拼写错误把我们之前的例子变成
<programlisting>
BEGIN;
INSERT INTO mytable VALUES(1);
COMMIT;
INSERT INTO mytable VALUES(2);
SELCT 1/0;
</programlisting>
     那么这些语句都不会被运行，导致可见的差别，即第一个<command>INSERT</command>没有被提交。在语义分析及其后阶段检测到的错误（例如拼错的表名或者列名）不会有这种效果。
    </para>
   </sect3>
  </sect2>

  <sect2 id="protocol-flow-ext-query">
<!--==========================orignal english content==========================
   <title>Extended Query</title>
____________________________________________________________________________-->
   <title>扩展查询</title>

<!--==========================orignal english content==========================
   <para>
    The extended query protocol breaks down the above-described simple
    query protocol into multiple steps.  The results of preparatory
    steps can be re-used multiple times for improved efficiency.
    Furthermore, additional features are available, such as the possibility
    of supplying data values as separate parameters instead of having to
    insert them directly into a query string.
   </para>
____________________________________________________________________________-->
   <para>
    扩展查询协议把上面描述的简单协议分裂成若干个步骤。准备步骤的结果可以被多次复用以提高效率。另外，还可以获得额外的特性， 比如可以把数据值作为独立的参数提供而不是必须把它们直接插入一个查询字符串。
   </para>

<!--==========================orignal english content==========================
   <para>
    In the extended protocol, the frontend first sends a Parse message,
    which contains a textual query string, optionally some information
    about data types of parameter placeholders, and the
    name of a destination prepared-statement object (an empty string
    selects the unnamed prepared statement).  The response is
    either ParseComplete or ErrorResponse.  Parameter data types can be
    specified by OID; if not given, the parser attempts to infer the
    data types in the same way as it would do for untyped literal string
    constants.
   </para>
____________________________________________________________________________-->
   <para>
   在扩展协议里，前端首先发送一个Parse消息，它包含一个文本查询字符串， 另外还有一些可选的有关参数占位符的数据类型的信息，以及一个最终的预备语句对象的名字（一个空字符串选择未命名的预备语句）。响应是一个ParseComplete或者ErrorResponse。 参数的数据类型可以用OID来指定；如果没有给出，那么分析器将试图用应付无类型文字符串常量的方法来推导其数据类型。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     A parameter data type can be left unspecified by setting it to zero,
     or by making the array of parameter type OIDs shorter than the
     number of parameter symbols (<literal>$</literal><replaceable>n</replaceable>)
     used in the query string.  Another special case is that a parameter's
     type can be specified as <type>void</type> (that is, the OID of the
     <type>void</type> pseudo-type).  This is meant to allow parameter symbols
     to be used for function parameters that are actually OUT parameters.
     Ordinarily there is no context in which a <type>void</type> parameter
     could be used, but if such a parameter symbol appears in a function's
     parameter list, it is effectively ignored.  For example, a function
     call such as <literal>foo($1,$2,$3,$4)</literal> could match a function with
     two IN and two OUT arguments, if <literal>$3</literal> and <literal>$4</literal>
     are specified as having type <type>void</type>.
    </para>
____________________________________________________________________________-->
    <para>
     一个参数的数据类型可以通过设置为零， 或者让参数类型OID的数目比查询字符串里的参数符号（<literal>$</literal><replaceable>n</replaceable>）的数目少的方式不予指定。另外一个特例是参数的类型可以声明为<type>void</type>（也就是说，伪类型<type>void</type>的OID）。这是为了允许用于某些函数参数的参数符号实际上是OUT参数。通常情况下，没有什么环境会用到<type>void</type>参数， 但是如果在函数的参数列表里出现了这么一个参数符号，那么它实际上会被忽略。比如，一个像这样的函数调用：<literal>foo($1,$2,$3,$4)</literal>，如果<literal>$3</literal>和<literal>$4</literal>被指定为具有类型是<type>void</type>，那么这个函数调用会匹配一个带有两个IN和两个OUT参数的函数。
    </para>
   </note>

   <note>
<!--==========================orignal english content==========================
    <para>
     The query string contained in a Parse message cannot include more
     than one SQL statement; else a syntax error is reported.  This
     restriction does not exist in the simple-query protocol, but it
     does exist in the extended protocol, because allowing prepared
     statements or portals to contain multiple commands would complicate
     the protocol unduly.
    </para>
____________________________________________________________________________-->
    <para>
     在一个Parse消息里包含的查询字符串不能包含超过一个SQL语句；否则就会报告一个语法错误。这个限制在简单查询协议中并不存在， 是它存在于扩展协议中，因为允许预备语句或者入口包含多个命令将导致协议过度地复杂。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    If successfully created, a named prepared-statement object lasts till
    the end of the current session, unless explicitly destroyed.  An unnamed
    prepared statement lasts only until the next Parse statement specifying
    the unnamed statement as destination is issued.  (Note that a simple
    Query message also destroys the unnamed statement.)  Named prepared
    statements must be explicitly closed before they can be redefined by
    another Parse message, but this is not required for the unnamed statement.
    Named prepared statements can also be created and accessed at the SQL
    command level, using <command>PREPARE</command> and <command>EXECUTE</command>.
   </para>
____________________________________________________________________________-->
   <para>
    如果成功创建了一个命名的预备语句对象，那么它将持续到当前会话结束， 除非被明确地删除。一个未命名的预备语句只持续到下一个声明未命名语句的Parse语句发出为止（请注意一个简单的查询消息也会销毁未命名语句）。命名预备语句必须被明确地关闭，然后才能用一个Parse消息重新定义，但是未命名语句并不要求这个动作。命名预备语句也可以在SQL命令级别创建和访问，方法是使用<command>PREPARE</command>和<command>EXECUTE</command>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Once a prepared statement exists, it can be readied for execution using a
    Bind message.  The Bind message gives the name of the source prepared
    statement (empty string denotes the unnamed prepared statement), the name
    of the destination portal (empty string denotes the unnamed portal), and
    the values to use for any parameter placeholders present in the prepared
    statement.  The
    supplied parameter set must match those needed by the prepared statement.
    (If you declared any <type>void</type> parameters in the Parse message,
    pass NULL values for them in the Bind message.)
    Bind also specifies the format to use for any data returned
    by the query; the format can be specified overall, or per-column.
    The response is either BindComplete or ErrorResponse.
   </para>
____________________________________________________________________________-->
   <para>
    一旦一个预备语句存在，就可以很使用Bind消息使之进入执行状态。Bind消息给出源预备语句的名字（空字符串表示未命名预备语句）、目标入口的名字（空字符串表示未命名的入口）及用于那些在预备语句中出现的所有参数占位符的值。提供的参数集必须匹配那些预备语句所需要的参数（如果你在Parse消息里声明任何<type>void</type>参数，那么在Bind消息里给它们传递NULL值）。Bind还指定被查询返回的数据的格式；格式可以在总体上声明，也可以对每个列进行声明。响应是BindComplete或ErrorResponse。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The choice between text and binary output is determined by the format
     codes given in Bind, regardless of the SQL command involved.  The
     <literal>BINARY</literal> attribute in cursor declarations is irrelevant when
     using extended query protocol.
    </para>
____________________________________________________________________________-->
    <para>
     输出的格式是文本还是二进制是由Bind里给出的格式代码决定的，而不管涉及的是什么SQL命令。在使用扩展查询协议的时候，游标声明里的<literal>BINARY</literal>属性是无关的。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Query planning typically occurs when the Bind message is processed.
    If the prepared statement has no parameters, or is executed repeatedly,
    the server might save the created plan and re-use it during subsequent
    Bind messages for the same prepared statement.  However, it will do so
    only if it finds that a generic plan can be created that is not much
    less efficient than a plan that depends on the specific parameter values
    supplied.  This happens transparently so far as the protocol is concerned.
   </para>
____________________________________________________________________________-->
   <para>
    当Bind消息被处理时通常会进行查询规划。如果预备语句没有参数或者是被反复执行，服务器可能会保存创建好的计划并在后续对同一个预备语句的Bind消息中重用之。不过，当它发现可以创建一个效率比依赖指定参数值的计划不低很多的一般性计划时，它仍然会进行查询规划。但是这对于协议所关注的来说是透明的。
   </para>

<!--==========================orignal english content==========================
   <para>
    If successfully created, a named portal object lasts till the end of the
    current transaction, unless explicitly destroyed.  An unnamed portal is
    destroyed at the end of the transaction, or as soon as the next Bind
    statement specifying the unnamed portal as destination is issued.  (Note
    that a simple Query message also destroys the unnamed portal.)  Named
    portals must be explicitly closed before they can be redefined by another
    Bind message, but this is not required for the unnamed portal.
    Named portals can also be created and accessed at the SQL
    command level, using <command>DECLARE CURSOR</command> and <command>FETCH</command>.
   </para>
____________________________________________________________________________-->
   <para>
    如果成功创建了一个命名入口对象，那么它将持续到当前事务的结尾，除非被明确地删除。一个未命名入口在事务的结尾删除，或者是在发出的下一个Bind语句声明了一个未命名入口为止（请注意一个简单查询消息也会删除这个未命名入口）。命名入口在可以用一个Bind消息重新定义之前必须明确地关闭，但是未命名入口不要求这个动作。命名入口也可以在SQL命令的级别创建和访问，方法是使用<command>DECLARE CURSOR</command>和<command>FETCH</command>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Once a portal exists, it can be executed using an Execute message.
    The Execute message specifies the portal name (empty string denotes the
    unnamed portal) and
    a maximum result-row count (zero meaning <quote>fetch all rows</quote>).
    The result-row count is only meaningful for portals
    containing commands that return row sets; in other cases the command is
    always executed to completion, and the row count is ignored.
    The possible
    responses to Execute are the same as those described above for queries
    issued via simple query protocol, except that Execute doesn't cause
    ReadyForQuery or RowDescription to be issued.
   </para>
____________________________________________________________________________-->
   <para>
    一旦一个入口存在，那么就可以用一个Execute消息执行它。Execute消息指定入口的名字（空字符串表示未命名入口）和一个最大的结果行计数（零表示<quote>取出所有行</quote>）。 结果行计数只对包含返回行集的入口有意义；在其它情况下，该命令总是被执行到结束，而行计数会被忽略。Execute消息的可能响应和那些通过简单查询协议发出的查询一样，只不过执行不会导致后端发出ReadyForQuery或者RowDescription。
   </para>

<!--==========================orignal english content==========================
   <para>
    If Execute terminates before completing the execution of a portal
    (due to reaching a nonzero result-row count), it will send a
    PortalSuspended message; the appearance of this message tells the frontend
    that another Execute should be issued against the same portal to
    complete the operation.  The CommandComplete message indicating
    completion of the source SQL command is not sent until
    the portal's execution is completed.  Therefore, an Execute phase is
    always terminated by the appearance of exactly one of these messages:
    CommandComplete, EmptyQueryResponse (if the portal was created from
    an empty query string), ErrorResponse, or PortalSuspended.
   </para>
____________________________________________________________________________-->
   <para>
    如果Execute在入口的执行完成之前终止（因为达到了一个非零的结果行计数），它将发送一个PortalSuspended消息；这个消息的出现告诉前端应该在同一个入口上发出另外一个Execute消息以完成操作。在入口的执行完成之前，不会发出表示源SQL命令结束的CommandComplete消息。因此执行阶段总是由下列消息之一出现标志着结束：CommandComplete、EmptyQueryResponse（如果入口是从一个空字符串创建出来的）、ErrorResponse或者PortalSuspended。
   </para>

<!--==========================orignal english content==========================
   <para>
    At completion of each series of extended-query messages, the frontend
    should issue a Sync message.  This parameterless message causes the
    backend to close the current transaction if it's not inside a
    <command>BEGIN</command>/<command>COMMIT</command> transaction block (<quote>close</quote>
    meaning to commit if no error, or roll back if error).  Then a
    ReadyForQuery response is issued.  The purpose of Sync is to provide
    a resynchronization point for error recovery.  When an error is detected
    while processing any extended-query message, the backend issues
    ErrorResponse, then reads and discards messages until a Sync is reached,
    then issues ReadyForQuery and returns to normal message processing.
    (But note that no skipping occurs if an error is detected
    <emphasis>while</emphasis> processing Sync &mdash; this ensures that there is one
    and only one ReadyForQuery sent for each Sync.)
   </para>
____________________________________________________________________________-->
   <para>
    每个扩展查询消息序列完成后，前端都应该发出一条Sync消息。这个无参数的消息导致后端关闭当前事务——如果当前事务不是在一个<command>BEGIN</command>/<command>COMMIT</command>事务块中（<quote>关闭</quote>的意思就是在没有错误的情况下提交， 或者是有错误的情况下回滚）。然后响应一条ReadyForQuery消息。Sync的目的是提供一个错误恢复的重新同步的点。 如果在处理任何扩展查询消息的时候侦测到任何错误，那么后端会发出ErrorResponse，然后读取并抛弃消息直到一个Sync到来，然后发出ReadyForQuery并且返回到正常的消息处理中（但是要注意如果正在处理Sync的时候发生了错误，那么不会忽略任何东西 — 这样就保证了为每个Sync发出一个并且只是一个ReadyForQuery）。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Sync does not cause a transaction block opened with <command>BEGIN</command>
     to be closed.  It is possible to detect this situation since the
     ReadyForQuery message includes transaction status information.
    </para>
____________________________________________________________________________-->
    <para>
     Sync并不导致一个用<command>BEGIN</command>打开的事务块关闭。我们可以侦测到这种情况，因为ReadyForQuery消息包含事务状态信息。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    In addition to these fundamental, required operations, there are several
    optional operations that can be used with extended-query protocol.
   </para>
____________________________________________________________________________-->
   <para>
    除了这些基本的、必须的操作之外，在扩展查询协议里还有几种可选的操作可以使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    The Describe message (portal variant) specifies the name of an existing
    portal (or an empty string for the unnamed portal).  The response is a
    RowDescription message describing the rows that will be returned by
    executing the portal; or a NoData message if the portal does not contain a
    query that will return rows; or ErrorResponse if there is no such portal.
   </para>
____________________________________________________________________________-->
   <para>
    Describe消息（入口变体）指定一个现有的入口的名字（或者一个空字符串表示未命名入口）。响应是一个RowDescription消息，它描述了执行该入口将要返回的行；或者是一个NoData消息——果入口并不包含会返回行的查询；或者是一个ErrorResponse——如果入口不存在。
   </para>

<!--==========================orignal english content==========================
   <para>
    The Describe message (statement variant) specifies the name of an existing
    prepared statement (or an empty string for the unnamed prepared
    statement).  The response is a ParameterDescription message describing the
    parameters needed by the statement, followed by a RowDescription message
    describing the rows that will be returned when the statement is eventually
    executed (or a NoData message if the statement will not return rows).
    ErrorResponse is issued if there is no such prepared statement.  Note that
    since Bind has not yet been issued, the formats to be used for returned
    columns are not yet known to the backend; the format code fields in the
    RowDescription message will be zeroes in this case.
   </para>
____________________________________________________________________________-->
   <para>
    Describe消息（语句变体）指定一个现有的预备语句的名字（或者一个空字符串表示未命名预备语句）。 响应是一个描述该语句需要的参数的ParameterDescription消息，后面跟着一个描述该语句最终执行后返回的行的RowDescription消息（或者是 NoData 消息，如果该语句不返回行）。如果没有这样的预备语句，则返回ErrorResponse。请注意因为还没有发出Bind，所以后端还不知道用于返回列的格式；在这种情况下，RowDescription消息里面的格式代码域将是零。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     In most scenarios the frontend should issue one or the other variant
     of Describe before issuing Execute, to ensure that it knows how to
     interpret the results it will get back.
    </para>
____________________________________________________________________________-->
    <para>
     在大多数情况下，前端在发出Execute之前应该发出某种Describe的变体，以保证它知道如何解析它将得到的结果。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    The Close message closes an existing prepared statement or portal
    and releases resources.  It is not an error to issue Close against
    a nonexistent statement or portal name.  The response is normally
    CloseComplete, but could be ErrorResponse if some difficulty is
    encountered while releasing resources.  Note that closing a prepared
    statement implicitly closes any open portals that were constructed
    from that statement.
   </para>
____________________________________________________________________________-->
   <para>
    Close消息关闭一个现有的预备语句或者入口，并且释放资源。对一个不存在的语句或者入口发出Close不是一个错误。响应通常是CloseComplete，但如果在释放资源的时候遇到了一些困难也可以是ErrorResponse。请注意关闭一个预备语句会隐含地关闭任何从该语句构造出来的打开的入口。
   </para>

<!--==========================orignal english content==========================
   <para>
    The Flush message does not cause any specific output to be generated,
    but forces the backend to deliver any data pending in its output
    buffers.  A Flush must be sent after any extended-query command except
    Sync, if the frontend wishes to examine the results of that command before
    issuing more commands.  Without Flush, messages returned by the backend
    will be combined into the minimum possible number of packets to minimize
    network overhead.
   </para>
____________________________________________________________________________-->
   <para>
    Flush消息并产生任何特定的输出，但是强制后端发送任何还在它的输出缓冲区中待处理的数据。Flush必须在除Sync外的任何扩展查询命令后面发出——如果前端希望在发出更多的命令之前检查该命令的结果的话。如果没有Flush，后端返回的消息将组合成尽可能少的数据包，以减少网络负荷。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The simple Query message is approximately equivalent to the series Parse,
     Bind, portal Describe, Execute, Close, Sync, using the unnamed prepared
     statement and portal objects and no parameters.  One difference is that
     it will accept multiple SQL statements in the query string, automatically
     performing the bind/describe/execute sequence for each one in succession.
     Another difference is that it will not return ParseComplete, BindComplete,
     CloseComplete, or NoData messages.
    </para>
____________________________________________________________________________-->
    <para>
     简单查询消息大概等于一系列使用未命名预备语句和无参数入口对象的Parse、Bind、入口Describe、Execute、Close、Sync。一个区别是它会在查询字符串中接受多个SQL语句，并连续地为每个语句自动执行绑定/描述/执行序列。另外一个区别是它不会返回ParseComplete、Bindcomplete、CloseComplete或者NoData消息。
    </para>
   </note>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Function Call</title>
____________________________________________________________________________-->
   <title> 函数调用</title>

<!--==========================orignal english content==========================
   <para>
    The Function Call sub-protocol allows the client to request a direct
    call of any function that exists in the database's
    <structname>pg_proc</structname> system catalog.  The client must have
    execute permission for the function.
   </para>
____________________________________________________________________________-->
   <para>
    函数调用子协议允许客户端请求一个对存在于数据库<structname>pg_proc</structname>系统表中的任意函数的直接调用。客户端必须在该函数上有执行的权限。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The Function Call sub-protocol is a legacy feature that is probably best
     avoided in new code.  Similar results can be accomplished by setting up
     a prepared statement that does <literal>SELECT function($1, ...)</literal>.
     The Function Call cycle can then be replaced with Bind/Execute.
    </para>
____________________________________________________________________________-->
    <para>
     函数调用子协议是一个遗留的特性，在新代码里可能最好避免用它。类似的结果可以通过设置一个执行<literal>SELECT function($1, ...)</literal>的预备语句得到。这样函数调用周期就可以用 Bind/Execute 代替。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    A Function Call cycle is initiated by the frontend sending a
    FunctionCall message to the backend.  The backend then sends one
    or more response messages depending on the results of the function
    call, and finally a ReadyForQuery response message.  ReadyForQuery
    informs the frontend that it can safely send a new query or
    function call.
   </para>
____________________________________________________________________________-->
   <para>
    一个函数调用周期是由前端向后端发送一条FunctionCall消息初始化的。然后后端根据函数调用的结果发送一条或者更多响应消息，并且最后是一条ReadyForQuery响应消息。ReadyForQuery通知前端它可以安全地发送一个新的查询或者函数调用了。
   </para>

<!--==========================orignal english content==========================
   <para>
    The possible response messages from the backend are:

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        An error has occurred.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
        The function call was completed and returned the result given
        in the message.
        (Note that the Function Call protocol can only handle a single
        scalar result, not a row type or set of results.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        Processing of the function call is complete.  ReadyForQuery
        will always be sent, whether processing terminates
        successfully or with an error.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        A warning message has been issued in relation to the function
        call.  Notices are in addition to other responses, i.e., the
        backend will continue processing the command.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
____________________________________________________________________________-->
   <para>
    来自后端的可能的响应消息是：

    <variablelist>
     <varlistentry>
      <term>ErrorResponse</term>
      <listitem>
       <para>
        发生了一个错误。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>FunctionCallResponse</term>
      <listitem>
       <para>
        函数调用完成并且在消息中返回一个结果（请注意函数调用协议只能处理单个标量结果，不能处理行类型或者集合类型的结果）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>ReadyForQuery</term>
      <listitem>
       <para>
        函数调用处理完成。ReadyForQuery将总是被发送，不管是成功完成处理还是发生一个错误。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>NoticeResponse</term>
      <listitem>
       <para>
        发出了一条有关该函数调用的警告信息。通知是附加在其他响应上的，也就是说，后端将继续处理该命令。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="protocol-copy">
<!--==========================orignal english content==========================
   <title>COPY Operations</title>
____________________________________________________________________________-->
   <title>COPY操作</title>

<!--==========================orignal english content==========================
   <para>
    The <command>COPY</command> command allows high-speed bulk data transfer
    to or from the server.  Copy-in and copy-out operations each switch
    the connection into a distinct sub-protocol, which lasts until the
    operation is completed.
   </para>
____________________________________________________________________________-->
   <para>
    <command>COPY</command>命令允许在服务器和客户端之间进行高速大批量数据传输。拷贝入和拷贝出操作每个都把连接切换到一个独立的子协议中，并且持续到操作结束。
   </para>

<!--==========================orignal english content==========================
   <para>
    Copy-in mode (data transfer to the server) is initiated when the
    backend executes a <command>COPY FROM STDIN</command> SQL statement.  The backend
    sends a CopyInResponse message to the frontend.  The frontend should
    then send zero or more CopyData messages, forming a stream of input
    data.  (The message boundaries are not required to have anything to do
    with row boundaries, although that is often a reasonable choice.)
    The frontend can terminate the copy-in mode by sending either a CopyDone
    message (allowing successful termination) or a CopyFail message (which
    will cause the <command>COPY</command> SQL statement to fail with an
    error).  The backend then reverts to the command-processing mode it was
    in before the <command>COPY</command> started, which will be either simple or
    extended query protocol.  It will next send either CommandComplete
    (if successful) or ErrorResponse (if not).
   </para>
____________________________________________________________________________-->
   <para>
    拷贝入模式（数据传输到服务器）是在后端执行一个<command>COPY FROM STDIN</command>语句的时候初始化的。后端发送一个CopyInResponse消息给前端。前端应该发送零条或者更多CopyData消息，形成一个输出数据的流（消息的边界和行的边界没有任何相关性要求，尽管通常那是合理的选择）。前端可以通过发送一个CopyDone消息来终止拷贝入操作（允许成功终止），也可以发出一个CopyFail消息（它将导致<command>COPY</command>语句带着错误失败）。 然后后端就恢复回它在<command>COPY</command>开始之前的命令处理模式，可能是简单查询协议，也可能是扩展查询协议。然后它会发送CommandComplete（如果成功）或者ErrorResponse（如果失败）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In the event of a backend-detected error during copy-in mode (including
    receipt of a CopyFail message), the backend will issue an ErrorResponse
    message.  If the <command>COPY</command> command was issued via an extended-query
    message, the backend will now discard frontend messages until a Sync
    message is received, then it will issue ReadyForQuery and return to normal
    processing.  If the <command>COPY</command> command was issued in a simple
    Query message, the rest of that message is discarded and ReadyForQuery
    is issued.  In either case, any subsequent CopyData, CopyDone, or CopyFail
    messages issued by the frontend will simply be dropped.
   </para>
____________________________________________________________________________-->
   <para>
    如果在拷贝入模式下后端检测到了错误（包括接受接收到CopyFiail消息， 或者是任何除了CopyData或者CopyDone之外的前端消息），那么后端将发出一个ErrorResponse消息。如果<command>COPY</command>命令是通过一个扩展查询消息发出的， 那么后端从现在开始将抛弃前端消息，直到一个Sync消息到达，然后它将发出ReadyForQuery并且返回到正常的处理中。如果<command>COPY</command>命令是在一个简单查询消息里发出的，那么该消息剩余部分被丢弃然后发出ReadyForQuery消息。不管是哪种情况，任何前端发出的CopyData、CopyDone或者CopyFail消息都将被简单地抛弃。
   </para>

<!--==========================orignal english content==========================
   <para>
    The backend will ignore Flush and Sync messages received during copy-in
    mode.  Receipt of any other non-copy message type constitutes an error
    that will abort the copy-in state as described above.  (The exception for
    Flush and Sync is for the convenience of client libraries that always
    send Flush or Sync after an Execute message, without checking whether
    the command to be executed is a <command>COPY FROM STDIN</command>.)
   </para>
____________________________________________________________________________-->
   <para>
    在拷贝入模式下，后端将忽略所收到的Flush和Sync消息。收到任何其他非拷贝消息类型都会造成一个错误，它将导致上面所描述的拷贝入状态中断（Flush和Sync的例外是为了方便客户端库，它们总是在一个Execute消息之后发送Flush和Sync，而不检查被执行的命令是否为一个<command>COPY FROM STDIN</command>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Copy-out mode (data transfer from the server) is initiated when the
    backend executes a <command>COPY TO STDOUT</command> SQL statement.  The backend
    sends a CopyOutResponse message to the frontend, followed by
    zero or more CopyData messages (always one per row), followed by CopyDone.
    The backend then reverts to the command-processing mode it was
    in before the <command>COPY</command> started, and sends CommandComplete.
    The frontend cannot abort the transfer (except by closing the connection
    or issuing a Cancel request),
    but it can discard unwanted CopyData and CopyDone messages.
   </para>
____________________________________________________________________________-->
   <para>
    拷贝出模式（数据从服务器发出）是在后端执行一个<command>COPY TO STDOUT</command>语句的时候初始化的。后端发出一个CopyOutResponse消息给前端，后面跟着零或者多个CopyData消息（总是每行一个），然后跟着CopyDone。然后后端回退到它在<command>COPY</command>开始之前的命令处理模式，然后发送CommandComplete。前端不能退出传输（除非是关闭连接或者发出一个Cancel请求），但是它可以抛弃不需要的CopyData和CopyDone消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    In the event of a backend-detected error during copy-out mode,
    the backend will issue an ErrorResponse message and revert to normal
    processing.  The frontend should treat receipt of ErrorResponse as
    terminating the copy-out mode.
   </para>
____________________________________________________________________________-->
   <para>
    在拷贝出模式中，如果后端检测到错误，那么它将发出一个ErrorResponse消息并且回到正常的处理。前端应该把收到ErrorResponse当作终止拷贝出模式的标志。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is possible for NoticeResponse and ParameterStatus messages to be
    interspersed between CopyData messages; frontends must handle these cases,
    and should be prepared for other asynchronous message types as well (see
    <xref linkend="protocol-async"/>).  Otherwise, any message type other than
    CopyData or CopyDone may be treated as terminating copy-out mode.
   </para>
____________________________________________________________________________-->
   <para>
    在CopyData消息中间可能会散布有NoticeResponse和ParameterStatus消息。前端必须处理这些情况，并且应该也为异步消息类型（参见<xref linkend="protocol-async"/>）准备好。否则任何除CopyData或CopyDone之外的消息类型都会被认为是要中止拷贝出模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    There is another Copy-related mode called copy-both, which allows
    high-speed bulk data transfer to <emphasis>and</emphasis> from the server.
    Copy-both mode is initiated when a backend in walsender mode
    executes a <command>START_REPLICATION</command> statement.  The
    backend sends a CopyBothResponse message to the frontend.  Both
    the backend and the frontend may then send CopyData messages
    until either end sends a CopyDone message. After the client
    sends a CopyDone message, the connection goes from copy-both mode to
    copy-out mode, and the client may not send any more CopyData messages.
    Similarly, when the server sends a CopyDone message, the connection
    goes into copy-in mode, and the server may not send any more CopyData
    messages. After both sides have sent a CopyDone message, the copy mode
    is terminated, and the backend reverts to the command-processing mode.
    In the event of a backend-detected error during copy-both mode,
    the backend will issue an ErrorResponse message, discard frontend messages
    until a Sync message is received, and then issue ReadyForQuery and return
    to normal processing.  The frontend should treat receipt of ErrorResponse
    as terminating the copy in both directions; no CopyDone should be sent
    in this case.  See <xref linkend="protocol-replication"/> for more
    information on the subprotocol transmitted over copy-both mode.
   </para>
____________________________________________________________________________-->
   <para>
    还有另外一种被称为双向拷贝的与拷贝相关的模式，它允许“向”<emphasis>和</emphasis>“从”服务器高速传输大批量数据。当后端处于walsender模式中执行一个<command>START_REPLICATION</command>语句时，它会启动双向拷贝模式。后端会发送一个CopyBothResponse消息给前端。然后前端和后端都会发送CopyData消息，然后直到最后发送一个CopyDone消息。在客户端发送一个CopyDone消息后，连接将从双向拷贝模式转换到拷贝出模式，并且客户端将不能发送更多CopyData消息。类似的，当服务器发送了一个CopyDone消息，连接进入到拷贝入模式，并且服务器将不能发送更多CopyData消息。在双方发送完一个CopyDone消息后，拷贝模式被中断，而后端将回到之前的命令处理模式。如果在双向拷贝模式中出现一个后端检测到的错误，后端将发出一个ErrorResponse消息，然后将发出ReadyForQuery并返回到普通处理。前端将把收到ErrorResponse作为在双向上中断拷贝的信号，在这种情况下不会有CopyDone被发出。关于在双向拷贝模式下传输的子协议请参见<xref linkend="protocol-replication"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The CopyInResponse, CopyOutResponse and CopyBothResponse messages
    include fields that inform the frontend of the number of columns
    per row and the format codes being used for each column.  (As of
    the present implementation, all columns in a given <command>COPY</command>
    operation will use the same format, but the message design does not
    assume this.)
   </para>
____________________________________________________________________________-->
   <para>
    CopyInResponse、CopyOutResponse和CopyBothResponse消息包括域和格式代码，域告诉前端每行的列数，而格式代码则用于具体每个列（就目前的实现而言，一个给定<command>COPY</command>操作中的所有列都将使用同样的格式，但是消息设计并不做这个假设）。
   </para>

  </sect2>

  <sect2 id="protocol-async">
<!--==========================orignal english content==========================
   <title>Asynchronous Operations</title>
____________________________________________________________________________-->
   <title> 异步操作</title>

<!--==========================orignal english content==========================
   <para>
    There are several cases in which the backend will send messages that
    are not specifically prompted by the frontend's command stream.
    Frontends must be prepared to deal with these messages at any time,
    even when not engaged in a query.
    At minimum, one should check for these cases before beginning to
    read a query response.
   </para>
____________________________________________________________________________-->
   <para>
    有几种情况下后端会发送一些并非由特定前端命令流传达的消息。在任何时候前端都必须准备处理这些消息，即使它是并未参与一个查询。在最低限度下，我们应该在开始读取查询响应之前检查这些情况。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is possible for NoticeResponse messages to be generated due to
    outside activity; for example, if the database administrator commands
    a <quote>fast</quote> database shutdown, the backend will send a NoticeResponse
    indicating this fact before closing the connection.  Accordingly,
    frontends should always be prepared to accept and display NoticeResponse
    messages, even when the connection is nominally idle.
   </para>
____________________________________________________________________________-->
   <para>
    NoticeResponse消息有可能是因为外部的活动而产生的；比如，如果数据库管理员进行一次<quote>快速</quote>数据库关闭，那么后端将在关闭连接之前发送一个NoticeResponse来表明这些。相应地，前端应该总是准备接受和显示NoticeResponse消息，即使连接事实上是空闲的。
   </para>

<!--==========================orignal english content==========================
   <para>
    ParameterStatus messages will be generated whenever the active
    value changes for any of the parameters the backend believes the
    frontend should know about.  Most commonly this occurs in response
    to a <command>SET</command> SQL command executed by the frontend, and
    this case is effectively synchronous &mdash; but it is also possible
    for parameter status changes to occur because the administrator
    changed a configuration file and then sent the
    <systemitem>SIGHUP</systemitem> signal to the server.  Also,
    if a <command>SET</command> command is rolled back, an appropriate
    ParameterStatus message will be generated to report the current
    effective value.
   </para>
____________________________________________________________________________-->
   <para>
    如果任何时候有任何参数值的活跃值改变且后端认为前端应该知道这些，那么都会产生ParameterStatus消息。这种情况最常见发生的情形是对前端执行的一个<command>SET</command>命令进行响应，并且这种情况实际上是同步的 &mdash; 但是也有可能是数据库管理员改变了配置文件然后项服务器发出<systemitem>SIGHUP</systemitem>信号导致了参数状态的变化。同样，如果一个<command>SET</command>命令回滚，那么也会生成一个合适的ParameterStatus	消息以报告当前有效值。
   </para>

<!--==========================orignal english content==========================
   <para>
    At present there is a hard-wired set of parameters for which
    ParameterStatus will be generated: they are
    <varname>server_version</varname>,
    <varname>server_encoding</varname>,
    <varname>client_encoding</varname>,
    <varname>application_name</varname>,
    <varname>is_superuser</varname>,
    <varname>session_authorization</varname>,
    <varname>DateStyle</varname>,
    <varname>IntervalStyle</varname>,
    <varname>TimeZone</varname>,
    <varname>integer_datetimes</varname>, and
    <varname>standard_conforming_strings</varname>.
    (<varname>server_encoding</varname>, <varname>TimeZone</varname>, and
    <varname>integer_datetimes</varname> were not reported by releases before 8.0;
    <varname>standard_conforming_strings</varname> was not reported by releases
    before 8.1;
    <varname>IntervalStyle</varname> was not reported by releases before 8.4;
    <varname>application_name</varname> was not reported by releases before 9.0.)
    Note that
    <varname>server_version</varname>,
    <varname>server_encoding</varname> and
    <varname>integer_datetimes</varname>
    are pseudo-parameters that cannot change after startup.
    This set might change in the future, or even become configurable.
    Accordingly, a frontend should simply ignore ParameterStatus for
    parameters that it does not understand or care about.
   </para>
____________________________________________________________________________-->
   <para>
    目前，系统内有一套会生成ParameterStatus消息的写成硬代码的参数，它们是：
    
     （server_encoding，TimeZone 和 integer_datetimes 在 8.0 版本之前没有报告。standard_conforming_strings 在版本 8.1 之前没有报告。） 请注意 server_version， server_encoding 和 integer_datetimes 是伪参数，启动后不能修改。 这些可能在将来改变，或者甚至是变成可以配置的。 因此，前端应该简单地忽略那些它不懂或者不关心的 ParameterStatus。
    <varname>server_version</varname>、
    <varname>server_encoding</varname>、
    <varname>client_encoding</varname>、
    <varname>application_name</varname>、
    <varname>is_superuser</varname>、
    <varname>session_authorization</varname>、
    <varname>DateStyle</varname>、
    <varname>IntervalStyle</varname>、
    <varname>TimeZone</varname>、
    <varname>integer_datetimes</varname>以及
    <varname>standard_conforming_strings</varname>
    （<varname>server_encoding</varname>、<varname>TimeZone</varname>以及<varname>integer_datetimes</varname>在版本8.0之前不会被报告；
    <varname>standard_conforming_strings</varname>在版本8.1之前不会被报告；
    <varname>IntervalStyle</varname>在版本8.4之前不会被报告；
    <varname>application_name</varname>在版本9.0之前不会被报告）。
    注意<varname>server_version</varname>、<varname>server_encoding</varname>以及<varname>integer_datetimes</varname>是伪参数，它们不能在启动之后被改变。这种设置可能在未来改变，甚至变成可配置的。相应地，一个前端应该简单地忽略那些与它不懂或者不关心的参数相关的ParameterStatus。
   </para>

<!--==========================orignal english content==========================
   <para>
    If a frontend issues a <command>LISTEN</command> command, then the
    backend will send a NotificationResponse message (not to be
    confused with NoticeResponse!)  whenever a
    <command>NOTIFY</command> command is executed for the same
    channel name.
   </para>
____________________________________________________________________________-->
   <para>
    如果前端发出一个<command>LISTEN</command>命令， 那么无论何时在为同一个通道名<command>NOTIFY</command>时，后端将发送一个NotificationResponse消息（不要和NoticeResponse搞混！）。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     At present, NotificationResponse can only be sent outside a
     transaction, and thus it will not occur in the middle of a
     command-response series, though it might occur just before ReadyForQuery.
     It is unwise to design frontend logic that assumes that, however.
     Good practice is to be able to accept NotificationResponse at any
     point in the protocol.
    </para>
____________________________________________________________________________-->
    <para>
     目前，NotificationResponse只能在一个事务外面发送，因此它将不会在一个命令响应序列中间出现，但是它可能正好在ReadyForQuery之前出现。不过，在前端逻辑中做上述假设是不明智的。好的做法是在协议的任何点上都可以接受NotificationResponse。
    </para>
   </note>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Canceling Requests in Progress</title>
____________________________________________________________________________-->
   <title> 取消正在处理的请求</title>

<!--==========================orignal english content==========================
   <para>
    During the processing of a query, the frontend might request
    cancellation of the query.  The cancel request is not sent
    directly on the open connection to the backend for reasons of
    implementation efficiency: we don't want to have the backend
    constantly checking for new input from the frontend during query
    processing.  Cancel requests should be relatively infrequent, so
    we make them slightly cumbersome in order to avoid a penalty in
    the normal case.
   </para>
____________________________________________________________________________-->
   <para>
    在一条查询正在处理的时候，前端可以请求取消该查询。这种取消请求不是直接通过打开的连接发送给后端的，这么做是因为实现的效率：我们不希望后端在处理查询的过程中不停地检查前端来的输入。 取消请求应该相对而言比较少见，所以我们把取消做得稍微笨拙一些，以便不影响正常状况的性能。
   </para>

<!--==========================orignal english content==========================
   <para>
    To issue a cancel request, the frontend opens a new connection to
    the server and sends a CancelRequest message, rather than the
    StartupMessage message that would ordinarily be sent across a new
    connection.  The server will process this request and then close
    the connection.  For security reasons, no direct reply is made to
    the cancel request message.
   </para>
____________________________________________________________________________-->
   <para>
    要发出一条取消请求，前端打开一个与服务器的新连接并且发送一条CancelRequest消息， 而不是通常在新连接中经常发送的StartupMessage消息。服务器将处理这个请求然后关闭连接。 出于安全原因，对取消请求消息不做直接的响应。
   </para>

<!--==========================orignal english content==========================
   <para>
    A CancelRequest message will be ignored unless it contains the
    same key data (PID and secret key) passed to the frontend during
    connection start-up.  If the request matches the PID and secret
    key for a currently executing backend, the processing of the
    current query is aborted.  (In the existing implementation, this is
    done by sending a special signal to the backend process that is
    processing the query.)
   </para>
____________________________________________________________________________-->
   <para>
    除非CancelRequest消息包含在连接启动过程中传递给前端的相同的关键数据（PID和密钥），否则它将被忽略。如果该请求匹配当前运行着的后端的PID和密钥， 则退出当前查询的处理（目前的实现里采用的方法是向正在处理该查询的后端进程发送一个特殊的信号）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The cancellation signal might or might not have any effect &mdash; for
    example, if it arrives after the backend has finished processing
    the query, then it will have no effect.  If the cancellation is
    effective, it results in the current command being terminated
    early with an error message.
   </para>
____________________________________________________________________________-->
   <para>
    取消信号可能产生或者不产生效果 &mdash; 例如，如果它在后端完成查询的处理后到达，那么它就没有做用。如果取消起作用了，会导致当前命令伴随着一个错误消息提前退出。
   </para>

<!--==========================orignal english content==========================
   <para>
    The upshot of all this is that for reasons of both security and
    efficiency, the frontend has no direct way to tell whether a
    cancel request has succeeded.  It must continue to wait for the
    backend to respond to the query.  Issuing a cancel simply improves
    the odds that the current query will finish soon, and improves the
    odds that it will fail with an error message instead of
    succeeding.
   </para>
____________________________________________________________________________-->
   <para>
    这么做是对安全性和有效性通盘考虑的结果，前端没有直接的方法获知一个取消请求是否成功。它必须继续等待后端对查询响应。发出一个取消仅仅是增加了当前查询快些结束的可能性， 同时也增加了当前查询会伴随着一条错误消息失败而不是成功执行的可能性。
   </para>

<!--==========================orignal english content==========================
   <para>
    Since the cancel request is sent across a new connection to the
    server and not across the regular frontend/backend communication
    link, it is possible for the cancel request to be issued by any
    process, not just the frontend whose query is to be canceled.
    This might provide additional flexibility when building
    multiple-process applications.  It also introduces a security
    risk, in that unauthorized persons might try to cancel queries.
    The security risk is addressed by requiring a dynamically
    generated secret key to be supplied in cancel requests.
   </para>
____________________________________________________________________________-->
   <para>
    因为取消请求是通过新的联接发送给服务器而不是通过平常的前端/后端通讯链接，所以取消请求可能被任意进程发出的，而不仅仅是要取消查询的前端。 这样可能对创建多进程应用提供了更多的灵活性。同时这样也带来了安全风险，因为任何一个非授权用户都可能试图取消查询。这个安全风险通过要求在取消请求中提供一个动态生成的密钥来解决。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Termination</title>
____________________________________________________________________________-->
   <title>终止</title>

<!--==========================orignal english content==========================
   <para>
    The normal, graceful termination procedure is that the frontend
    sends a Terminate message and immediately closes the connection.
    On receipt of this message, the backend closes the connection and
    terminates.
   </para>
____________________________________________________________________________-->
   <para>
    通常优雅的终止过程是前端发送一条Terminate消息并且立刻关闭连接。一旦收到消息，后端马上关闭连接并且终止。
   </para>

<!--==========================orignal english content==========================
   <para>
    In rare cases (such as an administrator-commanded database shutdown)
    the backend might disconnect without any frontend request to do so.
    In such cases the backend will attempt to send an error or notice message
    giving the reason for the disconnection before it closes the connection.
   </para>
____________________________________________________________________________-->
   <para>
    在少数情况下（比如一个管理员命令数据库关闭），后端可能在没有任何前端请求的情况下断开连接。在这种情况下，后端将在它断开连接之前尝试发送一个错误或者通知消息给出断开的原因。
   </para>

<!--==========================orignal english content==========================
   <para>
    Other termination scenarios arise from various failure cases, such as core
    dump at one end or the other, loss of the communications link, loss of
    message-boundary synchronization, etc.  If either frontend or backend sees
    an unexpected closure of the connection, it should clean
    up and terminate.  The frontend has the option of launching a new backend
    by recontacting the server if it doesn't want to terminate itself.
    Closing the connection is also advisable if an unrecognizable message type
    is received, since this probably indicates loss of message-boundary sync.
   </para>
____________________________________________________________________________-->
   <para>
    其它终止的情况发生在各种失败的场合，比如某一方的内核转储、失去通讯链路、丢失了消息边界同步等。不管是前端还是后端看到了一个意外的连接关闭，那么它应该清理现场并且终止。 如果前端不想终止自己，那么它有一个选项是重连服务器的方法启动一个新的后端。如果收到了一个无法识别的消息类型，那么我们也建议关闭连接，因为出现这种情况可能意味着是丢失了消息边界的同步。
   </para>

<!--==========================orignal english content==========================
   <para>
    For either normal or abnormal termination, any open transaction is
    rolled back, not committed.  One should note however that if a
    frontend disconnects while a non-<command>SELECT</command> query
    is being processed, the backend will probably finish the query
    before noticing the disconnection.  If the query is outside any
    transaction block (<command>BEGIN</command> ... <command>COMMIT</command>
    sequence) then its results might be committed before the
    disconnection is recognized.
   </para>
____________________________________________________________________________-->
   <para>
    不管是正常还是不正常的终止，任何打开的事务都会回滚而不是提交。不过，我们应该注意的是如果一个前端在一个非<command>SELECT</command>查询正在处理的时候断开， 那么后端很可能在发现断开之前先完成查询的处理。如果查询处于任何事务块之外（<command>BEGIN</command> ... <command>COMMIT</command>序列），那么其结果很可能在得知断开之前被提交。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><acronym>SSL</acronym> Session Encryption</title>
____________________________________________________________________________-->
   <title><acronym>SSL</acronym>会话加密</title>

<!--==========================orignal english content==========================
   <para>
    If <productname>PostgreSQL</productname> was built with
    <acronym>SSL</acronym> support, frontend/backend communications
    can be encrypted using <acronym>SSL</acronym>.  This provides
    communication security in environments where attackers might be
    able to capture the session traffic. For more information on
    encrypting <productname>PostgreSQL</productname> sessions with
    <acronym>SSL</acronym>, see <xref linkend="ssl-tcp"/>.
   </para>
____________________________________________________________________________-->
   <para>
    如果编译<productname>PostgreSQL</productname>的时候打开了<acronym>SSL</acronym>支持，那么前后端通讯就可以用<acronym>SSL</acronym>加密。 这样就提供了一种在攻击者可能捕获会话通讯数据包的环境下保证通讯安全的方法。有关使用<acronym>SSL</acronym>加密<productname>PostgreSQL</productname>会话的更多信息， 请参阅<xref linkend="ssl-tcp"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    To initiate an <acronym>SSL</acronym>-encrypted connection, the
    frontend initially sends an SSLRequest message rather than a
    StartupMessage.  The server then responds with a single byte
    containing <literal>S</literal> or <literal>N</literal>, indicating that it is
    willing or unwilling to perform <acronym>SSL</acronym>,
    respectively.  The frontend might close the connection at this point
    if it is dissatisfied with the response.  To continue after
    <literal>S</literal>, perform an <acronym>SSL</acronym> startup handshake
    (not described here, part of the <acronym>SSL</acronym>
    specification) with the server.  If this is successful, continue
    with sending the usual StartupMessage.  In this case the
    StartupMessage and all subsequent data will be
    <acronym>SSL</acronym>-encrypted.  To continue after
    <literal>N</literal>, send the usual StartupMessage and proceed without
    encryption.
   </para>
____________________________________________________________________________-->
   <para>
    要开始一次<acronym>SSL</acronym>加密连接，前端先是发送一个SSLRequest消息，而不是StartupMessage。然后服务器以一个包含<literal>S</literal>或<literal>N</literal>的字节响应，分别表示它愿意还是不愿意进行<acronym>SSL</acronym>。如果此时前端对响应不满意， 那么它可以关闭连接。要在<literal>S</literal>之后继续，那么先进行与服务器的<acronym>SSL</acronym>启动握手（没有在这里描述，是<acronym>SSL</acronym>规范的一部分）。 如果这些成功了，那么继续发送普通的StartupMessage。这种情况下，StartupMessage和所有随后的数据都将由<acronym>SSL</acronym>加密。要在<literal>N</literal>之后继续，则发送普通的StartupMessage并不适用加密继续处理。
   </para>

<!--==========================orignal english content==========================
   <para>
    The frontend should also be prepared to handle an ErrorMessage
    response to SSLRequest from the server.  This would only occur if
    the server predates the addition of <acronym>SSL</acronym> support
    to <productname>PostgreSQL</productname>.  (Such servers are now very ancient,
    and likely do not exist in the wild anymore.)
    In this case the connection must
    be closed, but the frontend might choose to open a fresh connection
    and proceed without requesting <acronym>SSL</acronym>.
   </para>
____________________________________________________________________________-->
   <para>
    前端应该也准备处理一个来自服务器的给SSLRequest的ErrorMessage响应。这种情况只在服务器早于<productname>PostgreSQL</productname>的<acronym>SSL</acronym>支持的情况下才会出现（这种服务器现在非常古老，并且可能不再存在了）。在这种情况下，连接必需关闭，但是前端可以选择打开一个新的连接然后不使用<acronym>SSL</acronym>进行连接。
   </para>

<!--==========================orignal english content==========================
   <para>
    An initial SSLRequest can also be used in a connection that is being
    opened to send a CancelRequest message.
   </para>
____________________________________________________________________________-->
   <para>
    一个初始化的 SSLRequest 也可以用于打开来用于发送一条 CancelRequest 消息的联接中。
   </para>

<!--==========================orignal english content==========================
   <para>
    While the protocol itself does not provide a way for the server to
    force <acronym>SSL</acronym> encryption, the administrator can
    configure the server to reject unencrypted sessions as a byproduct
    of authentication checking.
   </para>
____________________________________________________________________________-->
   <para>
    如果协议本身并未提供某种方法强制<acronym>SSL</acronym>加密，那么管理员可以把服务器配置为拒绝未加密的会话，这是认证检查的一个副产品。
   </para>
  </sect2>
 </sect1>

<sect1 id="sasl-authentication">
<!--==========================orignal english content==========================
<title>SASL Authentication</title>
____________________________________________________________________________-->
<title>SASL认证</title>

<!--==========================orignal english content==========================
<para>
<firstterm>SASL</firstterm> is a framework for authentication in connection-oriented
protocols. At the moment, <productname>PostgreSQL</productname> implements two SASL
authentication mechanisms, SCRAM-SHA-256 and SCRAM-SHA-256-PLUS. More
might be added in the future. The below steps illustrate how SASL
authentication is performed in general, while the next subsection gives
more details on SCRAM-SHA-256 and SCRAM-SHA-256-PLUS.
</para>
____________________________________________________________________________-->
<para>
<firstterm>SASL</firstterm>是一种针对面向连接协议的认证框架。当前，<productname>PostgreSQL</productname>实现了两种SASL认证机制，即SCRAM-SHA-256和SCRAM-SHA-256-PLUS。未来可能会增加更多。下面的步骤展示了通常SASL认证是如何执行的，而接下来的小节会给出更多有关SCRAM-SHA-256和SCRAM-SHA-256-PLUS的细节。
</para>

<procedure>
<!--==========================orignal english content==========================
<title>SASL Authentication Message Flow</title>
____________________________________________________________________________-->
<title>SASL认证消息流</title>

<step id="sasl-auth-begin">
<!--==========================orignal english content==========================
<para>
  To begin a SASL authentication exchange, the server sends an
  AuthenticationSASL message. It includes a list of SASL authentication
  mechanisms that the server can accept, in the server's preferred order.
</para>
____________________________________________________________________________-->
<para>
  为了开始一次SASL认证交换，服务器发送一个AuthenticationSASL消息。它包括一个服务器能够接受的SASL认证机制的列表，这个列表按照服务器喜欢的顺序组织。
</para>
</step>

<step id="sasl-auth-initial-response">
<!--==========================orignal english content==========================
<para>
  The client selects one of the supported mechanisms from the list, and sends
  a SASLInitialResponse message to the server. The message includes the name
  of the selected mechanism, and an optional Initial Client Response, if the
  selected mechanism uses that.
</para>
____________________________________________________________________________-->
<para>
  客户端从该列表中选取一种受支持的机制，并且发送一个SASLInitialResponse消息给服务器。该消息包括选中的机制名称以及一个可选的初始客户端响应（如果选中的机制要用到）。
</para>
</step>

<step id="sasl-auth-continue">
<!--==========================orignal english content==========================
<para>
  One or more server-challenge and client-response message will follow. Each
  server-challenge is sent in an AuthenticationSASLContinue message, followed
  by a response from client in an SASLResponse message. The particulars of
  the messages are mechanism specific.
</para>
____________________________________________________________________________-->
<para>
  接下来将是一个或者多个服务器挑战和客户端响应消息。每一次的服务器挑战都通过一个AuthenticationSASLContinue消息发送，后面会跟着客户端通过SASLResponse消息发送的响应。这些消息的细节与机制有关。
</para>
</step>

<step id="sasl-auth-end">
<!--==========================orignal english content==========================
<para>
  Finally, when the authentication exchange is completed successfully, the
  server sends an AuthenticationSASLFinal message, followed
  immediately by an AuthenticationOk message. The AuthenticationSASLFinal
  contains additional server-to-client data, whose content is particular to the
  selected authentication mechanism. If the authentication mechanism doesn't
  use additional data that's sent at completion, the AuthenticationSASLFinal
  message is not sent.
</para>
____________________________________________________________________________-->
<para>
  最后，当认证交换成功完成，服务器发送一个AuthenticationSASLFinal消息，后面马上跟上一个AuthenticationOk消息。AuthenticationSASLFinal包含服务器发给客户端的额外数据，其内容与选中的认证机制有关。如果认证机制不使用在完成时发送的额外数据，则不发送AuthenticationSASLFinal消息。
</para>
</step>
</procedure>

<!--==========================orignal english content==========================
<para>
On error, the server can abort the authentication at any stage, and send an
ErrorMessage.
</para>
____________________________________________________________________________-->
<para>
在出错时，服务器可以在任何阶段中止认证，并且发送一个ErrorMessage。
</para>

 <sect2 id="sasl-scram-sha-256">
<!--==========================orignal english content==========================
  <title>SCRAM-SHA-256 authentication</title>
____________________________________________________________________________-->
  <title>SCRAM-SHA-256认证</title>

<!--==========================orignal english content==========================
  <para>
   The implemented SASL mechanisms at the moment
   are <literal>SCRAM-SHA-256</literal> and its variant with channel
   binding <literal>SCRAM-SHA-256-PLUS</literal>. They are described in
   detail in RFC 7677 and RFC 5802.
  </para>
____________________________________________________________________________-->
  <para>
   目前实现的SASL机制是<literal>SCRAM-SHA-256</literal>及其带有通道绑定的变体<literal>SCRAM-SHA-256-PLUS</literal>。它们在RFC 7677和RFC 5802中有详细描述。
  </para>

<!--==========================orignal english content==========================
  <para>
When SCRAM-SHA-256 is used in PostgreSQL, the server will ignore the user name
that the client sends in the <structname>client-first-message</structname>. The user name
that was already sent in the startup message is used instead.
<productname>PostgreSQL</productname> supports multiple character encodings, while SCRAM
dictates UTF-8 to be used for the user name, so it might be impossible to
represent the PostgreSQL user name in UTF-8.
  </para>
____________________________________________________________________________-->
  <para>
当PostgreSQL使用SCRAM-SHA-256时，服务器将忽略客户端在<structname>client-first-message</structname>中发送的用户名，而是使用在启动消息中已经发过来的用户名。<productname>PostgreSQL</productname>支持多字符编码，然而SCRAM要求用户名使用UTF-8，因此可能无法表示PostgreSQL中的UTF-8用户名。
  </para>

<!--==========================orignal english content==========================
  <para>
The SCRAM specification dictates that the password is also in UTF-8, and is
processed with the <firstterm>SASLprep</firstterm> algorithm.
<productname>PostgreSQL</productname>, however, does not require UTF-8 to be used for
the password. When a user's password is set, it is processed with SASLprep
as if it was in UTF-8, regardless of the actual encoding used. However, if
it is not a legal UTF-8 byte sequence, or it contains UTF-8 byte sequences
that are prohibited by the SASLprep algorithm, the raw password will be used
without SASLprep processing, instead of throwing an error. This allows the
password to be normalized when it is in UTF-8, but still allows a non-UTF-8
password to be used, and doesn't require the system to know which encoding
the password is in.
  </para>
____________________________________________________________________________-->
  <para>
SCRAM规范要求口令也是UTF-8，并且要用<firstterm>SASLprep</firstterm>算法对口令进行处理。但是，<productname>PostgreSQL</productname>不要求对口令使用UTF-8。在设置一个用户的口令时，会把口令当作是UTF-8一样用SASLprep处理，而不管实际使用的编码是什么。不过，如果口令不是一种合法的UTF-8字节序列或者含有SASLprep算法禁止的UTF-8字节序列，将直接使用未被SASLprep处理过的原始口令，而不是抛出错误。这使得不是UTF-8的口令能够被规范化，但是也允许使用非UTF-8的口令，并且不要求系统了解口令到底是什么编码。
  </para>

<!--==========================orignal english content==========================
  <para>
<firstterm>Channel binding</firstterm> is supported in PostgreSQL builds with
SSL support. The SASL mechanism name for SCRAM with channel binding is
<literal>SCRAM-SHA-256-PLUS</literal>.  The channel binding type used by
PostgreSQL is <literal>tls-server-end-point</literal>.
  </para>
____________________________________________________________________________-->
  <para>
在编译了SSL支持的PostgreSQL中支持<firstterm>通道绑定</firstterm>。带有通道绑定的SCRAM的SASL机制名是<literal>SCRAM-SHA-256-PLUS</literal>。被PostgreSQL使用的通道绑定类型是<literal>tls-server-end-point</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   In <acronym>SCRAM</acronym> without channel binding, the server chooses
   a random number that is transmitted to the client to be mixed with the
   user-supplied password in the transmitted password hash.  While this
   prevents the password hash from being successfully retransmitted in
   a later session, it does not prevent a fake server between the real
   server and client from passing through the server's random value 
   and successfully authenticating.
  </para>
____________________________________________________________________________-->
  <para>
   在没有通道绑定的<acronym>SCRAM</acronym>中，服务器选择一个随机数，它被传送给客户端，客户端会把这个随机数与用户提供的口令混合在被传输的口令哈希中。虽然这能够防止在后面的会话中成功地重新传送这个口令哈希，但是却无法防止位于真实服务器和客户端之间的伪服务器经手服务器的随机值并且认证成功。
  </para>

<!--==========================orignal english content==========================
  <para>
   <acronym>SCRAM</acronym> with channel binding prevents such
   man-in-the-middle attacks by mixing the signature of the server's
   certificate into the transmitted password hash. While a fake server can
   retransmit the real server's certificate, it doesn't have access to the
   private key matching that certificate, and therefore cannot prove it is
   the owner, causing SSL connection failure.
  </para>
____________________________________________________________________________-->
  <para>
   带有通道绑定的<acronym>SCRAM</acronym>通过将服务器证书的签名混入被传输的口令哈希来防止这类中间人攻击。虽然伪服务器能够重新传输真实服务器的证书，但是它无法访问匹配该证书的私钥，因此无法证明它是其拥有者，进而导致SSL连接失败。
  </para>

<procedure>
<!--==========================orignal english content==========================
<title>Example</title>
____________________________________________________________________________-->
<title>示例</title>
  <step id="scram-begin">
<!--==========================orignal english content==========================
<para>
  The server sends an AuthenticationSASL message. It includes a list of
  SASL authentication mechanisms that the server can accept.
  This will be <literal>SCRAM-SHA-256-PLUS</literal>
  and <literal>SCRAM-SHA-256</literal> if the server is built with SSL
  support, or else just the latter.
</para>
____________________________________________________________________________-->
<para>
  服务器发送一个AuthenticationSASL消息。它包括一个服务器能够接受的SASL认证机制列表。如果服务器编译有SSL支持，这个列表将会是<literal>SCRAM-SHA-256-PLUS</literal>和<literal>SCRAM-SHA-256</literal>，否则列表中只会有后者。
</para>
</step>
<step id="scram-client-first">
<!--==========================orignal english content==========================
<para>
  The client responds by sending a SASLInitialResponse message, which
  indicates the chosen mechanism, <literal>SCRAM-SHA-256</literal> or
  <literal>SCRAM-SHA-256-PLUS</literal>. (A client is free to choose either
  mechanism, but for better security it should choose the channel-binding
  variant if it can support it.) In the Initial Client response field, the
  message contains the SCRAM <structname>client-first-message</structname>.
  The <structname>client-first-message</structname> also contains the channel
  binding type chosen by the client.
</para>
____________________________________________________________________________-->
<para>
  客户端通过发送一个SASLInitialResponse消息进行响应，该消息指出选中的机制，即<literal>SCRAM-SHA-256</literal>或者<literal>SCRAM-SHA-256-PLUS</literal>（客户端可以自由地选择机制，但是为了更安全在可以支持通道绑定变体时应该选择它）。在Initial Client响应字段中，该消息包含SCRAM的<structname>client-first-message</structname>。<structname>client-first-message</structname>还包含客户端选中的通道绑定类型。
</para>
</step>
<step id="scram-server-first">
<!--==========================orignal english content==========================
<para>
  Server sends an AuthenticationSASLContinue message, with a SCRAM
  <structname>server-first-message</structname> as the content.
</para>
____________________________________________________________________________-->
<para>
  服务器发送一个AuthenticationSASLContinue消息，其内容是一个SCRAM的<structname>server-first message</structname>。
</para>
</step>
<step id="scram-client-final">
<!--==========================orignal english content==========================
<para>
  Client sends a SASLResponse message, with SCRAM
  <structname>client-final-message</structname> as the content.
</para>
____________________________________________________________________________-->
<para>
  客户端发送一个SASLResponse消息，其内容是SCRAM的<structname>client-final-message</structname>。
</para>
</step>
<step id="scram-server-final">
<!--==========================orignal english content==========================
<para>
  Server sends an AuthenticationSASLFinal message, with the SCRAM
  <structname>server-final-message</structname>, followed immediately by
  an AuthenticationOk message.
</para>
____________________________________________________________________________-->
<para>
  服务器发送一个AuthenticationSASLFinal消息，其中是SCRAM的<structname>server-final-message</structname>，后面紧接着一个AuthenticationOk消息。
</para>
</step>
</procedure>
</sect2>
</sect1>

<sect1 id="protocol-replication">
<!--==========================orignal english content==========================
<title>Streaming Replication Protocol</title>
____________________________________________________________________________-->
<title>流复制协议</title>

<!--==========================orignal english content==========================
<para>
To initiate streaming replication, the frontend sends the
<literal>replication</literal> parameter in the startup message. A Boolean
value of <literal>true</literal> (or <literal>on</literal>,
<literal>yes</literal>, <literal>1</literal>) tells the backend to go into
physical replication walsender mode, wherein a small set of replication
commands, shown below, can be issued instead of SQL statements.
</para>
____________________________________________________________________________-->
<para>
要启动流复制，前端在启动消息中发送<literal>replication</literal>参数。布尔值<literal>true</literal>（或者<literal>on</literal>、<literal>yes</literal>、<literal>1</literal>）告诉后端进入到物理复制的walsender模式，在其中可以发出一个小型的复制命令集合（见下文）而不是普通的SQL命令。
</para>

<!--==========================orignal english content==========================
<para>
Passing <literal>database</literal> as the value for the
<literal>replication</literal> parameter instructs the backend to go into
logical replication walsender mode, connecting to the database specified in
the <literal>dbname</literal> parameter.  In logical replication walsender
mode, the replication commands shown below as well as normal SQL commands can
be issued.
</para>
____________________________________________________________________________-->
<para>
将<literal>database</literal>作为<literal>replication</literal>参数的值传递会指示后端进入到逻辑复制的walsender模式，连接到<literal>dbname</literal>参数指定的数据库。在逻辑复制的walsender模式中，可以发出下文所示的复制命令以及普通的SQL命令。
</para>

<!--==========================orignal english content==========================
<para>
In either physical replication or logical replication walsender mode, only the
simple query protocol can be used.
</para>
____________________________________________________________________________-->
<para>
在物理复制或者逻辑复制的walsender模式中，只能使用简单查询协议。
</para>

<!--==========================orignal english content==========================
<para>
 For the purpose of testing replication commands, you can make a replication
 connection via <application>psql</application> or any other <literal>libpq</literal>-using
 tool with a connection string including the <literal>replication</literal> option,
 e.g.:
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
 However, it is often more useful to use
 <xref linkend="app-pgreceivewal"/> (for physical replication) or
 <xref linkend="app-pgrecvlogical"/> (for logical replication).
</para>
____________________________________________________________________________-->
<para>
 出于测试复制命令的目的，你可以通过<application>psql</application>或者任何使用<literal>libpq</literal>的工具使用包含<literal>replication</literal>选项的连接字符串建立一个复制连接，例如：
<programlisting>
psql "dbname=postgres replication=database" -c "IDENTIFY_SYSTEM;"
</programlisting>
 不过更常用的是：<xref linkend="app-pgreceivewal"/>（对于物理复制）或者<xref linkend="app-pgrecvlogical"/>（对于逻辑复制）。
</para>

<!--==========================orignal english content==========================
<para>
Replication commands are logged in the server log when
<xref linkend="guc-log-replication-commands"/> is enabled.
</para>
____________________________________________________________________________-->
<para>
当<xref linkend="guc-log-replication-commands"/>被启用时，复制命令会被记录在服务器日志中。
</para>

<!--==========================orignal english content==========================
<para>
The commands accepted in replication mode are:
<variablelist>
  <varlistentry>
    <term><literal>IDENTIFY_SYSTEM</literal>
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>
      Requests the server to identify itself. Server replies with a result
      set of a single row, containing four fields:
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>systemid</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       The unique system identifier identifying the cluster. This
       can be used to check that the base backup used to initialize the
       standby came from the same cluster.
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>timeline</literal> (<type>int4</type>)
      </term>
      <listitem>
      <para>
       Current timeline ID. Also useful to check that the standby is
       consistent with the master.
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>xlogpos</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       Current WAL flush location. Useful to get a known location in the
       write-ahead log where streaming can start.
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>dbname</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       Database connected to or null.
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>SHOW</literal> <replaceable class="parameter">name</replaceable>
     <indexterm><primary>SHOW</primary></indexterm>
    </term>
    <listitem>
     <para>
      Requests the server to send the current setting of a run-time parameter.
      This is similar to the SQL command <xref linkend="sql-show"/>.
     </para>

     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">name</replaceable></term>
       <listitem>
         <para>
          The name of a run-time parameter. Available parameters are documented
          in <xref linkend="runtime-config"/>.
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>
      Requests the server to send over the timeline history file for timeline
      <replaceable class="parameter">tli</replaceable>.  Server replies with a
      result set of a single row, containing two fields:
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>filename</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       File name of the timeline history file, e.g., <filename>00000002.history</filename>.
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>content</literal> (<type>bytea</type>)
      </term>
      <listitem>
      <para>
       Contents of the timeline history file.
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry id="protocol-replication-create-slot" xreflabel="CREATE_REPLICATION_SLOT">
   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] }
     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      Create a physical or logical replication
      slot. See <xref linkend="streaming-replication-slots"/> for more about
      replication slots.
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          The name of the slot to create. Must be a valid replication slot
          name (see <xref linkend="streaming-replication-slots-manipulation"/>).
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">output_plugin</replaceable></term>
       <listitem>
         <para>
          The name of the output plugin used for logical decoding
          (see <xref linkend="logicaldecoding-output-plugin"/>).
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>TEMPORARY</literal></term>
       <listitem>
        <para>
         Specify that this replication slot is a temporary one. Temporary
         slots are not saved to disk and are automatically dropped on error
         or when the session has finished.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>RESERVE_WAL</literal></term>
       <listitem>
        <para>
         Specify that this physical replication slot reserves <acronym>WAL</acronym>
         immediately.  Otherwise, <acronym>WAL</acronym> is only reserved upon
         connection from a streaming replication client.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>EXPORT_SNAPSHOT</literal></term>
       <term><literal>NOEXPORT_SNAPSHOT</literal></term>
       <term><literal>USE_SNAPSHOT</literal></term>
       <listitem>
        <para>
         Decides what to do with the snapshot created during logical slot
         initialization. <literal>EXPORT_SNAPSHOT</literal>, which is the default,
         will export the snapshot for use in other sessions. This option can't
         be used inside a transaction.  <literal>USE_SNAPSHOT</literal> will use the
         snapshot for the current transaction executing the command. This
         option must be used in a transaction, and
         <literal>CREATE_REPLICATION_SLOT</literal> must be the first command
         run in that transaction.  Finally, <literal>NOEXPORT_SNAPSHOT</literal> will
         just use the snapshot for logical decoding as normal but won't do
         anything else with it.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      In response to this command, the server will send a one-row result set
      containing the following fields:

      <variablelist>
       <varlistentry>
        <term><literal>slot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          The name of the newly-created replication slot.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>consistent_point</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          The WAL location at which the slot became consistent.  This is the
          earliest location from which streaming can start on this replication
          slot.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>snapshot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          The identifier of the snapshot exported by the command.  The
          snapshot is valid until a new command is executed on this connection
          or the replication connection is closed.  Null if the created slot
          is physical.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>output_plugin</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          The name of the output plugin used by the newly-created replication
          slot.  Null if the created slot is physical.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
     <indexterm><primary>START_REPLICATION</primary></indexterm>
    </term>
    <listitem>
     <para>
      Instructs server to start streaming WAL, starting at
      WAL location <replaceable class="parameter">XXX/XXX</replaceable>.
      If <literal>TIMELINE</literal> option is specified,
      streaming starts on timeline <replaceable class="parameter">tli</replaceable>;
      otherwise, the server's current timeline is selected. The server can
      reply with an error, for example if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
     </para>

     <para>
      If a slot's name is provided
      via <replaceable class="parameter">slot_name</replaceable>, it will be updated
      as replication progresses so that the server knows which WAL segments,
      and if <varname>hot_standby_feedback</varname> is on which transactions,
      are still needed by the standby.
     </para>

     <para>
      If the client requests a timeline that's not the latest but is part of
      the history of the server, the server will stream all the WAL on that
      timeline starting from the requested start point up to the point where
      the server switched to another timeline. If the client requests
      streaming at exactly the end of an old timeline, the server responds
      immediately with CommandComplete without entering COPY mode.
     </para>

     <para>
      After streaming all the WAL on a timeline that is not the latest one,
      the server will end streaming by exiting the COPY mode. When the client
      acknowledges this by also exiting COPY mode, the server sends a result
      set with one row and two columns, indicating the next timeline in this
      server's history. The first column is the next timeline's ID (type <type>int8</type>), and the
      second column is the WAL location where the switch happened (type <type>text</type>). Usually,
      the switch position is the end of the WAL that was streamed, but there
      are corner cases where the server can send some WAL from the old
      timeline that it has not itself replayed before promoting. Finally, the
      server sends CommandComplete message, and is ready to accept a new
      command.
     </para>

     <para>
      WAL data is sent as a series of CopyData messages.  (This allows
      other information to be intermixed; in particular the server can send
      an ErrorResponse message if it encounters a failure after beginning
      to stream.)  The payload of each CopyData message from server to the
      client contains a message of one of the following formats:
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          XLogData (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('w')
      </term>
      <listitem>
      <para>
          Identifies the message as WAL data.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The starting point of the WAL data in this message.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The current end of WAL on the server.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte<replaceable>n</replaceable>
      </term>
      <listitem>
      <para>
          A section of the WAL data stream.
      </para>
      <para>
          A single WAL record is never split across two XLogData messages.
          When a WAL record crosses a WAL page boundary, and is therefore
          already split using continuation records, it can be split at the page
          boundary. In other words, the first main WAL record and its
          continuation records can be sent in different XLogData messages.
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Primary keepalive message (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('k')
      </term>
      <listitem>
      <para>
          Identifies the message as a sender keepalive.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The current end of WAL on the server.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The server's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          1 means that the client should reply to this message as soon as
          possible, to avoid a timeout disconnect. 0 otherwise.
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
       The receiving process can send replies back to the sender at any time,
       using one of the following message formats (also in the payload of a
       CopyData message):
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          Standby status update (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('r')
      </term>
      <listitem>
      <para>
          Identifies the message as a receiver status update.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The location of the last WAL byte + 1 received and written to disk
          in the standby.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The location of the last WAL byte + 1 flushed to disk in
          the standby.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The location of the last WAL byte + 1 applied in the standby.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          If 1, the client requests the server to reply to this message
          immediately. This can be used to ping the server, to test if
          the connection is still healthy.
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          Hot Standby feedback message (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('h')
      </term>
      <listitem>
      <para>
          Identifies the message as a Hot Standby feedback message.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          The client's system clock at the time of transmission, as
          microseconds since midnight on 2000-01-01.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          The standby's current global xmin, excluding the catalog_xmin from any
          replication slots. If both this value and the following
          catalog_xmin are 0 this is treated as a notification that Hot Standby
          feedback will no longer be sent on this connection. Later non-zero
          messages may reinitiate the feedback mechanism.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          The epoch of the global xmin xid on the standby.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          The lowest catalog_xmin of any replication slots on the standby. Set to 0
          if no catalog_xmin exists on the standby or if hot standby feedback is being
          disabled.
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          The epoch of the catalog_xmin xid on the standby.
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>
    <listitem>
     <para>
      Instructs server to start streaming WAL for logical replication, starting
      at WAL location <replaceable class="parameter">XXX/XXX</replaceable>. The server can
      reply with an error, for example if the requested section of WAL has already
      been recycled. On success, server responds with a CopyBothResponse
      message, and then starts to stream WAL to the frontend.
     </para>

     <para>
      The messages inside the CopyBothResponse messages are of the same format
      documented for <literal>START_REPLICATION ... PHYSICAL</literal>.
     </para>

     <para>
      The output plugin associated with the selected slot is used
      to process the output for streaming.
     </para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          The name of the slot to stream changes from. This parameter is required,
          and must correspond to an existing logical replication slot created
          with <literal>CREATE_REPLICATION_SLOT</literal> in
          <literal>LOGICAL</literal> mode.
         </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</replaceable></term>
       <listitem>
        <para>
         The WAL location to begin streaming at.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_name</replaceable></term>
       <listitem>
        <para>
         The name of an option passed to the slot's logical decoding plugin.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_value</replaceable></term>
       <listitem>
        <para>
         Optional value, in the form of a string constant, associated with the
         specified option.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>
     <literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      Drops a replication slot, freeing any reserved server-side resources.
      If the slot is a logical slot that was created in a database other than
      the database the walsender is connected to, this command fails.
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          The name of the slot to drop.
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>WAIT</literal></term>
       <listitem>
        <para>
         This option causes the command to wait if the slot is active until
         it becomes inactive, instead of the default behavior of raising an
         error.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ] [ <literal>NOVERIFY_CHECKSUMS</literal> ]
     <indexterm><primary>BASE_BACKUP</primary></indexterm>
    </term>
    <listitem>
     <para>
      Instructs the server to start streaming a base backup.
      The system will automatically be put in backup mode before the backup
      is started, and taken out of it when the backup is complete. The
      following options are accepted:
      <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
        <listitem>
         <para>
          Sets the label of the backup. If none is specified, a backup label
          of <literal>base backup</literal> will be used. The quoting rules
          for the label are the same as a standard SQL string with
          <xref linkend="guc-standard-conforming-strings"/> turned on.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</literal></term>
        <listitem>
         <para>
          Request information required to generate a progress report. This will
          send back an approximate size in the header of each tablespace, which
          can be used to calculate how far along the stream is done. This is
          calculated by enumerating all the file sizes once before the transfer
          is even started, and might as such have a negative impact on the
          performance.  In particular, it might take longer before the first data
          is streamed. Since the database files can change during the backup,
          the size is only approximate and might both grow and shrink between
          the time of approximation and the sending of the actual files.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</literal></term>
        <listitem>
         <para>
          Request a fast checkpoint.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>
          Include the necessary WAL segments in the backup. This will include
          all the files between start and stop backup in the
          <filename>pg_wal</filename> directory of the base directory tar
          file.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>
          By default, the backup will wait until the last required WAL
          segment has been archived, or emit a warning if log archiving is
          not enabled. Specifying <literal>NOWAIT</literal> disables both
          the waiting and the warning, leaving the client responsible for
          ensuring the required log is available.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>
        <listitem>
         <para>
          Limit (throttle) the maximum amount of data transferred from server
          to client per unit of time.  The expected unit is kilobytes per second.
          If this option is specified, the value must either be equal to zero
          or it must fall within the range from 32 kB through 1 GB (inclusive).
          If zero is passed or the option is not specified, no restriction is
          imposed on the transfer.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>TABLESPACE_MAP</literal></term>
        <listitem>
         <para>
          Include information about symbolic links present in the directory
          <filename>pg_tblspc</filename> in a file named
          <filename>tablespace_map</filename>. The tablespace map file includes
          each symbolic link name as it exists in the directory
          <filename>pg_tblspc/</filename> and the full path of that symbolic link.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOVERIFY_CHECKSUMS</literal></term>
        <listitem>
         <para>
          By default, checksums are verified during a base backup if they are
          enabled. Specifying <literal>NOVERIFY_CHECKSUMS</literal> disables
          this verification.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      When the backup is started, the server will first send two
      ordinary result sets, followed by one or more CopyResponse
      results.
     </para>
     <para>
      The first ordinary result set contains the starting position of the
      backup, in a single row with two columns. The first column contains
      the start position given in XLogRecPtr format, and the second column
      contains the corresponding timeline ID.
     </para>
     <para>
      The second ordinary result set has one row for each tablespace.
      The fields in this row are:
      <variablelist>
       <varlistentry>
        <term><literal>spcoid</literal> (<type>oid</type>)</term>
        <listitem>
         <para>
          The OID of the tablespace, or null if it's the base
          directory.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>spclocation</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          The full path of the tablespace directory, or null
          if it's the base directory.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>size</literal> (<type>int8</type>)</term>
        <listitem>
         <para>
          The approximate size of the tablespace, if progress report has
          been requested; otherwise it's null.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      After the second regular result set, one or more CopyResponse results
      will be sent, one for the main data directory and one for each additional tablespace other
      than <literal>pg_default</literal> and <literal>pg_global</literal>. The data in
      the CopyResponse results will be a tar format (following the
      <quote>ustar interchange format</quote> specified in the POSIX 1003.1-2008
      standard) dump of the tablespace contents, except that the two trailing
      blocks of zeroes specified in the standard are omitted.
      After the tar data is complete, a final ordinary result set will be sent,
      containing the WAL end position of the backup, in the same format as
      the start position.
     </para>

     <para>
      The tar archive for the data directory and each tablespace will contain
      all files in the directories, regardless of whether they are
      <productname>PostgreSQL</productname> files or other files added to the same
      directory. The only excluded files are:
      <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_internal.init</filename> (found in multiple directories)
        </para>
       </listitem>
       <listitem>
        <para>
         Various temporary files and directories created during the operation
         of the PostgreSQL server, such as any file or directory beginning
         with <filename>pgsql_tmp</filename> and temporary relations.
        </para>
       </listitem>
       <listitem>
        <para>
         Unlogged relations, except for the init fork which is required to
         recreate the (empty) unlogged relation on recovery.
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_wal</filename>, including subdirectories. If the backup is run
         with WAL files included, a synthesized version of <filename>pg_wal</filename> will be
         included, but it will only contain the files necessary for the
         backup to work, not the rest of the contents.
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_dynshmem</filename>, <filename>pg_notify</filename>,
         <filename>pg_replslot</filename>, <filename>pg_serial</filename>,
         <filename>pg_snapshots</filename>, <filename>pg_stat_tmp</filename>, and
         <filename>pg_subtrans</filename> are copied as empty directories (even if
         they are symbolic links).
        </para>
       </listitem>
       <listitem>
        <para>
         Files other than regular files and directories, such as symbolic
         links (other than for the directories listed above) and special
         device files, are skipped.  (Symbolic links
         in <filename>pg_tblspc</filename> are maintained.)
        </para>
       </listitem>
      </itemizedlist>
      Owner, group, and file mode are set if the underlying file system on
      the server supports it.
     </para>
    </listitem>
  </varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

在复制模式中可以接受的命令有：

<variablelist>
  <varlistentry>
    <term><literal>IDENTIFY_SYSTEM</literal>
     <indexterm><primary>IDENTIFY_SYSTEM</primary></indexterm>
    </term>
    <listitem>
     <para>
      请求服务器标识它自己。服务器以一个行构成的结果集作为答复，其中包含四个域：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>systemid</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       标识该集簇的唯一的系统标识符。这可以被用来检查用于初始化后备机的基础备份是否来自于同一个集簇。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>timeline</literal> (<type>int4</type>)
      </term>
      <listitem>
      <para>
       当前的时间线 ID。也对于检查后备机是否与主控机一致有用。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>xlogpos</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       当前的WAL刷写位置。用于得到一个在预写式日志中的已知位置作为流的开始位置。
      </para>
      </listitem>
      </varlistentry>
      
      <varlistentry>
      <term>
       <literal>dbname</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       要连接到的数据库或者空。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>SHOW</literal> <replaceable class="parameter">name</replaceable>
     <indexterm><primary>SHOW</primary></indexterm>
    </term>
    <listitem>
     <para>
      请求服务器发送一个运行时参数的当前设置。这类似于SQL命令<xref linkend="sql-show"/>。
     </para>

     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">name</replaceable></term>
       <listitem>
         <para>
          运行时参数的名称。可用的参数在<xref linkend="runtime-config"/>中。
         </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>TIMELINE_HISTORY</literal> <replaceable class="parameter">tli</replaceable>
     <indexterm><primary>TIMELINE_HISTORY</primary></indexterm>
    </term>
    <listitem>
     <para>
      请求服务器将时间线<replaceable class="parameter">tli</replaceable>的历史文件发送过来。服务器将以一行组成的结果集作为答复，其中包含两个域：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
       <literal>filename</literal> (<type>text</type>)
      </term>
      <listitem>
      <para>
       时间线历史文件的文件名，例如<filename>00000002.history</filename>。
      </para>
      </listitem>
      </varlistentry>

      <varlistentry>
      <term>
       <literal>content</literal> (<type>bytea</type>)
      </term>
      <listitem>
      <para>
       时间线历史文件的内容。
      </para>
      </listitem>
      </varlistentry>

      </variablelist>
     </para>
    </listitem>
  </varlistentry>
  
  <varlistentry id="protocol-replication-create-slot" xreflabel="CREATE_REPLICATION_SLOT">
   <term><literal>CREATE_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> [ <literal>TEMPORARY</literal> ] { <literal>PHYSICAL</literal> [ <literal>RESERVE_WAL</literal> ] | <literal>LOGICAL</literal> <replaceable class="parameter">output_plugin</replaceable> [ <literal>EXPORT_SNAPSHOT</literal> | <literal>NOEXPORT_SNAPSHOT</literal> | <literal>USE_SNAPSHOT</literal> ] }
     <indexterm><primary>CREATE_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      创建一个物理的或者逻辑的复制槽。更多关于复制槽的内容请见
      <xref linkend="streaming-replication-slots"/>。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          要创建的槽的名称。必须是一个合法的复制槽名称（见
          <xref linkend="streaming-replication-slots-manipulation"/>）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="parameter">output_plugin</replaceable></term>
       <listitem>
         <para>
          被用于逻辑解码的输出插件的名称（见
          <xref linkend="logicaldecoding-output-plugin"/>）。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>TEMPORARY</literal></term>
       <listitem>
        <para>
         指定这个复制槽是一个临时复制槽。临时复制槽不会被保存在磁盘上并且在发生错误或者会话结束时会被自动删除。
        </para>
       </listitem>
      </varlistentry>
      
      <varlistentry>
       <term><literal>RESERVE_WAL</literal></term>
       <listitem>
        <para>
         指定这个物理复制槽立即保留<acronym>WAL</acronym>。否则，只有来自流复制客户端的连接上才会保留<acronym>WAL</acronym>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>EXPORT_SNAPSHOT</literal></term>
       <term><literal>NOEXPORT_SNAPSHOT</literal></term>
       <term><literal>USE_SNAPSHOT</literal></term>
       <listitem>
        <para>
         决定如何处理在逻辑槽初始化期间取到的快照。默认值<literal>EXPORT_SNAPSHOT</literal>将把该快照导出以备在其他会话中使用。这个选项不能在事务外面使用。<literal>USE_SNAPSHOT</literal>将把该快照用于正在执行命令的当前事务。这个选项必须被用在一个事务中，并且<literal>CREATE_REPLICATION_SLOT</literal>必须是该事务中运行的第一个命令。最后，<literal>NOEXPORT_SNAPSHOT</literal>将按照正常把该快照用于逻辑解码，但是不会对它做其他事情。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      作为对这个命令的响应，服务器将发送一个一行的结果集，其中包含下列字段：

      <variablelist>
       <varlistentry>
        <term><literal>slot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          新创建的复制槽的名称。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>consistent_point</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          该槽达到一致的WAL位置。这是在该复制槽上可以开始流的最早位置。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>snapshot_name</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          被这个命令导出的快照的标识符。该快照一直是有效的，直到在这个连接中执行了新的命令或者该复制连接被关闭。如果被创建的槽是物理槽，则为空。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>output_plugin</literal> (<type>text</type>)</term>
        <listitem>
         <para>
          新创建的复制槽使用的输出插件的名称。如果被创建的槽是物理槽，则为空。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>START_REPLICATION</literal> [ <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> ] [ <literal>PHYSICAL</literal> ] <replaceable class="parameter">XXX/XXX</replaceable> [ <literal>TIMELINE</literal> <replaceable class="parameter">tli</replaceable> ]
     <indexterm><primary>START_REPLICATION</primary></indexterm>
    </term>
    <listitem>
     <para>
      指示服务器开始启动流WAL，从 WAL 位置<replaceable class="parameter">XXX/XXX</replaceable>开始。如果<literal>TIMELINE</literal>选项被指定，流传送会在时间线<replaceable class="parameter">tli</replaceable>上开始，否则会选择服务器的当前时间线。服务器可以回复一个错误，例如如果被请求的WAL节已经被回收了。如果成功，服务器将会响应一个CopyBothResponse消息，并且然后开始以流的方式把WAL传送给前端。
     </para>
     
     <para>
      如果通过<replaceable class="parameter">slot_name</replaceable>提供了一个槽的名称，它将被更新复制进度，这样该服务器知道哪些 WAL 段以及哪些事务（如果<varname>hot_standby_feedback</varname>为打开）仍然被后备机所需要。
     </para>

     <para>
      如果客户端请求一个并非最新的时间线，但是属于服务器历史的一部分，服务器将会把该时间线上从请求点开始的所有WAL以流式传送，一直到服务器切换到另外一个时间线的点。如果客户端请求在一个老的时间线末尾进行流传送，服务器将在不进入COPY模式的情况下立即响应CommandComplete。
     </para>

     <para>
      在流传送完一个非最新时间线上所有的WAL之后，服务器将会通过退出COPY模式来结束流。当客户端认识到这一点并也退出COPY模式时，服务器会发送一个包含一行两列的结果集，以指示在该服务器历史中的下一个时间线。第一列是下一个时间线的 ID（类型<type>int8</type>），而第二列是发生切换的 WAL 位置（类型<type>text</type>）。通常，切换位置是被流传送的WAL的末尾，但是在很少的情况下服务器会从旧的时间线中发送一些WAL，而该时间线是服务器本身在提示之前还没有重放的。最后，服务器发送CommandComplete消息，并且做好准备接受一个新的命令。
     </para>

     <para>
      WAL数据以一系列CopyData消息的形式被发送（这允许其他信息穿插其中，特别是服务器可以在开始流传送后遇到失败时发送一个ErrorResponse消息）。每个从服务器到客户端的CopyData消息承载了一个下列格式之一的消息：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          XLogData (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('w')
      </term>
      <listitem>
      <para>
          标识该消息是WAL数据。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在消息中WAL数据的起始点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          服务器上WAL的当前终点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时服务器的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte<replaceable>n</replaceable>
      </term>
      <listitem>
      <para>
          WAL数据流的一节。
      </para>
      <para>
          一个WAL记录绝不会被分割到两个XLogData消息。如果一个WAL记录跨越了一个WAL页面的边界，并且因此已经被使用连续的记录分割，它可以在页面边界被分割。换句话说，第一个主要WAL记录和它的后续记录可以在不同的XLogData消息中被发送。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          主要存活消息 (B)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('k')
      </term>
      <listitem>
      <para>
          标识该消息是一个发送者存活消息。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          服务器上WAL的当前终点。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时服务器的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          1表示客户端应该尽快回复该消息，以避免连接超时。否则为0。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
       接收进程可以在任何时候给发送者发送回复，回复可以使用下列消息格式之一（也在CopData消息中使用）：
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          后备机状态更新 (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('r')
      </term>
      <listitem>
      <para>
          标识该消息是一个接收者状态更新。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          接收到并且写入到后备机磁盘的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          被刷入到后备机磁盘的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          被应用在后备机上的最后一个WAL比特的位置+1。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时客户端的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Byte1
      </term>
      <listitem>
      <para>
          如果为1，客户端要求服务器马上回复这个消息。这可以被用来ping服务器以测试连接是否仍然完好。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>

     <para>
      <variablelist>
      <varlistentry>
      <term>
          热备机反馈消息 (F)
      </term>
      <listitem>
      <para>
      <variablelist>
      <varlistentry>
      <term>
          Byte1('h')
      </term>
      <listitem>
      <para>
          标识该消息是一个热备机反馈消息。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int64
      </term>
      <listitem>
      <para>
          在传送时客户端的系统时钟，以从2000-01-01午夜开始的微妙计。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机的当前全局xmin，排除来自任何复制槽的catalog_xmin。如果这个值和接下来的catalog_xmin都为0，这会被当作一个通知表示在这个连接上将不会再发送热备反馈。后来的非0消息将重新启动反馈机制。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机上全局xmin事务ID的世代。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机上任意复制槽中的最小catalog_xmin。如果在后备机上不存在catalog_xmin或者热备反馈被禁用，这个值被设置为0。
      </para>
      </listitem>
      </varlistentry>
      <varlistentry>
      <term>
          Int32
      </term>
      <listitem>
      <para>
          后备机上全局catalog_xmin事务ID的世代。
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
      </para>
      </listitem>
      </varlistentry>
      </variablelist>
     </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>START_REPLICATION</literal> <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <literal>LOGICAL</literal> <replaceable class="parameter">XXX/XXX</replaceable> [ ( <replaceable>option_name</replaceable> [ <replaceable>option_value</replaceable> ] [, ...] ) ]</term>
    <listitem>
     <para>
      指示服务器为逻辑复制开始流式传送 WAL，从 WAL 位置<replaceable class="parameter">XXX/XXX</replaceable>开始。服务器可以回复一个错误，例如如果请求的 WAL 小节已经回环。如果成功，服务器会响应一个 CopyBothResponse 消息，并且接着开始流失传送 WAL 给前端。
     </para>

     <para>
      消息内部的消息与<literal>START_REPLICATION ... PHYSICAL</literal>中记录的格式相同。
     </para>

     <para>
      与选中槽关联的输出插件被用来处理流的输出。
     </para>

     <variablelist>
      <varlistentry>
       <term><literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          要从哪个槽流式传送改变。这个参数是必须的，并且必须对应于一个现有的用<literal>LOGICAL</literal>模式的<literal>CREATE_REPLICATION_SLOT</literal>创建的逻辑复制槽。
         </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">XXX/XXX</replaceable></term>
       <listitem>
        <para>
         要开始流传送的 WAL 位置。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_name</replaceable></term>
       <listitem>
        <para>
         一个传递给该槽的逻辑解码插件的选项的名称。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><replaceable class="parameter">option_value</replaceable></term>
       <listitem>
        <para>
         字符串常量形式的选项值，与前面指定的选项关联。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>
     <literal>DROP_REPLICATION_SLOT</literal> <replaceable class="parameter">slot_name</replaceable> <optional> <literal>WAIT</literal> </optional>
     <indexterm><primary>DROP_REPLICATION_SLOT</primary></indexterm>
    </term>
    <listitem>
     <para>
      删除一个复制槽，释放任何保留的服务器端资源。如果该槽是一个在不同于walsender所连接的数据库中创建的逻辑槽，这个命令会失败。
     </para>
     <variablelist>
      <varlistentry>
       <term><replaceable class="parameter">slot_name</replaceable></term>
       <listitem>
         <para>
          要删除的槽的名称。
         </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>WAIT</literal></term>
       <listitem>
        <para>
         如果槽正处于活跃状态，这个选项会导致命令等待，直到槽变得不活跃，而不是像默认行为那样直接报错。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term><literal>BASE_BACKUP</literal> [ <literal>LABEL</literal> <replaceable>'label'</replaceable> ] [ <literal>PROGRESS</literal> ] [ <literal>FAST</literal> ] [ <literal>WAL</literal> ] [ <literal>NOWAIT</literal> ] [ <literal>MAX_RATE</literal> <replaceable>rate</replaceable> ] [ <literal>TABLESPACE_MAP</literal> ]
     <indexterm><primary>BASE_BACKUP</primary></indexterm>
    </term>
    <listitem>
     <para>
      指示服务器开始流传送一个基础备份。在备份开始之前系统将自动被置于备份模式，而在备份结束时会自动被退出备份模式。可以接受下列选项：
      <variablelist>
       <varlistentry>
        <term><literal>LABEL</literal> <replaceable>'label'</replaceable></term>
        <listitem>
         <para>
          设置备份的标签。如果没有指定，将会使用<literal>base backup</literal>作为标签。标签的引号规则和<xref linkend="guc-standard-conforming-strings"/>开启时标准SQL字符串的一样。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>PROGRESS</literal></term>
        <listitem>
         <para>
          请求用以生成一个进度报告的信息。这将送回位于每个表空间头部的一个近似大小，它可以被用于计算流还有多久才能被完成。它通过在传输开始之前枚举所有文件大小来计算，并且可能会对性能产生一种负面影响 -- 特别情况下它可能会在流传送第一个数据之前就耗费很长时间。因为数据库文件可能在备份期间改变，这个大小只是近似的并且可能在近似计算和发送真正的文件之间增长或者收缩。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>FAST</literal></term>
        <listitem>
         <para>
          请求一个快速检查点。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>WAL</literal></term>
        <listitem>
         <para>
          在备份中包含必需的WAL段。这将把开始和停止备份之间的所有文件包括在base目录tar文件中的<filename>pg_wal</filename>目录中。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOWAIT</literal></term>
        <listitem>
         <para>
          默认情况下，备份会等待直到最后一个要求的 WAL 段被归档，或者当日至归档被禁用时发出一个警告。指定<literal>NOWAIT</literal>会禁用等待和警告，而让客户端负责确保所要求的日志是可用的。
         </para>
         </listitem>
       </varlistentry>
       
       <varlistentry>
        <term><literal>MAX_RATE</literal> <replaceable>rate</replaceable></term>
        <listitem>
         <para>
          单位时间内从服务器传输到客户端的最大数据量限制。期望的单位是千字节每秒。如果指定了这个选项，值必须等于零或者位于 32 kB到 1 GB（包括）范围之间。如果 0 被传入或者没有指定该选项，对于传输将没有限制。
         </para>
        </listitem>
       </varlistentry>
       
       <varlistentry>
        <term><literal>TABLESPACE_MAP</literal></term>
        <listitem>
         <para>
          在名为<filename>tablespace_map</filename>的文件中包括有关<filename>pg_tblspc</filename>目录中存在的符号链接的信息。这个表空间映射文件包括了在目录<filename>pg_tblspc</filename>中存在的每一个符号链接的名字以及它的完整路径。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>NOVERIFY_CHECKSUMS</literal></term>
        <listitem>
         <para>
          默认情况下，如果启用了校验码，在基础备份期间会验证校验码。指定<literal>NOVERIFY_CHECKSUMS</literal>可以禁用这种验证。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      当备份被启动，服务器将首先发送两个普通结果集，后面会跟着一个或多个CopyResponse结果。
     </para>
     <para>
      第一个普通结果集在一行两列中包含了备份的起始位置。第一列包含使用XLogRecPtr格式给出的开始位置，第二列包含相应的时间线ID。
     </para>
     <para>
      第二个普通结果集中为每一个表空间都有一行。行中的域有：
      <variablelist>
       <varlistentry>
        <term><literal>spcoid</literal>（<type>oid</type>）</term>
        <listitem>
         <para>
          表空间的 OID，如果是base目录则为空。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>spclocation</literal>（<type>text</type>）</term>
        <listitem>
         <para>
          表空间目录的完整路径，如果是base目录则为空。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>size</literal>（<type>int8</type>）</term>
        <listitem>
         <para>
          如果进度报告被请求，这里是表空间的近似大小，否则为空。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      在第二个普通结果集之后，一个或多个CopyResponse结果将被发送，一个用于主数据目录而对每一个除<literal>pg_default</literal>和<literal>pg_global</literal>之外的额外表空间也会有一个。CopyResponse结果中的数据将会使一个tar格式（遵循POSIX 1003.1-2008标准中指定的<quote>ustar交换格式</quote>）的表空间内容转储，不过标准中定义的两个拖尾全0块将被忽略。在tar数据完成后，一个最终普通结果集将被发送，包含了备份的WAL结束位置，格式与起始位置相同。
     </para>

     <para>
      用于数据目录和每个表空间的tar归档将包含目录中的所有文件，不管它们是否为<productname>PostgreSQL</productname>文件或者是被加入的其他文件。唯一被排除的文件是：
      <itemizedlist spacing="compact" mark="bullet">
       <listitem>
        <para>
         <filename>postmaster.pid</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>postmaster.opts</filename>
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_internal.init</filename>（在多个目录中都有）
        </para>
       </listitem>
       <listitem>
        <para>
         在PostgreSQL服务器操作过程中创建的各种临时文件和目录，例如任何以<filename>pgsql_tmp</filename>开头的文件或目录以及临时关系。
        </para>
       </listitem>
       <listitem>
        <para>
         不做日志的关系，init分支除外，恢复时重建（空的）不做日志关系时需要它。
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_wal</filename>及其子目录。如果备份运行时要求包括WAL文件，一个<filename>pg_wal</filename>的合成版本将被包括进来，但是只会包含那些备份工作必需的文件，而不是包含剩下的内容。
        </para>
       </listitem>
       <listitem>
        <para>
         <filename>pg_dynshmem</filename>、<filename>pg_notify</filename>、
         <filename>pg_replslot</filename>、<filename>pg_serial</filename>、
         <filename>pg_snapshots</filename>、<filename>pg_stat_tmp</filename>以及
         <filename>pg_subtrans</filename>会被拷贝为空目录（即使它们是符号链接）。
        </para>
       </listitem>
       <listitem>
        <para>
         跳过除常规文件和目录之外的其他文件，例如符号链接（不同于上面所列出的目录）和特殊设备文件。（<filename>pg_tblspc</filename>中的符号链接会被保留）。
        </para>
       </listitem>
      </itemizedlist>
      如果服务器上的底层文件系统支持，所有者、组合文件模式都会被设置。
     </para>
    </listitem>
  </varlistentry>
</variablelist>

</para>

</sect1>

<sect1 id="protocol-logical-replication">
<!--==========================orignal english content==========================
 <title>Logical Streaming Replication Protocol</title>
____________________________________________________________________________-->
 <title>逻辑流复制协议</title>

<!--==========================orignal english content==========================
 <para>
  This section describes the logical replication protocol, which is the message
  flow started by the <literal>START_REPLICATION</literal>
  <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable>
  <literal>LOGICAL</literal> replication command.
 </para>
____________________________________________________________________________-->
 <para>
  这一节介绍逻辑复制协议，它是一种以复制命令<literal>START_REPLICATION</literal>
  <literal>SLOT</literal> <replaceable class="parameter">slot_name</replaceable>
  <literal>LOGICAL</literal>开始的消息流。
 </para>

<!--==========================orignal english content==========================
 <para>
  The logical streaming replication protocol builds on the primitives of
  the physical streaming replication protocol.
 </para>
____________________________________________________________________________-->
 <para>
  逻辑流复制协议建立在物理流复制协议的原始积累之上。
 </para>

 <sect2 id="protocol-logical-replication-params">
<!--==========================orignal english content==========================
  <title>Logical Streaming Replication Parameters</title>
____________________________________________________________________________-->
  <title>逻辑流复制参数</title>

<!--==========================orignal english content==========================
  <para>
   The logical replication <literal>START_REPLICATION</literal> command
   accepts following parameters:

   <variablelist>
    <varlistentry>
     <term>
      proto_version
     </term>
     <listitem>
      <para>
       Protocol version. Currently only version <literal>1</literal> is
       supported.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      publication_names
     </term>
     <listitem>
      <para>
       Comma separated list of publication names for which to subscribe
       (receive changes). The individual publication names are treated
       as standard objects names and can be quoted the same as needed.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制命令<literal>START_REPLICATION</literal>接受下列参数：

   <variablelist>
    <varlistentry>
     <term>
      proto_version
     </term>
     <listitem>
      <para>
       协议版本。当前支持版本<literal>1</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>
      publication_names
     </term>
     <listitem>
      <para>
       要订阅（接收更改）的publication名称列表，用逗号分隔。每一个publication名称个体都被当作一个标准的对象名称，并且可以根据需要加上引号。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  </para>
 </sect2>

 <sect2 id="protocol-logical-messages">
<!--==========================orignal english content==========================
  <title>Logical Replication Protocol Messages</title>
____________________________________________________________________________-->
  <title>逻辑复制协议消息</title>

<!--==========================orignal english content==========================
  <para>
   The individual protocol messages are discussed in the following
   subsections. Individual messages are described in
   <xref linkend="protocol-logicalrep-message-formats"/>.
  </para>
____________________________________________________________________________-->
  <para>
   协议消息的个体在接下来的小节中讨论。个体的消息在<xref linkend="protocol-logicalrep-message-formats"/>中介绍。
  </para>

<!--==========================orignal english content==========================
  <para>
   All top-level protocol messages begin with a message type byte.
   While represented in code as a character, this is a signed byte with no
   associated encoding.
  </para>
____________________________________________________________________________-->
  <para>
   所有的顶层协议消息都以一个消息类型字节开头。虽然被表示为字符代码，但这是一个没有相关编码的有符号字节。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since the streaming replication protocol supplies a message length there
   is no need for top-level protocol messages to embed a length in their
   header.
  </para>
____________________________________________________________________________-->
  <para>
   由于流复制协议提供了一个消息长度，因此不需要顶层协议消息在其头部嵌入长度。
  </para>

 </sect2>

 <sect2 id="protocol-logical-messages-flow">
<!--==========================orignal english content==========================
  <title>Logical Replication Protocol Message Flow</title>
____________________________________________________________________________-->
  <title>逻辑复制协议的消息流</title>

<!--==========================orignal english content==========================
  <para>
   With the exception of the <literal>START_REPLICATION</literal> command and
   the replay progress messages, all information flows only from the backend
   to the frontend.
  </para>
____________________________________________________________________________-->
  <para>
   除<literal>START_REPLICATION</literal>命令和重放进度消息之外，所有信息流的方向都是从后端到前端。
  </para>

<!--==========================orignal english content==========================
  <para>
   The logical replication protocol sends individual transactions one by one.
   This means that all messages between a pair of Begin and Commit messages
   belong to the same transaction.
  </para>
____________________________________________________________________________-->
  <para>
   逻辑复制协议会逐个发送事务个体。这意味着在一对Begin消息和Commit消息之间的所有消息都属于同一个事务。
  </para>

<!--==========================orignal english content==========================
  <para>
   Every sent transaction contains zero or more DML messages (Insert,
   Update, Delete). In case of a cascaded setup it can also contain Origin
   messages. The origin message indicated that the transaction originated on
   different replication node. Since a replication node in the scope of logical
   replication protocol can be pretty much anything, the only identifier
   is the origin name. It's downstream's responsibility to handle this as
   needed (if needed). The Origin message is always sent before any DML
   messages in the transaction.
  </para>
____________________________________________________________________________-->
  <para>
   每一个被发送的事务都包含零个或者多个DML消息（插入、更新、删除）。在级联设置的情况下，它还包括Origin消息。Origin消息表示该事务是在不同的复制节点上产生的。由于逻辑复制协议范围内的复制节点可以是任何东西，所以唯一的标识符是源头的名称。其下游的责任是根据需要处理这一信息（如果需要处理）。Origin消息总是在事务中任何DML消息之前被发送。
  </para>

<!--==========================orignal english content==========================
  <para>
   Every DML message contains an arbitrary relation ID, which can be mapped to
   an ID in the Relation messages. The Relation messages describe the schema of the
   given relation. The Relation message is sent for a given relation either
   because it is the first time we send a DML message for given relation in the
   current session or because the relation definition has changed since the
   last Relation message was sent for it. The protocol assumes that the client
   is capable of caching the metadata for as many relations as needed.
  </para>
____________________________________________________________________________-->
  <para>
   每个DML消息中都包含一个任意的关系ID，它可以被映射到Relation消息中的一个ID。Relation消息描述给定关系的模式。为一个给定的关系发送Relation消息的时机是：在当前会话中第一次为该关系发送DML消息，或者从上一次该关系的Relation消息以后该关系的定义发生改变。协议假定客户端有能力缓存够用的关系元数据。
  </para>
 </sect2>
</sect1>

<sect1 id="protocol-message-types">
<!--==========================orignal english content==========================
<title>Message Data Types</title>
____________________________________________________________________________-->
<title>消息数据类型</title>

<!--==========================orignal english content==========================
<para>
This section describes the base data types used in messages.

<variablelist>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
                An <replaceable>n</replaceable>-bit integer in network byte
                order (most significant byte first).
                If <replaceable>i</replaceable> is specified it
                is the exact value that will appear, otherwise the value
                is variable.  Eg. Int16, Int32(42).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
                An array of <replaceable>k</replaceable>
                <replaceable>n</replaceable>-bit integers, each in network
                byte order.  The array length <replaceable>k</replaceable>
                is always determined by an earlier field in the message.
                Eg. Int16[M].
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
                A null-terminated string (C-style string).  There is no
                specific length limitation on strings.
                If <replaceable>s</replaceable> is specified it is the exact
                value that will appear, otherwise the value is variable.
                Eg. String, String("user").
</para>

<note>
<para>
<emphasis>There is no predefined limit</emphasis> on the length of a string
that can be returned by the backend.  Good coding strategy for a frontend
is to use an expandable buffer so that anything that fits in memory can be
accepted.  If that's not feasible, read the full string and discard trailing
characters that don't fit into your fixed-size buffer.
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
                Exactly <replaceable>n</replaceable> bytes.  If the field
                width <replaceable>n</replaceable> is not a constant, it is
                always determinable from an earlier field in the message.
                If <replaceable>c</replaceable> is specified it is the exact
                value.  Eg. Byte2, Byte1('\n').
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>
本节描述消息里用到的基本数据类型。

<variablelist>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>(<replaceable>i</replaceable>)
</term>
<listitem>
<para>
                一个网络字节序（高位在前）的<replaceable>n</replaceable>位整数。 如果指定了<replaceable>i</replaceable>， 它就是将出现的准确值，否则该值就是一个变量。如 Int16、Int32(42)。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int<replaceable>n</replaceable>[<replaceable>k</replaceable>]
</term>
<listitem>
<para>
                一个<replaceable>k</replaceable>个<replaceable>n</replaceable>位整数的数组， 每个都是以网络字节序表示的。数组长度<replaceable>k</replaceable>总是由消息前面的域来判断的。比如，Int16[M]。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        String(<replaceable>s</replaceable>)
</term>
<listitem>
<para>
                一个（C风格的）空值结束的字符串。对字符串没有特别的长度限制。如果指定了<replaceable>s</replaceable>，那么它是将出现的确切的值， 否则这个值就是一个变量。比如，String, String("user")。
</para>

<note>
<para>
后端能返回的字符串的长度<emphasis>没有预定义的限制</emphasis>。所以对前端比较好的编码策略是使用某种可扩展的缓冲区，以便能接受任何能放进内存里的东西。如果那样做不可行，则读取完整的字符串然后抛弃不能放进固定大小缓冲区的尾部字符。
</para>
</note>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte<replaceable>n</replaceable>(<replaceable>c</replaceable>)
</term>
<listitem>
<para>
                精确的<replaceable>n</replaceable>字节。 如果域宽度<replaceable>n</replaceable>不是一个常量， 那么我们总是可以从消息中更早的域中判断它。如果指定了<replaceable>c</replaceable>，那么它就是确切数值。 例如，Byte2, Byte1('\n')。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="protocol-message-formats">
<!--==========================orignal english content==========================
<title>Message Formats</title>
____________________________________________________________________________-->
<title>消息格式</title>

<!--==========================orignal english content==========================
<para>
This section describes the detailed format of each message.  Each is marked to
indicate that it can be sent by a frontend (F), a backend (B), or both
(F &amp; B).
Notice that although each message includes a byte count at the beginning,
the message format is defined so that the message end can be found without
reference to the byte count.  This aids validity checking.  (The CopyData
message is an exception, because it forms part of a data stream; the contents
of any individual CopyData message cannot be interpretable on their own.)
</para>
____________________________________________________________________________-->
<para>
本节描述各种消息的详细格式。每种消息都标记来指示它是由前端（F）、后端（B）或者两者（F &amp; B）发送的。 请注意，尽管每条消息在开头都包含一个字节计数，但是消息格式也被定义为无需参考字节计数就可以找到消息的结尾。 这样是为了有效性检查（CopyData消息是一个例外，因为它形成一个数据流的一部分；任意独立的CopyData消息可能是无法自解释的）。
</para>

<variablelist>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationOk (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationOk (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
                Specifies that the authentication was successful.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括这个长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(0)
</term>
<listitem>
<para>
                指定该认证是成功的。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationKerberosV5 (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationKerberosV5 (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
                Specifies that Kerberos V5 authentication is required.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(2)
</term>
<listitem>
<para>
                指定要求Kerberos V5认证。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationCleartextPassword (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationCleartextPassword (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
                Specifies that a clear-text password is required.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一条认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(3)
</term>
<listitem>
<para>
                指定要求一个明文的口令。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationMD5Password (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationMD5Password (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                Specifies that an MD5-encrypted password is required.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
                The salt to use when encrypting the password.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识这条消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                指定要求一个MD5加密的口令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte4
</term>
<listitem>
<para>
                加密口令的时候使用的盐粒。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationSCMCredential (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationSCMCredential (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
                Specifies that an SCM credentials message is required.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识这条消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(6)
</term>
<listitem>
<para>
                指定请求一个SCM信任消息。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationGSS (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationGSS (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
                Specifies that GSSAPI authentication is required.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(7)
</term>
<listitem>
<para>
                指定被请求的是GSSAPI认证。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationSSPI (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationSSPI (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
                Specifies that SSPI authentication is required.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(9)
</term>
<listitem>
<para>
                指定被请求的是SSPI认证。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>
<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationGSSContinue (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationGSSContinue (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Specifies that this message contains GSSAPI or SSPI data.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                GSSAPI or SSPI authentication data.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                指定该消息包含GSSAPI或SSPI数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                GSSAPI或SSPI认证数据。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationSASL (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationSASL (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(10)
</term>
<listitem>
<para>
                Specifies that SASL authentication is required.
</para>
</listitem>
</varlistentry>
</variablelist>
The message body is a list of SASL authentication mechanisms, in the
server's order of preference. A zero byte is required as terminator after
the last authentication mechanism name. For each mechanism, there is the
following:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Name of a SASL authentication mechanism.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(10)
</term>
<listitem>
<para>
                指定SASL认证被要求。
</para>
</listitem>
</varlistentry>
</variablelist>
消息体是一个SASL认证机制的列表，该列表按照服务器偏爱的顺序组织。在最后一个认证机制名称的后面需要一个零字节作为终结符。对于每一种机制，有下列信息：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                一种SASL认证机制的名称。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationSASLContinue (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationSASLContinue (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(11)
</term>
<listitem>
<para>
                Specifies that this message contains a SASL challenge.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL data, specific to the SASL mechanism being used.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(11)
</term>
<listitem>
<para>
                指定这个消息包含一个SASL挑战。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL数据，与使用的SASL机制有关。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
AuthenticationSASLFinal (B)
</term>
____________________________________________________________________________-->
<term>
AuthenticationSASLFinal (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as an authentication request.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Specifies that SASL authentication has completed.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL outcome "additional data", specific to the SASL mechanism
                being used.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个认证请求。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                指定SASL认证已经完成。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL产出的“额外数据”，与使用的SASL机制有关。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
BackendKeyData (B)
</term>
____________________________________________________________________________-->
<term>
BackendKeyData (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifies the message as cancellation key data.
                The frontend must save these values if it wishes to be
                able to issue CancelRequest messages later.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The process ID of this backend.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The secret key of this backend.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                标识该消息是一个取消键数据。如果前端希望能够在稍后发出CancelRequest消息， 那么它必须保存这个值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(12)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                后端的进程号（PID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                此后端的密钥。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Bind (F)
</term>
____________________________________________________________________________-->
<term>
Bind (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                Identifies the message as a Bind command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the destination portal
                (an empty string selects the unnamed portal).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the source prepared statement
                (an empty string selects the unnamed prepared statement).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of parameter format codes that follow
                (denoted <replaceable>C</replaceable> below).
                This can be zero to indicate that there are no parameters
                or that the parameters all use the default format (text);
                or one, in which case the specified format code is applied
                to all parameters; or it can equal the actual number of
                parameters.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
                The parameter format codes.  Each must presently be
                zero (text) or one (binary).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of parameter values that follow (possibly zero).
                This must match the number of parameters needed by the query.
</para>
</listitem>
</varlistentry>
</variablelist>
        Next, the following pair of fields appear for each parameter:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The length of the parameter value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL parameter value.
                No value bytes follow in the NULL case.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                The value of the parameter, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
</para>
</listitem>
</varlistentry>
</variablelist>
        After the last parameter, the following fields appear:
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of result-column format codes that follow
                (denoted <replaceable>R</replaceable> below).
                This can be zero to indicate that there are no result columns
                or that the result columns should all use the default format
                (text);
                or one, in which case the specified format code is applied
                to all result columns (if any); or it can equal the actual
                number of result columns of the query.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>R</replaceable>]
</term>
<listitem>
<para>
                The result-column format codes.  Each must presently be
                zero (text) or one (binary).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                标识该信息是一个绑定命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                目标入口的名字（空字符串则选取未命名的入口）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                源预备语句的名字（空字符串则选取未命名的预备语句）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数格式代码的数目（由下文的<replaceable>C</replaceable>说明）。 这个数值可以是零，表示没有参数，或者是参数都使用缺省格式（文本）； 也可以是一，这种情况下指定的格式代码被应用于所有参数；或者它可以等于实际参数的数目。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
                参数格式代码。目前每个都必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数值的数目（可能为零）。这些必须和查询需要的参数个数匹配。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，每个参数都会出现下面的域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                参数值的长度，以字节计（这个长度并不包含长度本身）。可以为零。 一个特殊的情况是，-1 表示一个NULL参数值。在NULL 的情况下， 后面不会跟着字节值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                参数值，使用关联的格式代码表示的格式。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>
        在最后一个参数之后，出现下面的域：
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的结果列格式代码数目（下文的<replaceable>R</replaceable>描述）。 这个数目可以是零表示没有结果列或者结果列都使用缺省格式（文本）； 也可以是一，这种情况下指定的格式代码被应用于所有结果列（如果有的话）；或者它可以等于查询的结果列的实际数目。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>R</replaceable>]
</term>
<listitem>
<para>
                结果列格式代码。目前每个必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
BindComplete (B)
</term>
____________________________________________________________________________-->
<term>
BindComplete (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
                Identifies the message as a Bind-complete indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('2')
</term>
<listitem>
<para>
                标识该消息为一个绑定结束标识符。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CancelRequest (F)
</term>
____________________________________________________________________________-->
<term>
CancelRequest (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
                The cancel request code.  The value is chosen to contain
                <literal>1234</literal> in the most significant 16 bits, and <literal>5678</literal> in the
                least significant 16 bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The process ID of the target backend.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The secret key for the target backend.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Int32(16)
</term>
<listitem>
<para>
                以字节计的消息长度。包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877102)
</term>
<listitem>
<para>
                取消请求代码。该值被选中在高16位包含<literal>1234</literal>，并且在低16位包含 <literal>5678</literal>（为避免混淆，这个代码不能和任何协议版本号相同）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                目标后端的进程号（PID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                目标后端的密钥。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Close (F)
</term>
____________________________________________________________________________-->
<term>
Close (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Identifies the message as a Close command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>S</literal>' to close a prepared statement; or
                '<literal>P</literal>' to close a portal.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the prepared statement or portal to close
                (an empty string selects the unnamed prepared statement
                or portal).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                标识这条消息是一个Close命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>S</literal>'关闭一个准备的语句；或者'<literal>P</literal>'关闭一个入口。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                一个要关闭的预备语句或者入口的名字（一个空字符串选择未命名的预备语句或者入口）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CloseComplete (B)
</term>
____________________________________________________________________________-->
<term>
CloseComplete (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
                Identifies the message as a Close-complete indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('3')
</term>
<listitem>
<para>
                标识消息是一个Close完成指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CommandComplete (B)
</term>
____________________________________________________________________________-->
<term>
CommandComplete (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Identifies the message as a command-completed response.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
        The command tag.  This is usually a single
        word that identifies which SQL command was completed.
       </para>

       <para>
        For an <command>INSERT</command> command, the tag is
        <literal>INSERT <replaceable>oid</replaceable>
        <replaceable>rows</replaceable></literal>, where
        <replaceable>rows</replaceable> is the number of rows
        inserted. <replaceable>oid</replaceable> is the object ID
        of the inserted row if <replaceable>rows</replaceable> is 1
        and the target table has OIDs;
        otherwise <replaceable>oid</replaceable> is 0.
       </para>

       <para>
        For a <command>DELETE</command> command, the tag is
        <literal>DELETE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows deleted.
       </para>

       <para>
        For an <command>UPDATE</command> command, the tag is
        <literal>UPDATE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows updated.
       </para>

       <para>
        For a <command>SELECT</command> or <command>CREATE TABLE AS</command>
        command, the tag is <literal>SELECT <replaceable>rows</replaceable></literal>
        where <replaceable>rows</replaceable> is the number of rows retrieved.
       </para>

       <para>
        For a <command>MOVE</command> command, the tag is
        <literal>MOVE <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows the
        cursor's position has been changed by.
       </para>

       <para>
        For a <command>FETCH</command> command, the tag is
        <literal>FETCH <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows that
        have been retrieved from the cursor.
       </para>

       <para>
        For a <command>COPY</command> command, the tag is
        <literal>COPY <replaceable>rows</replaceable></literal> where
        <replaceable>rows</replaceable> is the number of rows copied.
        (Note: the row count appears only in
        <productname>PostgreSQL</productname> 8.2 and later.)
       </para>

</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                标识此消息是一个命令结束响应。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
       <para>
        命令标记。它通常是一个单字，标识被完成的SQL命令。
       </para>

       <para>
        对于<command>INSERT</command>命令，该标记是<literal>INSERT <replaceable>oid</replaceable> <replaceable>rows</replaceable></literal>， 其中<replaceable>rows</replaceable>是已被插入的行数。<replaceable>oid</replaceable>是在<replaceable>rows</replaceable>为 1并且目标表有OID时已插入行的对象ID；否则<replaceable>oid</replaceable>就是 0。
       </para>

       <para>
        对于<command>DELETE</command>命令，该标记是<literal>DELETE <replaceable>rows</replaceable></literal>， 其中<replaceable>rows</replaceable>是已被删除的行数。
       </para>

       <para>
        对于<command>UPDATE</command>命令，该标记是<literal>UPDATE <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已被更新的行数。
       </para>

       <para>
        对于<command>SELECT</command>或<command>CREATE TABLE AS</command>命令，该标记是<literal>SELECT <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是被检索的行数。
       </para>

       <para>
        对于<command>MOVE</command>命令，该标记是<literal>MOVE <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是游标位置被移动的行数。
       </para>

       <para>
        对于<command>FETCH</command>命令，该标记是<literal>FETCH <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已从游标中检索出来的行数。
       </para>

       <para>
        对于<command>COPY</command>命令，该标记是<literal>COPY <replaceable>rows</replaceable></literal>，其中<replaceable>rows</replaceable>是已拷贝的行数（注意，行计数只在<productname>PostgreSQL</productname> 8.2及其后的版本中出现）。
       </para>

</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyData (F &amp; B)
</term>
____________________________________________________________________________-->
<term>
CopyData (F &amp; B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
                Identifies the message as <command>COPY</command> data.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                Data that forms part of a <command>COPY</command> data stream.  Messages sent
                from the backend will always correspond to single data rows,
                but messages sent by frontends might divide the data stream
                arbitrarily.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('d')
</term>
<listitem>
<para>
                标识这条消息是一个<command>COPY</command>数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                构成<command>COPY</command>数据流的一部分的数据。从后端发出的消息总是对应单一的数据行，但是前端发出的消息可能会任意分割数据流。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyDone (F &amp; B)
</term>
____________________________________________________________________________-->
<term>
CopyDone (F &amp; B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
                Identifies the message as a <command>COPY</command>-complete indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('c')
</term>
<listitem>
<para>
                标识这条信息是一个<command>COPY</command>结束指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyFail (F)
</term>
____________________________________________________________________________-->
<term>
CopyFail (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
                Identifies the message as a <command>COPY</command>-failure indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                An error message to report as the cause of failure.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('f')
</term>
<listitem>
<para>
                标识这条消息是一个<command>COPY</command>失败指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                一个报告失败原因的错误消息。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyInResponse (B)
</term>
____________________________________________________________________________-->
<term>
CopyInResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
                Identifies the message as a Start Copy In response.
                The frontend must now send copy-in data (if not
                prepared to do so, send a CopyFail message).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0 indicates the overall <command>COPY</command> format is textual (rows
                separated by newlines, columns separated by separator
                characters, etc).
                1 indicates the overall copy format is binary (similar
                to DataRow format).
                See <xref linkend="sql-copy"/>
                for more information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('G')
</term>
<listitem>
<para>
                标识这条消息是一条Start Copy In（开始拷贝入）响应消息。前端现在必须发送拷贝入数据（如果还没准备好做这些事情，那么发送一条CopyFail消息）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体拷贝格式都是文本（数据行由新符分隔， 列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow 格式）。参阅<xref linkend="sql-copy"/>获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据中的列数（由下文的<replaceable>N</replaceable>解释）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyOutResponse (B)
</term>
____________________________________________________________________________-->
<term>
CopyOutResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                Identifies the message as a Start Copy Out response.
                This message will be followed by copy-out data.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"/> for more information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                标识这条消息是一条Start Copy Out（开始拷贝出）响应消息。这条消息后面将跟着拷贝出数据。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括它自己。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体拷贝格式都是文本（数据行由新符分隔， 列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow 格式）。参阅<xref linkend="sql-copy"/>获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据的列数（在下文的<replaceable>N</replaceable>说明）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
CopyBothResponse (B)
</term>
____________________________________________________________________________-->
<term>
CopyBothResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('W')
</term>
<listitem>
<para>
                Identifies the message as a Start Copy Both response.
                This message is used only for Streaming Replication.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0 indicates the overall <command>COPY</command> format
                is textual (rows separated by newlines, columns
                separated by separator characters, etc). 1 indicates
                the overall copy format is binary (similar to DataRow
                format). See <xref linkend="sql-copy"/> for more information.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of columns in the data to be copied
                (denoted <replaceable>N</replaceable> below).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                The format codes to be used for each column.
                Each must presently be zero (text) or one (binary).
                All must be zero if the overall copy format is textual.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('W')
</term>
<listitem>
<para>
                标识这个消息是一个Start Copy Both（启动双向复制）响应。这个消息只用于流复制。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                0表示全体<command>COPY</command>格式都是文本（数据行由新符分隔，列由分隔字符分隔等等）。1 表示全体拷贝格式都是二进制的（类似于DataRow格式）。参阅<xref linkend="sql-copy"/>获取更多信息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                要拷贝的数据中的列数目（在下文的<replaceable>N</replaceable>说明）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>N</replaceable>]
</term>
<listitem>
<para>
                每个列要使用的格式代码。目前每个都必须是零（文本）或者一（二进制）。 如果全体拷贝格式都是文本，那么所有的代码都必须是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
DataRow (B)
</term>
____________________________________________________________________________-->
<term>
DataRow (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Identifies the message as a data row.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of column values that follow (possibly zero).
</para>
</listitem>
</varlistentry>
</variablelist>
        Next, the following pair of fields appear for each column:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The length of the column value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL column value.
                No value bytes follow in the NULL case.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                The value of the column, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>
<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                标识这个消息是一个数据行。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的列值的个数（可能是零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，为每个列都会出现下面的域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                列值的长度，以字节计（这个长度不包括它自己）。可以为零。一个特殊的情况是，-1表示一个NULL的域值。 如果是NULL的情况则后面不会跟着值字节。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                一个列的数值，以相关的格式代码指示的格式展现。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Describe (F)
</term>
____________________________________________________________________________-->
<term>
Describe (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Identifies the message as a Describe command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                '<literal>S</literal>' to describe a prepared statement; or
                '<literal>P</literal>' to describe a portal.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the prepared statement or portal to describe
                (an empty string selects the unnamed prepared statement
                or portal).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                标识该消息是一个Describe（描述）命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括字节本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
               '<literal>S</literal>'描述一个预备语句；或者 '<literal>P</literal>' 描述一个入口。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要描述的预备语句或者入口的名字（或者一个空字符串，就会选取未命名的预备语句或者入口）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
EmptyQueryResponse (B)
</term>
____________________________________________________________________________-->
<term>
EmptyQueryResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                Identifies the message as a response to an empty query string.
                (This substitutes for CommandComplete.)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                标识这条消息是对一个空查询字符串的响应（这个消息替换了CommandComplete）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括它自己。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
ErrorResponse (B)
</term>
____________________________________________________________________________-->
<term>
ErrorResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                Identifies the message as an error.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields"/>.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The field value.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                标识该消息是一条错误。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>
        消息体由一个或多个标识域组成，后面跟着一个零字节作为终止符。域可以以任何顺序出现。对于每个域都有下面的东西：
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                一个标识域类型的代码；如果为零，这就是消息终止符并且不会跟着有字符串。目前定义的域类型在<xref linkend="protocol-error-fields"/>列出。由于将来可能增加更多的域类型，所以前端应该默默地忽略未识别类型的域。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                域值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Execute (F)
</term>
____________________________________________________________________________-->
<term>
Execute (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                Identifies the message as an Execute command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the portal to execute
                (an empty string selects the unnamed portal).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Maximum number of rows to return, if portal contains
                a query that returns rows (ignored otherwise).  Zero
                denotes <quote>no limit</quote>.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('E')
</term>
<listitem>
<para>
                标识该消息是一个Execute命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要执行的入口的名字（空字符串选择未命名的入口）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                要返回的最大行数，如果入口包含返回行的查询（否则忽略）。零表示<quote>无限制</quote>。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Flush (F)
</term>
____________________________________________________________________________-->
<term>
Flush (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                Identifies the message as a Flush command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('H')
</term>
<listitem>
<para>
                标识该消息是一条Flush命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
FunctionCall (F)
</term>
____________________________________________________________________________-->
<term>
FunctionCall (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
                Identifies the message as a function call.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Specifies the object ID of the function to call.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of argument format codes that follow
                (denoted <replaceable>C</replaceable> below).
                This can be zero to indicate that there are no arguments
                or that the arguments all use the default format (text);
                or one, in which case the specified format code is applied
                to all arguments; or it can equal the actual number of
                arguments.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
                The argument format codes.  Each must presently be
                zero (text) or one (binary).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Specifies the number of arguments being supplied to the
                function.
</para>
</listitem>
</varlistentry>
</variablelist>
        Next, the following pair of fields appear for each argument:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The length of the argument value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL argument value.
                No value bytes follow in the NULL case.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                The value of the argument, in the format indicated by the
                associated format code.
                <replaceable>n</replaceable> is the above length.
</para>
</listitem>
</varlistentry>
</variablelist>
        After the last argument, the following field appears:
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The format code for the function result. Must presently be
                zero (text) or one (binary).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('F')
</term>
<listitem>
<para>
                标识该消息是一个函数调用。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定要调用的函数的对象ID（OID）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                后面跟着的参数格式代码的数目（用下文的<replaceable>C</replaceable>表示）。 它可以是零，表示没有参数，或者是所有参数都使用缺省格式（文本）； 也可以是一，这种情况下声明的格式代码被应用于所有参数；或者它可以等于参数的实际个数。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16[<replaceable>C</replaceable>]
</term>
<listitem>
<para>
                参数格式代码。目前每个必须是零（文本）或者一（二进制）
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定提供给函数的参数个数。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数都出现下面域对：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的参数值的长度（不包括长度本身）。可以为零。一个特殊的例子是，-1表示一个NULL参数值。如果是NULL，则没有参数字节跟在后面。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                参数的值，格式由相关的格式代码指示。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>
        在最后一个参数之后，出现下面的域：
<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                函数结果的格式代码。目前必须是零（文本）或者一（二进制）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
FunctionCallResponse (B)
</term>
____________________________________________________________________________-->
<term>
FunctionCallResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
                Identifies the message as a function call result.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The length of the function result value, in bytes (this count
                does not include itself).  Can be zero.
                As a special case, -1 indicates a NULL function result.
                No value bytes follow in the NULL case.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                The value of the function result, in the format indicated by
                the associated format code.
                <replaceable>n</replaceable> is the above length.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('V')
</term>
<listitem>
<para>
                标识这条消息是一个函数调用结果。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的函数结果值的长度（不包括长度本身）。可以为零。一个特殊的情况是，-1表示NULL函数结果。如果是NULL则后面没有值字节跟随。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                函数结果的值，格式由相关联的格式代码指示。<replaceable>n</replaceable>是上文的长度。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
GSSResponse (F)
</term>
____________________________________________________________________________-->
<term>
GSSResponse (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                Identifies the message as a GSSAPI or SSPI response. Note that
                this is also used for SASL and password response messages.
                The exact message type can be deduced from the context.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                GSSAPI/SSPI specific message data.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                标识该消息是一个GSSAPI或SSPI响应。注意这也被用于SASL和口令响应消息。准确的消息类型可以从上下文中得出。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                GSSAPI/SSPI相关的消息数据。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
NegotiateProtocolVersion (B)
</term>
____________________________________________________________________________-->
<term>
NegotiateProtocolVersion (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('v')
</term>
<listitem>
<para>
                Identifies the message as a protocol version negotiation
                message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Newest minor protocol version supported by the server
                for the major protocol version requested by the client.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Number of protocol options not recognized by the server.
</para>
</listitem>
</varlistentry>
</variablelist>
        Then, for protocol option not recognized by the server, there
        is the following:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The option name.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('v')
</term>
<listitem>
<para>
                标识该消息是一个协议版本协商消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                对于客户端请求的主协议版本，服务器能支持的最新的次协议版本。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                服务器无法识别的协议选项数目。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对于服务器无法识别的协议选项，还有下列信息：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                选项名称。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
NoData (B)
</term>
____________________________________________________________________________-->
<term>
NoData (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                Identifies the message as a no-data indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                标识这条消息是一个无数据指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
NoticeResponse (B)
</term>
____________________________________________________________________________-->
<term>
NoticeResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Identifies the message as a notice.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>
        The message body consists of one or more identified fields,
        followed by a zero byte as a terminator.  Fields can appear in
        any order.  For each field there is the following:
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                A code identifying the field type; if zero, this is
                the message terminator and no string follows.
                The presently defined field types are listed in
                <xref linkend="protocol-error-fields"/>.
                Since more field types might be added in future,
                frontends should silently ignore fields of unrecognized
                type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The field value.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                标识这条消息是一个通知。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
</variablelist>
        消息体由一个或多个标识域组成，后面跟着零字节作为中止符。域可以以任何顺序出现。对于每个域，都有下面的东西：
<variablelist>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                一个标识域类型的代码；如果为零，那么它就是消息终止符，并且后面不会跟着字符串。目前定义的域类型在<xref linkend="protocol-error-fields"/>里列出。由于将来可能会增加更多域类型，所以前端应该将不能识别的域安静地忽略掉。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                域值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
NotificationResponse (B)
</term>
____________________________________________________________________________-->
<term>
NotificationResponse (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
                Identifies the message as a notification response.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The process ID of the notifying backend process.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the channel that the notify has been raised on.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The <quote>payload</quote> string passed from the notifying process.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('A')
</term>
<listitem>
<para>
                标识这条消息是一个通知响应。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计地消息内容地长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                通知后端进程的进程ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                通知被抛出的通道的名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                从通知进程传递过来的<quote>载荷</quote>字符串。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
ParameterDescription (B)
</term>
____________________________________________________________________________-->
<term>
ParameterDescription (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                Identifies the message as a parameter description.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of parameters used by the statement
                (can be zero).
</para>
</listitem>
</varlistentry>
</variablelist>
        Then, for each parameter, there is the following:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Specifies the object ID of the parameter data type.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                标识该消息是一个参数描述。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                语句所使用的参数的个数（可以为零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数，有下面的东西：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定参数数据类型的对象ID。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
ParameterStatus (B)
</term>
____________________________________________________________________________-->
<term>
ParameterStatus (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                Identifies the message as a run-time parameter status report.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the run-time parameter being reported.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The current value of the parameter.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                标识这条消息是一个运行时参数的状态报告。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                被报告的运行时参数的名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数的当前值。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Parse (F)
</term>
____________________________________________________________________________-->
<term>
Parse (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
                Identifies the message as a Parse command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The name of the destination prepared statement
                (an empty string selects the unnamed prepared statement).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The query string to be parsed.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The number of parameter data types specified
                (can be zero).  Note that this is not an indication of
                the number of parameters that might appear in the
                query string, only the number that the frontend wants to
                prespecify types for.
</para>
</listitem>
</varlistentry>
</variablelist>
        Then, for each parameter, there is the following:
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Specifies the object ID of the parameter data type.
                Placing a zero here is equivalent to leaving the type
                unspecified.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('P')
</term>
<listitem>
<para>
                标识该消息是一条Parse命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                目的预备语句的名字（空字符串选取未命名的预备语句）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                要分析的查询字符串。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定的参数数据类型的数目（可以为零）。请注意这个参数并不表示可能在查询字符串里出现的参数个数， 只是前端希望预先为其指定类型的参数数目。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后，对每个参数，有下面的东西：
<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                指定参数数据类型的对象ID。这里为零等效于不指定该类型。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
ParseComplete (B)
</term>
____________________________________________________________________________-->
<term>
ParseComplete (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
                Identifies the message as a Parse-complete indicator.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('1')
</term>
<listitem>
<para>
                标识该消息是一个Parse完成指示器。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
PasswordMessage (F)
</term>
____________________________________________________________________________-->
<term>
PasswordMessage (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                Identifies the message as a password response. Note that
                this is also used for GSSAPI, SSPI and SASL response messages.
                The exact message type can be deduced from the context.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The password (encrypted, if requested).
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                标识该消息是一个口令响应。注意这也被用于GSSAPI、SSPI以及SASL响应消息。确切的消息类型可以从上下文推出。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                口令（如果要求了，就是加密后的）。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
PortalSuspended (B)
</term>
____________________________________________________________________________-->
<term>
PortalSuspended (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
                Identifies the message as a portal-suspended indicator.
                Note this only appears if an Execute message's row-count limit
                was reached.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('s')
</term>
<listitem>
<para>
                标识这条消息是一个入口暂停指示器。请注意这个消息只出现在达到一条Execute消息的行计数限制的时候。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Query (F)
</term>
____________________________________________________________________________-->
<term>
Query (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
                Identifies the message as a simple query.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The query string itself.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Q')
</term>
<listitem>
<para>
                标识该消息是一个简单查询。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                查询字符串自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
ReadyForQuery (B)
</term>
____________________________________________________________________________-->
<term>
ReadyForQuery (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
                Identifies the message type.  ReadyForQuery is sent
                whenever the backend is ready for a new query cycle.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                Current backend transaction status indicator.
                Possible values are '<literal>I</literal>' if idle (not in
                a transaction block); '<literal>T</literal>' if in a transaction
                block; or '<literal>E</literal>' if in a failed transaction
                block (queries will be rejected until block is ended).
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Z')
</term>
<listitem>
<para>
                标识消息的类型。在后端为新的查询周期准备好的时候，总会发送 ReadyForQuery。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(5)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1
</term>
<listitem>
<para>
                当前后端事务状态指示器。可能的值是空闲状况下的'<literal>I</literal>'（不在事务块里）；在事务块里是'<literal>T</literal>'； 或者在一个失败的事务块里是'<literal>E</literal>'（在事务块结束之前，任何查询都将被拒绝）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
RowDescription (B)
</term>
____________________________________________________________________________-->
<term>
RowDescription (B)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                Identifies the message as a row description.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Specifies the number of fields in a row (can be zero).
</para>
</listitem>
</varlistentry>
</variablelist>
        Then, for each field, there is the following:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The field name.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                If the field can be identified as a column of a specific
                table, the object ID of the table; otherwise zero.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                If the field can be identified as a column of a specific
                table, the attribute number of the column; otherwise zero.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The object ID of the field's data type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The data type size (see <varname>pg_type.typlen</varname>).
                Note that negative values denote variable-width types.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                The type modifier (see <varname>pg_attribute.atttypmod</varname>).
                The meaning of the modifier is type-specific.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                The format code being used for the field.  Currently will
                be zero (text) or one (binary).  In a RowDescription
                returned from the statement variant of Describe, the
                format code is not yet known and will always be zero.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                标识该消息是一个行描述。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                指定在一个行里面的域的数目（可以为零）。
</para>
</listitem>
</varlistentry>
</variablelist>
        然后对于每个字段，有下面的东西：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                字段名字。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                如果域可以被标识为一个指定表的列，这里就是表的对象ID；否则就是零。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                如果该域可以被标识为一个指定表的列，这里就是该列的属性号；否则就是零。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                域数据类型的对象ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                数据类型尺寸（参阅<varname>pg_type.typlen</varname>）。请注意负值表示变宽类型。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                类型修饰词（参阅<varname>pg_attribute.atttypmod</varname>）。 修饰词的含义是类型相关的。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                用于该域的格式码。目前会是零（文本）或者一（二进制）。 在Describe语句的变体返回的RowDescription里，格式码还是未知的，因此总是零。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
SASLInitialResponse (F)
</term>
____________________________________________________________________________-->
<term>
SASLInitialResponse (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                Identifies the message as an initial SASL response. Note that
                this is also used for GSSAPI, SSPI and password response messages.
                The exact message type is deduced from the context.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Name of the SASL authentication mechanism that the client
                selected.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of SASL mechanism specific "Initial Client Response" that
                follows, or -1 if there is no Initial Response.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL mechanism specific "Initial Response".
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                标识该消息是一个初始SASL响应。注意这也被用于GSSAPI、SSPI以及口令响应消息。确切的消息类型可以从上下文推知。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                客户端选择的SASL认证机制的名称。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                后面跟着的SASL机制相关的"Initial Client Response"的长度，如果没有Initial Response则为-1。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL机制相关的"Initial Response"。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
SASLResponse (F)
</term>
____________________________________________________________________________-->
<term>
SASLResponse (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                Identifies the message as a SASL response. Note that
                this is also used for GSSAPI, SSPI and password response messages.
                The exact message type can be deduced from the context.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL mechanism specific message data.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('p')
</term>
<listitem>
<para>
                标识该消息是一个初始SASL响应。注意这也被用于GSSAPI、SSPI以及口令响应消息。确切的消息类型可以从上下文推知。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                消息内容的长度，以字节为单位，包括其自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                SASL机制相关的消息数据。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
SSLRequest (F)
</term>
____________________________________________________________________________-->
<term>
SSLRequest (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
                The <acronym>SSL</acronym> request code.  The value is chosen to contain
                <literal>1234</literal> in the most significant 16 bits, and <literal>5679</literal> in the
                least significant 16 bits.  (To avoid confusion, this code
                must not be the same as any protocol version number.)
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Int32(8)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度本身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(80877103)
</term>
<listitem>
<para>
                <acronym>SSL</acronym>请求码。选取的值在高16位里包含<literal>1234</literal>，在低16位里包含<literal>5679</literal> （为了避免混淆，这个编码必须和任何协议版本号不同）。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
StartupMessage (F)
</term>
____________________________________________________________________________-->
<term>
StartupMessage (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
                The protocol version number.  The most significant 16 bits are
                the major version number (3 for the protocol described here).
                The least significant 16 bits are the minor version number
                (0 for the protocol described here).
</para>
</listitem>
</varlistentry>
</variablelist>
        The protocol version number is followed by one or more pairs of
        parameter name and value strings.  A zero byte is required as a
        terminator after the last name/value pair.
        Parameters can appear in any
        order.  <literal>user</literal> is required, others are optional.
        Each parameter is specified as:
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The parameter name.  Currently recognized names are:

<variablelist>
<varlistentry>
<term>
                <literal>user</literal>
</term>
<listitem>
<para>
                        The database user name to connect as.  Required;
                        there is no default.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</literal>
</term>
<listitem>
<para>
                        The database to connect to.  Defaults to the user name.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</literal>
</term>
<listitem>
<para>
                        Command-line arguments for the backend.  (This is
                        deprecated in favor of setting individual run-time
                        parameters.)  Spaces within this string are
                        considered to separate arguments, unless escaped with
                        a backslash (<literal>\</literal>); write <literal>\\</literal> to
                        represent a literal backslash.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>replication</literal>
</term>
<listitem>
<para>
                        Used to connect in streaming replication mode, where
                        a small set of replication commands can be issued
                        instead of SQL statements. Value can be
                        <literal>true</literal>, <literal>false</literal>, or
                        <literal>database</literal>, and the default is
                        <literal>false</literal>. See
                        <xref linkend="protocol-replication"/> for details.
</para>
</listitem>
</varlistentry>
</variablelist>

                In addition to the above, other parameters may be listed.
                Parameter names beginning with <literal>_pq_.</literal> are
                reserved for use as protocol extensions, while others are
                treated as run-time parameters to be set at backend start
                time.  Such settings will be applied during backend start
                (after parsing the command-line arguments if any) and will
                act as session defaults.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                The parameter value.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                以字节计的消息内容长度，包括长度自身。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(196608)
</term>
<listitem>
<para>
                协议版本号。高16位是主版本号（对这里描述的协议而言是 3）。低16位是次版本号（对于这里描述的协议而言是 0）。
</para>
</listitem>
</varlistentry>
</variablelist>
        协议版本号后面跟着一个或多个参数名和值字符串的对。要求在最后一个名字/数值对后面有个零字节作为终止符。 参数可以以任意顺序出现。<literal>user</literal>是必须的，其它都是可选的。每个参数是这样指定的：
<variablelist>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数名。目前可以识别的名字是：

<variablelist>
<varlistentry>
<term>
                <literal>user</literal>
</term>
<listitem>
<para>
                        用于连接的数据库用户名。必须；无缺省。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>database</literal>
</term>
<listitem>
<para>
                        要连接的数据库。缺省是用户名。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>options</literal>
</term>
<listitem>
<para>
                        给后端的命令行参数（这个特性已经废弃，更好的方法是设置单独的运行时参数）。 
                        这个字符串中的空格会被当做参数的分隔符，除非用一个反斜线（<literal>\</literal>）
                        对它转义。写<literal>\\</literal>可表示一个而字面意义上的反斜线。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
                <literal>replication</literal>
</term>
<listitem>
<para>
                        用于连入流复制模式，其中可以发出复制命令的一个小型集合而不是SQL语句。值可以是<literal>true</literal>、<literal>false</literal>或者<literal>database</literal>，默认值是<literal>false</literal>。详情请参考<xref linkend="protocol-replication"/>。
</para>
</listitem>
</varlistentry>
</variablelist>

                除了上述参数之外，还可以列出其他参数。以<literal>_pq_.</literal>开头的参数名被保留给协议扩展之用，而其他的参数名被当做在后端开始时要设置的运行时参数。这类设置将在后端启动期间被应用（如果有命令行参数，则在解析完命令行参数之后）并且将作为会话的默认值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                参数值。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Sync (F)
</term>
____________________________________________________________________________-->
<term>
Sync (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                Identifies the message as a Sync command.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('S')
</term>
<listitem>
<para>
                表示该消息为一条 Sync 命令。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


<varlistentry>
<!--==========================orignal english content==========================
<term>
Terminate (F)
</term>
____________________________________________________________________________-->
<term>
Terminate (F)
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
                Identifies the message as a termination.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                Length of message contents in bytes, including self.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('X')
</term>
<listitem>
<para>
                标识本消息是一个终止。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32(4)
</term>
<listitem>
<para>
                以字节计的消息内容的长度，包括长度自身。
</para>
</listitem>
</varlistentry>
</variablelist>

</para>
</listitem>
</varlistentry>


</variablelist>

</sect1>


<sect1 id="protocol-error-fields">
<!--==========================orignal english content==========================
<title>Error and Notice Message Fields</title>
____________________________________________________________________________-->
<title>错误和通知消息域</title>

<!--==========================orignal english content==========================
<para>
This section describes the fields that can appear in ErrorResponse and
NoticeResponse messages.  Each field type has a single-byte identification
token.  Note that any given field type should appear at most once per
message.
</para>
____________________________________________________________________________-->
<para>
本节描述那些可能出现在ErrorResponse和NoticeResponse消息里的域。 每个域类型有一个单字节标识记号。请注意，任意给定的域类型在每条消息里应该最多出现一次。
</para>

<variablelist>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>S</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>S</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Severity: the field contents are
        <literal>ERROR</literal>, <literal>FATAL</literal>, or
        <literal>PANIC</literal> (in an error message), or
        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message),
        or a localized translation of one of these.  Always present.
</para>
____________________________________________________________________________-->
<para>
        严重性：该域的内容是<literal>ERROR</literal>、<literal>FATAL</literal>或者<literal>PANIC</literal>（在一个错误消息里），或者<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>或者<literal>LOG</literal>（在一条通知消息里），或者是这些形式的某种本地化翻译。总是会出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>V</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>V</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Severity: the field contents are
        <literal>ERROR</literal>, <literal>FATAL</literal>, or
        <literal>PANIC</literal> (in an error message), or
        <literal>WARNING</literal>, <literal>NOTICE</literal>, <literal>DEBUG</literal>,
        <literal>INFO</literal>, or <literal>LOG</literal> (in a notice message).
        This is identical to the <literal>S</literal> field except
        that the contents are never localized.  This is present only in
        messages generated by <productname>PostgreSQL</productname> versions 9.6
        and later.
</para>
____________________________________________________________________________-->
<para>
        严重性：该域的内容是<literal>ERROR</literal>、<literal>FATAL</literal>或者<literal>PANIC</literal>（在一个错误消息里），或者<literal>WARNING</literal>、<literal>NOTICE</literal>、<literal>DEBUG</literal>、<literal>INFO</literal>或者<literal>LOG</literal>（在一条通知消息里）。这和<literal>S</literal>域相同，不过其内容没有被本地化。这只存在于<productname>PostgreSQL</productname>版本 9.6 及其后版本产生的消息中。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>C</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>C</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Code: the SQLSTATE code for the error (see <xref
        linkend="errcodes-appendix"/>).  Not localizable.  Always present.
</para>
____________________________________________________________________________-->
<para>
        代码：错误的SQLSTATE代码（参阅<xref linkend="errcodes-appendix"/>）。非本地化。总是出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>M</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>M</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Message: the primary human-readable error message.
        This should be accurate but terse (typically one line).
        Always present.
</para>
____________________________________________________________________________-->
<para>
        消息：人类可读的错误消息的主体。这些信息应该准确并且简洁（通常是一行）。总是出现。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>D</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>D</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Detail: an optional secondary error message carrying more
        detail about the problem.  Might run to multiple lines.
</para>
____________________________________________________________________________-->
<para>
        细节：一个可选的二级错误消息，携带了有关问题的更多错误消息。可以是多行。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>H</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>H</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Hint: an optional suggestion what to do about the problem.
        This is intended to differ from Detail in that it offers advice
        (potentially inappropriate) rather than hard facts.
        Might run to multiple lines.
</para>
____________________________________________________________________________-->
<para>
        提示：一个可选的有关如何处理问题的建议。它和细节不同的地方是它提出了建议（可能并不合适）而不仅仅是事实。可以是多行。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>P</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>P</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Position: the field value is a decimal ASCII integer, indicating
        an error cursor position as an index into the original query string.
        The first character has index 1, and positions are measured in
        characters not bytes.
</para>
____________________________________________________________________________-->
<para>
        位置：这个域值是一个十进制ASCII整数，表示一个错误游标的位置，它是一个指向原始查询字符串的索引。第一个字符的索引是 1，位置是以字符计算而非字节计算的。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>p</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>p</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Internal position: this is defined the same as the <literal>P</literal>
        field, but it is used when the cursor position refers to an internally
        generated command rather than the one submitted by the client.
        The <literal>q</literal> field will always appear when this field appears.
</para>
____________________________________________________________________________-->
<para>
        内部位置：这个域和<literal>P</literal>域定义相同，但是它被用于当游标位置指向一个内部生成的命令的情况， 而不是用于客户端提交的命令。这个域出现的时候，总是会出现<literal>q</literal>域。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>q</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>q</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Internal query: the text of a failed internally-generated command.
        This could be, for example, a SQL query issued by a PL/pgSQL function.
</para>
____________________________________________________________________________-->
<para>
        内部查询：失败的内部生成的命令的文本。比如，它可能是一个PL/pgSQL函数发出的 SQL 查询。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>W</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>W</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Where: an indication of the context in which the error occurred.
        Presently this includes a call stack traceback of active
        procedural language functions and internally-generated queries.
        The trace is one entry per line, most recent first.
</para>
____________________________________________________________________________-->
<para>
        哪里：一个指示错误发生的环境的指示器。目前，它包含一个活跃的过程语言函数的调用堆栈的路径和内部生成的查询。 这个路径每个项记录一行，最新的在最前面。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>s</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>s</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Schema name: if the error was associated with a specific database
        object, the name of the schema containing that object, if any.
</para>
____________________________________________________________________________-->
<para>
        模式名：如果错误与一个指定数据库对象相关，这里是包含该对象的模式名（如果有）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>t</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>t</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Table name: if the error was associated with a specific table, the
        name of the table.  (Refer to the schema name field for the name of
        the table's schema.)
</para>
____________________________________________________________________________-->
<para>
        表名：如果错误与一个指定表相关，这里是表的名字（引用该表模式的名字的模式名域）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>c</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>c</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Column name: if the error was associated with a specific table column,
        the name of the column.  (Refer to the schema and table name fields to
        identify the table.)
</para>
____________________________________________________________________________-->
<para>
        列名：如果错误与一个指定表列相关，这里是该列的名字（引用该模式和表的名字来标识该表）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>d</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>d</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Data type name: if the error was associated with a specific data type,
        the name of the data type.  (Refer to the schema name field for the
        name of the data type's schema.)
</para>
____________________________________________________________________________-->
<para>
        数据类型名：如果错误与一个指定数据类型相关，这里是该数据类型的名字（引用该数据类型模式的名字的模式名域）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>n</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>n</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Constraint name: if the error was associated with a specific
        constraint, the name of the constraint.  Refer to fields listed above
        for the associated table or domain.  (For this purpose, indexes are
        treated as constraints, even if they weren't created with constraint
        syntax.)
</para>
____________________________________________________________________________-->
<para>
        约束名：如果错误是和一个指定约束相关，这里是该约束的名字。引用至上面列出的相关表或域的域（为了这个目的，索引被视作约束，即使它们并不是按照约束语法创建的）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>F</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>F</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        File: the file name of the source-code location where the error
        was reported.
</para>
____________________________________________________________________________-->
<para>
        文件：报告的错误在源代码中的文件名。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>L</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>L</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Line: the line number of the source-code location where the error
        was reported.
</para>
____________________________________________________________________________-->
<para>
        行：报告的错误所在的源代码的位置的行号。
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
<literal>R</literal>
</term>
____________________________________________________________________________-->
<term>
<literal>R</literal>
</term>
<listitem>
<!--==========================orignal english content==========================
<para>
        Routine: the name of the source-code routine reporting the error.
</para>
____________________________________________________________________________-->
<para>
        例程：报告错误的例程在源代码中的名字。
</para>
</listitem>
</varlistentry>

</variablelist>

<note>
<!--==========================orignal english content==========================
 <para>
  The fields for schema name, table name, column name, data type name, and
  constraint name are supplied only for a limited number of error types;
  see <xref linkend="errcodes-appendix"/>.  Frontends should not assume that
  the presence of any of these fields guarantees the presence of another
  field.  Core error sources observe the interrelationships noted above, but
  user-defined functions may use these fields in other ways.  In the same
  vein, clients should not assume that these fields denote contemporary
  objects in the current database.
 </para>
____________________________________________________________________________-->
 <para>
  用于模式名、表名、列名、数据类型名和约束名只提供给有限的几种错误类型；请参考<xref linkend="errcodes-appendix"/>。前端不应当假设任何一个这些域的出现会保证其他域的出现。核心错误资源会看到上面提示的相互关系，但是用户定义的函数可能会以其他方式使用这些域。同样的道理，客户端不应该假设这些域表示当前数据库中同一时期的对象。
 </para>
</note>

<!--==========================orignal english content==========================
<para>
The client is responsible for formatting displayed information to meet its
needs; in particular it should break long lines as needed.  Newline characters
appearing in the error message fields should be treated as paragraph breaks,
not line breaks.
</para>
____________________________________________________________________________-->
<para>
客户端负责格式化要显示的信息以符合需要；特别是它应该根据需要断开长的行。在错误消息域里出现的新行字符应该被当作一个分段的符号，而不是换行。
</para>

</sect1>

<sect1 id="protocol-logicalrep-message-formats">
<!--==========================orignal english content==========================
<title>Logical Replication Message Formats</title>
____________________________________________________________________________-->
<title>逻辑复制消息格式</title>

<!--==========================orignal english content==========================
<para>
This section describes the detailed format of each logical replication message.
These messages are returned either by the replication slot SQL interface or are
sent by a walsender. In case of a walsender they are encapsulated inside the replication
protocol WAL messages as described in <xref linkend="protocol-replication"/>
and generally obey same message flow as physical replication.
</para>
____________________________________________________________________________-->
<para>
这一节介绍每一种逻辑复制消息的详细格式。这些消息会通过复制槽的SQL接口返回或者由walsender发送。在由walsender发送的情况下，它们被封装在<xref linkend="protocol-replication"/>中所述的复制协议WAL消息中，并且通常服从和物理复制相同的消息流。
</para>

<variablelist>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Begin
</term>
____________________________________________________________________________-->
<term>
Begin
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                Identifies the message as a begin message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                The final LSN of the transaction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Commit timestamp of the transaction. The value is in number
                of microseconds since PostgreSQL epoch (2000-01-01).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Xid of the transaction.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('B')
</term>
<listitem>
<para>
                标识该消息是一个开始消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                该事务的最终LSN。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                该事务的提交时间戳。该值是自PostgreSQL纪元（2000-01-01）以来的微秒数。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                事务的XID。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Commit
</term>
____________________________________________________________________________-->
<term>
Commit
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                Identifies the message as a commit message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Flags; currently unused (must be 0).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                The LSN of the commit.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                The end LSN of the transaction.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                Commit timestamp of the transaction. The value is in number
                of microseconds since PostgreSQL epoch (2000-01-01).
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('C')
</term>
<listitem>
<para>
                标识该消息是一个提交消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                标志，当前未使用（必须为0）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                提交的LSN。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                该事务的结束LSN。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                该事务的提交时间戳。该值是自PostgreSQL纪元（2000-01-01）以来的微秒数。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Origin
</term>
____________________________________________________________________________-->
<term>
Origin
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifies the message as an origin message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                The LSN of the commit on the origin server.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Name of the origin.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                标识该消息是一个源头消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int64
</term>
<listitem>
<para>
                源头服务器上的提交LSN。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                源头的名称。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<!--==========================orignal english content==========================
<para>
  Note that there can be multiple Origin messages inside a single transaction.
</para>
____________________________________________________________________________-->
<para>
  注意在一个单一事务中可能有多个Origin消息。
</para>

</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Relation
</term>
____________________________________________________________________________-->
<term>
Relation
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                Identifies the message as a relation message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the relation.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Namespace (empty string for <literal>pg_catalog</literal>).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Relation name.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Replica identity setting for the relation (same as
                <structfield>relreplident</structfield> in <structname>pg_class</structname>).
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Number of columns.
</para>
</listitem>
</varlistentry>
</variablelist>
        Next, the following message part appears for each column:
<variablelist>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Flags for the column. Currently can be either 0 for no flags
                or 1 which marks the column as part of the key.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Name of the column.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the column's data type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Type modifier of the column (<structfield>atttypmod</structfield>).
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('R')
</term>
<listitem>
<para>
                标识该消息是一个关系消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                关系的ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                名字空间（<literal>pg_catalog</literal>是空字符串）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                关系名。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                该关系的副本标识设置（和<structname>pg_class</structname>中的<structfield>relreplident</structfield>相同）。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                列数。
</para>
</listitem>
</varlistentry>
</variablelist>
        接下来，会为每一列出现下面的消息部分：
<variablelist>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                该列的标志。当前可以是0（无标志）或者1（标记该列为键的一部分）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                列的名称。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                列的数据类型的ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                列的类型修饰符（<structfield>atttypmod</structfield>）。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Type
</term>
____________________________________________________________________________-->
<term>
Type
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Y')
</term>
<listitem>
<para>
                Identifies the message as a type message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the data type.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Namespace (empty string for <literal>pg_catalog</literal>).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                Name of the data type.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('Y')
</term>
<listitem>
<para>
                标识该消息是一个类型消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                数据类型的ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                名字空间（<literal>pg_catalog</literal>的是空字符串）。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        String
</term>
<listitem>
<para>
                数据类型的名称。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Insert
</term>
____________________________________________________________________________-->
<term>
Insert
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                Identifies the message as an insert message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the relation corresponding to the ID in the relation
                message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Identifies the following TupleData message as a new tuple.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData message part representing the contents of new tuple.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('I')
</term>
<listitem>
<para>
                标识该消息是一个插入消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                对应于关系消息中的ID的关系的ID。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                标识接下来的TupleData消息是一个新元组。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData消息部分表示新元组的内容。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Update
</term>
____________________________________________________________________________-->
<term>
Update
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('U')
</term>
<listitem>
<para>
                Identifies the message as an update message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the relation corresponding to the ID in the relation
                message.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifies the following TupleData submessage as a key.
                This field is optional and is only present if
                the update changed data in any of the column(s) that are
                part of the REPLICA IDENTITY index.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifies the following TupleData submessage as an old tuple.
                This field is optional and is only present if table in which
                the update happened has REPLICA IDENTITY set to FULL.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData message part representing the contents of the old tuple
                or primary key. Only present if the previous 'O' or 'K' part
                is present.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                Identifies the following TupleData message as a new tuple.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData message part representing the contents of a new tuple.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('U')
</term>
<listitem>
<para>
                标识该消息是一个更新消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                对应于关系消息中的ID的关系的ID。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                标识接下来的TupleData子消息为一个键。这个字段是可选的并且仅当任意列中被更新更改的数据是REPLICA IDENTITY索引的一部分时才存在。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                标识接下来的TupleData子消息为一个旧元组。这个字段是可选的并且仅当发生更新的表的REPLICA IDENTITY被设置为FULL时才存在。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData消息部分表示旧元组或主键的内容。仅当之前的'0'或'K'部分存在时才存在。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('N')
</term>
<listitem>
<para>
                标识接下来的TupleData消息是一个新元组。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData消息部分表示一个新元组的内容。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<!--==========================orignal english content==========================
<para>
    The Update message may contain either a 'K' message part or an 'O' message part
    or neither of them, but never both of them.
</para>
____________________________________________________________________________-->
<para>
    Update消息可能包含一个'K'消息部分或者一个'O'消息部分，或者两者都不包含，但是绝不会同时包含两者。
</para>

</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Delete
</term>
____________________________________________________________________________-->
<term>
Delete
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                Identifies the message as a delete message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the relation corresponding to the ID in the relation
                message.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                Identifies the following TupleData submessage as a key.
                This field is present if the table in which the delete has
                happened uses an index as REPLICA IDENTITY.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                Identifies the following TupleData message as a old tuple.
                This field is present if the table in which the delete has
                happened has REPLICA IDENTITY set to FULL.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData message part representing the contents of the old tuple
                or primary key, depending on the previous field.
</para>
</listitem>
</varlistentry>
</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('D')
</term>
<listitem>
<para>
                标识该消息是一个删除消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                对应于关系消息中的ID的关系的ID。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('K')
</term>
<listitem>
<para>
                标识接下来的TupleData子消息是一个键。如果发生删除的表正好用一个索引作为REPLICA IDENTITY，那么就会存在这个字段。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        Byte1('O')
</term>
<listitem>
<para>
                标识接下来的TupleData子消息为一个旧元组。这个字段是可选的并且仅当发生删除的表的REPLICA IDENTITY被设置为FULL时才存在。
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
        TupleData
</term>
<listitem>
<para>
                TupleData消息部分表示旧元组或主键的内容，取决于前面的字段。
</para>
</listitem>
</varlistentry>
</variablelist>
</para>

<!--==========================orignal english content==========================
<para>
    The Delete message may contain either a 'K' message part or an 'O' message part,
    but never both of them.
</para>
____________________________________________________________________________-->
<para>
    Delete消息可能包含一个'K'消息部分或者一个'O'消息部分，或者两者都不包含，但是绝不会同时包含两者。
</para>

</listitem>
</varlistentry>

<varlistentry>
<!--==========================orignal english content==========================
<term>
Truncate
</term>
____________________________________________________________________________-->
<term>
Truncate
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                Identifies the message as a truncate message.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Number of relations
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                Option bits for <command>TRUNCATE</command>:
                1 for <literal>CASCADE</literal>, 2 for <literal>RESTART IDENTITY</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                ID of the relation corresponding to the ID in the relation
                message.  This field is repeated for each relation.
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Byte1('T')
</term>
<listitem>
<para>
                标识该消息是一个截断消息。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                关系的数目。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int8
</term>
<listitem>
<para>
                <command>TRUNCATE</command>的选项位：1表示<literal>CASCADE</literal>，2表示<literal>RESTART IDENTITY</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                对应于关系消息中的ID的关系的ID。这个字段会为每个关系重复出现。
</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

<!--==========================orignal english content==========================
<para>

The following message parts are shared by the above messages.

</para>
____________________________________________________________________________-->
<para>

下面的消息部分由上面的消息共享。

</para>

<variablelist>

<varlistentry>
<!--==========================orignal english content==========================
<term>
TupleData
</term>
____________________________________________________________________________-->
<term>
TupleData
</term>
<listitem>
<!--==========================orignal english content==========================
<para>

<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                Number of columns.
</para>
</listitem>
</varlistentry>
</variablelist>
        Next, one of the following submessages appears for each column:
<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                Identifies the data as NULL value.
</para>
</listitem>
</varlistentry>
</variablelist>
        Or
<variablelist>
<varlistentry>
<term>
        Byte1('u')
</term>
<listitem>
<para>
                Identifies unchanged TOASTed value (the actual value is not
                sent).
</para>
</listitem>
</varlistentry>
</variablelist>
        Or
<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                Identifies the data as text formatted value.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                Length of the column value.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                The value of the column, in text format.  (A future release
                might support additional formats.)
                <replaceable>n</replaceable> is the above length.

</para>
</listitem>
</varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>

<variablelist>
<varlistentry>
<term>
        Int16
</term>
<listitem>
<para>
                列数。
</para>
</listitem>
</varlistentry>
</variablelist>
        接下来，为每一列会有下列子消息之一出现：
<variablelist>
<varlistentry>
<term>
        Byte1('n')
</term>
<listitem>
<para>
                标识该数据为NULL值。
</para>
</listitem>
</varlistentry>
</variablelist>
        或者
<variablelist>
<varlistentry>
<term>
        Byte1('u')
</term>
<listitem>
<para>
                标识未更改的被TOAST过的值（实际值没有被发送）。
</para>
</listitem>
</varlistentry>
</variablelist>
        或者
<variablelist>
<varlistentry>
<term>
        Byte1('t')
</term>
<listitem>
<para>
                标识数据为文本格式化的值。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Int32
</term>
<listitem>
<para>
                列值的长度。
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>
        Byte<replaceable>n</replaceable>
</term>
<listitem>
<para>
                该列的值的文本格式（未来的发行可能会支持额外的格式）。<replaceable>n</replaceable>是上面的长度。

</para>
</listitem>
</varlistentry>

</variablelist>
</para>
</listitem>
</varlistentry>

</variablelist>

</sect1>

<sect1 id="protocol-changes">
<!--==========================orignal english content==========================
<title>Summary of Changes since Protocol 2.0</title>
____________________________________________________________________________-->
<title>自协议2.0以来的变化总结</title>

<!--==========================orignal english content==========================
<para>
This section provides a quick checklist of changes, for the benefit of
developers trying to update existing client libraries to protocol 3.0.
</para>
____________________________________________________________________________-->
<para>
本节提供一个快速的改变检查列表，以便于那些试图将现有的客户端库更新到3.0协议的开发人员。
</para>

<!--==========================orignal english content==========================
<para>
The initial startup packet uses a flexible list-of-strings format
instead of a fixed format.  Notice that session default values for run-time
parameters can now be specified directly in the startup packet.  (Actually,
you could do that before using the <literal>options</literal> field, but given the
limited width of <literal>options</literal> and the lack of any way to quote
whitespace in the values, it wasn't a very safe technique.)
</para>
____________________________________________________________________________-->
<para>
初始化的启动包用了一个灵活的字符串列表格式取代了固定的格式。请注意，运行时参数的会话缺省值现在可以直接在启动包中指定（实际上，你可以在使用<literal>options</literal>域之前干这件事情，但是因为<literal>options</literal>的宽度限制以及缺乏引用值中空白的方法，这并不是很安全的技巧）。
</para>

<!--==========================orignal english content==========================
<para>
All messages now have a length count immediately following the message type
byte (except for startup packets, which have no type byte).  Also note that
PasswordMessage now has a type byte.
</para>
____________________________________________________________________________-->
<para>
现在所有的消息在消息类型字节后面都有一个长度计数（除了启动包之外，它没有类型字节）。同时还要注意现在PasswordMessage有一个类型字节。
</para>

<!--==========================orignal english content==========================
<para>
ErrorResponse and NoticeResponse ('<literal>E</literal>' and '<literal>N</literal>')
messages now contain multiple fields, from which the client code can
assemble an error message of the desired level of verbosity.  Note that
individual fields will typically not end with a newline, whereas the single
string sent in the older protocol always did.
</para>
____________________________________________________________________________-->
<para>
ErrorResponse和NoticeResponse（'<literal>E</literal>' 和 '<literal>N</literal>'）消息现在包含多个域， 从这些域里客户端代码可以组合出自己所希望的详细程度的错误消息。请注意个体的域通常不是用新行终止的，虽然在老的协议里发送的单个字符串总是会用新行终止。
</para>

<!--==========================orignal english content==========================
<para>
The ReadyForQuery ('<literal>Z</literal>') message includes a transaction status
indicator.
</para>
____________________________________________________________________________-->
<para>
ReadyForQuery（'<literal>Z</literal>'）消息包括一个事务状态指示符。
</para>

<!--==========================orignal english content==========================
<para>
The distinction between BinaryRow and DataRow message types is gone; the
single DataRow message type serves for returning data in all formats.
Note that the layout of DataRow has changed to make it easier to parse.
Also, the representation of binary values has changed: it is no longer
directly tied to the server's internal representation.
</para>
____________________________________________________________________________-->
<para>
BinaryRow和DataRow消息类型之间的区别不再存在了；单个DataRow消息类型用于返回所有格式的数据。请注意DataRow的布局已经被变得更容易分析。同样，二进制值的表现形式已经改变了：它不再直接和服务器的内部表现形式绑定。
</para>

<!--==========================orignal english content==========================
<para>
There is a new <quote>extended query</quote> sub-protocol, which adds the frontend
message types Parse, Bind, Execute, Describe, Close, Flush, and Sync, and the
backend message types ParseComplete, BindComplete, PortalSuspended,
ParameterDescription, NoData, and CloseComplete.  Existing clients do not
have to concern themselves with this sub-protocol, but making use of it
might allow improvements in performance or functionality.
</para>
____________________________________________________________________________-->
<para>
有了一种新的<quote>扩展查询</quote>的子协议，它增加了前端消息类型Parse、Bind、Execute、Describe、Close、Flush和Sync，以及后端消息类型ParseComplete、 BindComplete、PortalSuspended、ParameterDescription、NoData和CloseComplete。现有的客户端不用关心这个子协议，但是利用这个子协议将令我们可能提升性能或者功能。
</para>

<!--==========================orignal english content==========================
<para>
<command>COPY</command> data is now encapsulated into CopyData and CopyDone messages.  There
is a well-defined way to recover from errors during <command>COPY</command>.  The special
<quote><literal>\.</literal></quote> last line is not needed anymore, and is not sent
during <command>COPY OUT</command>.
(It is still recognized as a terminator during <command>COPY IN</command>, but its use is
deprecated and will eventually be removed.)  Binary <command>COPY</command> is supported.
The CopyInResponse and CopyOutResponse messages include fields indicating
the number of columns and the format of each column.
</para>
____________________________________________________________________________-->
<para>
<command>COPY</command>数据现在封装到了CopyData和CopyDone消息里。现在有种很好的方法从正在进行的<command>COPY</command>动作中的错误恢复。 最后一行的特殊的<quote><literal>\.</literal></quote>不再需要了，并且在<command>COPY OUT</command>的过程中不再发送（在<command>COPY IN</command>的时候它仍然被认为是一个终止符，但是它的使用已经废弃了并且最终将被删除）。 现在支持二进制<command>COPY</command>。CopyInResponse和CopyOutResponse消息包括指示列数目和每个列格式的域。
</para>

<!--==========================orignal english content==========================
<para>
The layout of FunctionCall and FunctionCallResponse messages has changed.
FunctionCall can now support passing NULL arguments to functions.  It also
can handle passing parameters and retrieving results in either text or
binary format.  There is no longer any reason to consider FunctionCall a
potential security hole, since it does not offer direct access to internal
server data representations.
</para>
____________________________________________________________________________-->
<para>
FunctionCall和FunctionCallResponse消息的布局变化了。FunctionCall现在支持给函数传递NULL参数。它同样可以处理以文本或者二进制格式传递参数和检索结果。我们不用再认为FunctionCall有潜在的安全性漏洞，因为它并不提供对内部服务器数据表现形式的直接访问。
</para>

<!--==========================orignal english content==========================
<para>
The backend sends ParameterStatus ('<literal>S</literal>') messages during connection
startup for all parameters it considers interesting to the client library.
Subsequently, a ParameterStatus message is sent whenever the active value
changes for any of these parameters.
</para>
____________________________________________________________________________-->
<para>
在连接启动期间，后端会为它认为客户端库感兴趣的所有参数发送ParameterStatus（'<literal>S</literal>'）消息。随后，如果这些参数的任何活跃值发生变化，那么将发送一条ParameterStatus消息。
</para>

<!--==========================orignal english content==========================
<para>
The RowDescription ('<literal>T</literal>') message carries new table OID and column
number fields for each column of the described row.  It also shows the format
code for each column.
</para>
____________________________________________________________________________-->
<para>
RowDescription（'<literal>T</literal>'）消息为所描述的行的每个列运载新表的OID和列编号域。它同样还表示每个列的格式代码。
</para>

<!--==========================orignal english content==========================
<para>
The CursorResponse ('<literal>P</literal>') message is no longer generated by
the backend.
</para>
____________________________________________________________________________-->
<para>
后端不再生成 CursorResponse（'<literal>P</literal>'）消息。
</para>

<!--==========================orignal english content==========================
<para>
The NotificationResponse ('<literal>A</literal>') message has an additional string
field, which can carry a <quote>payload</quote> string passed
from the <command>NOTIFY</command> event sender.
</para>
____________________________________________________________________________-->
<para>
NotificationResponse（'<literal>A</literal>'）消息有一个附加的字符串域，它能携带来自<command>NOTIFY</command>事件发送者的一个<quote>载荷</quote>字符串。
</para>

<!--==========================orignal english content==========================
<para>
The EmptyQueryResponse ('<literal>I</literal>') message used to include an empty
string parameter; this has been removed.
</para>
____________________________________________________________________________-->
<para>
EmptyQueryResponse（'<literal>I</literal>'）以前包含一个空字符串参数；现在已经被删除。
</para>

</sect1>

</chapter>
