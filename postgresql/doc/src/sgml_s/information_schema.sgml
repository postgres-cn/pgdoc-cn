<!-- doc/src/sgml/information_schema.sgml -->

<chapter id="information-schema">
<!--==========================orignal english content==========================
 <title>The Information Schema</title>
____________________________________________________________________________-->
 <title>信息模式</title>

<!--==========================orignal english content==========================
 <indexterm zone="information-schema">
  <primary>information schema</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="information-schema">
  <primary>信息模式</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The information schema consists of a set of views that contain
  information about the objects defined in the current database.  The
  information schema is defined in the SQL standard and can therefore
  be expected to be portable and remain stable &mdash; unlike the system
  catalogs, which are specific to
  <productname>PostgreSQL</productname> and are modeled after
  implementation concerns.  The information schema views do not,
  however, contain information about
  <productname>PostgreSQL</productname>-specific features; to inquire
  about those you need to query the system catalogs or other
  <productname>PostgreSQL</productname>-specific views.
 </para>
____________________________________________________________________________-->
 <para>
  信息模式由一组视图构成，它们包含定义在当前数据库中对象的信息。信息模式以 SQL 标准定义，因此能够被移植并且保持稳定 &mdash; 系统目录则不同，它们是与<productname>PostgreSQL</productname>相关的并且是为了实现的考虑而建模的。不过，信息模式视图不包含与<productname>PostgreSQL</productname>-相关特性有关的信息。要咨询那些信息你需要查询系统目录或其他<productname>PostgreSQL</productname>-相关视图。
 </para>

 <note>
<!--==========================orignal english content==========================
  <para>
   When querying the database for constraint information, it is possible
   for a standard-compliant query that expects to return one row to
   return several.  This is because the SQL standard requires constraint
   names to be unique within a schema, but
   <productname>PostgreSQL</productname> does not enforce this
   restriction.  <productname>PostgreSQL</productname>
   automatically-generated constraint names avoid duplicates in the
   same schema, but users can specify such duplicate names.
  </para>
____________________________________________________________________________-->
  <para>
   当在数据库中查询约束信息时，一个期望返回一行的标准兼容的查询可能返回多行。这是因为 SQL 标准要求约束名在一个模式中唯一，但是<productname>PostgreSQL</productname>并不强制这种限制。<productname>PostgreSQL</productname>自动产生的约束名避免在相同的模式中重复，但是用户能够指定这种重复的名称。
  </para>

<!--==========================orignal english content==========================
  <para>
   This problem can appear when querying information schema views such
   as <literal>check_constraint_routine_usage</literal>,
   <literal>check_constraints</literal>, <literal>domain_constraints</literal>, and
   <literal>referential_constraints</literal>.  Some other views have similar
   issues but contain the table name to help distinguish duplicate
   rows, e.g., <literal>constraint_column_usage</literal>,
   <literal>constraint_table_usage</literal>, <literal>table_constraints</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   这个问题可能在查询信息模式视图时出现，例如<literal>check_constraint_routine_usage</literal>、
   <literal>check_constraints</literal>、<literal>domain_constraints</literal>和
   <literal>referential_constraints</literal>。一些其他视图也有相似的问题，但是它们包含了表名来帮助区分重复行，例如<literal>constraint_column_usage</literal>、
   <literal>constraint_table_usage</literal>、<literal>table_constraints</literal>。
  </para>
 </note>


 <sect1 id="infoschema-schema">
<!--==========================orignal english content==========================
  <title>The Schema</title>
____________________________________________________________________________-->
  <title>模式</title>

<!--==========================orignal english content==========================
  <para>
   The information schema itself is a schema named
   <literal>information_schema</literal>.  This schema automatically
   exists in all databases.  The owner of this schema is the initial
   database user in the cluster, and that user naturally has all the
   privileges on this schema, including the ability to drop it (but
   the space savings achieved by that are minuscule).
  </para>
____________________________________________________________________________-->
  <para>
   信息模式本身是一个名为<literal>information_schema</literal>的模式。这个模式自动存在于所有数据库中。这个模式的拥有者是集簇中的初始数据库用户，并且该用户自然地拥有这个模式上的所有特权，包括删除它的能力（但是这样节省的空间是很小的）。
  </para>

<!--==========================orignal english content==========================
  <para>
   By default, the information schema is not in the schema search
   path, so you need to access all objects in it through qualified
   names.  Since the names of some of the objects in the information
   schema are generic names that might occur in user applications, you
   should be careful if you want to put the information schema in the
   path.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，信息模式不在模式搜索路径中，因此你需要使用限定名访问其中的所有对象。因为信息模式中的某些对象的名称是可能出现在用户应用中的一般名称，如果你想把该信息模式放在路径中，你应该小心。
  </para>
 </sect1>

 <sect1 id="infoschema-datatypes">
<!--==========================orignal english content==========================
  <title>Data Types</title>
____________________________________________________________________________-->
  <title>数据类型</title>

<!--==========================orignal english content==========================
  <para>
   The columns of the information schema views use special data types
   that are defined in the information schema.  These are defined as
   simple domains over ordinary built-in types.  You should not use
   these types for work outside the information schema, but your
   applications must be prepared for them if they select from the
   information schema.
  </para>
____________________________________________________________________________-->
  <para>
   信息模式视图的列使用定义在信息模式中的特殊数据类型。它们被定义为普通内建类型之上的简单域。你不应在信息模式之外使用这些类型进行工作，但是如果你的应用从信息模式中进行选择，那你的应用就必须准备好面对它们。
  </para>

<!--==========================orignal english content==========================
  <para>
   These types are:

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       A nonnegative integer.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       A character string (without specific maximum length).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       A character string.  This type is used for SQL identifiers, the
       type <type>character_data</type> is used for any other kind of
       text data.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       A domain over the type <type>timestamp with time zone</type>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       A character string domain that contains
       either <literal>YES</literal> or <literal>NO</literal>.  This
       is used to represent Boolean (true/false) data in the
       information schema.  (The information schema was invented
       before the type <type>boolean</type> was added to the SQL
       standard, so this convention is necessary to keep the
       information schema backward compatible.)
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Every column in the information schema has one of these five types.
  </para>
____________________________________________________________________________-->
  <para>
   这些类型是：

   <variablelist>
    <varlistentry>
     <term><type>cardinal_number</type></term>
     <listitem>
      <para>
       一种非负整数。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>character_data</type></term>
     <listitem>
      <para>
       一种字符串（没有指定最大长度）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>sql_identifier</type></term>
     <listitem>
      <para>
       一种字符串。这种类型被用于 SQL 标识符，类型<type>character_data</type>被用于任何其他类型的文本数据。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>time_stamp</type></term>
     <listitem>
      <para>
       在类型<type>timestamp with time zone</type>之上的一个域。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><type>yes_or_no</type></term>
     <listitem>
      <para>
       一种字符串域，它包含<literal>YES</literal>或<literal>NO</literal>。这被用来在信息模式中表示布尔（真/假）（信息模式是在类型<type>boolean</type>被加到 SQL 标准之前被发明的，因此这个惯例是用来使信息模式向后兼容）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   信息模式中的每一列都是这五种类型之一。
  </para>
 </sect1>

 <sect1 id="infoschema-information-schema-catalog-name">
<!--==========================orignal english content==========================
  <title><literal>information_schema_catalog_name</literal></title>
____________________________________________________________________________-->
  <title><literal>information_schema_catalog_name</literal></title>

<!--==========================orignal english content==========================
  <para>
   <literal>information_schema_catalog_name</literal> is a table that
   always contains one row and one column containing the name of the
   current database (current catalog, in SQL terminology).
  </para>
____________________________________________________________________________-->
  <para>
   <literal>information_schema_catalog_name</literal>是一个表，它总是包含一行和一列，其中包含了当前数据库（SQL 术语中的当前目录）的名字。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>information_schema_catalog_name</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>information_schema_catalog_name</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains this information schema</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含这个信息模式的数据库名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-administrable-role-authorizations">
<!--==========================orignal english content==========================
  <title><literal>administrable_role_authorizations</literal></title>
____________________________________________________________________________-->
  <title><literal>administrable_role_authorizations</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>administrable_role_authorizations</literal>
   identifies all roles that the current user has the admin option
   for.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>administrable_role_authorizations</literal>标识当前用户对其有管理选项的所有角色。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>administrable_role_authorizations</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>administrable_role_authorizations</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被授予这个角色的成员关系的角色名（可以是当前用户，或者在嵌套角色成员关系情况下的一个不同角色）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of a role</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Always <literal>YES</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>总是 <literal>YES</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-applicable-roles">
<!--==========================orignal english content==========================
  <title><literal>applicable_roles</literal></title>
____________________________________________________________________________-->
  <title><literal>applicable_roles</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>applicable_roles</literal> identifies all roles
   whose privileges the current user can use.  This means there is
   some chain of role grants from the current user to the role in
   question.  The current user itself is also an applicable role.  The
   set of applicable roles is generally used for permission checking.
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>applicable_roles</literal>当前用户可以使用其特权的所有角色。这意味着有某种角色授权链从当前用户到讨论中的角色。当前用户本身也是一个可应用的角色。可应用的角色的集合通常被用于权限检查。
   <indexterm><primary>applicable role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>applicable</secondary></indexterm>
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>applicable_roles</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>applicable_roles</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the role to which this role membership was granted (can
       be the current user, or a different role in case of nested role
       memberships)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被授予这个角色的成员关系的角色名（可以是当前用户，或者在嵌套角色成员关系情况下的一个不同角色）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of a role</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个角色的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the grantee has the admin option on
       the role, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal>表示被授予者在该角色上有管理选项，<literal>NO</literal>表示没有管理选项
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-attributes">
<!--==========================orignal english content==========================
  <title><literal>attributes</literal></title>
____________________________________________________________________________-->
  <title><literal>attributes</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>attributes</literal> contains information about
   the attributes of composite data types defined in the database.
   (Note that the view does not give information about table columns,
   which are sometimes called attributes in PostgreSQL contexts.)
   Only those attributes are shown that the current user has access to (by way
   of being the owner of or having some privilege on the type).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>attributes</literal>包含数据库中定义的组合数据类型的属性的有关信息（注意该视图并不给出有关表列的信息，表列有时候在 PostgreSQL 上下文环境中也被称为属性）。只有当前用户能够访问（由于是拥有者获得的权限或是在类型上有某些特权）的那些属性会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>attributes</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>attributes</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the data type (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该数据类型的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该数据类型的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>数据类型名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the attribute</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>attribute_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>属性名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Ordinal position of the attribute within the data type (count starts at 1)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>属性在该数据类型内部的顺序位置（从 1 开始计算）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Default expression of the attribute</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>attribute_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该属性的默认表达式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the attribute is possibly nullable,
       <literal>NO</literal> if it is known not nullable.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该属性是可能为空的，值为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the attribute, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>attribute_udt_name</literal> and
       associated columns).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该属性是一个内建类型，此列值为该属性的数据类型；如果该属性是某种数组，此列值为<literal>ARRAY</literal>（在这种情况下，见视图<literal>element_types</literal>）；其他情况，此列值为<literal>USER-DEFINED</literal>（在这种情况下，该类型在<literal>attribute_udt_name</literal>和相关列中标识）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符或位串类型，这里是声明的最大长度；如果没有声明最大长度，则对于所有其他数据类型为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database containing the collation of the attribute
       (always the current database), null if default or the data type
       of the attribute is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的数据库名（总是当前数据库），如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema containing the collation of the attribute,
       null if default or the data type of the attribute is not
       collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的模式名，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the collation of the attribute, null if default or the
       data type of the attribute is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该属性排序规则的名称，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this attribute.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这列包含这个属性类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this attribute.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种准确数字类型，这列包含这个属性类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       attribute, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个属性类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this attribute, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个属性包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type attributes)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</productname>中不可用的特性（关于时间间隔类型属性的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the attribute data type is defined in
       (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>attribute_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型被定义的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the attribute data type is defined in
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>attribute_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型被定义的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the attribute data type
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>attribute_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       属性数据类型的名称
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列的数据类型描述符的一个标识符，在从属于该表的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_derived_reference_attribute</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   See also under <xref linkend="infoschema-columns"/>, a similarly
   structured view, for further information on some of the columns.
  </para>
____________________________________________________________________________-->
  <para>
   关于某些列的详情，参见<xref linkend="infoschema-columns"/>之下的一个相似结构的视图。
  </para>
 </sect1>

 <sect1 id="infoschema-character-sets">
<!--==========================orignal english content==========================
  <title><literal>character_sets</literal></title>
____________________________________________________________________________-->
  <title><literal>character_sets</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>character_sets</literal> identifies the character
   sets available in the current database.  Since PostgreSQL does not
   support multiple character sets within one database, this view only
   shows one, which is the database encoding.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>character_sets</literal>标识当前数据库中可用的字符集。因为 PostgreSQL 不支持在同一个数据库中有多个字符集，这个视图只显示一个字符集，它就是数据库编码。
  </para>

<!--==========================orignal english content==========================
  <para>
   Take note of how the following terms are used in the SQL standard:
   <variablelist>
    <varlistentry>
     <term>character repertoire</term>
     <listitem>
      <para>
       An abstract collection of characters, for
       example <literal>UNICODE</literal>, <literal>UCS</literal>, or
       <literal>LATIN1</literal>.  Not exposed as an SQL object, but
       visible in this view.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>character encoding form</term>
     <listitem>
      <para>
       An encoding of some character repertoire.  Most older character
       repertoires only use one encoding form, and so there are no
       separate names for them (e.g., <literal>LATIN1</literal> is an
       encoding form applicable to the <literal>LATIN1</literal>
       repertoire).  But for example Unicode has the encoding forms
       <literal>UTF8</literal>, <literal>UTF16</literal>, etc. (not
       all supported by PostgreSQL).  Encoding forms are not exposed
       as an SQL object, but are visible in this view.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>character set</term>
     <listitem>
      <para>
       A named SQL object that identifies a character repertoire, a
       character encoding, and a default collation.  A predefined
       character set would typically have the same name as an encoding
       form, but users could define other names.  For example, the
       character set <literal>UTF8</literal> would typically identify
       the character repertoire <literal>UCS</literal>, encoding
       form <literal>UTF8</literal>, and some default collation.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   You can think of an <quote>encoding</quote> in PostgreSQL either as
   a character set or a character encoding form.  They will have the
   same name, and there can only be one in one database.
  </para>
____________________________________________________________________________-->
  <para>
   注意下列术语在 SQL 标准中是怎样使用的：
   <variablelist>
    <varlistentry>
     <term>字元集（character repertoire）</term>
     <listitem>
      <para>
       字符的一个抽象集合，例如<literal>UNICODE</literal>、<literal>UCS</literal>或<literal>LATIN1</literal>。它不作为一个 SQL 对象显示，但是在这个视图中可见。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>字符编码形式（character encoding form）</term>
     <listitem>
      <para>
       某种字元集的一种编码。大部分较老的字元集只使用一种编码形式，并且因此它们没有独立的名字（例如<literal>LATIN1</literal>就是一种适用于<literal>LATIN1</literal>字元集的编码形式）。但是 Unicode 就有几种编码形式如<literal>UTF8</literal>、<literal>UTF16</literal>等等（并非全部被 PostgreSQL 支持）。编码形式不作为一个 SQL 对象显示，但是在这个视图中可见。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>字符集（character set）</term>
     <listitem>
      <para>
       一个标识一种字元集、一种字符编码以及一种默认排序规则的命名 SQL 对象。一个预定义的字符集通常具有和一种编码形式相同的名字，但是用户可以定义其他名字。例如，字符集<literal>UTF8</literal>通常标识字元集<literal>UCS</literal>、编码形式<literal>UTF8</literal>以及某种默认排序规则。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   你可以把 PostgreSQL 中的一种<quote>编码</quote>想成一个字符集或是一种字符编码形式。它们将具有相同的名字，并且在一个数据库中只能用其中一个。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>character_sets</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>character_sets</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character sets are currently not implemented as schema objects, so this column is null.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集并未被实现为模式对象，因此这一列为空。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character sets are currently not implemented as schema objects, so this column is null.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集并未被实现为模式对象，因此这一列为空。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the character set, currently implemented as showing the name of the database encoding</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>该字符集的名字，当前实现为显示该数据库编码的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_repertoire</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character repertoire, showing <literal>UCS</literal> if the encoding is <literal>UTF8</literal>, else just the encoding name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_repertoire</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字元集，如果编码为<literal>UTF8</literal>则显示<literal>UCS</literal>，否则只显示编码名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>form_of_use</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character encoding form, same as the database encoding</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>form_of_use</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字符编码形式，与数据库编码相同</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_collate_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the default collation (always the current database, if any collation is identified)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_collate_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该默认排序规则的数据库名（如果任意排序规则被标识，总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_collate_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the default collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_collate_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该默认排序规则的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_collate_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the default collation.  The default collation is
       identified as the collation that matches
       the <literal>COLLATE</literal> and <literal>CTYPE</literal>
       settings of the current database.  If there is no such
       collation, then this column and the associated schema and
       catalog columns are null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_collate_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       默认排序规则的名字。该默认排序规则被标识为匹配当前数据库的<literal>COLLATE</literal>和<literal>CTYPE</literal>设置的排序规则。如果没有那种排序规则，那么这一列和相关模式以及目录列为空。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraint-routine-usage">
<!--==========================orignal english content==========================
  <title><literal>check_constraint_routine_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>check_constraint_routine_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>check_constraint_routine_usage</literal>
   identifies routines (functions and procedures) that are used by a
   check constraint.  Only those routines are shown that are owned by
   a currently enabled role.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>check_constraint_routine_usage</literal>标识被检查约束琐事使用的例程（函数和过程）。只有被一个当前启用的角色所拥有的例程才被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>check_constraint_routine_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>check_constraint_routine_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       该函数的<quote>指定名称</quote>。详见<xref linkend="infoschema-routines"/>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-check-constraints">
<!--==========================orignal english content==========================
  <title><literal>check_constraints</literal></title>
____________________________________________________________________________-->
  <title><literal>check_constraints</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>check_constraints</literal> contains all check
   constraints, either defined on a table or on a domain, that are
   owned by a currently enabled role.  (The owner of the table or
   domain is the owner of the constraint.)
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>check_constraints</literal>包含所有检查约束，不管是定义在一个表上的还是定义在一个域上的，它们被一个当前启用的角色所拥有（表或域的拥有者就是约束的拥有者）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>check_constraints</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>check_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>The check expression of the check constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>check_clause</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>该检查约束的检查表达式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collations">
<!--==========================orignal english content==========================
  <title><literal>collations</literal></title>
____________________________________________________________________________-->
  <title><literal>collations</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>collations</literal> contains the collations
   available in the current database.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>collations</literal>包含在当前数据库中可用的排序规则。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>collations</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>collations</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the collation (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the default collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>默认排序规则的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>pad_attribute</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Always <literal>NO PAD</literal> (The alternative <literal>PAD
       SPACE</literal> is not supported by PostgreSQL.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>pad_attribute</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       总是<literal>NO PAD</literal>（另一种选择<literal>PAD
       SPACE</literal>没有被 PostgreSQL 支持）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-collation-character-set-applicab"> <!-- max 44 characters -->
<!--==========================orignal english content==========================
  <title><literal>collation_character_set_applicability</literal></title>
____________________________________________________________________________-->
  <title><literal>collation_character_set_applicability</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>collation_character_set_applicability</literal>
   identifies which character set the available collations are
   applicable to.  In PostgreSQL, there is only one character set per
   database (see explanation
   in <xref linkend="infoschema-character-sets"/>), so this view does
   not provide much useful information.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>collation_character_set_applicability</literal>标识可用的排序规则适用于哪些字符集。在 PostgreSQL 中，每个数据库中只有一种字符集（解释见<xref linkend="infoschema-character-sets"/>），因此这个视图没有提供很有用的信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>collation_character_set_applicability</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>collation_character_set_applicability</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the collation (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该排序规则的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the default collation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>默认排序规则的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character sets are currently not implemented as schema objects, so this column is null</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集还未被实现为模式对象，所以这一列为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Character sets are currently not implemented as schema objects, so this column is null</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>当前字符集还未被实现为模式对象，所以这一列为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the character set</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>字符集名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-domain-usage">
<!--==========================orignal english content==========================
  <title><literal>column_domain_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>column_domain_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>column_domain_usage</literal> identifies all
   columns (of a table or a view) that make use of some domain defined
   in the current database and owned by a currently enabled role.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>column_domain_usage</literal>标识所有使用定义在当前数据库中并且被一个当前启用的角色拥有的域的列（表列或视图列）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>column_domain_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>column_domain_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the domain (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>域名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-options">
<!--==========================orignal english content==========================
  <title><literal>column_options</literal></title>
____________________________________________________________________________-->
  <title><literal>column_options</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>column_options</literal> contains all the
   options defined for foreign table columns in the current database.  Only
   those foreign table columns are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>column_options</literal>包含为当前数据库中外部表列定义的所有选项。只有当前用户能够访问（作为拥有者或具有某些特权）的那些外部表列才被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>column_options</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>column_options</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the foreign table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部表名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of an option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Value of the option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-privileges">
<!--==========================orignal english content==========================
  <title><literal>column_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>column_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>column_privileges</literal> identifies all
   privileges granted on columns to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of
   column, grantor, and grantee.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>column_privileges</literal>标识所有授予给一个当前启用的角色或者被一个当前启用的角色授予的特权。对每一个列、授予者、被授予者的组合只有一行。
  </para>

<!--==========================orignal english content==========================
  <para>
   If a privilege has been granted on an entire table, it will show up in
   this view as a grant for each column, but only for the
   privilege types where column granularity is possible:
   <literal>SELECT</literal>, <literal>INSERT</literal>,
   <literal>UPDATE</literal>, <literal>REFERENCES</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个特权被授予在一整个表上，它在这个视图中被显示为在每一列上授予，但是只有可用于列粒度的特权类型才会这样：
   <literal>SELECT</literal>、<literal>INSERT</literal>、
   <literal>UPDATE</literal>、<literal>REFERENCES</literal>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>column_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>column_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that contains the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that contains the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>或
       <literal>REFERENCES</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-column-udt-usage">
<!--==========================orignal english content==========================
  <title><literal>column_udt_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>column_udt_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>column_udt_usage</literal> identifies all columns
   that use data types owned by a currently enabled role.  Note that in
   <productname>PostgreSQL</productname>, built-in data types behave
   like user-defined types, so they are included here as well.  See
   also <xref linkend="infoschema-columns"/> for details.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>column_udt_usage</literal>标识所有使用被一个当前启用的角色拥有的数据类型的列。注意在<productname>PostgreSQL</productname>中，内建数据类型的行为和用户定义的类型相似，因此它们也被包括在这里。详见<xref linkend="infoschema-columns"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>column_udt_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>column_udt_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）的名称
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-columns">
<!--==========================orignal english content==========================
  <title><literal>columns</literal></title>
____________________________________________________________________________-->
  <title><literal>columns</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>columns</literal> contains information about all
   table columns (or view columns) in the database.  System columns
   (<literal>oid</literal>, etc.) are not included.  Only those columns are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>columns</literal>包含数据库中有关所有表列（或视图列）的信息。系统列（<literal>oid</literal>等）不被包括在内。只有那些当前用户能够访问（作为拥有者或具有某些特权）的列才被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>columns</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>columns</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Ordinal position of the column within the table (count starts at 1)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该列在表内的顺序位置（从 1 开始计）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Default expression of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该列的默认表达式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the column is possibly nullable,
       <literal>NO</literal> if it is known not nullable.  A not-null
       constraint is one way a column can be known not nullable, but
       there can be others.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_nullable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列可以为空，则为<literal>YES</literal>，否则为<literal>NO</literal>。一个非空约束是让一列成为不能为空的方法，但还有其他方法。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the column, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).  If the column is based on a domain, this column
       refers to the type underlying the domain (and the domain is
       identified in <literal>domain_name</literal> and associated
       columns).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列的数据类型是一种内建类型，则为该列的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况下该类型被标识在<literal>udt_name</literal>和相关列中）。如果该列基于一个域，这一列引用该域底层的类型（该列被标识在<literal>domain_name</literal>和相关列中）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种字符或位串类型，这里是声明的最大长度；如果没有声明最大长度或者所有其他数据类型，这里为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a character type,
       the maximum possible length in octets (bytes) of a datum; null
       for all other data types.  The maximum octet length depends on
       the declared character maximum length (see above) and the
       server encoding.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this column.  The precision indicates the number of
       significant digits.  It can be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这列包含这个属性类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a numeric type, this
       column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this column.  The scale indicates the number of
       significant digits to the right of the decimal point.  It can
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种准确数字类型，这列包含这个属性类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       column, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个属性类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this column, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个属性包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type columns)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</productname>中不可用的特性（关于时间间隔类型属性的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database containing the collation of the column
       (always the current database), null if default or the data type
       of the column is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的数据库名（总是当前数据库），如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema containing the collation of the column, null
       if default or the data type of the column is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此属性排序规则的模式名，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the collation of the column, null if default or the
       data type of the column is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该属性排序规则的名称，如果默认或者该属性的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the column has a domain type, the name of the database that
       the domain is defined in (always the current database), else
       null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该列有一个域类型，这里是该域所在的数据库名（总是当前数据库），否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the column has a domain type, the name of the schema that
       the domain is defined in, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该列有一个域类型，这里是该域所在的模式名，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>If the column has a domain type, the name of the domain, else null.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果该列有一个域类型，这里是该域的名称，否则为空。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）被定义的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column data type (the underlying type of the
       domain, if applicable)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列数据类型（如果适用，底层的域类型）的名称
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该列的数据类型描述符的一个标识符，在从属于该表的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_self_referencing</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       If the column is an identity column, then <literal>YES</literal>,
       else <literal>NO</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_identity</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列是一个标识列，则为<literal>YES</literal>，否则为<literal>NO</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the column is an identity column, then <literal>ALWAYS</literal>
       or <literal>BY DEFAULT</literal>, reflecting the definition of the
       column.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列是一个标识列，则为<literal>ALWAYS</literal>或者<literal>BY DEFAULT</literal>，它反映该列的定义。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the column is an identity column, then the start value of the
       internal sequence, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_start</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列是一个标识列，则是内部序列的起始值，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the column is an identity column, then the increment of the internal
       sequence, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列是一个标识列，则是内部序列的增量，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the column is an identity column, then the maximum value of the
       internal sequence, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_maximum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列是一个标识列，则是内部序列的最大值，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the column is an identity column, then the minimum value of the
       internal sequence, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_minimum</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该列是一个标识列，则是内部序列的最小值，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       If the column is an identity column, then <literal>YES</literal> if the
       internal sequence cycles or <literal>NO</literal> if it does not;
       otherwise null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>identity_cycle</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列是一个标识列，则<literal>YES</literal>和<literal>NO</literal>分别表示内部序列可循环和不可循环，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_generated</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>generation_expression</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the column is updatable,
       <literal>NO</literal> if not (Columns in base tables are always
       updatable, columns in views not necessarily)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该列是可更新的，则为<literal>YES</literal>，否则为<literal>NO</literal>（基表中的列总是可更新的，视图中的列则不一定）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Since data types can be defined in a variety of ways in SQL, and
   <productname>PostgreSQL</productname> contains additional ways to
   define data types, their representation in the information schema
   can be somewhat difficult.  The column <literal>data_type</literal>
   is supposed to identify the underlying built-in type of the column.
   In <productname>PostgreSQL</productname>, this means that the type
   is defined in the system catalog schema
   <literal>pg_catalog</literal>.  This column might be useful if the
   application can handle the well-known built-in types specially (for
   example, format the numeric types differently or use the data in
   the precision columns).  The columns <literal>udt_name</literal>,
   <literal>udt_schema</literal>, and <literal>udt_catalog</literal>
   always identify the underlying data type of the column, even if the
   column is based on a domain.  (Since
   <productname>PostgreSQL</productname> treats built-in types like
   user-defined types, built-in types appear here as well.  This is an
   extension of the SQL standard.)  These columns should be used if an
   application wants to process data differently according to the
   type, because in that case it wouldn't matter if the column is
   really based on a domain.  If the column is based on a domain, the
   identity of the domain is stored in the columns
   <literal>domain_name</literal>, <literal>domain_schema</literal>,
   and <literal>domain_catalog</literal>.  If you want to pair up
   columns with their associated data types and treat domains as
   separate types, you could write <literal>coalesce(domain_name,
   udt_name)</literal>, etc.
  </para>
____________________________________________________________________________-->
  <para>
   因为在 SQL 中有多种方式定义数据类型，而<productname>PostgreSQL</productname>还包含额外的方式来定义数据类型，它们在信息模式中的表示可能有点困难。列<literal>data_type</literal>应该标识列的底层内建类型。在<productname>PostgreSQL</productname>中，这表示定义在系统目录模式<literal>pg_catalog</literal>中的类型。如果应用能够特别地（例如以不同方式格式化数字类型或使用精度列中的数据）处理总所周知的内建类型，这列可能会有用。列<literal>udt_name</literal>、<literal>udt_schema</literal>和<literal>udt_catalog</literal>总是标识列的底层数据类型，即使该列是基于一个域的（因为<productname>PostgreSQL</productname>对待内建类型和用户定义类型的方式是一样的，内建类型也出现在这里。这是 SQL 标准的一种扩展）。如果一个应用想要根据该类型以不同的方式处理数据，就应该使用这些列，因为在那种情况下即使该列真地基于一个域也没有关系。如果该列是基于一个域，该域的标识被存储在列<literal>domain_name</literal>、<literal>domain_schema</literal>和<literal>domain_catalog</literal>。如果你想要把列和它们相关的数据类型配对并且把域视作单独的类型，你可以写<literal>coalesce(domain_name,
   udt_name)</literal>等等。
  </para>
 </sect1>

 <sect1 id="infoschema-constraint-column-usage">
<!--==========================orignal english content==========================
  <title><literal>constraint_column_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>constraint_column_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>constraint_column_usage</literal> identifies all
   columns in the current database that are used by some constraint.
   Only those columns are shown that are contained in a table owned by
   a currently enabled role.  For a check constraint, this view
   identifies the columns that are used in the check expression.  For
   a foreign key constraint, this view identifies the columns that the
   foreign key references.  For a unique or primary key constraint,
   this view identifies the constrained columns.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>constraint_column_usage</literal>标识在当前数据库中被某个约束使用的所有列。只有包含在被一个当前启用的角色拥有的表中的那些列才被显示。对于一个检查约束，这个视图标识被用在该检查约束中的列。对于一个外键约束，这个视图标识外键引用的列。对于一个唯一或主键约束，这个视图标识被约束的列。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>constraint_column_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>constraint_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is used by some constraint (always the current
       database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表所在的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is used by some constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表所在的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is used by some
       constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列的表名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column that is used by some constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的列名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-constraint-table-usage">
<!--==========================orignal english content==========================
  <title><literal>constraint_table_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>constraint_table_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>constraint_table_usage</literal> identifies all
   tables in the current database that are used by some constraint and
   are owned by a currently enabled role.  (This is different from the
   view <literal>table_constraints</literal>, which identifies all
   table constraints along with the table they are defined on.)  For a
   foreign key constraint, this view identifies the table that the
   foreign key references.  For a unique or primary key constraint,
   this view simply identifies the table the constraint belongs to.
   Check constraints and not-null constraints are not included in this
   view.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>constraint_table_usage</literal>标识在当前数据库中被某个约束使用的所有表（这与视图<literal>table_constraints</literal>不同，它标识哪些表约束定义在哪些表上）。对于一个外键约束，这个视图标识该外键引用的表。对于一个唯一或主键约束，这个视图仅标识该约束属于的表。检查约束和非空约束不被包括在这个视图中。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>constraint_table_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>constraint_table_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that is used by
       some constraint (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的表的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that is used by some
       constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被某个约束使用的表的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that is used by some constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被某个约束使用的表名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-data-type-privileges">
<!--==========================orignal english content==========================
  <title><literal>data_type_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>data_type_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>data_type_privileges</literal> identifies all
   data type descriptors that the current user has access to, by way
   of being the owner of the described object or having some privilege
   for it.  A data type descriptor is generated whenever a data type
   is used in the definition of a table column, a domain, or a
   function (as parameter or return type) and stores some information
   about how the data type is used in that instance (for example, the
   declared maximum length, if applicable).  Each data type
   descriptor is assigned an arbitrary identifier that is unique
   among the data type descriptor identifiers assigned for one object
   (table, domain, function).  This view is probably not useful for
   applications, but it is used to define some other views in the
   information schema.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>data_type_privileges</literal>标识当前用户能够访问（作为被描述对象的拥有者或者具有其上的某种特权）的所有数据类型描述符。只要一个数据类型被用在一个表列、一个域或一个函数（作为参数或返回类型）就会生成一个数据类型描述符并且在那个实例中存储一些有关该数据类型如何被使用的信息（例如，声明的最大长度，如果适用）。每一个数据类型描述符被赋予一个任意的标识符，它在被赋予给一个对象（表、域、函数）的数据类型描述符中唯一。这个视图对于应用可能没什么用，但是它被用于定义信息模式中的一些其他视图。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>data_type_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>data_type_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the described object (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该被描述对象的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the described object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该被描述对象的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the described object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该描述对象的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The type of the described object: one of
       <literal>TABLE</literal> (the data type descriptor pertains to
       a column of that table), <literal>DOMAIN</literal> (the data
       type descriptors pertains to that domain),
       <literal>ROUTINE</literal> (the data type descriptor pertains
       to a parameter or the return data type of that function).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       被描述对象的类型：<literal>TABLE</literal>（从属于表的一列的数据类型描述符）、<literal>DOMAIN</literal> （从属于域的数据类型描述符）、<literal>ROUTINE</literal>（从属于函数的一个参数或返回数据类型的数据类型描述符）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The identifier of the data type descriptor, which is unique
       among the data type descriptors for that same object.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       数据类型描述符的标识符，它在同一对象的数据类型描述符之间唯一。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-constraints">
<!--==========================orignal english content==========================
  <title><literal>domain_constraints</literal></title>
____________________________________________________________________________-->
  <title><literal>domain_constraints</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>domain_constraints</literal> contains all constraints
   belonging to domains defined in the current database.  Only those domains
   are shown that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>domain_constraints</literal>包含所有属于当前数据库中定义的域的约束。只有当前用户能访问的那些域才被显示（作为拥有者或具有某些特权）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>domain_constraints</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>domain_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的且初始就被延迟，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domain-udt-usage">
<!--==========================orignal english content==========================
  <title><literal>domain_udt_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>domain_udt_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>domain_udt_usage</literal> identifies all domains
   that are based on data types owned by a currently enabled role.
   Note that in <productname>PostgreSQL</productname>, built-in data
   types behave like user-defined types, so they are included here as
   well.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>domain_udt_usage</literal>标识所有基于被一个当前启用的角色拥有的数据类型的域。注意在<productname>PostgreSQL</productname>中，内建数据类型的行为相似于用户定义的类型，因此它们也被包括在这里。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>domain_udt_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>domain_udt_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that the domain data type is defined in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-domains">
<!--==========================orignal english content==========================
  <title><literal>domains</literal></title>
____________________________________________________________________________-->
  <title><literal>domains</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>domains</literal> contains all domains defined in the
   current database.  Only those domains are shown that the current user has
   access to (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>domains</literal>包含定义在当前数据库中的所有域。只有当前用户能够访问（作为拥有者或具有某些特权）的域才被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>domains</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>domains</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the domain (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该域的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the domain, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该域的数据类型如果是一种内建类型，这里是该域的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a character or bit string type, the declared
       maximum length; null for all other data types or if no maximum
       length was declared.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一个字符或位串类型，这里是声明的最大长度；如果没有声明最大长度，则对于所有其他数据类型为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a character type, the maximum possible length
       in octets (bytes) of a datum; null for all other data types.
       The maximum octet length depends on the declared character
       maximum length (see above) and the server encoding.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      如果该域有一个字符类型，这里是一个数据的最大可能长度（以字节计）；对其他所有数据类型为空。最大字节长度取决于声明的字符最大长度（见上文）和服务器编码。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database containing the collation of the domain
       (always the current database), null if default or the data type
       of the domain is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此域排序规则的数据库名（总是当前数据库），如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema containing the collation of the domain, null
       if default or the data type of the domain is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含此域排序规则的模式名，如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the collation of the domain, null if default or the
       data type of the domain is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该域排序规则的名称，如果默认或者该域的数据类型不可排序则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a numeric type, this column contains the
       (declared or implicit) precision of the type for this domain.
       The precision indicates the number of significant digits.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一种数字类型，这列包含这个域类型的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has a numeric type, this column indicates in
       which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       
       如果该域有一种数字类型，这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If the domain has an exact numeric type, this column contains
       the (declared or implicit) scale of the type for this domain.
       The scale indicates the number of significant digits to the
       right of the decimal point.  It can be expressed in decimal
       (base 10) or binary (base 2) terms, as specified in the column
       <literal>numeric_precision_radix</literal>.  For all other data
       types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果该域有一种准确数字类型，这列包含这个域类型的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       If <literal>data_type</literal> identifies a date, time,
       timestamp, or interval type, this column contains the (declared
       or implicit) fractional seconds precision of the type for this
       domain, that is, the number of decimal digits maintained
       following the decimal point in the seconds value.  For all
       other data types, this column is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种日期、时间、时间戳或时间间隔类型，这一列包含这个域类型的（声明的或隐式的）分数秒的精度，也就是秒值的小数点后的十进制位数。对于所有其他数据类型，这一列为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If <literal>data_type</literal> identifies an interval type,
       this column contains the specification which fields the
       intervals include for this domain, e.g., <literal>YEAR TO
       MONTH</literal>, <literal>DAY TO SECOND</literal>, etc.  If no
       field restrictions were specified (that is, the interval
       accepts all fields), and for all other data types, this field
       is null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果<literal>data_type</literal>标识一种时间间隔类型，这一列包含时间间隔为这个域包括哪些域的声明，例如<literal>YEAR TO
       MONTH</literal>、<literal>DAY TO SECOND</literal>等等。如果没有指定域限制（也就是该时间间隔接受所有域），并且对于所有其他数据类型，这个域为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Applies to a feature not available
       in <productname>PostgreSQL</productname>
       (see <literal>datetime_precision</literal> for the fractional
       seconds precision of interval type domains)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       应用于一个<productname>PostgreSQL</productname>中不可用的特性（关于时间间隔类型域的分数秒精度可见<literal>datetime_precision</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Default expression of the domain</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该域的默认表达式</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the domain data type is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that the domain data type is defined in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型被定义的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the domain data type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该域数据类型的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the domain, unique
       among the data type descriptors pertaining to the domain (which
       is trivial, because a domain only contains one data type
       descriptor).  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该域的数据类型描述符的一个标识符，在从属于该域的数据类型标识符之中唯一（这不重要，因为一个域只包含一个数据类型描述符）。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-element-types">
<!--==========================orignal english content==========================
  <title><literal>element_types</literal></title>
____________________________________________________________________________-->
  <title><literal>element_types</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>element_types</literal> contains the data type
   descriptors of the elements of arrays.  When a table column, composite-type attribute,
   domain, function parameter, or function return value is defined to
   be of an array type, the respective information schema view only
   contains <literal>ARRAY</literal> in the column
   <literal>data_type</literal>.  To obtain information on the element
   type of the array, you can join the respective view with this view.
   For example, to show the columns of a table with data types and
   array element types, if applicable, you could do:
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   This view only includes objects that the current user has access
   to, by way of being the owner or having some privilege.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>element_types</literal>包含数组元素的数据类型描述符。当一个表列、组合类型属性、域、函数参数或函数返回值被定义为一种数组类型，相应的信息模式视图只在列<literal>data_type</literal>中包含<literal>ARRAY</literal>。要获得该数组元素类型的信息，你可以连接该相应的视图和这个视图。例如，要显示一个表的列及其数据类型和数组元素类型，你可以：
<programlisting>
SELECT c.column_name, c.data_type, e.data_type AS element_type
FROM information_schema.columns c LEFT JOIN information_schema.element_types e
     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)
       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))
WHERE c.table_schema = '...' AND c.table_name = '...'
ORDER BY c.ordinal_position;
</programlisting>
   这个视图只包括当前用户能够访问（作为拥有者或具有某些特权）的对象。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>element_types</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>element_types</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the object that uses the
       array being described (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含使用被描述的数组的对象的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the object that uses the array
       being described
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含使用被描述的数组的对象的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the object that uses the array being described
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       使用被描述的模式的对象名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The type of the object that uses the array being described: one
       of <literal>TABLE</literal> (the array is used by a column of
       that table), <literal>USER-DEFINED TYPE</literal> (the array is
       used by an attribute of that composite type),
       <literal>DOMAIN</literal> (the array is used by that domain),
       <literal>ROUTINE</literal> (the array is used by a parameter or
       the return data type of that function).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       使用被描述的数组的对象的类型：<literal>TABLE</literal>（被一个表列使用的数组）、<literal>USER-DEFINED TYPE</literal>（被组合类型的一个属性使用的数组）、<literal>DOMAIN</literal> （被域使用的数组）、<literal>ROUTINE</literal>（被函数的一个参数或返回数据类型使用的数组）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The identifier of the data type descriptor of the array being
       described.  Use this to join with the
       <literal>dtd_identifier</literal> columns of other information
       schema views.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collection_type_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被描述的数组的数据类型描述符的标识符。使用这个去与其他信息模式视图的<literal>dtd_identifier</literal>列连接。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the array elements, if it is a built-in type, else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果数组元素的数据类型是内建类型，这里是数组元素的数据类型，否则为<literal>USER-DEFINED</literal>（在那种情况下，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database containing the collation of the element
       type (always the current database), null if default or the data
       type of the element is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含元素类型排序规则的数据库名（总是当前数据库）, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema containing the collation of the element
       type, null if default or the data type of the element is not
       collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含元素类型排序规则的模式名, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the collation of the element type, null if default or
       the data type of the element is not collatable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素类型的排序规则名, 如果默认或该元素的数据类型是不可排序的则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to array element data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的数组元素数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>domain_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>还未被实现</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the data type of the elements is
       defined in (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素的数据类型所在的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the data type of the elements is
       defined in
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       元素的数据类型所在的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the data type of the elements
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       模式的数据类型名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the element.  This
       is currently not useful.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该元素的数据类型描述符的标识符。当前无用。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-enabled-roles">
<!--==========================orignal english content==========================
  <title><literal>enabled_roles</literal></title>
____________________________________________________________________________-->
  <title><literal>enabled_roles</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>enabled_roles</literal> identifies the currently
   <quote>enabled roles</quote>.  The enabled roles are recursively
   defined as the current user together with all roles that have been
   granted to the enabled roles with automatic inheritance.  In other
   words, these are all roles that the current user has direct or
   indirect, automatically inheriting membership in.
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>enabled_roles</literal>标识当前<quote>已被启用的角色</quote>。已被启用的角色被递归地定义为：当前用户以及被授予给具有自动继承的已被启用角色的所有角色。换句话说，就是当前用户是其直接或间接成员的所有角色。
   <indexterm><primary>enabled role</primary></indexterm>
   <indexterm><primary>role</primary><secondary>enabled</secondary></indexterm>
  </para>

<!--==========================orignal english content==========================
  <para>
   For permission checking, the set of <quote>applicable roles</quote>
   is applied, which can be broader than the set of enabled roles.  So
   generally, it is better to use the view
   <literal>applicable_roles</literal> instead of this one; See
   <xref linkend="infoschema-applicable-roles"/> for details on
   <literal>applicable_roles</literal> view.
  </para>
____________________________________________________________________________-->
  <para>
   为了权限检查，<quote>可应用角色</quote>的集合被应用，它会比已被启用角色的集合包含的角色范围更宽。因此通常使用视图<literal>applicable_roles</literal>要更好，<literal>applicable_roles</literal>视图的详情请见<xref linkend="infoschema-applicable-roles"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>enabled_roles</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>enabled_roles</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of a role</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>role_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>角色名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrapper-options">
<!--==========================orignal english content==========================
  <title><literal>foreign_data_wrapper_options</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_data_wrapper_options</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_data_wrapper_options</literal> contains
   all the options defined for foreign-data wrappers in the current
   database.  Only those foreign-data wrappers are shown that the
   current user has access to (by way of being the owner or having
   some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_data_wrapper_options</literal>包含为当前数据库中外部数据包装器定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部数据包装器被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_data_wrapper_options</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_data_wrapper_options</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign-data wrapper is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部数据包装器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部数据包装器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of an option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Value of the option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-data-wrappers">
<!--==========================orignal english content==========================
  <title><literal>foreign_data_wrappers</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_data_wrappers</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_data_wrappers</literal> contains all
   foreign-data wrappers defined in the current database.  Only those
   foreign-data wrappers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_data_wrappers</literal>包含定义在当前数据库中的所有外部数据包装器。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部数据包装器才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_data_wrappers</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_data_wrappers</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the foreign-data
      wrapper (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部数据包装器的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部数据包装器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the owner of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部服务器拥有者的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>File name of the library that implementing this foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>library_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>实现这个外部数据包装器的库文件名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Language used to implement this foreign-data wrapper</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>用于实现这个外部数据包装器的语言</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-server-options">
<!--==========================orignal english content==========================
  <title><literal>foreign_server_options</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_server_options</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_server_options</literal> contains all the
   options defined for foreign servers in the current database.  Only
   those foreign servers are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_server_options</literal>包含为当前数据库中外部服务器定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部服务器才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_server_options</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_server_options</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of an option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Value of the option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-servers">
<!--==========================orignal english content==========================
  <title><literal>foreign_servers</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_servers</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_servers</literal> contains all foreign
   servers defined in the current database.  Only those foreign
   servers are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_servers</literal>包含当前数据库中定义的所有外部服务器。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部服务器才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_servers</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_servers</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the foreign-data
      wrapper used by the foreign server (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被该外部服务器使用的外部数据包装器的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign-data wrapper used by the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_data_wrapper_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被该外部服务器所使用的外部数据包装器的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Foreign server type information, if specified upon creation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>外部服务器类型信息（如果在创建时指定过）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Foreign server version information, if specified upon creation</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_version</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>外部服务器版本信息（如果在创建时指定过）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the owner of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的拥有者名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-table-options">
<!--==========================orignal english content==========================
  <title><literal>foreign_table_options</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_table_options</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_table_options</literal> contains all the
   options defined for foreign tables in the current database.  Only
   those foreign tables are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_table_options</literal>包含为当前数据库中外部表定义的所有选项。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部表才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_table_options</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_table_options</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the foreign table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>外部表的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of an option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Value of the option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该选项的值</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-foreign-tables">
<!--==========================orignal english content==========================
  <title><literal>foreign_tables</literal></title>
____________________________________________________________________________-->
  <title><literal>foreign_tables</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>foreign_tables</literal> contains all foreign
   tables defined in the current database.  Only those foreign
   tables are shown that the current user has access to (by way of
   being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>foreign_tables</literal>包含定义在当前数据库中的所有外部表。只有那些当前用户能够访问（作为拥有者或具有某些特权）的外部表才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>foreign_tables</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>foreign_tables</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign table is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部表所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该外部表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部表的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign server is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign server</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该外部服务器的名字</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-key-column-usage">
<!--==========================orignal english content==========================
  <title><literal>key_column_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>key_column_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>key_column_usage</literal> identifies all columns
   in the current database that are restricted by some unique, primary
   key, or foreign key constraint.  Check constraints are not included
   in this view.  Only those columns are shown that the current user
   has access to, by way of being the owner or having some privilege.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>key_column_usage</literal>标识当前数据库中所有被某种唯一、主键或外键约束限制的列。检查约束不被包括在这个视图中。只有那些当前用户能够访问的列才会被显示（作为拥有者或具有某些特权）。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>key_column_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>key_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is restricted by this constraint (always the
       current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is restricted by this constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表所在的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is restricted
       by this constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含被这个约束限制的列的表的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the column that is restricted by this constraint
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被这个约束限制的列名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Ordinal position of the column within the constraint key (count
       starts at 1)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该列在约束键中的顺序位置（从 1 开始计数）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       For a foreign-key constraint, ordinal position of the referenced
       column within its unique constraint (count starts at 1);
       otherwise null
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>position_in_unique_constraint</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>对于一个外键约束，被引用行在其唯一约束中的顺序位置（从 1 开始计数）；对于其他约束为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-parameters">
<!--==========================orignal english content==========================
  <title><literal>parameters</literal></title>
____________________________________________________________________________-->
  <title><literal>parameters</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>parameters</literal> contains information about
   the parameters (arguments) of all functions in the current database.
   Only those functions are shown that the current user has access to
   (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>parameters</literal>包含当前数据库中所有函数的参数的有关信息。只有那些当前用户能够访问（作为拥有者或具有某些特权）的函数才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>parameters</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>parameters</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Ordinal position of the parameter in the argument list of the
       function (count starts at 1)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordinal_position</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该参数在函数参数列表中的顺序位置（从 1 开始计数）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal> for input parameter,
       <literal>OUT</literal> for output parameter,
       and <literal>INOUT</literal> for input/output parameter.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>parameter_mode</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>IN</literal>表示输入参数，
       <literal>OUT</literal>表示输出参数，
       <literal>INOUT</literal>表示输入输出参数。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_result</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the parameter, or null if the parameter has no name</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>parameter_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>参数名，如果参数没有名称则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Data type of the parameter, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>udt_name</literal> and associated
       columns).
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该参数的数据类型如果是一种内建类型，这里是该参数的数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>udt_name</literal>和相关列中）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to parameter data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the data type of the parameter is
       defined in (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型所在的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the data type of the parameter is
       defined in
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型所在的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the data type of the parameter
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该参数的数据类型的名字
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the parameter,
       unique among the data type descriptors pertaining to the
       function.  This is mainly useful for joining with other
       instances of such identifiers.  (The specific format of the
       identifier is not defined and not guaranteed to remain the same
       in future versions.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该参数的数据类型描述符的一个标识符，在从属于该函数的数据类型标识符之中唯一（这不重要，因为一个域只包含一个数据类型描述符）。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>
     
<!--==========================orignal english content==========================
     <row>
      <entry><literal>parameter_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The default expression of the parameter, or null if none or if the
       function is not owned by a currently enabled role.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>parameter_default</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该参数的默认表达式，如果没有或者该函数不被一个当前启用的角色拥有则为空值。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-referential-constraints">
<!--==========================orignal english content==========================
  <title><literal>referential_constraints</literal></title>
____________________________________________________________________________-->
  <title><literal>referential_constraints</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>referential_constraints</literal> contains all
   referential (foreign key) constraints in the current database.
   Only those constraints are shown for which the current user has
   write access to the referencing table (by way of being the
   owner or having some privilege other than <literal>SELECT</literal>).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>referential_constraints</literal>包含当前数据库中的所有引用（外键）约束。只有那些当前用户具有其引用表上写权限（作为拥有者或具有某些除<literal>SELECT</literal>之外的特权）的约束才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>referential_constraints</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>referential_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the database that contains the unique or primary key
       constraint that the foreign key constraint references (always
       the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>unique_constraint_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the schema that contains the unique or primary key
       constraint that the foreign key constraint references
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>unique_constraint_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       Name of the unique or primary key constraint that the foreign
       key constraint references
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>unique_constraint_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       包含该外键约束所引用的唯一或主键约束的名字
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Match option of the foreign key constraint:
       <literal>FULL</literal>, <literal>PARTIAL</literal>, or
       <literal>NONE</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>match_option</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的匹配选项：
       <literal>FULL</literal>、<literal>PARTIAL</literal>或<literal>NONE</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Update rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>update_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的更新规则：
       <literal>CASCADE</literal>、<literal>SET NULL</literal>、
       <literal>SET DEFAULT</literal>、<literal>RESTRICT</literal>或
       <literal>NO ACTION</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       Delete rule of the foreign key constraint:
       <literal>CASCADE</literal>, <literal>SET NULL</literal>,
       <literal>SET DEFAULT</literal>, <literal>RESTRICT</literal>, or
       <literal>NO ACTION</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>delete_rule</literal></entry>
      <entry><literal>character_data</literal></entry>
      <entry>
       外键约束的删除规则：
       <literal>CASCADE</literal>、<literal>SET NULL</literal>、
       <literal>SET DEFAULT</literal>、<literal>RESTRICT</literal>或
       <literal>NO ACTION</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="infoschema-role-column-grants">
<!--==========================orignal english content==========================
  <title><literal>role_column_grants</literal></title>
____________________________________________________________________________-->
  <title><literal>role_column_grants</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>role_column_grants</literal> identifies all
   privileges granted on columns where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>column_privileges</literal>.  The only effective
   difference between this view
   and <literal>column_privileges</literal> is that this view omits
   columns that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>role_column_grants</literal>标识所有在列上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>column_privileges</literal>中找到。这个视图和<literal>column_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的列。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>role_column_grants</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>role_column_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table that contains the column (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that contains the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表所在的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that contains the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该列的表名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>列名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>, or
       <literal>REFERENCES</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>或
       <literal>REFERENCES</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-routine-grants">
<!--==========================orignal english content==========================
  <title><literal>role_routine_grants</literal></title>
____________________________________________________________________________-->
  <title><literal>role_routine_grants</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>role_routine_grants</literal> identifies all
   privileges granted on functions where the grantor or grantee is a
   currently enabled role.  Further information can be found under
   <literal>routine_privileges</literal>.  The only effective
   difference between this view
   and <literal>routine_privileges</literal> is that this view omits
   functions that have been made accessible to the current user by way
   of a grant to <literal>PUBLIC</literal>.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>role_routine_grants</literal>标识所有在函数上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>routine_privileges</literal>中找到。这个视图和<literal>routine_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的函数。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>role_routine_grants</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>role_routine_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (might be duplicated in case of overloading)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能会重复）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为<literal>EXECUTE</literal>（函数唯一的特权类型）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-table-grants">
<!--==========================orignal english content==========================
  <title><literal>role_table_grants</literal></title>
____________________________________________________________________________-->
  <title><literal>role_table_grants</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>role_table_grants</literal> identifies all
   privileges granted on tables or views where the grantor or grantee
   is a currently enabled role.  Further information can be found
   under <literal>table_privileges</literal>.  The only effective
   difference between this view
   and <literal>table_privileges</literal> is that this view omits
   tables that have been made accessible to the current user by way of
   a grant to <literal>PUBLIC</literal>.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>role_table_grants</literal>标识所有在表或视图上授予的特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>table_privileges</literal>中找到。这个视图和<literal>table_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的表。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>role_table_grants</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>role_table_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该特权的类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>、
       <literal>REFERENCES</literal>或<literal>TRIGGER</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       在 SQL 标准中，<literal>WITH HIERARCHY OPTION</literal>是一个独立的（子）特权，它允许在表继承层级上的特定操作。在 PostgreSQL 中，这被包括在<literal>SELECT</literal>特权中，因此这一列在特权为<literal>SELECT</literal>时显示<literal>YES</literal>，其他时候显示<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-udt-grants">
<!--==========================orignal english content==========================
  <title><literal>role_udt_grants</literal></title>
____________________________________________________________________________-->
  <title><literal>role_udt_grants</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>role_udt_grants</literal> is intended to identify
   <literal>USAGE</literal> privileges granted on user-defined types
   where the grantor or grantee is a currently enabled role.  Further
   information can be found under
   <literal>udt_privileges</literal>.  The only effective difference
   between this view and <literal>udt_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.  Since
   data types do not have real privileges in PostgreSQL, but only an
   implicit grant to <literal>PUBLIC</literal>, this view is empty.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>role_udt_grants</literal>标识所有在用户定义类型上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>udt_privileges</literal>中找到。这个视图和<literal>udt_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的对象。因为数据类型在 PostgreSQL 中并没有真正的特权，而是只有一个给<literal>PUBLIC</literal>的隐式授予，这个视图为空。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>role_udt_grants</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>role_udt_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>The name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>The name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the type (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>TYPE USAGE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-role-usage-grants">
<!--==========================orignal english content==========================
  <title><literal>role_usage_grants</literal></title>
____________________________________________________________________________-->
  <title><literal>role_usage_grants</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>role_usage_grants</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects where the grantor or grantee is a currently enabled role.
   Further information can be found under
   <literal>usage_privileges</literal>.  The only effective difference
   between this view and <literal>usage_privileges</literal> is that
   this view omits objects that have been made accessible to the
   current user by way of a grant to <literal>PUBLIC</literal>.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>role_usage_grants</literal>标识所有在多种对象上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。更多信息可以在<literal>usage_privileges</literal>中找到。这个视图和<literal>usage_privileges</literal>之间的唯一实质性区别是：这个视图忽略那些以授予给<literal>PUBLIC</literal>的方式使当前用户获得其访问权限的对象。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>role_usage_grants</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>role_usage_grants</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>The name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>The name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the object (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该对象的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the object, if applicable,
      else an empty string</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果适用，则为包含该对象的模式名，否则为一个空字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>对象的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>或<literal>DOMAIN</literal>或<literal>FOREIGN DATA WRAPPER</literal>或<literal>FOREIGN SERVER</literal>或<literal>SEQUENCE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>USAGE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>USAGE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routine-privileges">
<!--==========================orignal english content==========================
  <title><literal>routine_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>routine_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>routine_privileges</literal> identifies all
   privileges granted on functions to a currently enabled role or by a
   currently enabled role.  There is one row for each combination of function,
   grantor, and grantee.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>routine_privileges</literal>标识所有在函数上授予的特权，其授予者或被授予者是一个当前已被启用的角色。对于每一种函数、授予者和被授予者的组合，这里都有一行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>routine_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>routine_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (might be duplicated in case of overloading)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能重复）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>EXECUTE</literal> (the only privilege type for functions)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>EXECUTE</literal>（函数唯一的特权类型）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-routines">
<!--==========================orignal english content==========================
  <title><literal>routines</literal></title>
____________________________________________________________________________-->
  <title><literal>routines</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>routines</literal> contains all functions and procedures in the
   current database.  Only those functions and procedures are shown that the current
   user has access to (by way of being the owner or having some
   privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>routines</literal>包含当前数据库中所有的函数和过程。只有那些当前用户能够访问（作为拥有者或具有某些特权）的函数和过程才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>routines</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>routines</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       The <quote>specific name</quote> of the function.  This is a
       name that uniquely identifies the function in the schema, even
       if the real name of the function is overloaded.  The format of
       the specific name is not defined, it should only be used to
       compare it to other instances of specific routine names.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的<quote>专用名</quote>。这是一个在模式中唯一标识该函数的名称，即使该函数真正的名称已经被重载。专用名的格式尚未被定义，它应当仅被用来与指定例程名称的其他实例进行比较。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the function (might be duplicated in case of overloading)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该函数的名字（在重载的情况下可能重复）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>FUNCTION</literal> for a
       function, <literal>PROCEDURE</literal> for a procedure
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>FUNCTION</literal>表示是一个函数，<literal>PROCEDURE</literal>表示是一个过程
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>module_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>module_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>module_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Return data type of the function, if it is a built-in type, or
       <literal>ARRAY</literal> if it is some array (in that case, see
       the view <literal>element_types</literal>), else
       <literal>USER-DEFINED</literal> (in that case, the type is
       identified in <literal>type_udt_name</literal> and associated
       columns).  Null for a procedure.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该函数的返回数据类型如果是一种内建类型，这里是该数据类型；如果是某种数组（此种情况见视图<literal>element_types</literal>），则为<literal>ARRAY</literal>；否则为<literal>USER-DEFINED</literal>（此种情况中，该类型被标识在<literal>type_udt_name</literal>和相关列中）。如果是过程则此项为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, since this information is not applied to return data types in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是为空，因为这种信息不适用于<productname>PostgreSQL</productname>中的返回数据类型</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that the return data type of the function
       is defined in (always the current database).  Null for a procedure.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该函数的返回数据类型所在的数据库名（总是当前数据库）。如果是过程则此项为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that the return data type of the function is
       defined in.  Null for a procedure.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的返回数据类型所在的模式名。如果是过程则此项为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the return data type of the function.  Null for a procedure.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       该函数的返回数据类型的名字。如果是过程则此项为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Always null, because arrays always have unlimited maximum cardinality in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>总是空，因为数组在<productname>PostgreSQL</productname>中总是有无限制的最大势</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       An identifier of the data type descriptor of the return data
       type of this function, unique among the data type descriptors
       pertaining to the function.  This is mainly useful for joining
       with other instances of such identifiers.  (The specific format
       of the identifier is not defined and not guaranteed to remain
       the same in future versions.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
      该函数返回数据类型的数据类型描述符的一个标识符，在从属于该函数的数据类型标识符之中唯一。这主要用于与这类标识符的其他实例进行连接（该标识符的指定格式没有被定义并且不保证在未来的版本中保持相同）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function is an SQL function, then
       <literal>SQL</literal>, else <literal>EXTERNAL</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_body</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该函数是一个 SQL 函数，则为<literal>SQL</literal>，否则为<literal>EXTERNAL</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The source text of the function (null if the function is not
       owned by a currently enabled role).  (According to the SQL
       standard, this column is only applicable if
       <literal>routine_body</literal> is <literal>SQL</literal>, but
       in <productname>PostgreSQL</productname> it will contain
       whatever source text was specified when the function was
       created.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>routine_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该函数的源文本（如果该函数不属于一个当前已被启用的角色，则为空）。（根据 SQL 标准，只有<literal>routine_body</literal>为<literal>SQL</literal>时这一列才适用。但是在<productname>PostgreSQL</productname>中，它将会包含该函数被创建时所指定的任何源文本。）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If this function is a C function, then the external name (link
       symbol) of the function; else null.  (This works out to be the
       same value that is shown in
       <literal>routine_definition</literal>.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>external_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果这个函数是一个 C 函数，则为该函数的外部名称（链接符号），否则为空（这会产生和显示在<literal>routine_definition</literal>中相同的值）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The language the function is written in</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>external_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该函数所用的语言</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>GENERAL</literal> (The SQL standard defines
       other parameter styles, which are not available in <productname>PostgreSQL</productname>.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>parameter_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是<literal>GENERAL</literal>（SQL 标准定义了其他参数风格，但在<productname>PostgreSQL</productname>中不可用）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       If the function is declared immutable (called deterministic in
       the SQL standard), then <literal>YES</literal>, else
       <literal>NO</literal>.  (You cannot query the other volatility
       levels available in <productname>PostgreSQL</productname> through the information schema.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_deterministic</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该函数被声明为不变（在 SQL 标准中被称为确定性的），则为<literal>YES</literal>，否则为<literal>NO</literal>（你不能通过该信息模式查询在<productname>PostgreSQL</productname>中可用的其他易变级别）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always <literal>MODIFIES</literal>, meaning that the function
       possibly modifies SQL data.  This information is not useful for
       <productname>PostgreSQL</productname>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_data_access</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是<literal>MODIFIES</literal>，表示该函数可能修改 SQL 数据。这种信息对<productname>PostgreSQL</productname>没有用处。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       If the function automatically returns null if any of its
       arguments are null, then <literal>YES</literal>, else
       <literal>NO</literal>.  Null for a procedure.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_null_call</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该函数在任一参数为空时自动返回空值，则为<literal>YES</literal>，否则为<literal>NO</literal>。如果是过程则此项为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Always <literal>YES</literal> (The opposite would be a method
       of a user-defined type, which is a feature not available in
       <productname>PostgreSQL</productname>.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>schema_level_routine</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       总是<literal>YES</literal>（反例是一个用户定义类型的方法，这是在<productname>PostgreSQL</productname>不可用的一种特性）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>max_dynamic_result_sets</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_user_defined_cast</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_implicitly_invocable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       If the function runs with the privileges of the current user,
       then <literal>INVOKER</literal>, if the function runs with the
       privileges of the user who defined it, then
       <literal>DEFINER</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>security_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果该函数以当前用户的特权运行，则为<literal>INVOKER</literal>；如果该函数以定义它的用户的特权运行，则为<literal>DEFINER</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>to_sql_specific_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>to_sql_specific_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>to_sql_specific_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>last_altered</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>new_savepoint_level</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       Currently always <literal>NO</literal>.  The alternative
       <literal>YES</literal> applies to a feature not available in
       <productname>PostgreSQL</productname>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_udt_dependent</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       当前总是<literal>NO</literal>。另一个选项<literal>YES</literal>应用于一个<productname>PostgreSQL</productname>中不可用的特性。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_from_data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_as_locator</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_char_max_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_char_octet_length</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_char_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_char_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_char_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_datetime_precision</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_type_udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_type_udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_type_udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_scope_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_scope_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_scope_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_maximum_cardinality</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>result_cast_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-schemata">
<!--==========================orignal english content==========================
  <title><literal>schemata</literal></title>
____________________________________________________________________________-->
  <title><literal>schemata</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>schemata</literal> contains all schemas in the current
   database that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>schemata</literal>包含当前数据库中被当前用户（作为属主或具有某些特权）可访问的所有模式。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>schemata</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>schemata</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the schema is contained in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>catalog_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>schema_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the owner of the schema</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>schema_owner</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该模式拥有者的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>default_character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_path</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sequences">
<!--==========================orignal english content==========================
  <title><literal>sequences</literal></title>
____________________________________________________________________________-->
  <title><literal>sequences</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>sequences</literal> contains all sequences
   defined in the current database.  Only those sequences are shown
   that the current user has access to (by way of being the owner or
   having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>sequences</literal>包含所有定义在当前数据库中的序列。只有那些当前用户能够访问（作为拥有者或具有某些特权）的序列才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sequences</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sequences</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the sequence (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sequence_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该序列的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sequence_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该序列的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sequence_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该序列的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The data type of the sequence.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该序列的数据类型。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       This column contains the (declared or implicit) precision of
       the sequence data type (see above).  The precision indicates
       the number of significant digits.  It can be expressed in
       decimal (base 10) or binary (base 2) terms, as specified in the
       column <literal>numeric_precision_radix</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       这列包含这个序列数据类型（见上文）的（声明的或隐式的）精度。精度指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       This column indicates in which base the values in the columns
       <literal>numeric_precision</literal> and
       <literal>numeric_scale</literal> are expressed.  The value is
       either 2 or 10.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      这一列指示<literal>numeric_precision</literal>和<literal>numeric_scale</literal>列中的值是基于什么来表示。该值为 2 或 10。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       This column contains the (declared or implicit) scale of the
       sequence data type (see above).  The scale indicates the number
       of significant digits to the right of the decimal point.  It
       can be expressed in decimal (base 10) or binary (base 2) terms,
       as specified in the column
       <literal>numeric_precision_radix</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
      这列包含这个序列数据类型（见上文）的（声明的或隐式的）比例。比例指示了有效位数。它可以按照列<literal>numeric_precision_radix</literal>中指定的被表示为十进制（基于 10）或二进制（基于 2）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>start_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The start value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>start_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的开始值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The minimum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>minimum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的最小值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The maximum value of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>maximum_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的最大值</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>The increment of the sequence</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>increment</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该序列的增量</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the sequence cycles, else <literal>NO</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>cycle_option</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该序列会循环，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Note that in accordance with the SQL standard, the start, minimum,
   maximum, and increment values are returned as character strings.
  </para>
____________________________________________________________________________-->
  <para>
   注意依照 SQL 标准，开始值、最小值、最大值和增量值被作为字符串返回。
  </para>
 </sect1>

 <sect1 id="infoschema-sql-features">
<!--==========================orignal english content==========================
  <title><literal>sql_features</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_features</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_features</literal> contains information
   about which formal features defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  This is the
   same information that is presented in <xref linkend="features"/>.
   There you can also find some additional background information.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_features</literal>包含的信息指示了哪些 SQL 标准中定义的正式特性被<productname>PostgreSQL</productname>所支持。这和<xref linkend="features"/>中的信息一样。这里你也能找到一些额外的背景信息。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_features</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_features</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the feature</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该特性的标识符字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the feature</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该特性的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the subfeature, or a zero-length string if not a subfeature</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sub_feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该子特性的标识符字符串，或者如果不是一个子特性则为一个长度为零的字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the subfeature, or a zero-length string if not a subfeature</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sub_feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该子特性的描述性名称，或者如果不是一个子特性则为一个长度为零的字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the feature is fully supported by the
       current version of <productname>PostgreSQL</productname>, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该特性被当前版本的<productname>PostgreSQL</productname>完全支持，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always null, since the <productname>PostgreSQL</productname> development group does not
       perform formal testing of feature conformance
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</productname>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment about the supported status of the feature</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该特性被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-implementation-info">
<!--==========================orignal english content==========================
  <title><literal>sql_implementation_info</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_implementation_info</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_implementation_info</literal> contains
   information about various aspects that are left
   implementation-defined by the SQL standard.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual implementation
   information items are not described here; you will find them in the
   description of the ODBC interface.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_implementation_info</literal>包含的信息指示剩下的由 SQL 标准实现定义的多个方面。这类信息主要用来在 ODBC 接口的情境中使用；其它接口的用户可能将发现这类信息用处不大。由于这个原因，个体实现信息项没有在这里描述，你将会在 ODBC 接口的描述中找到它们。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_implementation_info</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_implementation_info</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the implementation information item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>implementation_info_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该实现信息项的标识符字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the implementation information item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>implementation_info_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该实现信息项的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>character_value</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>integer_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       该实现信息项的值，如果该值被包含在<literal>character_value</literal>列中则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Value of the implementation information item, or null if the
       value is contained in the column
       <literal>integer_value</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
      该实现信息项的值，如果该值被包含在<literal>integer_value</literal>列中则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the implementation information item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于该实现信息项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-languages">
<!--==========================orignal english content==========================
  <title><literal>sql_languages</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_languages</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_languages</literal> contains one row for
   each SQL language binding that is supported by
   <productname>PostgreSQL</productname>.
   <productname>PostgreSQL</productname> supports direct SQL and
   embedded SQL in C; that is all you will learn from this table.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_languages</literal>为每一种被<productname>PostgreSQL</productname>支持的 SQL 语言绑定包含一行。<productname>PostgreSQL</productname>支持在 C 中的直接 SQL 和嵌入式 SQL，这是你从这张表中知道的所有东西。
  </para>

<!--==========================orignal english content==========================
  <para>
   This table was removed from the SQL standard in SQL:2008, so there
   are no entries referring to standards later than SQL:2003.
  </para>
____________________________________________________________________________-->
  <para>
   这个表在 SQL:2008 中已被从 SQL 标准中移除，因此这里没有项引用 SQL:2003 之后的标准。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_languages</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_languages</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The name of the source of the language definition; always
       <literal>ISO 9075</literal>, that is, the SQL standard
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_source</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该语言定义的源名称，总是<literal>ISO 9075</literal>，即 SQL 标准
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The year the standard referenced in
       <literal>sql_language_source</literal> was approved.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_year</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>sql_language_source</literal>中引用的标准被通过的年份。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The standard conformance level for the language binding.  For
       ISO 9075:2003 this is always <literal>CORE</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_conformance</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该语言绑定的标准一致性级别。对于 ISO 9075:2003 总是<literal>CORE</literal>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null (This value is relevant to an earlier version of the SQL standard.)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_integrity</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空（这个值与一个早期版本的 SQL 标准相关）。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always null</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_implementation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The language binding style, either <literal>DIRECT</literal> or
       <literal>EMBEDDED</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_binding_style</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       语言绑定风格，为<literal>DIRECT</literal>或<literal>EMBEDDED</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       The programming language, if the binding style is
       <literal>EMBEDDED</literal>, else null.  <productname>PostgreSQL</productname> only
       supports the language C.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sql_language_programming_language</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       如果绑定风格为<literal>EMBEDDED</literal>，则为编程语言，否则为空。<productname>PostgreSQL</productname>仅支持 C 语言。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-packages">
<!--==========================orignal english content==========================
  <title><literal>sql_packages</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_packages</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_packages</literal> contains information
   about which feature packages defined in the SQL standard are
   supported by <productname>PostgreSQL</productname>.  Refer to <xref
   linkend="features"/> for background information on feature packages.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_packages</literal>包含的信息指示哪些定义在 SQL 标准中的特性包被<productname>PostgreSQL</productname>支持。特性包上的背景信息可参考<xref linkend="features"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_packages</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_packages</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of the package</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该包的标识符字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the package</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该包的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the package is fully supported by the
       current version of <productname>PostgreSQL</productname>, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该包被当前版本的<productname>PostgreSQL</productname>支持，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always null, since the <productname>PostgreSQL</productname> development group does not
       perform formal testing of feature conformance
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</productname>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment about the supported status of the package</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该包被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-parts">
<!--==========================orignal english content==========================
  <title><literal>sql_parts</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_parts</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_parts</literal> contains information about
   which of the several parts of the SQL standard are supported by
   <productname>PostgreSQL</productname>.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_parts</literal>包含的信息指示哪些定义在 SQL 标准中的部分被<productname>PostgreSQL</productname>支持。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_parts</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_parts</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>An identifier string containing the number of the part</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>包含该部分编号的一个标识符字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the part</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>feature_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该部分的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the part is fully supported by the
       current version of <productname>PostgreSQL</productname>,
       <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_supported</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果当前版本的<productname>PostgreSQL</productname>完全支持该部分，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Always null, since the <productname>PostgreSQL</productname> development group does not
       perform formal testing of feature conformance
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_verified_by</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       总是为空，因为<productname>PostgreSQL</productname>开发组没有对特性的一致性执行正式的测试
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment about the supported status of the part</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能会是关于该部分被支持状态的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing">
<!--==========================orignal english content==========================
  <title><literal>sql_sizing</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_sizing</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_sizing</literal> contains information about
   various size limits and maximum values in
   <productname>PostgreSQL</productname>.  This information is
   primarily intended for use in the context of the ODBC interface;
   users of other interfaces will probably find this information to be
   of little use.  For this reason, the individual sizing items are
   not described here; you will find them in the description of the
   ODBC interface.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_sizing</literal>包含有关<productname>PostgreSQL</productname>中多种尺寸限制和最大值的信息。这类信息主要用来在 ODBC 接口的情境中使用；其它接口的用户可能将发现这类信息用处不大。由于这个原因，个体实现信息项没有在这里描述，你将会在 ODBC 接口的描述中找到它们。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_sizing</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_sizing</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifier of the sizing item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该尺寸项的标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the sizing item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该尺寸项的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Value of the sizing item, or 0 if the size is unlimited or
       cannot be determined, or null if the features for which the
       sizing item is applicable are not supported
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>supported_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       尺寸项的值，如果尺寸是不受限制或不能确定的则为 0，如果尺寸项适用的特性不受支持则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the sizing item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于尺寸项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-sql-sizing-profiles">
<!--==========================orignal english content==========================
  <title><literal>sql_sizing_profiles</literal></title>
____________________________________________________________________________-->
  <title><literal>sql_sizing_profiles</literal></title>

<!--==========================orignal english content==========================
  <para>
   The table <literal>sql_sizing_profiles</literal> contains
   information about the <literal>sql_sizing</literal> values that are
   required by various profiles of the SQL standard.  <productname>PostgreSQL</productname> does
   not track any SQL profiles, so this table is empty.
  </para>
____________________________________________________________________________-->
  <para>
   表<literal>sql_sizing_profiles</literal>包含有关 SQL 标准的多种 profile 所需的<literal>sql_sizing</literal>值的信息。<productname>PostgreSQL</productname>不追踪任何 SQL profile，因此这个表为空。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>sql_sizing_profiles</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>sql_sizing_profiles</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Identifier of the sizing item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sizing_id</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>该尺寸项的标识符</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Descriptive name of the sizing item</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>sizing_name</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>该尺寸项的描述性名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Identifier string of a profile</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>profile_id</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>一个 profile 的标识符字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       The value required by the SQL profile for the sizing item, or 0
       if the profile places no limit on the sizing item, or null if
       the profile does not require any of the features for which the
       sizing item is applicable
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>required_value</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       该 SQL profile 对尺寸项所要求的值，如果该 profile 对尺寸项没有限制则为 0，如果该 profile 不要求该尺寸项所适用的任何特性则为空
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Possibly a comment pertaining to the sizing item within the profile</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>comments</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>可能是从属于该 profile 中尺寸项的一段注释</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-constraints">
<!--==========================orignal english content==========================
  <title><literal>table_constraints</literal></title>
____________________________________________________________________________-->
  <title><literal>table_constraints</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>table_constraints</literal> contains all
   constraints belonging to tables that the current user owns or has
   some privilege other than <literal>SELECT</literal> on.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>table_constraints</literal>包含属于特定表的所有约束，这些表要满足的条件是：当前用户拥有表或者是当前用户在表上具有某种除<literal>SELECT</literal>之外的特权。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>table_constraints</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>table_constraints</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the constraint (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该约束的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the constraint</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>约束名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the constraint: <literal>CHECK</literal>,
       <literal>FOREIGN KEY</literal>, <literal>PRIMARY KEY</literal>,
       or <literal>UNIQUE</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>constraint_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该约束的类型：<literal>CHECK</literal>、
       <literal>FOREIGN KEY</literal>、<literal>PRIMARY KEY</literal>或<literal>UNIQUE</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_deferrable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the constraint is deferrable and initially deferred, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>initially_deferred</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该约束是可延迟的并且是初始已被延迟，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>enforced</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in
      <productname>PostgreSQL</productname> (currently always
      <literal>YES</literal>)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>enforced</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>适用于一种<productname>PostgreSQL</productname>中不可用的特性（当前总是<literal>YES</literal>）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-table-privileges">
<!--==========================orignal english content==========================
  <title><literal>table_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>table_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>table_privileges</literal> identifies all
   privileges granted on tables or views to a currently enabled role
   or by a currently enabled role.  There is one row for each
   combination of table, grantor, and grantee.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>table_privileges</literal>标识在表或视图上所有被授予的特权，这些特权必须是被一个当前已被启用角色授出或者被授予给一个当前已被启用角色。对每一个表、授予者和被授予者的组合都有一行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>table_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>table_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the privilege: <literal>SELECT</literal>,
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>,
       <literal>REFERENCES</literal>, or <literal>TRIGGER</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       特权类型：<literal>SELECT</literal>、
       <literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>、
       <literal>REFERENCES</literal>或<literal>TRIGGER</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       In the SQL standard, <literal>WITH HIERARCHY OPTION</literal>
       is a separate (sub-)privilege allowing certain operations on
       table inheritance hierarchies.  In PostgreSQL, this is included
       in the <literal>SELECT</literal> privilege, so this column
       shows <literal>YES</literal> if the privilege
       is <literal>SELECT</literal>, else <literal>NO</literal>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>with_hierarchy</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       在 SQL 标准中，<literal>WITH HIERARCHY OPTION</literal>是一个独立的（子）特权，它允许在表继承层级上的特定操作。在 PostgreSQL 中，这被包括在<literal>SELECT</literal>特权中，因此这一列在特权为<literal>SELECT</literal>时显示<literal>YES</literal>，其他时候显示<literal>NO</literal>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-tables">
<!--==========================orignal english content==========================
  <title><literal>tables</literal></title>
____________________________________________________________________________-->
  <title><literal>tables</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>tables</literal> contains all tables and views
   defined in the current database.  Only those tables and views are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>tables</literal>包含定义在当前数据库中的所有表和视图。只有那些当前用户能够访问（作为拥有者或具有某些特权）的表和视图才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>tables</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>tables</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the table (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>表名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Type of the table: <literal>BASE TABLE</literal> for a
       persistent base table (the normal table type),
       <literal>VIEW</literal> for a view, <literal>FOREIGN</literal>
       for a foreign table, or
       <literal>LOCAL TEMPORARY</literal> for a temporary table
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该表的类型：<literal>BASE TABLE</literal>表示一个持久的基本表（常见表类型），<literal>VIEW</literal>表示一个视图，<literal>FOREIGN</literal>表示一个外部表，<literal>LOCAL TEMPORARY</literal>表示一个临时表
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>self_referencing_column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>reference_generation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the table is a typed table, the name of the database that
       contains the underlying data type (always the current
       database), else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是包含其底层数据类型的数据库名（总是当前数据库），否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the table is a typed table, the name of the schema that
       contains the underlying data type, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是包含其底层数据类型的模式名，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       If the table is a typed table, the name of the underlying data
       type, else null.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       如果该表是一个有类型的表，则是其底层数据类型的名称，否则为空。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the table is insertable into,
       <literal>NO</literal> if not (Base tables are always insertable
       into, views not necessarily.)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该表能够被插入，则为<literal>YES</literal>，否则为<literal>NO</literal>（基本表总是能被插入，而视图则不一定）。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the table is a typed table, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_typed</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该表是一个有类型的表，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Not yet implemented</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>commit_action</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>还未被实现</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>
 
 <sect1 id="infoschema-transforms">
<!--==========================orignal english content==========================
  <title><literal>transforms</literal></title>
____________________________________________________________________________-->
  <title><literal>transforms</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>transforms</literal> contains information about the
   transforms defined in the current database.  More precisely, it contains a
   row for each function contained in a transform (the <quote>from SQL</quote>
   or <quote>to SQL</quote> function).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>transforms</literal>包含定义在当前数据库中的转换的信息。更准确
   来说， 包含在转换中的每一个函数（<quote>FROM SQL</quote>或者
   <quote>TO SQL</quote>函数）在其中都有一行。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>transforms</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>transforms</literal> 列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the type the transform is for (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该转换所适用类型的数据库的名称（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the type the transform is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该转换所适用类型的模式的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the type the transform is for</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该转换所适用类型的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的数据库的名称（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的模式的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       该函数的<quote>专用名</quote>。更多信息请见<xref
       linkend="infoschema-routines"/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>group_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       The SQL standard allows defining transforms in <quote>groups</quote>,
       and selecting a group at run time.  PostgreSQL does not support this.
       Instead, transforms are specific to a language.  As a compromise, this
       field contains the language the transform is for.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>group_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       SQL 标准允许在<quote>组</quote>中定义转换，并且在运行时选择一个
       组。PostgreSQL 不支持这种做法，转换是与一种语言相关的。作为一种折衷，
       这个域包含该转换所适用的语言。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>transform_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>FROM SQL</literal> or <literal>TO SQL</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>transform_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>FROM SQL</literal>或者<literal>TO SQL</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggered-update-columns">
<!--==========================orignal english content==========================
  <title><literal>triggered_update_columns</literal></title>
____________________________________________________________________________-->
  <title><literal>triggered_update_columns</literal></title>

<!--==========================orignal english content==========================
  <para>
   For triggers in the current database that specify a column list
   (like <literal>UPDATE OF column1, column2</literal>), the
   view <literal>triggered_update_columns</literal> identifies these
   columns.  Triggers that do not specify a column list are not
   included in this view.  Only those columns are shown that the
   current user owns or has some privilege other than
   <literal>SELECT</literal> on.
  </para>
____________________________________________________________________________-->
  <para>
   对于当前数据库中指定一个列列表（如<literal>UPDATE OF column1, column2</literal>）的触发器，视图<literal>triggered_update_columns</literal>标识这些列。没有指定一个列列表的触发器不被包括在这个视图中。只有那些当前用户拥有或具有某种除<literal>SELECT</literal>之外特权的列才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>triggered_update_columns</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>triggered_update_columns</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the trigger (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the trigger</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the trigger</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that the trigger
       is defined on (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含触发器所在的表的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that the trigger is defined on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含触发器所在的表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that the trigger is defined on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>触发器所在的表的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_column</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column that the trigger is defined on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_column</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>触发器所在的列的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-triggers">
<!--==========================orignal english content==========================
  <title><literal>triggers</literal></title>
____________________________________________________________________________-->
  <title><literal>triggers</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>triggers</literal> contains all triggers defined
   in the current database on tables and views that the current user owns
   or has some privilege other than <literal>SELECT</literal> on.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>triggers</literal>包含所有定义在当前数据库中表和视图上的触发器，并且只显示当前用户拥有的触发器或者是当前用户在其上具有某种除<literal>SELECT</literal>之外特权的触发器。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>triggers</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>triggers</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the trigger (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the trigger</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the trigger</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>trigger_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Event that fires the trigger (<literal>INSERT</literal>,
       <literal>UPDATE</literal>, or <literal>DELETE</literal>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_manipulation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发该触发器的事件（<literal>INSERT</literal>、
       <literal>UPDATE</literal>或<literal>DELETE</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that the trigger
       is defined on (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含触发器所在的表的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the table that the trigger is defined on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该触发器所在的表的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the table that the trigger is defined on</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>event_object_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该触发器所在的表的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       Firing order among triggers on the same table having the same
       <literal>event_manipulation</literal>,
       <literal>action_timing</literal>, and
       <literal>action_orientation</literal>.  In
       <productname>PostgreSQL</productname>, triggers are fired in name
       order, so this column reflects that.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_order</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>
       同一个表上具有相同<literal>event_manipulation</literal>、<literal>action_timing</literal>和<literal>action_orientation</literal>的触发器之间的触发顺序。在<productname>PostgreSQL</productname>中，触发器按照名称顺序被触发，因此这一列会反映这种规则。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       <literal>WHEN</literal> condition of the trigger, null if none
       (also null if the table is not owned by a currently enabled
       role)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_condition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发器的<literal>WHEN</literal>条件，如果没有则为空（如果该表不被一个当前已启用角色拥有也是为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Statement that is executed by the trigger (currently always
       <literal>EXECUTE FUNCTION
       <replaceable>function</replaceable>(...)</literal>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_statement</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       该触发器执行的语句（当前总是
       <literal>EXECUTE FUNCTION
       <replaceable>function</replaceable>(...)</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Identifies whether the trigger fires once for each processed
       row or once for each statement (<literal>ROW</literal> or
       <literal>STATEMENT</literal>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_orientation</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       标识触发器是对每个被处理的行触发一次还是为每个语句触发一次（<literal>ROW</literal>或<literal>STATEMENT</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Time at which the trigger fires (<literal>BEFORE</literal>,
       <literal>AFTER</literal>, or <literal>INSTEAD OF</literal>)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_timing</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       触发器在什么时候触发（<literal>BEFORE</literal>、
       <literal>AFTER</literal>或<literal>INSTEAD OF</literal>）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the <quote>old</quote> transition table, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_reference_old_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry><quote>旧</quote>传递表的名称，如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the <quote>new</quote> transition table, or null if none</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_reference_new_table</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry><quote>新</quote>传递表的名称，如果没有则为空</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_reference_old_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>action_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>action_reference_new_row</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>created</literal></entry>
      <entry><type>time_stamp</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Triggers in <productname>PostgreSQL</productname> have two
   incompatibilities with the SQL standard that affect the
   representation in the information schema.  First, trigger names are
   local to each table in <productname>PostgreSQL</productname>, rather
   than being independent schema objects.  Therefore there can be duplicate
   trigger names defined in one schema, so long as they belong to
   different tables.  (<literal>trigger_catalog</literal> and
   <literal>trigger_schema</literal> are really the values pertaining
   to the table that the trigger is defined on.)  Second, triggers can
   be defined to fire on multiple events in
   <productname>PostgreSQL</productname> (e.g., <literal>ON INSERT OR
   UPDATE</literal>), whereas the SQL standard only allows one.  If a
   trigger is defined to fire on multiple events, it is represented as
   multiple rows in the information schema, one for each type of
   event.  As a consequence of these two issues, the primary key of
   the view <literal>triggers</literal> is really
   <literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal> instead of
   <literal>(trigger_catalog, trigger_schema, trigger_name)</literal>,
   which is what the SQL standard specifies.  Nonetheless, if you
   define your triggers in a manner that conforms with the SQL
   standard (trigger names unique in the schema and only one event
   type per trigger), this will not affect you.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的触发器有两点与 SQL 标准不兼容，这会影响在该信息模式中的表示。第一，在<productname>PostgreSQL</productname>中触发器的名字是局限于每个表的，而不是独立于模式对象。因此可能在一个模式中会有重复的触发器名称，只要它们属于不同的表（<literal>trigger_catalog</literal>和<literal>trigger_schema</literal>才真正标识了触发器被定义在哪个表上）。第二，在<productname>PostgreSQL</productname>中触发器可以被定义为在多个事件上触发（例如<literal>ON INSERT OR
   UPDATE</literal>），而在 SQL 标准中只允许一个。如果一个触发器被定义为在多个事件上触发，它在信息模式中被表示为多行，每一行对应于一类事件。作为这两个问题的结果，视图<literal>triggers</literal>的主键实际上是<literal>(trigger_catalog, trigger_schema, event_object_table,
   trigger_name, event_manipulation)</literal>，而不是<literal>(trigger_catalog, trigger_schema, trigger_name)</literal>（这是 SQL 标准指定的）。尽管如此，如果你以符合 SQL 标准（在模式中触发器名称唯一并且每个触发器只能有一种事件类型）的方式定义你的触发器，这将不会影响你。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Prior to <productname>PostgreSQL</productname> 9.1, this view's columns
    <structfield>action_timing</structfield>,
    <structfield>action_reference_old_table</structfield>,
    <structfield>action_reference_new_table</structfield>,
    <structfield>action_reference_old_row</structfield>, and
    <structfield>action_reference_new_row</structfield>
    were named
    <structfield>condition_timing</structfield>,
    <structfield>condition_reference_old_table</structfield>,
    <structfield>condition_reference_new_table</structfield>,
    <structfield>condition_reference_old_row</structfield>, and
    <structfield>condition_reference_new_row</structfield>
    respectively.
    That was how they were named in the SQL:1999 standard.
    The new naming conforms to SQL:2003 and later.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 9.1 之前，这个视图的列
    <structfield>action_timing</structfield>、
    <structfield>action_reference_old_table</structfield>、
    <structfield>action_reference_new_table</structfield>、
    <structfield>action_reference_old_row</structfield>和
    <structfield>action_reference_new_row</structfield>
    分别被命名为
    <structfield>condition_timing</structfield>、
    <structfield>condition_reference_old_table</structfield>、
    <structfield>condition_reference_new_table</structfield>、
    <structfield>condition_reference_old_row</structfield>和
    <structfield>condition_reference_new_row</structfield>。
    那也是它们在 SQL:1999 标准中的命名。新的命名遵循 SQL:2003 及其后的版本。
   </para>
  </note>
 </sect1>

 <sect1 id="infoschema-udt-privileges">
<!--==========================orignal english content==========================
  <title><literal>udt_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>udt_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>udt_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on user-defined types to a
   currently enabled role or by a currently enabled role.  There is one row for
   each combination of type, grantor, and grantee.  This view shows only
   composite types (see under <xref linkend="infoschema-user-defined-types"/>
   for why); see
   <xref linkend="infoschema-usage-privileges"/> for domain privileges.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>udt_privileges</literal>标识所有在用户定义类型上授予的
  <literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。
  对每一个类型、授予者和被授予者的组合都有一行。这个视图只显示组合类型（原因见下面的
  <xref linkend="infoschema-user-defined-types"/>）。
  域特权见<xref linkend="infoschema-usage-privileges"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>udt_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>udt_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the type (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>udt_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>TYPE USAGE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>TYPE USAGE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-usage-privileges">
<!--==========================orignal english content==========================
  <title><literal>usage_privileges</literal></title>
____________________________________________________________________________-->
  <title><literal>usage_privileges</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>usage_privileges</literal> identifies
   <literal>USAGE</literal> privileges granted on various kinds of
   objects to a currently enabled role or by a currently enabled role.
   In <productname>PostgreSQL</productname>, this currently applies to
   collations, domains, foreign-data wrappers, foreign servers, and sequences.  There is one
   row for each combination of object, grantor, and grantee.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>usage_privileges</literal>标识所有在多种对象上授予的<literal>USAGE</literal>特权，这些特权的授予者或者被授予者是一个当前已被启用的角色。在<productname>PostgreSQL</productname>中，这当前适用于排序规则、域、外部数据包装器、外部服务器和序列。对每一个对象、授予者和被授予者都有一行。
  </para>

<!--==========================orignal english content==========================
  <para>
   Since collations do not have real privileges
   in <productname>PostgreSQL</productname>, this view shows implicit
   non-grantable <literal>USAGE</literal> privileges granted by the
   owner to <literal>PUBLIC</literal> for all collations.  The other
   object types, however, show real privileges.
  </para>
____________________________________________________________________________-->
  <para>
   由于在<productname>PostgreSQL</productname>中排序规则并没有真正的特权，这个视图对所有排序规则显示由拥有者授予给<literal>PUBLIC</literal>的隐式非可授予的<literal>USAGE</literal>特权。但是对其他对象类型则显示真实的特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   In PostgreSQL, sequences also support <literal>SELECT</literal>
   and <literal>UPDATE</literal> privileges in addition to
   the <literal>USAGE</literal> privilege.  These are nonstandard and therefore
   not visible in the information schema.
  </para>
____________________________________________________________________________-->
  <para>
   在 PostgreSQL 中，序列也支持除<literal>USAGE</literal>之外的<literal>SELECT</literal>和<literal>UPDATE</literal>特权。这些是非标准的并且因此在该信息模式中不可见。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>usage_privileges</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>usage_privileges</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that granted the privilege</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantor</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the role that the privilege was granted to</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>grantee</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被授予该特权的角色名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database containing the object (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该对象的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema containing the object, if applicable,
      else an empty string</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>如果适用，则是包含该对象的模式名，否则为一个空字符串</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the object</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该对象的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal> or <literal>DOMAIN</literal> or <literal>FOREIGN DATA WRAPPER</literal> or <literal>FOREIGN SERVER</literal> or <literal>SEQUENCE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry><literal>COLLATION</literal>或<literal>DOMAIN</literal>或<literal>FOREIGN DATA WRAPPER</literal>或<literal>FOREIGN SERVER</literal>或<literal>SEQUENCE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Always <literal>USAGE</literal></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>privilege_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>总是<literal>USAGE</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry><literal>YES</literal> if the privilege is grantable, <literal>NO</literal> if not</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_grantable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>如果该特权是可授予的，则为<literal>YES</literal>，否则为<literal>NO</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-defined-types">
<!--==========================orignal english content==========================
  <title><literal>user_defined_types</literal></title>
____________________________________________________________________________-->
  <title><literal>user_defined_types</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>user_defined_types</literal> currently contains
   all composite types defined in the current database.
   Only those types are shown that the current user has access to (by way
   of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>user_defined_types</literal>目前包含定义在当前数据库中的所有组合类型。只有那些当前用户能够访问（作为拥有者或具有某些特权）的类型才会被显示。
  </para>

<!--==========================orignal english content==========================
  <para>
   SQL knows about two kinds of user-defined types: structured types
   (also known as composite types
   in <productname>PostgreSQL</productname>) and distinct types (not
   implemented in <productname>PostgreSQL</productname>).  To be
   future-proof, use the
   column <literal>user_defined_type_category</literal> to
   differentiate between these.  Other user-defined types such as base
   types and enums, which are <productname>PostgreSQL</productname>
   extensions, are not shown here.  For domains,
   see <xref linkend="infoschema-domains"/> instead.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 知道两种用户定义类型：结构类型（在<productname>PostgreSQL</productname>中也被称为组合类型）以及独特类型（在<productname>PostgreSQL</productname>没有实现）。要经得起未来的考验，请使用列<literal>user_defined_type_category</literal>来区分它们。其他用户定义类型如基类型和枚举（都是<productname>PostgreSQL</productname>的扩展）不会被显示在这里。对于域，请见<xref linkend="infoschema-domains"/>。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>user_defined_types</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>user_defined_types</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the type (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该类型的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the type</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该类型的名字</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>user_defined_type_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Currently always <literal>STRUCTURED</literal>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>user_defined_type_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       当前总是<literal>STRUCTURED</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_instantiable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_instantiable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_final</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_final</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordering_form</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordering_form</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordering_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordering_category</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordering_routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordering_routine_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordering_routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordering_routine_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ordering_routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ordering_routine_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>reference_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>reference_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>data_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_maximum_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_octet_length</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>character_set_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>collation_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_precision_radix</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>numeric_scale</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>datetime_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_type</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>interval_precision</literal></entry>
      <entry><type>cardinal_number</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>source_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>source_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>ref_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ref_dtd_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mapping-options">
<!--==========================orignal english content==========================
  <title><literal>user_mapping_options</literal></title>
____________________________________________________________________________-->
  <title><literal>user_mapping_options</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>user_mapping_options</literal> contains all the
   options defined for user mappings in the current database.  Only
   those user mappings are shown where the current user has access to
   the corresponding foreign server (by way of being the owner or
   having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>user_mapping_options</literal>包含在当前数据库中为用户映射定义的所有选项。只有那些当前用户能够访问其相应外部服务器（作为拥有者或具有某些特权）的用户映射才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>user_mapping_options</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>user_mapping_options</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user being mapped,
      or <literal>PUBLIC</literal> if the mapping is public</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被映射的用户名，如果映射是公共的则为<literal>PUBLIC</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign server used by this
      mapping is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign server used by this mapping</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of an option</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>一个选项名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Value of the option.  This column will show as null
      unless the current user is the user being mapped, or the mapping
      is for <literal>PUBLIC</literal> and the current user is the
      server owner, or the current user is a superuser.  The intent is
      to protect password information stored as user mapping
      option.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>option_value</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>选项的值。除非当前用户是被映射的用户或者映射是<literal>PUBLIC</literal>的并且当前用户是服务器拥有者或者超级用户，这一列将显示为空。这样做的目的是保护作为用户映射选项存储的口令信息。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-user-mappings">
<!--==========================orignal english content==========================
  <title><literal>user_mappings</literal></title>
____________________________________________________________________________-->
  <title><literal>user_mappings</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>user_mappings</literal> contains all user
   mappings defined in the current database.  Only those user mappings
   are shown where the current user has access to the corresponding
   foreign server (by way of being the owner or having some
   privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>user_mappings</literal>包含定义在当前数据库中的所有用户映射。只有当前用户能够访问其对应外部服务器（作为拥有者或具有某些特权）的用户映射才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>user_mappings</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>user_mappings</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the user being mapped,
      or <literal>PUBLIC</literal> if the mapping is public</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>authorization_identifier</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被映射的用户名，如果映射是公共的则为<literal>PUBLIC</literal></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that the foreign server used by this
      mapping is defined in (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器所在的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the foreign server used by this mapping</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>foreign_server_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>这个映射所使用的外部服务器的名称</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-column-usage">
<!--==========================orignal english content==========================
  <title><literal>view_column_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>view_column_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>view_column_usage</literal> identifies all
   columns that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   column is only included if the table that contains the column is
   owned by a currently enabled role.
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>view_column_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有列。只有当包含一列的表被一个当前已被启用角色拥有时，该列才会被包括在这个视图中。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Columns of system tables are not included.  This should be fixed
    sometime.
   </para>
____________________________________________________________________________-->
   <para>
    系统表列不被包括。在某个时候这应该会被修复。
   </para>
  </note>

  <table>
<!--==========================orignal english content==========================
   <title><literal>view_column_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>view_column_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that contains the
       column that is used by the view (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that contains the
       column that is used by the view
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that contains the column that is used by the
       view
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       被视图所使用的列所属表的名称
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the column that is used by the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>column_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>被该视图所使用的列名</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-routine-usage">
<!--==========================orignal english content==========================
  <title><literal>view_routine_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>view_routine_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>view_routine_usage</literal> identifies all
   routines (functions and procedures) that are used in the query
   expression of a view (the <command>SELECT</command> statement that
   defines the view).  A routine is only included if that routine is
   owned by a currently enabled role.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>view_routine_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有例程（函数和过程）。只有被一个当前已被启用角色拥有的例程才会被包括在这个视图中。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>view_routine_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>view_routine_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the view (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该视图的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>该视图的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the database containing the function (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_catalog</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>Name of the schema containing the function</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_schema</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>包含该函数的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       The <quote>specific name</quote> of the function.  See <xref
       linkend="infoschema-routines"/> for more information.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>specific_name</literal></entry>
      <entry><literal>sql_identifier</literal></entry>
      <entry>
       该函数的<quote>专用名</quote>。详见<xref
       linkend="infoschema-routines"/>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-view-table-usage">
<!--==========================orignal english content==========================
  <title><literal>view_table_usage</literal></title>
____________________________________________________________________________-->
  <title><literal>view_table_usage</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>view_table_usage</literal> identifies all tables
   that are used in the query expression of a view (the
   <command>SELECT</command> statement that defines the view).  A
   table is only included if that table is owned by a currently
   enabled role.
  </para>
____________________________________________________________________________-->
  <para>
  视图<literal>view_table_usage</literal>标识被使用在一个视图的查询表达式（定义该视图的<command>SELECT</command>语句）中的所有表。只有被一个当前已被启用角色拥有的表才会被包括在这个视图中。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    System tables are not included.  This should be fixed sometime.
   </para>
____________________________________________________________________________-->
   <para>
    系统表没有被包括。这应当会在某个时候被修复。
   </para>
  </note>

  <table>
<!--==========================orignal english content==========================
   <title><literal>view_table_usage</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>view_table_usage</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the database that contains the table that is
       used by the view (always the current database)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的数据库名（总是当前数据库）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the schema that contains the table that is used by the
       view
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的模式名
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       Name of the table that is used by the view
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>
       包含被该视图所使用的表的名称
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="infoschema-views">
<!--==========================orignal english content==========================
  <title><literal>views</literal></title>
____________________________________________________________________________-->
  <title><literal>views</literal></title>

<!--==========================orignal english content==========================
  <para>
   The view <literal>views</literal> contains all views defined in the
   current database.  Only those views are shown that the current user
   has access to (by way of being the owner or having some privilege).
  </para>
____________________________________________________________________________-->
  <para>
   视图<literal>views</literal>包含定义在当前数据库中的所有视图。只有当前用户能够访问（作为拥有者或具有某些特权）的视图才会被显示。
  </para>

  <table>
<!--==========================orignal english content==========================
   <title><literal>views</literal> Columns</title>
____________________________________________________________________________-->
   <title><literal>views</literal>列</title>

   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Name</entry>
      <entry>Data Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>数据类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the database that contains the view (always the current database)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_catalog</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的数据库名（总是当前数据库）</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the schema that contains the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_schema</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>包含该视图的模式名</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>Name of the view</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>table_name</literal></entry>
      <entry><type>sql_identifier</type></entry>
      <entry>该视图的名称</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>view_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       Query expression defining the view (null if the view is not
       owned by a currently enabled role)
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>view_definition</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>
       定义视图的查询表达式（如果该视图不被一个当前已被启用角色拥有则为空）
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>Applies to a feature not available in <productname>PostgreSQL</productname></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>check_option</literal></entry>
      <entry><type>character_data</type></entry>
      <entry>应用于一个<productname>PostgreSQL</productname>中不可用的特性</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the view is updatable (allows
       <command>UPDATE</command> and <command>DELETE</command>),
       <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该视图是可更新的（允许<command>UPDATE</command>和<command>DELETE</command>），则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the view is insertable into (allows
       <command>INSERT</command>), <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       如果该视图是可插入的（允许<command>INSERT</command>），则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_trigger_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>UPDATE</command> trigger defined on it, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_trigger_updatable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
        如果该视图上有一个<literal>INSTEAD OF</literal>
       <command>UPDATE</command>触发器，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_trigger_deletable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>DELETE</command> trigger defined on it, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_trigger_deletable</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
      如果该视图上有一个<literal>INSTEAD OF</literal>
       <command>DELETE</command>触发器，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><literal>is_trigger_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
       <literal>YES</literal> if the view has an <literal>INSTEAD OF</literal>
       <command>INSERT</command> trigger defined on it, <literal>NO</literal> if not
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>is_trigger_insertable_into</literal></entry>
      <entry><type>yes_or_no</type></entry>
      <entry>
      如果该视图上有一个<literal>INSTEAD OF</literal>
       <command>INSERT</command>触发器，则为<literal>YES</literal>，否则为<literal>NO</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

</chapter>
