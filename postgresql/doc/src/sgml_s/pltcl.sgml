<!-- doc/src/sgml/pltcl.sgml -->

 <chapter id="pltcl">
<!--==========================orignal english content==========================
  <title>PL/Tcl - Tcl Procedural Language</title>
____________________________________________________________________________-->
  <title>PL/Tcl - Tcl 过程语言</title>

<!--==========================orignal english content==========================
  <indexterm zone="pltcl">
   <primary>PL/Tcl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="pltcl">
   <primary>PL/Tcl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="pltcl">
   <primary>Tcl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="pltcl">
   <primary>Tcl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   PL/Tcl is a loadable procedural language for the
   <productname>PostgreSQL</productname> database system
   that enables the <ulink url="http://www.tcl.tk/">
   Tcl language</ulink> to be used to write
   <productname>PostgreSQL</productname> functions.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Tcl 是一种用于<productname>PostgreSQL</productname>数据库系统的可载入过程语言， 它可以让<ulink url="http://www.tcl.tk/">Tcl 语言</ulink>被用来编写<productname>PostgreSQL</productname>函数。
  </para>

  <!-- **** PL/Tcl overview **** -->

  <sect1 id="pltcl-overview">
<!--==========================orignal english content==========================
   <title>Overview</title>
____________________________________________________________________________-->
   <title>概述</title>

<!--==========================orignal english content==========================
   <para>
    PL/Tcl offers most of the capabilities a function writer has in
    the C language, with a few restrictions, and with the addition of
    the powerful string processing libraries that are available for
    Tcl.
   </para>
____________________________________________________________________________-->
   <para>
    PL/Tcl 提供了大部分函数编写者在 C 语言中能够获得的能力，虽然有一些限制，但是却额外提供了 Tcl 中强大的字符串处理库。
   </para>
<!--==========================orignal english content==========================
   <para>
    One compelling <emphasis>good</emphasis> restriction is that
    everything is executed from within the safety of the context of a
    Tcl interpreter.  In addition to the limited command set of safe
    Tcl, only a few commands are available to access the database via
    SPI and to raise messages via <function>elog()</function>.  PL/Tcl
    provides no way to access internals of the database server or to
    gain OS-level access under the permissions of the
    <productname>PostgreSQL</productname> server process, as a C
    function can do.  Thus, unprivileged database users can be trusted
    to use this language; it does not give them unlimited authority.
   </para>
____________________________________________________________________________-->
   <para>
    一种强制性的<emphasis>好</emphasis>限制是所有被执行的东西都处于 Tcl 解释器的安全上下文中。除了安全 Tcl 的有限的命令集合之外，只有几个通过 SPI 访问数据库的命令以及通过<function>elog()</function>产生消息的命令。PL/Tcl 没有提供访问数据库服务器内部或者在<productname>PostgreSQL</productname>服务器进程权限之下得到 OS-级访问的方法，而 C 函数是可以那样做的。因此，非特权数据库用户可以使用这种语言，它不会给予他们无限制的权利。
   </para>
<!--==========================orignal english content==========================
   <para>
    The other notable implementation restriction is that Tcl functions
    cannot be used to create input/output functions for new data
    types.
   </para>
____________________________________________________________________________-->
   <para>
    其他值得注意的实现限制是 Tcl 函数不能被用来创建新数据类型的输入/输出函数。
   </para>
<!--==========================orignal english content==========================
   <para>
    Sometimes it is desirable to write Tcl functions that are not restricted
    to safe Tcl.  For example, one might want a Tcl function that sends
    email.  To handle these cases, there is a variant of <application>PL/Tcl</application> called <literal>PL/TclU</literal>
    (for untrusted Tcl).  This is exactly the same language except that a full
    Tcl interpreter is used.  <emphasis>If <application>PL/TclU</application> is used, it must be
    installed as an untrusted procedural language</emphasis> so that only
    database superusers can create functions in it.  The writer of a <application>PL/TclU</application>
    function must take care that the function cannot be used to do anything
    unwanted, since it will be able to do anything that could be done by
    a user logged in as the database administrator.
   </para>
____________________________________________________________________________-->
   <para>
    有时候我们想要编写不受安全 Tcl 限制的 Tcl 函数。例如，我们可能想要一个能发送电子邮件的 Tcl 函数。要处理这些情况，可以使用一种<application>PL/Tcl</application>的变体，它被称为<literal>PL/TclU</literal>（用于非可信 Tcl）。它其实是完全相同的一种语言，不过它使用了一个完整的 Tcl 解释器。<emphasis>如果使用了<application>PL/TclU</application>，它必须被安装为一种非可信的过程语言</emphasis>，这样只有数据库超级用户可以用它来创建函数。<application>PL/TclU</application>函数的编写者必须注意该函数不能被用来做其设计目的之外的事情，因为该函数能做一个作为数据库管理员登录的用户可以做的任何事情。
   </para>
<!--==========================orignal english content==========================
   <para>
    The shared object code for the <application>PL/Tcl</application> and
    <application>PL/TclU</application> call handlers is automatically built and
    installed in the <productname>PostgreSQL</productname> library
    directory if Tcl support is specified in the configuration step of
    the installation procedure.  To install <application>PL/Tcl</application>
    and/or <application>PL/TclU</application> in a particular database, use the
    <command>CREATE EXTENSION</command> command, for example
    <literal>CREATE EXTENSION pltcl</literal> or
    <literal>CREATE EXTENSION pltclu</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    如果在安装过程的配置步骤中指定了 Tcl 支持，<application>PL/Tcl</application>以及<application>PL/TclU</application>调用处理器的共享对象代码会被自动编译并且被安装在<productname>PostgreSQL</productname>的库目录中。要在一个特定数据库中安装<application>PL/Tcl</application>或者<application>PL/TclU</application>，请使用<command>CREATE EXTENSION</command>命令，例如<literal>CREATE EXTENSION pltcl</literal>或者<literal>CREATE EXTENSION pltclu</literal>。
   </para>
  </sect1>

  <!-- **** PL/Tcl description **** -->

   <sect1 id="pltcl-functions">
<!--==========================orignal english content==========================
    <title>PL/Tcl Functions and Arguments</title>
____________________________________________________________________________-->
    <title>PL/Tcl 函数和参数</title>

<!--==========================orignal english content==========================
    <para>
     To create a function in the <application>PL/Tcl</application> language, use
     the standard <xref linkend="sql-createfunction"/> syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
    # PL/Tcl function body
$$ LANGUAGE pltcl;
</programlisting>

     <application>PL/TclU</application> is the same, except that the language has to be specified as
     <literal>pltclu</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     要用<application>PL/Tcl</application>语言创建函数，可使用标准的<xref linkend="sql-createfunction"/>语法：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
    # PL/Tcl function body
$$ LANGUAGE pltcl;
</programlisting>

     <application>PL/TclU</application>的函数是一样的语法，只是语言被指定为<literal>pltclu</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The body of the function is simply a piece of Tcl script.
     When the function is called, the argument values are passed to the
     Tcl script as variables named <literal>1</literal>
     ... <literal><replaceable>n</replaceable></literal>.  The result is
     returned from the Tcl code in the usual way, with
     a <literal>return</literal> statement.  In a procedure, the return value
     from the Tcl code is ignored.
    </para>
____________________________________________________________________________-->
    <para>
     函数的主体就是一个 Tcl 脚本。当函数被调用时，参数值会被以变量名<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>传递给该Tcl脚本。结果会以常见的方式通过一个<literal>return</literal>语句从 Tcl 脚本中返回。在一个过程中，Tcl代码的返回值会被忽略。
    </para>

<!--==========================orignal english content==========================
    <para>
     For example, a function
     returning the greater of two integer values could be defined as:

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
</programlisting>

     Note the clause <literal>STRICT</literal>, which saves us from
     having to think about null input values: if a null value is passed, the
     function will not be called at all, but will just return a null
     result automatically.
    </para>
____________________________________________________________________________-->
    <para>
     例如，一个返回两个整数值中较大值的函数可以定义为：

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
</programlisting>

     注意子句<literal>STRICT</literal>，它让我们不用去操心空输入值：如果空值被传入，函数根本就不会被调用，而是自动地返回一个空结果。
    </para>

<!--==========================orignal english content==========================
    <para>
     In a nonstrict function,
     if the actual value of an argument is null, the corresponding
     <literal>$<replaceable>n</replaceable></literal> variable will be set to an empty string.
     To detect whether a particular argument is null, use the function
     <literal>argisnull</literal>.  For example, suppose that we wanted <function>tcl_max</function>
     with one null and one nonnull argument to return the nonnull
     argument, rather than null:

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在非严格函数中，如果一个参数的实际值为空，对应的<literal>$<replaceable>n</replaceable></literal>变量将被设置为一个空串。为了检测一个特定参数是否为空，可使用函数<literal>argisnull</literal>。例如，假设我们想要带有一个空参数和一个非空参数并且返回非空参数的<function>tcl_max</function>：

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     As shown above,
     to return a null value from a PL/Tcl function, execute
     <literal>return_null</literal>.  This can be done whether the
     function is strict or not.
    </para>
____________________________________________________________________________-->
    <para>
     如上所述，要从一个 PL/Tcl 函数返回空值，可执行<literal>return_null</literal>。不管函数是严格还是非严格都可以这样做。
    </para>

<!--==========================orignal english content==========================
    <para>
     Composite-type arguments are passed to the function as Tcl
     arrays.  The element names of the array are the attribute names
     of the composite type. If an attribute in the passed row has the
     null value, it will not appear in the array. Here is an example:

<programlisting>
CREATE TABLE employee (
    name text,
    salary integer,
    age integer
);

CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salary)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     组合类型参数会被作为 Tcl 数组传递给函数。该数组的元素名就是组合类型的属性值。如果被传入行的一个属性为空值，它不会出现在数组中。这里是一个例子：

<programlisting>
CREATE TABLE employee (
    name text,
    salary integer,
    age integer
);

CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salary)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     PL/Tcl functions can return composite-type results, too.  To do this,
     the Tcl code must return a list of column name/value pairs matching
     the expected result type.  Any column names omitted from the list
     are returned as nulls, and an error is raised if there are unexpected
     column names.  Here is an example:

<programlisting>
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     PL/Tcl函数也能返回组合类型的结果。要返回组合类型结果，Tcl代码必须返回匹配预期结果类型的“列名/值”对的列表。任何从该列表中省略的列名将被返回为空，如果有预期之外的列名则会报出错误。这里是一个例子：

<programlisting>
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Output arguments of procedures are returned in the same way, for example:

<programlisting>
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;

CALL tcl_triple(5, 10);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     过程的输出参数以相同的方式返回，例如：

<programlisting>
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;

CALL tcl_triple(5, 10);
</programlisting>
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      The result list can be made from an array representation of the
      desired tuple with the <literal>array get</literal> Tcl command.  For example:

<programlisting>
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
    set 1(salary) [expr {$1(salary) + $2}]
    return [array get 1]
$$ LANGUAGE pltcl;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      结果列表可以用Tcl的<literal>array get</literal>命令从想得到的元组的数组表示中造出。例如：

<programlisting>
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
    set 1(salary) [expr {$1(salary) + $2}]
    return [array get 1]
$$ LANGUAGE pltcl;
</programlisting>
     </para>
    </tip>

<!--==========================orignal english content==========================
    <para>
     PL/Tcl functions can return sets.  To do this, the Tcl code should
     call <function>return_next</function> once per row to be returned,
     passing either the appropriate value when returning a scalar type,
     or a list of column name/value pairs when returning a composite type.
     Here is an example returning a scalar type:

<programlisting>
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next $i
    }
$$ LANGUAGE pltcl;
</programlisting>

     and here is one returning a composite type:

<programlisting>
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next [list x $i x2 [expr {$i * $i}]]
    }
$$ LANGUAGE pltcl;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     PL/Tcl函数能够返回集合。要返回集合，Tcl代码应该对每一个要返回的行调用一次<function>return_next</function>，在返回标量类型时传入合适的值或者在返回组合类型时传入“列名/值”堆的列表。这里是一个返回标量类型的例子：

<programlisting>
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next $i
    }
$$ LANGUAGE pltcl;
</programlisting>

     这里是一个返回组合类型的例子：

<programlisting>
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next [list x $i x2 [expr {$i * $i}]]
    }
$$ LANGUAGE pltcl;
</programlisting>
    </para>

   </sect1>

   <sect1 id="pltcl-data">
<!--==========================orignal english content==========================
    <title>Data Values in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl 中的数据值</title>

<!--==========================orignal english content==========================
    <para>
     The argument values supplied to a PL/Tcl function's code are simply
     the input arguments converted to text form (just as if they had been
     displayed by a <command>SELECT</command> statement).  Conversely, the
     <literal>return</literal> and <literal>return_next</literal> commands will accept
     any string that is acceptable input format for the function's declared
     result type, or for the specified column of a composite result type.
    </para>
____________________________________________________________________________-->
    <para>
     提供给 PL/Tcl 函数代码的参数值是输入参数简单转换而成的文本形式（就像被<command>SELECT</command>语句显示的那样）。反过来，<literal>return</literal>和<literal>return_next</literal>命令将接受任何字符串，只要它是该函数声明的返回类型的可接受的输入格式，或者是组合结果类型的指定列的可接受输入格式。
    </para>

   </sect1>

   <sect1 id="pltcl-global">
<!--==========================orignal english content==========================
    <title>Global Data in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl 中的全局数据</title>

<!--==========================orignal english content==========================
    <indexterm zone="pltcl-global">
     <primary>global data</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="pltcl-global">
     <primary>global data</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Sometimes it
     is useful to have some global data that is held between two
     calls to a function or is shared between different functions.
     This is easily done in PL/Tcl, but there are some restrictions that
     must be understood.
    </para>
____________________________________________________________________________-->
    <para>
     有时候需要在同一个函数的两次调用间保持某些全局数据或者在不同的函数之间共享全局数据。在 PL/Tcl 中这很容易做到，但是必须了解一些限制。
    </para>

<!--==========================orignal english content==========================
    <para>
     For security reasons, PL/Tcl executes functions called by any one SQL
     role in a separate Tcl interpreter for that role.  This prevents
     accidental or malicious interference by one user with the behavior of
     another user's PL/Tcl functions.  Each such interpreter will have its own
     values for any <quote>global</quote> Tcl variables.  Thus, two PL/Tcl
     functions will share the same global variables if and only if they are
     executed by the same SQL role.  In an application wherein a single
     session executes code under multiple SQL roles (via <literal>SECURITY
     DEFINER</literal> functions, use of <command>SET ROLE</command>, etc) you may need to
     take explicit steps to ensure that PL/Tcl functions can share data.  To
     do that, make sure that functions that should communicate are owned by
     the same user, and mark them <literal>SECURITY DEFINER</literal>.  You must of
     course take care that such functions can't be used to do anything
     unintended.
    </para>
____________________________________________________________________________-->
    <para>
     由于安全性原因，PL/Tcl 会为一个 SQL 角色建立一个单独的 Tcl 解释器来执行该角色调用的函数。这可以避免一个用户无意或者恶意地干涉另一个用户的 PL/Tcl 函数的行为。对任何<quote>全局</quote> Tcl 变量，每一个这样的解释器都有其自身的值。因此，当且仅当两个 PL/Tcl 函数由用一个 SQL 角色执行时，它们才能共享相同的全局变量。在使用单个会话执行多个 SQL 角色的代码（通过<literal>SECURITY DEFINER</literal>函数、使用<command>SET ROLE</command>等）的应用中，需要采取显式的步骤以保证 PL/Tcl 函数能共享数据。要这样做，需要确保要通信的函数都属于同一个用户，并且把它们标记为<literal>SECURITY DEFINER</literal>。当然，要小心这样的函数被滥用。
    </para>

<!--==========================orignal english content==========================
    <para>
     All PL/TclU functions used in a session execute in the same Tcl
     interpreter, which of course is distinct from the interpreter(s)
     used for PL/Tcl functions.  So global data is automatically shared
     between PL/TclU functions.  This is not considered a security risk
     because all PL/TclU functions execute at the same trust level,
     namely that of a database superuser.
    </para>
____________________________________________________________________________-->
    <para>
     在一个会话中使用的所有 PL/TclU 函数都在同一个 Tcl 解释器中执行，这当然与用于 PL/Tcl 函数的解释器不同。因此，在 PL/TclU 函数之间会自动地共享全局数据。这并不是一种安全性风险，因为所有的 PL/TclU 函数都在同样的信任级别上执行，即都以数据库超级用户的级别执行。
    </para>

<!--==========================orignal english content==========================
    <para>
     To help protect PL/Tcl functions from unintentionally interfering
     with each other, a global
     array is made available to each function via the <function>upvar</function>
     command. The global name of this variable is the function's internal
     name, and the local name is <literal>GD</literal>.  It is recommended that
     <literal>GD</literal> be used
     for persistent private data of a function.  Use regular Tcl global
     variables only for values that you specifically intend to be shared among
     multiple functions.  (Note that the <literal>GD</literal> arrays are only
     global within a particular interpreter, so they do not bypass the
     security restrictions mentioned above.)
    </para>
____________________________________________________________________________-->
    <para>
     为了保护 PL/Tcl 函数不会无意间彼此干扰，通过<function>upvar</function>命令可以建立一个对每个函数可用的全局数组。这个变量的全局名称是该函数的内部名称，并且本地名称为<literal>GD</literal>。推荐使用<literal>GD</literal>来保持一个函数的持久私有数据。只对你特别希望在多个函数之间共享的值使用常规的 Tcl 全局变量（注意<literal>GD</literal>数组只在一个特定的解释器中是全局的，因此它们不会绕过上文提到的安全性限制）。
    </para>

<!--==========================orignal english content==========================
    <para>
     An example of using <literal>GD</literal> appears in the
     <function>spi_execp</function> example below.
    </para>
____________________________________________________________________________-->
    <para>
     下文的<function>spi_execp</function>例子中有一个使用<literal>GD</literal>的例子。
    </para>
   </sect1>

   <sect1 id="pltcl-dbaccess">
<!--==========================orignal english content==========================
    <title>Database Access from PL/Tcl</title>
____________________________________________________________________________-->
    <title>从 PL/Tcl 访问数据库</title>

<!--==========================orignal english content==========================
    <para>
     The following commands are available to access the database from
     the body of a PL/Tcl function:

    <variablelist>

     <varlistentry>
      <term><literal><function>spi_exec</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <replaceable>command</replaceable> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
        Executes an SQL command given as a string.  An error in the command
        causes an error to be raised.  Otherwise, the return value of <function>spi_exec</function>
        is the number of rows processed (selected, inserted, updated, or
        deleted) by the command, or zero if the command is a utility
        statement.  In addition, if the command is a <command>SELECT</command> statement, the
        values of the selected columns are placed in Tcl variables as
        described below.
       </para>
       <para>
        The optional <literal>-count</literal> value tells
        <function>spi_exec</function> the maximum number of rows
        to process in the command.  The effect of this is comparable to
        setting up a query as a cursor and then saying <literal>FETCH <replaceable>n</replaceable></literal>.
       </para>
       <para>
        If the command is a <command>SELECT</command> statement, the values of the
        result columns are placed into Tcl variables named after the columns.
        If the <literal>-array</literal> option is given, the column values are
        instead stored into elements of the named associative array, with the
        column names used as array indexes.  In addition, the current row
        number within the result (counting from zero) is stored into the array
        element named <quote><literal>.tupno</literal></quote>, unless that name is
        in use as a column name in the result.
       </para>
       <para>
        If the command is a <command>SELECT</command> statement and no <replaceable>loop-body</replaceable>
        script is given, then only the first row of results are stored into
        Tcl variables or array elements; remaining rows, if any, are ignored.
        No storing occurs if the query returns no rows.  (This case can be
        detected by checking the result of <function>spi_exec</function>.)
        For example:
<programlisting>
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
</programlisting>
        will set the Tcl variable <literal>$cnt</literal> to the number of rows in
        the <structname>pg_proc</structname> system catalog.
       </para>
       <para>
        If the optional <replaceable>loop-body</replaceable> argument is given, it is
        a piece of Tcl script that is executed once for each row in the
        query result.  (<replaceable>loop-body</replaceable> is ignored if the given
        command is not a <command>SELECT</command>.)
        The values of the current row's columns
        are stored into Tcl variables or array elements before each iteration.
        For example:
<programlisting>
spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
</programlisting>
        will print a log message for every row of <literal>pg_class</literal>.  This
        feature works similarly to other Tcl looping constructs; in
        particular <literal>continue</literal> and <literal>break</literal> work in the
        usual way inside the loop body.
       </para>
       <para>
        If a column of a query result is null, the target
        variable for it is <quote>unset</quote> rather than being set.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>spi_prepare</function> <replaceable>query</replaceable> <replaceable>typelist</replaceable></term>
      <listitem>
       <para>
        Prepares and saves a query plan for later execution.  The
        saved plan will be retained for the life of the current
        session.<indexterm><primary>preparing a query</primary>
        <secondary>in PL/Tcl</secondary></indexterm>
       </para>
       <para>
        The query can use parameters, that is, placeholders for
        values to be supplied whenever the plan is actually executed.
        In the query string, refer to parameters
        by the symbols <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>.
        If the query uses parameters, the names of the parameter types
        must be given as a Tcl list.  (Write an empty list for
        <replaceable>typelist</replaceable> if no parameters are used.)
       </para>
       <para>
        The return value from <function>spi_prepare</function> is a query ID
        to be used in subsequent calls to <function>spi_execp</function>. See
        <function>spi_execp</function> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal><function>spi_execp</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <optional role="tcl">-nulls <replaceable>string</replaceable></optional> <replaceable>queryid</replaceable> <optional role="tcl"><replaceable>value-list</replaceable></optional> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
        Executes a query previously prepared with <function>spi_prepare</function>.
        <replaceable>queryid</replaceable> is the ID returned by
        <function>spi_prepare</function>.  If the query references parameters,
        a <replaceable>value-list</replaceable> must be supplied.  This
        is a Tcl list of actual values for the parameters.  The list must be
        the same length as the parameter type list previously given to
        <function>spi_prepare</function>.  Omit <replaceable>value-list</replaceable>
        if the query has no parameters.
       </para>
       <para>
        The optional value for <literal>-nulls</literal> is a string of spaces and
        <literal>'n'</literal> characters telling <function>spi_execp</function>
        which of the parameters are null values. If given, it must have exactly the
        same length as the <replaceable>value-list</replaceable>.  If it
        is not given, all the parameter values are nonnull.
       </para>
       <para>
        Except for the way in which the query and its parameters are specified,
        <function>spi_execp</function> works just like <function>spi_exec</function>.
        The <literal>-count</literal>, <literal>-array</literal>, and
        <replaceable>loop-body</replaceable> options are the same,
        and so is the result value.
       </para>
       <para>
        Here's an example of a PL/Tcl function using a prepared plan:

<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
        # prepare the saved plan on the first call
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
</programlisting>

        We need backslashes inside the query string given to
        <function>spi_prepare</function> to ensure that the
        <literal>$<replaceable>n</replaceable></literal> markers will be passed
        through to <function>spi_prepare</function> as-is, and not replaced by Tcl
        variable substitution.

       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>spi_lastoid</function>
       <indexterm>
        <primary>spi_lastoid</primary>
        <secondary>in PL/Tcl</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
        Returns the OID of the row inserted by the last
        <function>spi_exec</function> or <function>spi_execp</function>, if the
        command was a single-row <command>INSERT</command> and the modified
        table contained OIDs.  (If not, you get zero.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>subtransaction</function> <replaceable>command</replaceable></term>
      <listitem>
       <para>
        The Tcl script contained in <replaceable>command</replaceable> is
        executed within a SQL subtransaction.  If the script returns an
        error, that entire subtransaction is rolled back before returning the
        error out to the surrounding Tcl code.
        See <xref linkend="pltcl-subtransactions"/> for more details and an
        example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>quote</function> <replaceable>string</replaceable></term>
      <listitem>
       <para>
        Doubles all occurrences of single quote and backslash characters
        in the given string.  This can be used to safely quote strings
        that are to be inserted into SQL commands given
        to <function>spi_exec</function> or
        <function>spi_prepare</function>.
        For example, think about an SQL command string like:

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

        where the Tcl variable <literal>val</literal> actually contains
        <literal>doesn't</literal>. This would result
        in the final command string:

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

        which would cause a parse error during
        <function>spi_exec</function> or
        <function>spi_prepare</function>.
        To work properly, the submitted command should contain:

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

        which can be formed in PL/Tcl using:

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

        One advantage of <function>spi_execp</function> is that you don't
        have to quote parameter values like this, since the parameters are never
        parsed as part of an SQL command string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>elog</function> <replaceable>level</replaceable> <replaceable>msg</replaceable>
       <indexterm>
        <primary>elog</primary>
        <secondary>in PL/Tcl</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
        Emits a log or error message. Possible levels are
        <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
        <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, and
        <literal>FATAL</literal>. <literal>ERROR</literal>
        raises an error condition; if this is not trapped by the surrounding
        Tcl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Tcl <literal>error</literal> command.
        <literal>FATAL</literal> aborts the transaction and causes the current
        session to shut down.  (There is probably no good reason to use
        this error level in PL/Tcl functions, but it's provided for
        completeness.)  The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"/> and
        <xref linkend="guc-client-min-messages"/> configuration
        variables. See <xref linkend="runtime-config"/>
        and <xref linkend="pltcl-error-handling"/>
        for more information.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     下面的命令可以用来从 PL/Tcl 函数体中访问数据库：

    <variablelist>

     <varlistentry>
      <term><literal><function>spi_exec</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <replaceable>command</replaceable> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
        执行一个以字符串给出的 SQL 命令。命令中错误将会导致错误发生。否则，<function>spi_exec</function>的返回值是被命令处理的行数（选择、插入、更新或者删除），如果命令是一条功能性语句则返回零。此外，如果命令是一条<command>SELECT</command>语句，被选中的列的值会被放在上文所述的 Tcl 变量中。
       </para>
       <para>
        可选的<literal>-count</literal>值告诉<function>spi_exec</function>命令中要处理的最大行数。这种效果类似于用游标建立一个查询然后使用<literal>FETCH <replaceable>n</replaceable></literal>。
       </para>
       <para>
        如果命令是一条<command>SELECT</command>语句，结果列的值会被放在以列名命名的 Tcl 变量中。如果给出了<literal>-array</literal>选项，列值会被存储在所提及的关联数组的元素中，而列名则被用作数组索引。此外，结果中的当前行号（从零开始记）被存储在数组元素<quote><literal>.tupno</literal></quote>中，除非这个名字在结果中已经被用作一个列名。
       </para>
       <para>
        如果命令是一条<command>SELECT</command>语句并且没有给出<replaceable>loop-body</replaceable>脚本，则只有结果的第一行被存储在 Tcl 变量或数组元素中。如果结果中有剩余的行，它们会被忽略。如果查询不返回行则不存储任何东西（这种情况可以通过<function>spi_exec</function>的结果检测到）。例如：
<programlisting>
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
</programlisting>

        将把 Tcl 变量<literal>$cnt</literal>设置为<structname>pg_proc</structname>系统目录中的行数。
       </para>
       <para>
        如果给出了可选的<replaceable>loop-body</replaceable>参数，它会是一个 Tcl 脚本，对查询结果中的每一行都要执行这个脚本（如果给出的查询不是<command>SELECT</command>则忽略<replaceable>loop-body</replaceable>）。在每次迭代前当前行的列值会被存储在 Tcl 变量或数组元素中。例如：

<programlisting>
spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
</programlisting>

        会对<literal>pg_class</literal>的每一行打印一段日志消息。这种特性工作起来类似于其他的 Tcl 循环结构。特别是<literal>continue</literal>和<literal>break</literal>的动作方式与在循环体中的通常方式相同。
       </para>
       <para>
        如果一个查询结果的一列为空，为它准备的目标变量不会被建立，而是会被<quote>unset</quote>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>spi_prepare</function> <replaceable>query</replaceable> <replaceable>typelist</replaceable></term>
      <listitem>
       <para>
        为后面的执行准备并且保存一个查询计划。保存下来的计划将在当前会话的生命期内保持存在。
        <indexterm><primary>preparing a query</primary>
        <secondary>in PL/Tcl</secondary></indexterm>
       </para>
       <para>
        查询可以使用参数，也就是占位符。在计划真正被执行时将会为占位符提供值。在查询字符串中，可以用符号<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>引用参数。如果查询使用了参数，参数类型的名称必须以一个 Tcl 列表的形式给出（如果不使用参数，可以为<replaceable>typelist</replaceable>写一个空列表）。
       </para>
       <para>
        从<function>spi_prepare</function>返回的值是一个查询 ID，在后续的<function>spi_execp</function>调用中需要用到这个 ID。例子可见<function>spi_execp</function>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal><function>spi_execp</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <optional role="tcl">-nulls <replaceable>string</replaceable></optional> <replaceable>queryid</replaceable> <optional role="tcl"><replaceable>value-list</replaceable></optional> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
       <para>
        执行一个之前用<function>spi_prepare</function>准备的查询。<replaceable>queryid</replaceable>是<function>spi_prepare</function>返回的 ID。如果查询引用参数，则必须提供一个<replaceable>value-list</replaceable>。这是一个参数实际值的 Tcl 列表。这个列表必须和之前传给<function>spi_prepare</function>的参数类型列表具有相同的长度。如果查询没有参数则可省略<replaceable>value-list</replaceable>。
       </para>
       <para>
        <literal>-nulls</literal>的值可选，它是一个空格和<literal>'n'</literal>字符构成的串，它告诉<function>spi_execp</function>哪些参数是空值。如果给出这个值，它必须正好和<replaceable>value-list</replaceable>长度相等。如果没有给出这个值，所有的参数值都是空。
       </para>
       <para>
        除了指定查询及其参数的方法，<function>spi_execp</function>和<function>spi_exec</function>很像。<literal>-count</literal>、<literal>-array</literal>以及<replaceable>loop-body</replaceable>选项是相同的，并且结果值也一样。
       </para>
       <para>
        这里是一个使用预备计划的 PL/Tcl 函数的例子：

<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
        # 第一次调用时准备保存的计划
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
</programlisting>

        我们需要在给<function>spi_prepare</function>的查询字符串里放上反斜线来确保<literal>$<replaceable>n</replaceable></literal>标记会被原样传递给<function>spi_prepare</function>，并且不会被 Tcl 变量替换。

       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>spi_lastoid</function>
       <indexterm>
        <primary>spi_lastoid</primary>
        <secondary>in PL/Tcl</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
        返回最后一次<function>spi_exec</function>或者<function>spi_execp</function>插入的行的 OID（如果该命令是一个单行<command>INSERT</command>且被修改表包含 OID。否则将会得到零）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>subtransaction</function> <replaceable>command</replaceable></term>
      <listitem>
       <para>
        <replaceable>command</replaceable>中包含的Tcl脚本会被在一个SQL子事务中执行。如果该脚本返回一个错误，那么整个子事务会在把错误返回到外围的Tcl代码之前就回滚。更多细节和例子请参考<xref linkend="pltcl-subtransactions"/>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>quote</function> <replaceable>string</replaceable></term>
      <listitem>
       <para>
        在给定的字符串中双写所有单引号和反斜线字符。这可以被用来引用字符串，以便它们能被安全地插入到传给<function>spi_exec</function>或者<function>spi_prepare</function>的 SQL 命令字符串中。例如，考虑这样的 SQL 命令字符串：

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

        这里的 Tcl 变量<literal>val</literal>实际上包含<literal>doesn't</literal>。这将会导致最终的命令串：

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

        这种命令串会导致<function>spi_exec</function>或<function>spi_prepare</function>期间的解析错误。要正确地工作，提交的命令应该包含：

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

        在 PL/Tcl 中可以这样做：

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

        <function>spi_execp</function>的一个好处是你不必这样引用参数值，因为参数值不会被作为 SQL 命令串的一部分被解析。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <function>elog</function> <replaceable>level</replaceable> <replaceable>msg</replaceable>
       <indexterm>
        <primary>elog</primary>
        <secondary>in PL/Tcl</secondary>
       </indexterm>
      </term>
      <listitem>
       <para>
        发出一段日志或者错误消息。可能的级别是<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>、<literal>WARNING</literal>、<literal>ERROR</literal>以及<literal>FATAL</literal>。<literal>ERROR</literal>产生一个错误情况。如果周围的 Tcl 代码没有捕捉它，错误会传播到调用查询，导致当前事务或者子事务被中止。这实际上与 Tcl 的<literal>error</literal>命令相同。<literal>FATAL</literal>中止事务并且导致当前会话关闭（可能在 PL/Tcl 函数中没有很好的理由来使用这种错误级别，但是为了完整性还是提供了这种级别）。其他级别只产生不同优先级的消息。一个特定级别的消息是被报告给客户端、写入到服务器日志或者两者都做，是由配置变量<xref linkend="guc-log-min-messages"/>和<xref linkend="guc-client-min-messages"/>所控制。详见<xref linkend="runtime-config"/>和<xref linkend="pltcl-error-handling"/>。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
    </para>

   </sect1>

   <sect1 id="pltcl-trigger">
<!--==========================orignal english content==========================
    <title>Trigger Functions in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl 中的触发器函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Trigger functions can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a function that is to be called
     as a trigger must be declared as a function with no arguments
     and a return type of <literal>trigger</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     触发器函数也可以用 PL/Tcl 编写。<productname>PostgreSQL</productname>要求能作为触发器被调用的函数必须被声明为没有参数并且返回类型为<literal>trigger</literal>。
    </para>
<!--==========================orignal english content==========================
    <para>
     The information from the trigger manager is passed to the function body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><varname>$TG_name</varname></term>
       <listitem>
        <para>
         The name of the trigger from the <command>CREATE TRIGGER</command> statement.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relid</varname></term>
       <listitem>
        <para>
         The object ID of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_name</varname></term>
       <listitem>
        <para>
         The name of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_schema</varname></term>
       <listitem>
        <para>
         The schema of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relatts</varname></term>
       <listitem>
        <para>
         A Tcl list of the table column names, prefixed with an empty list
         element. So looking up a column name in the list with <application>Tcl</application>'s
         <function>lsearch</function> command returns the element's number starting
         with 1 for the first column, the same way the columns are customarily
         numbered in <productname>PostgreSQL</productname>.  (Empty list
         elements also appear in the positions of columns that have been
         dropped, so that the attribute numbering is correct for columns
         to their right.)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_when</varname></term>
       <listitem>
        <para>
         The string <literal>BEFORE</literal>, <literal>AFTER</literal>, or
         <literal>INSTEAD OF</literal>, depending on the type of trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_level</varname></term>
       <listitem>
        <para>
         The string <literal>ROW</literal> or <literal>STATEMENT</literal> depending on the
         type of trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_op</varname></term>
       <listitem>
        <para>
         The string <literal>INSERT</literal>, <literal>UPDATE</literal>,
         <literal>DELETE</literal>, or <literal>TRUNCATE</literal> depending on the type of
         trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$NEW</varname></term>
       <listitem>
        <para>
         An associative array containing the values of the new table
         row for <command>INSERT</command> or <command>UPDATE</command> actions, or
         empty for <command>DELETE</command>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$OLD</varname></term>
       <listitem>
        <para>
         An associative array containing the values of the old table
         row for <command>UPDATE</command> or <command>DELETE</command> actions, or
         empty for <command>INSERT</command>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$args</varname></term>
       <listitem>
        <para>
         A Tcl list of the arguments to the function as given in the
         <command>CREATE TRIGGER</command> statement. These arguments are also accessible as
         <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> in the function body.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     来自于触发器管理器的信息通过下列变量被传递给函数体：

     <variablelist>

      <varlistentry>
       <term><varname>$TG_name</varname></term>
       <listitem>
        <para>
         <command>CREATE TRIGGER</command>语句中触发器的名字。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relid</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表的对象 ID。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_name</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表的名字。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_schema</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表所在的模式。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relatts</varname></term>
       <listitem>
        <para>
         表列名的 Tcl 列表，前面放上一个空列表元素。因此用<application>Tcl</application>的<function>lsearch</function>命令在该列表中查找一个列名返回的元素编号会从 1 开始（对于第一列），这和<productname>PostgreSQL</productname>中的自定义编号是同样的方式（空列表元数也出现在被删除的列的位置上，这样其右边的列的属性编号才是正确的）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_when</varname></term>
       <listitem>
        <para>
         可以为<literal>BEFORE</literal>、<literal>AFTER</literal>或者<literal>INSTEAD OF</literal>，具体的选择取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_level</varname></term>
       <listitem>
        <para>
         可以为<literal>ROW</literal>或者<literal>STATEMENT</literal>，取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_op</varname></term>
       <listitem>
        <para>
         可以为<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或者<literal>TRUNCATE</literal>，取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$NEW</varname></term>
       <listitem>
        <para>
         对于<command>INSERT</command>或者<command>UPDATE</command>动作是一个包含着新表行值的关联数组，对于<command>DELETE</command>为空。该数组以列名为索引。为空的列不会出现在数组中。对于语句级触发器这个变量不会被设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$OLD</varname></term>
       <listitem>
        <para>
         对于<command>UPDATE</command>或者<command>DELETE</command>动作是一个包含着新表行值的关联数组，对于<command>INSERT</command>为空。该数组以列名为索引。为空的列不会出现在数组中。对于语句级触发器这个变量不会被设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$args</varname></term>
       <listitem>
        <para>
         在<command>CREATE TRIGGER</command>语句中对过程给出的参数的 Tcl 列表。在过程体中也可以用<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>来访问这些参数。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>

<!--==========================orignal english content==========================
    <para>
     The return value from a trigger function can be one of the strings
     <literal>OK</literal> or <literal>SKIP</literal>, or a list of column name/value pairs.
     If the return value is <literal>OK</literal>,
     the operation (<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>)
     that fired the trigger will proceed
     normally. <literal>SKIP</literal> tells the trigger manager to silently suppress
     the operation for this row. If a list is returned, it tells PL/Tcl to
     return a modified row to the trigger manager; the contents of the
     modified row are specified by the column names and values in the list.
     Any columns not mentioned in the list are set to null.
     Returning a modified row is only meaningful
     for row-level <literal>BEFORE</literal> <command>INSERT</command> or <command>UPDATE</command>
     triggers, for which the modified row will be inserted instead of the one
     given in <varname>$NEW</varname>; or for row-level <literal>INSTEAD OF</literal>
     <command>INSERT</command> or <command>UPDATE</command> triggers where the returned row
     is used as the source data for <command>INSERT RETURNING</command> or
     <command>UPDATE RETURNING</command> clauses.
     In row-level <literal>BEFORE</literal> <command>DELETE</command> or <literal>INSTEAD
     OF</literal> <command>DELETE</command> triggers, returning a modified row has the same
     effect as returning <literal>OK</literal>, that is the operation proceeds.
     The trigger return value is ignored for all other types of triggers.
    </para>
____________________________________________________________________________-->
    <para>
     一个触发器函数的返回值可以是字符串<literal>OK</literal>或者<literal>SKIP</literal>，或者是一个“列名/值”对的列表。如果返回值是<literal>OK</literal>，引发该触发器的操作（<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>）将正常继续下去。<literal>SKIP</literal>告诉触发器管理器悄悄地抑制对这一行的该操作。如果返回一个列表，它告诉PL/Tcl返回一个被修改的行给触发器管理器，这个被修改的行的内容由列表中的列名和值指定。该列表中没有提到的任何列会被设置为空。返回被修改行只对行级<literal>BEFORE</literal> <command>INSERT</command>或<command>UPDATE</command>触发器有意义，对它们来说这个被修改的行将被插入而不是插入<varname>$NEW</varname>中给出的行。返回被修改行还对行级<literal>INSTEAD OF</literal>
     <command>INSERT</command>或<command>UPDATE</command>触发器有意义，其中被返回的行被用作<command>INSERT RETURNING</command>或<command>UPDATE RETURNING</command>子句的源数据。在行级<literal>BEFORE</literal> <command>DELETE</command>或<literal>INSTEAD OF</literal> <command>DELETE</command>触发器中，返回一个被修改行的效果和返回<literal>OK</literal>的效果相同，即操作继续。对所有其他类型的触发器来说，触发器返回值会被忽略。
    </para>

    <tip>
<!--==========================orignal english content==========================
     <para>
      The result list can be made from an array representation of the
      modified tuple with the <literal>array get</literal> Tcl command.
     </para>
____________________________________________________________________________-->
     <para>
      结果列表可以用Tcl的<literal>array get</literal>命令从被修改的元组的数组表示中造出。
     </para>
    </tip>

<!--==========================orignal english content==========================
    <para>
     Here's a little example trigger function that forces an integer value
     in a table to keep track of the number of updates that are performed on the
     row. For new rows inserted, the value is initialized to 0 and then
     incremented on every update operation.

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
</programlisting>

     Notice that the trigger function itself does not know the column
     name; that's supplied from the trigger arguments.  This lets the
     trigger function be reused with different tables.
    </para>
____________________________________________________________________________-->
    <para>
     这里有一个触发器函数的例子，它用一个表中的整数值来跟踪在行上被执行的更新数。对于被插入的新行，该值被初始化为 0 并且之后在每一次更新操作时被加一。

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
</programlisting>

     注意触发器函数本身不知道列名，列名由触发器参数提供。这让触发器函数可以被重用于不同的表。
    </para>
   </sect1>

   <sect1 id="pltcl-event-trigger">
<!--==========================orignal english content==========================
    <title>Event Trigger Functions in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl 中的事件触发器函数</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>event trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>event trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Event trigger functions can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a function that is
     to be called as an event trigger must be declared as a function with no
     arguments and a return type of <literal>event_trigger</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     事件触发器函数也可以用 PL/Tcl 编写。<productname>PostgreSQL</productname>要求能作为事件触发器被调用的函数必须被声明为没有参数并且返回类型为<literal>event_trigger</literal>。
    </para>
<!--==========================orignal english content==========================
    <para>
     The information from the trigger manager is passed to the function body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><varname>$TG_event</varname></term>
       <listitem>
        <para>
         The name of the event the trigger is fired for.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_tag</varname></term>
       <listitem>
        <para>
         The command tag for which the trigger is fired.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
____________________________________________________________________________-->
    <para>
     来自于触发器管理器的信息通过下列变量被传递给函数体：

     <variablelist>

      <varlistentry>
       <term><varname>$TG_event</varname></term>
       <listitem>
        <para>
         触发器为其引发的事件名。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_tag</varname></term>
       <listitem>
        <para>
         触发器为其引发的命令标签。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>

<!--==========================orignal english content==========================
    <para>
     The return value of the trigger function is ignored.
    </para>
____________________________________________________________________________-->
    <para>
     触发器函数的返回值被忽略。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here's a little example event trigger function that simply raises
     a <literal>NOTICE</literal> message each time a supported command is
     executed:

<programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个事件触发器函数的小例子，它在所支持的命令每次执行时简单地产生一个<literal>NOTICE</literal>消息：

<programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
</programlisting>
    </para>
   </sect1>
   
   <sect1 id="pltcl-error-handling">
<!--==========================orignal english content==========================
    <title>Error Handling in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl 中的错误处理</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Tcl code within or called from a PL/Tcl function can raise an error,
     either by executing some invalid operation or by generating an error
     using the Tcl <function>error</function> command or
     PL/Tcl's <function>elog</function> command.  Such errors can be caught
     within Tcl using the Tcl <function>catch</function> command.  If an
     error is not caught but is allowed to propagate out to the top level of
     execution of the PL/Tcl function, it is reported as a SQL error in the
     function's calling query.
    </para>
____________________________________________________________________________-->
    <para>
     PL/Tcl 函数中的 Tcl 代码或者从 PL/Tcl 函数中调用的代码可以抛出一个错误，错误可以由执行某些非法操作产生或者通过使用 Tcl <function>error</function>命令或者 PL/Tcl 的<function>elog</function>命令产生。Tcl 中可以使用 Tcl <function>catch</function>命令捕获这类错误。如果一个错误没有被捕捉但是被允许传播到该PL/Tcl函数执行的顶层，它会在该函数的调用查询中被报告为一个SQL错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Conversely, SQL errors that occur within PL/Tcl's
     <function>spi_exec</function>, <function>spi_prepare</function>,
     and <function>spi_execp</function> commands are reported as Tcl errors,
     so they are catchable by Tcl's <function>catch</function> command.
     (Each of these PL/Tcl commands runs its SQL operation in a
     subtransaction, which is rolled back on error, so that any
     partially-completed operation is automatically cleaned up.)
     Again, if an error propagates out to the top level without being caught,
     it turns back into a SQL error.
    </para>
____________________________________________________________________________-->
    <para>
     相反，在 PL/Tcl 的<function>spi_exec</function>、<function>spi_prepare</function>以及<function>spi_execp</function>命令中发生的SQL错误会被报告为 Tcl 错误，因此它们也可以被 Tcl 的<function>catch</function>命令捕获（这些PL/Tcl命令中的每一个都在一个子事务中运行它的SQL操作，该子事务在错误时会被回滚，这样任何部分完成的操作也会被自动清除）。同样地，如果一个错误被传播到顶层而没有被捕获，它会转变成SQL错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Tcl provides an <varname>errorCode</varname> variable that can represent
     additional information about an error in a form that is easy for Tcl
     programs to interpret.  The contents are in Tcl list format, and the
     first word identifies the subsystem or library reporting the error;
     beyond that the contents are left to the individual subsystem or
     library.  For database errors reported by PL/Tcl commands, the first
     word is <literal>POSTGRES</literal>, the second word is the PostgreSQL
     version number, and additional words are field name/value pairs
     providing detailed information about the error.
     Fields <varname>SQLSTATE</varname>, <varname>condition</varname>,
     and <varname>message</varname> are always supplied
     (the first two represent the error code and condition name as shown
     in <xref linkend="errcodes-appendix"/>).
     Fields that may be present include
     <varname>detail</varname>, <varname>hint</varname>, <varname>context</varname>,
     <varname>schema</varname>, <varname>table</varname>, <varname>column</varname>,
     <varname>datatype</varname>, <varname>constraint</varname>,
     <varname>statement</varname>, <varname>cursor_position</varname>,
     <varname>filename</varname>, <varname>lineno</varname>, and
     <varname>funcname</varname>.
    </para>
____________________________________________________________________________-->
    <para>
     Tcl 提供了一个<varname>errorCode</varname>变量，它表示有关于一个错误的附加信息，它的格式易于 Tcl 程序解释。该变量的内容符合 Tcl 列表格式，第一个词标识报告该错误的子系统或者库，之后的内容则留给子系统或者库来填充。对于 PL/Tcl 命令报告的数据库错误，第一个词是<literal>POSTGRES</literal>，第二个词是 PostgreSQL 的版本号，剩下的部分是域名称/域值构成的对，它们提供有关该错误的详细信息。域<varname>SQLSTATE</varname>、<varname>condition</varname>以及<varname>message</varname>总是会被提供（前两个表示<xref linkend="errcodes-appendix"/>中所示的错误代码和情况名称）。可能出现的域包括
     <varname>detail</varname>、<varname>hint</varname>、<varname>context</varname>、
     <varname>schema</varname>、<varname>table</varname>、<varname>column</varname>、
     <varname>datatype</varname>、<varname>constraint</varname>、
     <varname>statement</varname>、<varname>cursor_position</varname>、
     <varname>filename</varname>、<varname>lineno</varname>以及
     <varname>funcname</varname>。
    </para>

<!--==========================orignal english content==========================
    <para>
     A convenient way to work with PL/Tcl's <varname>errorCode</varname>
     information is to load it into an array, so that the field names become
     array subscripts.  Code for doing that might look like
<programlisting>
if {[catch { spi_exec $sql_command }]} {
    if {[lindex $::errorCode 0] == "POSTGRES"} {
        array set errorArray $::errorCode
        if {$errorArray(condition) == "undefined_table"} {
            # deal with missing table
        } else {
            # deal with some other type of SQL error
        }
    }
}
</programlisting>
     (The double colons explicitly specify that <varname>errorCode</varname>
     is a global variable.)
    </para>
____________________________________________________________________________-->
    <para>
     使用 PL/Tcl 的<varname>errorCode</varname>信息的一种便捷方式是把它载入到一个数组中，这样域名称就变成了数组下标。这样做的代码看起来像这样
<programlisting>
if {[catch { spi_exec $sql_command }]} {
    if {[lindex $::errorCode 0] == "POSTGRES"} {
        array set errorArray $::errorCode
        if {$errorArray(condition) == "undefined_table"} {
            # deal with missing table
        } else {
            # deal with some other type of SQL error
        }
    }
}
</programlisting>
     （双冒号显式地指定<varname>errorCode</varname>是一个全局变量）。
    </para>
   </sect1>

   <sect1 id="pltcl-subtransactions">
<!--==========================orignal english content==========================
    <title>Explicit Subtransactions in PL/Tcl</title>
____________________________________________________________________________-->
    <title>PL/Tcl中的显式子事务</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>subtransactions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>subtransactions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Recovering from errors caused by database access as described in
     <xref linkend="pltcl-error-handling"/> can lead to an undesirable
     situation where some operations succeed before one of them fails,
     and after recovering from that error the data is left in an
     inconsistent state.  PL/Tcl offers a solution to this problem in
     the form of explicit subtransactions.
    </para>
____________________________________________________________________________-->
    <para>
     从<xref linkend="pltcl-error-handling"/>中介绍的数据库访问导致的错误中恢复可能导致一种不可取的情况，其中一些操作在它们中的一个失败前成功完成，并且在从错误中恢复过来后数据还处于一种不一致的状态。PL/Tcl以显式子事务的形式为这类问题提供了一个解决方案。
    </para>

<!--==========================orignal english content==========================
    <para>
     Consider a function that implements a transfer between two accounts:
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
    if [catch {
        spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
        spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     If the second <command>UPDATE</command> statement results in an
     exception being raised, this function will log the failure, but
     the result of the first <command>UPDATE</command> will
     nevertheless be committed.  In other words, the funds will be
     withdrawn from Joe's account, but will not be transferred to
     Mary's account.  This happens because each <function>spi_exec</function>
     is a separate subtransaction, and only one of those subtransactions
     got rolled back.
    </para>
____________________________________________________________________________-->
    <para>
     考虑一个在两个账户间实现转账的函数：
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
    if [catch {
        spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
        spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     如果第二个<command>UPDATE</command>语句导致一个异常，这个函数将记下该失败，但是第一个<command>UPDATE</command>的结果将被提交。换句话说，资金将从Joe的账户中被取走，但不会被转到Mary的账户。这是因为每个<function>spi_exec</function>都是一个单独的子事务，并且那些子事务中只有一个被回滚。
    </para>

<!--==========================orignal english content==========================
    <para>
     To handle such cases, you can wrap multiple database operations in an
     explicit subtransaction, which will succeed or roll back as a whole.
     PL/Tcl provides a <function>subtransaction</function> command to manage
     this.  We can rewrite our function as:
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
    if [catch {
        subtransaction {
            spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
            spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
        }
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     Note that use of <function>catch</function> is still required for this
     purpose.  Otherwise the error would propagate to the top level of the
     function, preventing the desired insertion into
     the <structname>operations</structname> table.
     The <function>subtransaction</function> command does not trap errors, it
     only assures that all database operations executed inside its scope will
     be rolled back together when an error is reported.
    </para>
____________________________________________________________________________-->
    <para>
     为了处理这类情况，你可以把多个数据库操作包裹在一个显式子事务中，它将作为一个整体成功完成或者回滚。PL/Tcl提供了一个<function>subtransaction</function>命令来做这件事情。我们可以把我们的函数写成：
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
    if [catch {
        subtransaction {
            spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
            spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
        }
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     注意，为了实现这个目的仍要求使用<function>catch</function>。否则错误将传播到该函数的顶层，导致想要对<structname>operations</structname>表的插入被阻止。<function>subtransaction</function>命令不会捕捉错误，它仅确保报告错误时在其范围内执行的所有数据库操作将被一起回滚。
    </para>

<!--==========================orignal english content==========================
    <para>
     A rollback of an explicit subtransaction occurs on any error reported
     by the contained Tcl code, not only errors originating from database
     access.  Thus a regular Tcl exception raised inside
     a <function>subtransaction</function> command will also cause the
     subtransaction to be rolled back.  However, non-error exits out of the
     contained Tcl code (for instance, due to <function>return</function>) do
     not cause a rollback.
    </para>
____________________________________________________________________________-->
    <para>
     一个显式子事务的回滚发生在包含它的Tcl代码报告任何错误时，而不仅仅是数据库访问导致的错误。因此一个<function>subtransaction</function>命令中发生的常规Tcl异常也将导致该子事务被回滚。不过，无错误退出到包含子事务的Tcl代码外面（例如，由于<function>return</function>）不会导致回滚。
    </para>
   </sect1>

   <sect1 id="pltcl-transactions">
<!--==========================orignal english content==========================
    <title>Transaction Management</title>
____________________________________________________________________________-->
    <title>事务管理</title>

<!--==========================orignal english content==========================
    <para>
     In a procedure called from the top level or an anonymous code block
     (<command>DO</command> command) called from the top level it is possible
     to control transactions.  To commit the current transaction, call the
     <literal>commit</literal> command.  To roll back the current transaction,
     call the <literal>rollback</literal> command.  (Note that it is not
     possible to run the SQL commands <command>COMMIT</command> or
     <command>ROLLBACK</command> via <function>spi_exec</function> or similar.
     It has to be done using these functions.)  After a transaction is ended,
     a new transaction is automatically started, so there is no separate
     command for that.
    </para>
____________________________________________________________________________-->
    <para>
     在从顶层调用的过程中或者从顶层调用的匿名代码块（<command>DO</command>命令）中，可以控制事务。要提交当前的事务，可调用<literal>commit</literal>。要回滚当前事务，可调用<literal>rollback</literal>（注意不能通过<function>spi_exec</function>或类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这类工作必须用这些函数完成）。在事务结束以后，一个新的事务会自动开始，因此没有独立的函数用来开始新事务。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i &lt; 10} {incr i} {
    spi_exec "INSERT INTO test1 (a) VALUES ($i)"
    if {$i % 2 == 0} {
        commit
    } else {
        rollback
    }
}
$$;

CALL transaction_test1();
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i &lt; 10} {incr i} {
    spi_exec "INSERT INTO test1 (a) VALUES ($i)"
    if {$i % 2 == 0} {
        commit
    } else {
        rollback
    }
}
$$;

CALL transaction_test1();
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Transactions cannot be ended when an explicit subtransaction is active.
    </para>
____________________________________________________________________________-->
    <para>
     当一个显式的子事务处于活跃状态时，事务不能被结束。
    </para>
   </sect1>

   <sect1 id="pltcl-config">
<!--==========================orignal english content==========================
    <title>PL/Tcl Configuration</title>
____________________________________________________________________________-->
    <title>PL/Tcl配置</title>

<!--==========================orignal english content==========================
    <para>
     This section lists configuration parameters that
     affect <application>PL/Tcl</application>.
    </para>
____________________________________________________________________________-->
    <para>
     这一节列举影响<application>PL/Tcl</application>的配置参数。
    </para>

    <variablelist>

     <varlistentry id="guc-pltcl-start-proc" xreflabel="pltcl.start_proc">
<!--==========================orignal english content==========================
      <term>
       <varname>pltcl.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltcl.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>pltcl.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltcl.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter, if set to a nonempty string, specifies the name
        (possibly schema-qualified) of a parameterless PL/Tcl function that
        is to be executed whenever a new Tcl interpreter is created for
        PL/Tcl.  Such a function can perform per-session initialization, such
        as loading additional Tcl code.  A new Tcl interpreter is created
        when a PL/Tcl function is first executed in a database session, or
        when an additional interpreter has to be created because a PL/Tcl
        function is called by a new SQL role.
       </para>
____________________________________________________________________________-->
       <para>
        如果被设置为一个非空字符串，这个参数指定一个无参数PL/Tcl函数的名称（可能是方案限定的），只要为PL/Tcl创建一个新的Tcl解释器，就会执行这个函数。这样一个函数可以执行针对会话的初始化，例如载入额外的Tcl代码。当一个PL/Tcl在一个数据库会话中被第一次执行时，或者由于一个PL/Tcl函数被一个新的SQL角色调用而必须创建一个额外的解释器时，一个新的Tcl解释器会被创建。
       </para>

<!--==========================orignal english content==========================
       <para>
        The referenced function must be written in the <literal>pltcl</literal>
        language, and must not be marked <literal>SECURITY DEFINER</literal>.
        (These restrictions ensure that it runs in the interpreter it's
        supposed to initialize.)  The current user must have permission to
        call it, too.
       </para>
____________________________________________________________________________-->
       <para>
        被引用的函数必须用<literal>pltcl</literal>语言编写，并且不能被标记为<literal>SECURITY DEFINER</literal>（这些限制确保它运行在它应该要初始化的解释器中）。当前用户也必须有权限调用它。
       </para>

<!--==========================orignal english content==========================
       <para>
        If the function fails with an error it will abort the function call
        that caused the new interpreter to be created and propagate out to
        the calling query, causing the current transaction or subtransaction
        to be aborted.  Any actions already done within Tcl won't be undone;
        however, that interpreter won't be used again.  If the language is
        used again the initialization will be attempted again within a fresh
        Tcl interpreter.
       </para>
____________________________________________________________________________-->
       <para>
        如果该函数带着一个错误失败，它将中止导致新解释器创建的函数并且把错误传播到调用查询，进而导致当前事务或子事务被中止。在Tcl中已完成的任何动作将不会被撤销，不过，那个解释器将不会被再次使用。如果该语言被再次使用，则初始化将在一个全新的Tcl解释器中被再次尝试。
       </para>

<!--==========================orignal english content==========================
       <para>
        Only superusers can change this setting.  Although this setting
        can be changed within a session, such changes will not affect Tcl
        interpreters that have already been created.
       </para>
____________________________________________________________________________-->
       <para>
        只有超级用户能够更改这个设置。尽管这个设置能在会话中更改，但这种更改将不会影响已经被创建的Tcl解释器。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pltclu-start-proc" xreflabel="pltclu.start_proc">
<!--==========================orignal english content==========================
      <term>
       <varname>pltclu.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltclu.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
____________________________________________________________________________-->
      <term>
       <varname>pltclu.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltclu.start_proc</varname>配置参数</primary>
       </indexterm>
      </term>
      <listitem>
<!--==========================orignal english content==========================
       <para>
        This parameter is exactly like <varname>pltcl.start_proc</varname>,
        except that it applies to PL/TclU.  The referenced function must
        be written in the <literal>pltclu</literal> language.
       </para>
____________________________________________________________________________-->
       <para>
        这个参数与<varname>pltcl.start_proc</varname>几乎一模一样，只不过它适用于PL/TclU。被引用的函数必须用<literal>pltclu</literal>语言编写。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="pltcl-procnames">
<!--==========================orignal english content==========================
    <title>Tcl Procedure Names</title>
____________________________________________________________________________-->
    <title>Tcl 过程名</title>

<!--==========================orignal english content==========================
    <para>
     In <productname>PostgreSQL</productname>, the same function name can be used for
     different function definitions as long as the number of arguments or their types
     differ. Tcl, however, requires all procedure names to be distinct.
     PL/Tcl deals with this by making the internal Tcl procedure names contain
     the object
     ID of the function from the system table <structname>pg_proc</structname> as part of their name. Thus,
     <productname>PostgreSQL</productname> functions with the same name
     and different argument types will be different Tcl procedures, too.  This
     is not normally a concern for a PL/Tcl programmer, but it might be visible
     when debugging.
    </para>
____________________________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>，同一个函数名可以被用于不同的函数定义，只要它们的参数个数或者类型不同。不过，Tcl 要求所有过程名必须能区分。PL/Tcl 通过让内部 Tcl 过程名称包含该函数在系统表<structname>pg_proc</structname>中的对象 ID 作为名称的一部分来解决这样的限制。因此，具有相同名称和不同参数类型的<productname>PostgreSQL</productname>函数也将是不同的 Tcl 过程。这对 PL/Tcl 程序员来说通常不需要关心，但是在调试时可见。
    </para>

   </sect1>
 </chapter>
