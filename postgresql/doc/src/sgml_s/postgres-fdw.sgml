<!-- doc/src/sgml/postgres-fdw.sgml -->

<sect1 id="postgres-fdw" xreflabel="postgres_fdw">
<!--==========================orignal english content==========================
 <title>postgres_fdw</title>
____________________________________________________________________________-->
 <title>postgres_fdw</title>

<!--==========================orignal english content==========================
 <indexterm zone="postgres-fdw">
  <primary>postgres_fdw</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="postgres-fdw">
  <primary>postgres_fdw</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>postgres_fdw</> module provides the foreign-data wrapper
  <literal>postgres_fdw</literal>, which can be used to access data
  stored in external <productname>PostgreSQL</productname> servers.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>postgres_fdw</filename>模块提供了外部数据包装器<literal>postgres_fdw</literal>，它可以被用来访问存储在外部<productname>PostgreSQL</productname>服务器中的数据。
 </para>

<!--==========================orignal english content==========================
 <para>
  The functionality provided by this module overlaps substantially
  with the functionality of the older <xref linkend="dblink"> module.
  But <filename>postgres_fdw</> provides more transparent and
  standards-compliant syntax for accessing remote tables, and can give
  better performance in many cases.
 </para>
____________________________________________________________________________-->
 <para>
  这个模块提供的功能大体上覆盖了较老的<xref linkend="dblink"/>模块的功能。但是<filename>postgres_fdw</filename>提供了更透明且更兼容标准的语法来访问远程表，并且可以在很多情况下给出更好的性能。
 </para>

<!--==========================orignal english content==========================
 <para>
  To prepare for remote access using <filename>postgres_fdw</>:
  <orderedlist spacing="compact">
   <listitem>
    <para>
     Install the  <filename>postgres_fdw</> extension using <xref
     linkend="sql-createextension">.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a foreign server object, using <xref linkend="sql-createserver">,
     to represent each remote database you want to connect to.
     Specify connection information, except <literal>user</literal> and
     <literal>password</literal>, as options of the server object.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a user mapping, using <xref linkend="sql-createusermapping">, for
     each database user you want to allow to access each foreign server.
     Specify the remote user name and password to use as
     <literal>user</literal> and <literal>password</literal> options of the
     user mapping.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a foreign table, using <xref linkend="sql-createforeigntable">
     or <xref linkend="sql-importforeignschema">,
     for each remote table you want to access.  The columns of the foreign
     table must match the referenced remote table.  You can, however, use
     table and/or column names different from the remote table's, if you
     specify the correct remote names as options of the foreign table object.
    </para>
   </listitem>
  </orderedlist>
 </para>
____________________________________________________________________________-->
 <para>
  要使用<filename>postgres_fdw</filename>来为远程访问做准备：
  <orderedlist spacing="compact">
   <listitem>
    <para>
     使用<xref linkend="sql-createextension"/>来安装<filename>postgres_fdw</filename>扩展。
    </para>
   </listitem>
   <listitem>
    <para>
     使用<xref linkend="sql-createserver"/>创建一个外部服务器对象，它用来表示你想连接的每一个远程数据库。指定除了<literal>user</literal>和<literal>password</literal>之外的连接信息作为该服务器对象的选项。
    </para>
   </listitem>
   <listitem>
    <para>
     使用<xref linkend="sql-createusermapping"/>创建一个用户映射，每一个用户映射都代表你想允许一个数据库用户访问一个外部服务器。指定远程用户名和口令作为用户映射的<literal>user</literal>和<literal>password</literal>选项。
    </para>
   </listitem>
   <listitem>
    <para>
     为每一个你想访问的远程表使用<xref linkend="sql-createforeigntable"/>或者<xref linkend="sql-importforeignschema"/>创建一个外部表。外部表的列必须匹配被引用的远程表。但是，如果你在外部表对象的选项中指定了正确的远程名称，你可以使用不同于远程表的表名和/或列名。
    </para>
   </listitem>
  </orderedlist>
 </para>

<!--==========================orignal english content==========================
 <para>
  Now you need only <command>SELECT</> from a foreign table to access
  the data stored in its underlying remote table.  You can also modify
  the remote table using <command>INSERT</>, <command>UPDATE</>, or
  <command>DELETE</>.  (Of course, the remote user you have specified
  in your user mapping must have privileges to do these things.)
 </para>
____________________________________________________________________________-->
 <para>
  现在你只需要从一个外部表<command>SELECT</command>来访问存储在它的底层的远程表中的数据。你也可以使用<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>修改远程表（当然，你在你的用户映射中已经指定的远程用户必须具有做这些事情的权限）。
 </para>
 
<!--==========================orignal english content==========================
 <para>
  Note that <filename>postgres_fdw</> currently lacks support for
  <command>INSERT</command> statements with an <literal>ON CONFLICT DO
  UPDATE</> clause.  However, the <literal>ON CONFLICT DO NOTHING</>
  clause is supported, provided a unique index inference specification
  is omitted.
 </para>
____________________________________________________________________________-->
 <para>
  注意当前<filename>postgres_fdw</filename>缺少对于带<literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>语句的支持。不过，它支持<literal>ON CONFLICT DO NOTHING</literal>子句，已提供的唯一索引推断说明会被省略。
 </para>

<!--==========================orignal english content==========================
 <para>
  It is generally recommended that the columns of a foreign table be declared
  with exactly the same data types, and collations if applicable, as the
  referenced columns of the remote table.  Although <filename>postgres_fdw</>
  is currently rather forgiving about performing data type conversions at
  need, surprising semantic anomalies may arise when types or collations do
  not match, due to the remote server interpreting <literal>WHERE</> clauses
  slightly differently from the local server.
 </para>
____________________________________________________________________________-->
 <para>
  我们通常推荐一个外部表的列被声明为与被引用的远程表列完全相同的数据类型和排序规则（如果可用）。尽管<filename>postgres_fdw</filename>目前已经能够容忍在需要时执行数据类型转换，但是当类型或排序规则不匹配时可能会发生奇怪的语义异常，因为远程服务器解释<literal>WHERE</literal>子句时可能会与本地服务器有所不同。
 </para>

<!--==========================orignal english content==========================
 <para>
  Note that a foreign table can be declared with fewer columns, or with a
  different column order, than its underlying remote table has.  Matching
  of columns to the remote table is by name, not position.
 </para>
____________________________________________________________________________-->
 <para>
  注意一个外部表可以被声明比底层的远程表较少的列，或者使用一种不同的列序。与远程表的列匹配是通过名字而不是位置进行的。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>FDW Options of postgres_fdw</title>
____________________________________________________________________________-->
  <title>postgres_fdw 的 FDW 选项</title>

  <sect3>
<!--==========================orignal english content==========================
   <title>Connection Options</title>
____________________________________________________________________________-->
   <title>连接选项</title>

<!--==========================orignal english content==========================
   <para>
    A foreign server using the <filename>postgres_fdw</> foreign data wrapper
    can have the same options that <application>libpq</> accepts in
    connection strings, as described in <xref linkend="libpq-paramkeywords">,
    except that these options are not allowed:

    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>user</literal> and <literal>password</literal> (specify these
       in a user mapping, instead)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>client_encoding</> (this is automatically set from the local
       server encoding)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>fallback_application_name</> (always set to
       <literal>postgres_fdw</>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个使用<filename>postgres_fdw</filename>外部数据包装器的外部服务器可以使用和<application>libpq</application>在连接字符串中能接受的选项，如<xref linkend="libpq-paramkeywords"/>所述，不过不允许这些选项：

    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>user</literal>和<literal>password</literal>（应该在用户映射中指定这些）
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>client_encoding</literal>（这是自动从本地服务器编码设置）
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>fallback_application_name</literal>（总是设置为<literal>postgres_fdw</literal>）
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Only superusers may connect to foreign servers without password
    authentication, so always specify the <literal>password</literal> option
    for user mappings belonging to non-superusers.
   </para>
____________________________________________________________________________-->
   <para>
    只有超级用户可以在不经过口令认证的情况下连接到外部服务器，因此应总是为属于非超级用户的用户映射指定<literal>password</literal>选项。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Object Name Options</title>
____________________________________________________________________________-->
   <title>对象名称选项</title>

<!--==========================orignal english content==========================
   <para>
    These options can be used to control the names used in SQL statements
    sent to the remote <productname>PostgreSQL</productname> server.  These
    options are needed when a foreign table is created with names different
    from the underlying remote table's names.
   </para>
____________________________________________________________________________-->
   <para>
    这些选项可以被用来控制使用在被发送到远程<productname>PostgreSQL</productname>服务器的 SQL 语句中使用的名称。当一个外部表被使用不同于底层远程表的名称创建时，就需要这些选项。
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>schema_name</literal></term>
____________________________________________________________________________-->
     <term><literal>schema_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table, gives the
       schema name to use for the foreign table on the remote server.  If this
       option is omitted, the name of the foreign table's schema is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器之上的外部表的模式名称，它可以为一个外部表指定。如果这个选项被忽略，该外部表的模式名称将被使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>table_name</literal></term>
____________________________________________________________________________-->
     <term><literal>table_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table, gives the
       table name to use for the foreign table on the remote server.  If this
       option is omitted, the foreign table's name is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器上的外部表给出表名，它可以为一个外部表指定。如果这个选项被忽略，该外部表的名字将被使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>column_name</literal></term>
____________________________________________________________________________-->
     <term><literal>column_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a column of a foreign table,
       gives the column name to use for the column on the remote server.
       If this option is omitted, the column's name is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器上列的列名，它可以为一个外部表的一个列指定。如果这个选项被忽略，该列的名字将被使用。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Cost Estimation Options</title>
____________________________________________________________________________-->
   <title>代价估计选项</title>

<!--==========================orignal english content==========================
   <para>
    <filename>postgres_fdw</> retrieves remote data by executing queries
    against remote servers, so ideally the estimated cost of scanning a
    foreign table should be whatever it costs to be done on the remote
    server, plus some overhead for communication.  The most reliable way to
    get such an estimate is to ask the remote server and then add something
    for overhead &mdash; but for simple queries, it may not be worth the cost
    of an additional remote query to get a cost estimate.
    So <filename>postgres_fdw</> provides the following options to control
    how cost estimation is done:
   </para>
____________________________________________________________________________-->
   <para>
    <filename>postgres_fdw</filename>通过在远程服务器上执行查询来检索远程数据，因此理想的扫描一个外部表的估计代价应该是在远程服务器上完成它的花销，外加一些通信开销。得到这样一个估计的最可靠的方法是询问远程服务器并加上一些通信开销 &mdash; 但是对于简单查询，不值得为获得一个代价估计而额外使用一次远程查询。因此<filename>postgres_fdw</filename>提供了下列选项来控制如何完成代价估计：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>use_remote_estimate</literal></term>
____________________________________________________________________________-->
     <term><literal>use_remote_estimate</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table or a foreign
       server, controls whether <filename>postgres_fdw</> issues remote
       <command>EXPLAIN</command> commands to obtain cost estimates.
       A setting for a foreign table overrides any setting for its server,
       but only for that table.
       The default is <literal>false</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制<filename>postgres_fdw</filename>是否发出<command>EXPLAIN</command>命令来获得代价估计，它可以为一个外部表或一个外部服务器指定。一个外部表的设置会覆盖它的服务器的任何设置，但是只用于这个表。默认值是<literal>false</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fdw_startup_cost</literal></term>
____________________________________________________________________________-->
     <term><literal>fdw_startup_cost</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign server, is a numeric
       value that is added to the estimated startup cost of any foreign-table
       scan on that server.  This represents the additional overhead of
       establishing a connection, parsing and planning the query on the
       remote side, etc.
       The default value is <literal>100</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个要被加到那个服务器上所有外部表扫描的估计启动代价的数字值。这表示建立一个连接、在远端解析和规查询的额外负荷等。默认值是<literal>100</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fdw_tuple_cost</literal></term>
____________________________________________________________________________-->
     <term><literal>fdw_tuple_cost</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign server, is a numeric
       value that is used as extra cost per-tuple for foreign-table
       scans on that server.  This represents the additional overhead of
       data transfer between servers.  You might increase or decrease this
       number to reflect higher or lower network delay to the remote server.
       The default value is <literal>0.01</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个数字值，它被用作那个服务器上外部表扫描的每元组额外代价，它可以为一个外部服务器指定。这表示在服务器之间数据传输的额外负荷。你可以增加或减少这个数来反映到远程服务器更高或更低的网络延迟。默认值是<literal>0.01</literal>。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

<!--==========================orignal english content==========================
   <para>
    When <literal>use_remote_estimate</literal> is true,
    <filename>postgres_fdw</> obtains row count and cost estimates from the
    remote server and then adds <literal>fdw_startup_cost</literal> and
    <literal>fdw_tuple_cost</literal> to the cost estimates.  When
    <literal>use_remote_estimate</literal> is false,
    <filename>postgres_fdw</> performs local row count and cost estimation
    and then adds <literal>fdw_startup_cost</literal> and
    <literal>fdw_tuple_cost</literal> to the cost estimates.  This local
    estimation is unlikely to be very accurate unless local copies of the
    remote table's statistics are available.  Running
    <xref linkend="sql-analyze"> on the foreign table is the way to update
    the local statistics; this will perform a scan of the remote table and
    then calculate and store statistics just as though the table were local.
    Keeping local statistics can be a useful way to reduce per-query planning
    overhead for a remote table &mdash; but if the remote table is
    frequently updated, the local statistics will soon be obsolete.
   </para>
____________________________________________________________________________-->
   <para>
    当<literal>use_remote_estimate</literal>为真时，<filename>postgres_fdw</filename>从远程服务器获得行计数和代价估计，然后在代价估计上加上<literal>fdw_startup_cost</literal>和<literal>fdw_tuple_cost</literal>。当<literal>use_remote_estimate</literal>为假时，<filename>postgres_fdw</filename>执行本地行计数和代价估计，并且接着在代价估计上加上<literal>fdw_startup_cost</literal> 和<literal>fdw_tuple_cost</literal>。这种本地估计不会很准确，除非有远程表统计数据的本地拷贝可用。在外部表上运行<xref linkend="sql-analyze"/>是更新本地统计数据的方法，这将执行远程表的一次扫描并接着计算和存储统计数据，就好像表在本地一样。保留本地统计数据可能是一种有用的方法来减少一个远程表的预查询规划负荷 &mdash; 但是如果远程表被频繁更新，本地统计数据将很快就被废弃。
   </para>

  </sect3>
  
  <sect3>
<!--==========================orignal english content==========================
   <title>Remote Execution Options</title>
____________________________________________________________________________-->
   <title>远程执行选项</title>

<!--==========================orignal english content==========================
   <para>
    By default, only <literal>WHERE</> clauses using built-in operators and
    functions will be considered for execution on the remote server.  Clauses
    involving non-built-in functions are checked locally after rows are
    fetched.  If such functions are available on the remote server and can be
    relied on to produce the same results as they do locally, performance can
    be improved by sending such <literal>WHERE</> clauses for remote
    execution.  This behavior can be controlled using the following option:
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，只有使用了内建操作符和函数的<literal>WHERE</literal>子句才会被考虑在远程服务器上执行。涉及非内建函数的子句将会在取完行后在本地进行检查。如果这类函数在远程服务器上可用并且可以用来产生和本地执行时一样的结果，则可以通过将这种<literal>WHERE</literal>子句发送到远程执行来提高性能。可以用下面的选项控制这种行为：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>extensions</literal></term>
____________________________________________________________________________-->
     <term><literal>extensions</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option is a comma-separated list of names
       of <productname>PostgreSQL</> extensions that are installed, in
       compatible versions, on both the local and remote servers.  Functions
       and operators that are immutable and belong to a listed extension will
       be considered shippable to the remote server.
       This option can only be specified for foreign servers, not per-table.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个用逗号分隔的已安装的<productname>PostgreSQL</productname>扩展名称列表，这些扩展在本地和远程服务器上具有兼容的版本。属于一个该列表中扩展的 immutable 函数和操作符将被考虑转移到远程服务器上执行。这个选项只能为外部服务器指定，无法逐个表指定。
      </para>

<!--==========================orignal english content==========================
      <para>
       When using the <literal>extensions</literal> option, <emphasis>it is the
       user's responsibility</> that the listed extensions exist and behave
       identically on both the local and remote servers.  Otherwise, remote
       queries may fail or behave unexpectedly.
      </para>
____________________________________________________________________________-->
      <para>
       在使用<literal>extensions</literal>选项时，<emphasis>用户应该负责确保</emphasis>列出的扩展在本地和远程服务器上都存在且保持一致。否则，远程查询可能失败或者行为异常。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fetch_size</literal></term>
____________________________________________________________________________-->
     <term><literal>fetch_size</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option specifies the number of rows <filename>postgres_fdw</>
       should get in each fetch operation. It can be specified for a foreign
       table or a foreign server. The option specified on a table overrides
       an option specified for the server.
       The default is <literal>100</>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项指定在每次获取行的操作中<filename>postgres_fdw</filename>应该得到的行数。可以为一个外部表或者外部服务器指定这个选项。在表上指定的选项将会覆盖在服务器级别上指定的选项。默认值为<literal>100</literal>。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Updatability Options</title>
____________________________________________________________________________-->
   <title>可更新性选项</title>

<!--==========================orignal english content==========================
   <para>
    By default all foreign tables using <filename>postgres_fdw</> are assumed
    to be updatable.  This may be overridden using the following option:
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，所有使用<filename>postgres_fdw</filename>的外部表都被假定是可更新的。这可以使用下列选项覆盖：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>updatable</literal></term>
____________________________________________________________________________-->
     <term><literal>updatable</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether <filename>postgres_fdw</> allows foreign
       tables to be modified using <command>INSERT</>, <command>UPDATE</> and
       <command>DELETE</> commands.  It can be specified for a foreign table
       or a foreign server.  A table-level option overrides a server-level
       option.
       The default is <literal>true</>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制<filename>postgres_fdw</filename>是否允许外部表被使用<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>命令更新。它可以为一个外部表或一个外部服务器指定。一个表级选项会覆盖一个服务器级选项。默认值是<literal>true</literal>。
      </para>

<!--==========================orignal english content==========================
      <para>
       Of course, if the remote table is not in fact updatable, an error
       would occur anyway.  Use of this option primarily allows the error to
       be thrown locally without querying the remote server.  Note however
       that the <literal>information_schema</> views will report a
       <filename>postgres_fdw</> foreign table to be updatable (or not)
       according to the setting of this option, without any check of the
       remote server.
      </para>
____________________________________________________________________________-->
      <para>
       当然，如果远程表实际上并非可更新的，将产生一个错误。这个选项的使用主要是允许在不查询远程服务器的情况下在本地抛出错误。但是要注意<literal>information_schema</literal>视图会根据这个选项的设置报告一个<filename>postgres_fdw</filename>外部表是可更新的（或者不可更新），而不需要远程服务器的任何检查。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect3>
  
  <sect3>
<!--==========================orignal english content==========================
   <title>Importing Options</title>
____________________________________________________________________________-->
   <title>导入选项</title>

<!--==========================orignal english content==========================
   <para>
    <filename>postgres_fdw</> is able to import foreign table definitions
    using <xref linkend="sql-importforeignschema">.  This command creates
    foreign table definitions on the local server that match tables or
    views present on the remote server.  If the remote tables to be imported
    have columns of user-defined data types, the local server must have
    compatible types of the same names.
   </para>
____________________________________________________________________________-->
   <para>
    <filename>postgres_fdw</filename>能使用<xref linkend="sql-importforeignschema"/>导入外部表定义。这个命令会在本地服务器上创建外部表定义，这个定义能匹配存在于远程服务器上的表或者视图。如果要被导入的远程表有用户自定义数据类型的列，本地服务器上也必须具有相同名称的兼容类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    Importing behavior can be customized with the following options
    (given in the <command>IMPORT FOREIGN SCHEMA</> command):
   </para>
____________________________________________________________________________-->
   <para>
    导入行为可以用下列选项自定义（在<command>IMPORT FOREIGN SCHEMA</command>命令中给出）：
   </para>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_collate</literal></term>
____________________________________________________________________________-->
     <term><literal>import_collate</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>COLLATE</> options
       are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>true</>.  You might
       need to turn this off if the remote server has a different set of
       collation names than the local server does, which is likely to be the
       case if it's running on a different operating system.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>COLLATE</literal>选项。默认是<literal>true</literal>。如果远程服务器具有和本地服务器不同的排序规则名集合，可能需要关闭这个选项，在不同的操作系统上运行时很可能就是这样。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_default</literal></term>
____________________________________________________________________________-->
     <term><literal>import_default</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>DEFAULT</> expressions
       are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>false</>.  If you
       enable this option, be wary of defaults that might get computed
       differently on the local server than they would be on the remote
       server; <function>nextval()</> is a common source of problems.
       The <command>IMPORT</> will fail altogether if an imported default
       expression uses a function or operator that does not exist locally.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>DEFAULT</literal>表达式。默认是<literal>false</literal>。如果启用这个选项，要当心在远程服务器和本地服务器上计算表达式的方式不同，<function>nextval()</function>常会导致这类问题。如果导入的默认值表达式使用了一个本地不存在的函数或者操作符，<command>IMPORT</command>将整个失败。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_not_null</literal></term>
____________________________________________________________________________-->
     <term><literal>import_not_null</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>NOT NULL</>
       constraints are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>true</>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>NOT NULL</literal>约束。默认是<literal>true</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    Note that constraints other than <literal>NOT NULL</> will never be
    imported from the remote tables.  Although <productname>PostgreSQL</>
    does support <literal>CHECK</> constraints on foreign tables, there is no
    provision for importing them automatically, because of the risk that a
    constraint expression could evaluate differently on the local and remote
    servers.  Any such inconsistency in the behavior of a <literal>CHECK</>
    constraint could lead to hard-to-detect errors in query optimization.
    So if you wish to import <literal>CHECK</> constraints, you must do so
    manually, and you should verify the semantics of each one carefully.
    For more detail about the treatment of <literal>CHECK</> constraints on
    foreign tables, see <xref linkend="sql-createforeigntable">.
   </para>
____________________________________________________________________________-->
   <para>
    注意除<literal>NOT NULL</literal>之外的约束将不会从远程表中导入。虽然<productname>PostgreSQL</productname>确实支持外部表上的<literal>CHECK</literal>约束，但不会自动导入它们，因为存在本地和远程服务器计算约束表达式方式不同的风险。<literal>CHECK</literal>约束中的任何这类不一致都可能导致查询优化中很难检测的错误。因此，如果你希望导入<literal>CHECK</literal>约束，你必须手工来做，并且你应该仔细地验证每一个这种约束的语义。有关处理外部表上<literal>CHECK</literal>约束的更多细节，请见<xref linkend="sql-createforeigntable"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Tables or foreign tables which are partitions of some other table are
    automatically excluded.  Partitioned tables are imported, unless they
    are a partition of some other table.  Since all data can be accessed
    through the partitioned table which is the root of the partitioning
    hierarchy, this approach should allow access to all the data without
    creating extra objects.
   </para>
____________________________________________________________________________-->
   <para>
    自动排除作为其他表的分区的表或外部表。分区表被导入，除非它们是其他表的分区。
	由于所有数据都可以通过作为分区层次根的分区表来访问，
	所以这种方法应该允许访问所有数据而不创建额外的对象。
   </para>

   </sect3>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Connection Management</title>
____________________________________________________________________________-->
  <title>连接管理</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</filename> establishes a connection to a
   foreign server during the first query that uses a foreign table
   associated with the foreign server.  This connection is kept and
   re-used for subsequent queries in the same session.  However, if
   multiple user identities (user mappings) are used to access the foreign
   server, a connection is established for each user mapping.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>在第一个使用关联到外部服务器的外部表的查询期间建立一个到外部服务器的连接。这个连接会被保持，并被重用于同一个会话中的后续查询。但是，如果使用了多个用户实体（用户映射）来访问外部服务器，会为每一个用户映射建立一个连接。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Transaction Management</title>
____________________________________________________________________________-->
  <title>事务管理</title>

<!--==========================orignal english content==========================
  <para>
   During a query that references any remote tables on a foreign server,
   <filename>postgres_fdw</filename> opens a transaction on the
   remote server if one is not already open corresponding to the current
   local transaction.  The remote transaction is committed or aborted when
   the local transaction commits or aborts.  Savepoints are similarly
   managed by creating corresponding remote savepoints.
  </para>
____________________________________________________________________________-->
  <para>
   在一个引用外部服务器上任何远程表的查询期间，如果还没有根据当前的本地事务打开一个远程事务，<filename>postgres_fdw</filename>将在远程服务器上打开一个事务。当本地事务提交或中止时，远程事务也被提交或中止。保存点也相似地采用创建相应的远程保存点来管理。
  </para>

<!--==========================orignal english content==========================
  <para>
   The remote transaction uses <literal>SERIALIZABLE</>
   isolation level when the local transaction has <literal>SERIALIZABLE</>
   isolation level; otherwise it uses <literal>REPEATABLE READ</>
   isolation level.  This choice ensures that if a query performs multiple
   table scans on the remote server, it will get snapshot-consistent results
   for all the scans.  A consequence is that successive queries within a
   single transaction will see the same data from the remote server, even if
   concurrent updates are occurring on the remote server due to other
   activities.  That behavior would be expected anyway if the local
   transaction uses <literal>SERIALIZABLE</> or <literal>REPEATABLE READ</>
   isolation level, but it might be surprising for a <literal>READ
   COMMITTED</> local transaction.  A future
   <productname>PostgreSQL</productname> release might modify these rules.
  </para>
____________________________________________________________________________-->
  <para>
   当本地事务为<literal>SERIALIZABLE</literal>隔离级别时，远程事务使用<literal>SERIALIZABLE</literal>隔离级别；否则它使用<literal>REPEATABLE READ</literal>隔离级别。如果一个查询在远程服务器上执行多个表查询，这种选择保证它将为所有扫描得到快照一致的结果。一种后果是在单一事务中的后继查询将会看到来自远程服务器的相同数据，即便由于其他活动在远程服务器上发生了其他并发更新。如果本地事务使用<literal>SERIALIZABLE</literal>或<literal>REPEATABLE READ</literal>隔离级别，这种行为也是可以预期的，但是对于一个<literal>READ COMMITTED</literal>本地事务它是奇怪的。一个未来的<productname>PostgreSQL</productname>发布可能会修改这些规则。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Remote Query Optimization</title>
____________________________________________________________________________-->
  <title>远程查询优化</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</> attempts to optimize remote queries to reduce
   the amount of data transferred from foreign servers.  This is done by
   sending query <literal>WHERE</> clauses to the remote server for
   execution, and by not retrieving table columns that are not needed for
   the current query.  To reduce the risk of misexecution of queries,
   <literal>WHERE</> clauses are not sent to the remote server unless they use
   only data types, operators, and functions that are built-in or belong to an
   extension that's listed in the foreign server's <literal>extensions</>
   option.  Operators and functions in such clauses must
   be <literal>IMMUTABLE</> as well.
   For an <command>UPDATE</> or <command>DELETE</> query,
   <filename>postgres_fdw</> attempts to optimize the query execution by
   sending the whole query to the remote server if there are no query
   <literal>WHERE</> clauses that cannot be sent to the remote server,
   no local joins for the query, no row-level local <literal>BEFORE</> or
   <literal>AFTER</> triggers on the target table, and no
   <literal>CHECK OPTION</> constraints from parent views.
   In <command>UPDATE</>,
   expressions to assign to target columns must use only built-in data types,
   <literal>IMMUTABLE</> operators, or <literal>IMMUTABLE</> functions,
   to reduce the risk of misexecution of the query.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>尝试优化远程查询来减少从外部服务器传来的数据量。这可以通过把查询的<literal>WHERE</literal>子句发送给远程服务器执行来完成，并且还可以不检索当前查询不需要的表列。为了降低查询被误执行的风险，除非<literal>WHERE</literal>子句使用的数据类型、操作符和函数都是内建的或者属于列在该外部服务器的<literal>extensions</literal>选项中的一个扩展，将不会把<literal>WHERE</literal>子句发送到远程服务器。这些子句中的操作符合函数也必须是<literal>IMMUTABLE</literal>。对于<command>UPDATE</command>或者<command>DELETE</command>查询，
   如果没有不能发送给远程服务器的<literal>WHERE</literal>子句、
   没有查询的本地连接、目标表上没有本地的行级<literal>BEFORE</literal>或<literal>AFTER</literal>触发器，
   并且没有来自父视图的<literal>CHECK OPTION</literal>约束，<filename>postgres_fdw</filename>会尝试通过将整个查询发送给远程服务器来优化查询的执行。在<command>UPDATE</command>中，赋值给目标列的表达式只能使用内建数据类型、<literal>IMMUTABLE</literal>操作符或者<literal>IMMUTABLE</literal>操作符，这样能降低查询被误执行的风险。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <filename>postgres_fdw</> encounters a join between foreign tables on
   the same foreign server, it sends the entire join to the foreign server,
   unless for some reason it believes that it will be more efficient to fetch
   rows from each table individually, or unless the table references involved
   are subject to different user mappings.  While sending the <literal>JOIN</>
   clauses, it takes the same precautions as mentioned above for the
   <literal>WHERE</> clauses.
  </para>
____________________________________________________________________________-->
  <para>
   当<filename>postgres_fdw</filename>碰到同一个外部服务器上的外部表之间的连接时，它会把整个连接发送给外部服务器，除非由于某些原因它认为逐个从每一个表取得行的效率更高或者涉及的表引用属于不同的用户映射。在发送<literal>JOIN</literal>子句时，它也会采取和上述<literal>WHERE</literal>子句相同的预防措施。
  </para>

<!--==========================orignal english content==========================
  <para>
   The query that is actually sent to the remote server for execution can
   be examined using <command>EXPLAIN VERBOSE</>.
  </para>
____________________________________________________________________________-->
  <para>
   实际被发送到远程服务器执行的查询可以使用<command>EXPLAIN VERBOSE</command>来检查。
  </para>
 </sect2>
 
 <sect2>
<!--==========================orignal english content==========================
  <title>Remote Query Execution Environment</title>
____________________________________________________________________________-->
  <title>远程查询执行环境</title>

<!--==========================orignal english content==========================
  <para>
   In the remote sessions opened by <filename>postgres_fdw</>,
   the <xref linkend="guc-search-path"> parameter is set to
   just <literal>pg_catalog</>, so that only built-in objects are visible
   without schema qualification.  This is not an issue for queries
   generated by <filename>postgres_fdw</> itself, because it always
   supplies such qualification.  However, this can pose a hazard for
   functions that are executed on the remote server via triggers or rules
   on remote tables.  For example, if a remote table is actually a view,
   any functions used in that view will be executed with the restricted
   search path.  It is recommended to schema-qualify all names in such
   functions, or else attach <literal>SET search_path</> options
   (see <xref linkend="sql-createfunction">) to such functions
   to establish their expected search path environment.
  </para>
____________________________________________________________________________-->
  <para>
   在<filename>postgres_fdw</filename>开启的远程会话中，<xref linkend="guc-search-path"/>参数只被设置为<literal>pg_catalog</literal>，因此只有内建对象可以在无模式限定时可见。这对于<filename>postgres_fdw</filename>本身产生的查询来说不是问题，因为它总是会提供这样的限定。不过，这可能会对在远程服务器上通过触发器或者远程表上的规则执行的函数带来灾难。例如，如果一个远程表实际是一个视图，任何在该视图中使用的函数都将被在这个受限的搜索路径中执行。我们推荐在这类函数中用模式限定所有名称，或者为这类函数附着<literal>SET search_path</literal>选项（见<xref linkend="sql-createfunction"/>）来建立它们所期望的搜索路径环境。
  </para>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</> likewise establishes remote session settings
   for various parameters: 
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <xref linkend="guc-timezone"> is set to <literal>UTC</>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-datestyle"> is set to <literal>ISO</>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-intervalstyle"> is set to <literal>postgres</>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-extra-float-digits"> is set to <literal>3</> for remote
      servers 9.0 and newer and is set to <literal>2</> for older versions
     </para>
    </listitem>
   </itemizedlist>
   These are less likely to be problematic than <varname>search_path</>, but
   can be handled with function <literal>SET</> options if the need arises.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>同样为各种参数建立远程会话设置：
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <xref linkend="guc-timezone"/>设置为<literal>UTC</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-datestyle"/>设置为<literal>ISO</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-intervalstyle"/>设置为<literal>postgres</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      对于远程服务器9.0和更新版本，<xref linkend="guc-extra-float-digits"/>
	  设置为<literal>3</literal>，并且针对更老版本设置为<literal>2</literal>
     </para>
    </listitem>
   </itemizedlist>
   这些不如<varname>search_path</varname>有那么多问题，但是如果需要也可以使用函数
   <literal>SET</literal>选项来处理。
  </para>
   
<!--==========================orignal english content==========================
  <para>
   It is <emphasis>not</> recommended that you override this behavior by
   changing the session-level settings of these parameters; that is likely
   to cause <filename>postgres_fdw</> to malfunction.
  </para>
____________________________________________________________________________-->
  <para>
   我们<emphasis>不</emphasis>推荐通过更改这些参数的会话级设置来推翻这种行为，这很可能会导致<filename>postgres_fdw</filename>故障。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Cross-Version Compatibility</title>
____________________________________________________________________________-->
  <title>跨版本兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</> can be used with remote servers dating back
   to <productname>PostgreSQL</> 8.3.  Read-only capability is available
   back to 8.1.  A limitation however is that <filename>postgres_fdw</>
   generally assumes that immutable built-in functions and operators are
   safe to send to the remote server for execution, if they appear in a
   <literal>WHERE</> clause for a foreign table.  Thus, a built-in
   function that was added since the remote server's release might be sent
   to it for execution, resulting in <quote>function does not exist</> or
   a similar error.  This type of failure can be worked around by
   rewriting the query, for example by embedding the foreign table
   reference in a sub-<literal>SELECT</> with <literal>OFFSET 0</> as an
   optimization fence, and placing the problematic function or operator
   outside the sub-<literal>SELECT</>.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>能够与最老是<productname>PostgreSQL</productname> 8.3 的远程服务器一起使用。只读能力则最低可以在 8.1 中使用。但是一个限制是<filename>postgres_fdw</filename>通常假定不变的内建函数和操作符是安全的，如果它们出现在一个外部表的<literal>WHERE</literal>子句中，它们可以发送给远程服务器执行。因此，由于一个由于远程服务器的发布可能被发送给它来执行而被增加的内建函数，会导致<quote>function does not exist</quote>或一个类似的错误。这类错误可以通过重写查询来解决，例如通过嵌入在一个带<literal>OFFSET 0</literal>的子<literal>SELECT</literal>中引用的外部表作为一种优化墙，并且把出问题的函数或操作符放在子<literal>SELECT</literal>的外部。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   Here is an example of creating a foreign table with
   <literal>postgres_fdw</>. First install the extension:
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个用<literal>postgres_fdw</literal>创建外部表的例子。首先安装该扩展：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE EXTENSION postgres_fdw;
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE EXTENSION postgres_fdw;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   Then create a foreign server using <xref linkend="sql-createserver">.
   In this example we wish to connect to a <productname>PostgreSQL</> server
   on host <literal>192.83.123.89</literal> listening on
   port <literal>5432</literal>.  The database to which the connection is made
   is named <literal>foreign_db</literal> on the remote server:

<programlisting>
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   然后使用<xref linkend="sql-createserver"/>创建一个外部服务器。在这个例子中我们希望连接到一个位于主机<literal>192.83.123.89</literal>上并且监听<literal>5432</literal>端口的<productname>PostgreSQL</productname>服务器。在该远程服务器上要连接的数据库名为<literal>foreign_db</literal>：

<programlisting>
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   A user mapping, defined with <xref linkend="sql-createusermapping">, is
   needed as well to identify the role that will be used on the remote
   server:

<programlisting>
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   需要用<xref linkend="sql-createusermapping"/>定义一个用户映射来标识在远程服务器上使用哪个角色：

<programlisting>
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Now it is possible to create a foreign table with
   <xref linkend="sql-createforeigntable">.  In this example we
   wish to access the table named <structname>some_schema.some_table</>
   on the remote server.  The local name for it will
   be <structname>foreign_table</>:

<programlisting>
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</programlisting>

   It's essential that the data types and other properties of the columns
   declared in <command>CREATE FOREIGN TABLE</> match the actual remote table.
   Column names must match as well, unless you attach <literal>column_name</>
   options to the individual columns to show how they are named in the remote
   table.
   In many cases, use of <xref linkend="sql-importforeignschema"> is
   preferable to constructing foreign table definitions manually.
  </para>
____________________________________________________________________________-->
  <para>
   现在就可以使用<xref linkend="sql-createforeigntable"/>创建外部表了。在这个例子中我们希望访问远程服务器上名为<structname>some_schema.some_table</structname>的表。它的本地名称是<structname>foreign_table</structname>：

<programlisting>
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</programlisting>

   <command>CREATE FOREIGN TABLE</command>中声明的列数据类型和其他性质必须要匹配实际的远程表。列名也必须匹配，不过也可以为个别列附上<literal>column_name</literal>选项以表示它们在远程服务器上对应哪个列。在很多情况中，要手工构造外部表定义，使用<xref linkend="sql-importforeignschema"/>会更好。
  </para>
 </sect2>
 
 <sect2>
<!--==========================orignal english content==========================
  <title>Author</title>
____________________________________________________________________________-->
  <title>作者</title>
<!--==========================orignal english content==========================
  <para>
   Shigeru Hanada <email>shigeru.hanada@gmail.com</email>
  </para>
____________________________________________________________________________-->
  <para>
   Shigeru Hanada <email>shigeru.hanada@gmail.com</email>
  </para>
 </sect2>

</sect1>
