<!-- doc/src/sgml/pgcrypto.sgml -->

<sect1 id="pgcrypto" xreflabel="pgcrypto">
<!--==========================orignal english content==========================
 <title>pgcrypto</title>
____________________________________________________________________________-->
 <title>pgcrypto</title>

<!--==========================orignal english content==========================
 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="pgcrypto">
  <primary>encryption</primary>
  <secondary>for specific columns</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="pgcrypto">
  <primary>encryption</primary>
  <secondary>for specific columns</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>pgcrypto</filename> module provides cryptographic functions for
  <productname>PostgreSQL</productname>.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>pgcrypto</filename>模块为<productname>PostgreSQL</productname>提供了密码函数。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>General Hashing Functions</title>
____________________________________________________________________________-->
  <title>普通哈希函数</title>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>digest()</function></title>
____________________________________________________________________________-->
   <title><function>digest()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>digest</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>digest</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
</synopsis>

<!--==========================orignal english content==========================
   <para>
    Computes a binary hash of the given <parameter>data</parameter>.
    <parameter>type</parameter> is the algorithm to use.
    Standard algorithms are <literal>md5</literal>, <literal>sha1</literal>,
    <literal>sha224</literal>, <literal>sha256</literal>,
    <literal>sha384</literal> and <literal>sha512</literal>.
    If <filename>pgcrypto</filename> was built with
    OpenSSL, more algorithms are available, as detailed in
    <xref linkend="pgcrypto-with-without-openssl"/>.
   </para>
____________________________________________________________________________-->
   <para>
    计算一个给定<parameter>data</parameter>的一个二进制哈希值。<parameter>type</parameter>是要使用的算法。标准算法是<literal>md5</literal>、<literal>sha1</literal>、<literal>sha224</literal>、<literal>sha256</literal>、<literal>sha384</literal>和<literal>sha512</literal>。如果使用 OpenSSL 编译了<filename>pgcrypto</filename>，如<xref linkend="pgcrypto-with-without-openssl"/>中所述，有更多算法可用。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you want the digest as a hexadecimal string, use
    <function>encode()</function> on the result.  For example:
<programlisting>
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    如果你想摘要成为一个十六进制字符串，可以在结果上使用<function>encode()</function>。例如：
<programlisting>
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
</programlisting>
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>hmac()</function></title>
____________________________________________________________________________-->
   <title><function>hmac()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>hmac</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>hmac</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
hmac(data text, key text, type text) returns bytea
hmac(data bytea, key bytea, type text) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
hmac(data text, key text, type text) returns bytea
hmac(data bytea, key bytea, type text) returns bytea
</synopsis>

<!--==========================orignal english content==========================
   <para>
    Calculates hashed MAC for <parameter>data</parameter> with key <parameter>key</parameter>.
    <parameter>type</parameter> is the same as in <function>digest()</function>.
   </para>
____________________________________________________________________________-->
   <para>
    为带有密钥<parameter>key</parameter>的<parameter>data</parameter>计算哈希过的 MAC。<parameter>type</parameter>与<function>digest()</function>中相同。
   </para>

<!--==========================orignal english content==========================
   <para>
    This is similar to <function>digest()</function> but the hash can only be
    recalculated knowing the key.  This prevents the scenario of someone
    altering data and also changing the hash to match.
   </para>
____________________________________________________________________________-->
   <para>
    这与<function>digest()</function>相似，但是该哈希只能在知晓密钥的情况下被重新计算出来。这阻止了某人修改数据且还想更改哈希以匹配之的企图。
   </para>

<!--==========================orignal english content==========================
   <para>
    If the key is larger than the hash block size it will first be hashed and
    the result will be used as key.
   </para>
____________________________________________________________________________-->
   <para>
    如果该密钥大于哈希块的尺寸，它将先被哈希然后把结果用作密钥。
   </para>
  </sect3>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Password Hashing Functions</title>
____________________________________________________________________________-->
  <title>口令哈希函数</title>

<!--==========================orignal english content==========================
  <para>
   The functions <function>crypt()</function> and <function>gen_salt()</function>
   are specifically designed for hashing passwords.
   <function>crypt()</function> does the hashing and <function>gen_salt()</function>
   prepares algorithm parameters for it.
  </para>
____________________________________________________________________________-->
  <para>
   函数<function>crypt()</function>和<function>gen_salt()</function>是特别设计用来做口令哈希的。<function>crypt()</function>完成哈希，而<function>gen_salt()</function>负责为前者准备算法参数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The algorithms in <function>crypt()</function> differ from the usual
   MD5 or SHA1 hashing algorithms in the following respects:
  </para>
____________________________________________________________________________-->
  <para>
   <function>crypt()</function>中的算法在以下方面不同于通常的 MD5 或 SHA1 哈希算法：
  </para>

  <orderedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     They are slow.  As the amount of data is so small, this is the only
     way to make brute-forcing passwords hard.
    </para>
____________________________________________________________________________-->
    <para>
     它们很慢。由于数据量很小，这是增加蛮力口令破解难度的唯一方法。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     They use a random value, called the <firstterm>salt</firstterm>, so that users
     having the same password will have different encrypted passwords.
     This is also an additional defense against reversing the algorithm.
    </para>
____________________________________________________________________________-->
    <para>
     它们使用一个随机值（称为<firstterm>salt</firstterm>），这样具有相同口令的用户将得到不同的密文口令。这也是针对逆转算法的一种额外保护。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     They include the algorithm type in the result, so passwords hashed with
     different algorithms can co-exist.
    </para>
____________________________________________________________________________-->
    <para>
     它们会在结果中包括算法类型，这样用不同算法哈希的口令能共存。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Some of them are adaptive &mdash; that means when computers get
     faster, you can tune the algorithm to be slower, without
     introducing incompatibility with existing passwords.
    </para>
____________________________________________________________________________-->
    <para>
     其中一些是自适应的 &mdash; 这意味着当计算机变得更快时，你可以调整该算法变得更慢，而不会产生与现有口令的不兼容。
    </para>
   </listitem>
  </orderedlist>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="pgcrypto-crypt-algorithms"/> lists the algorithms
   supported by the <function>crypt()</function> function.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="pgcrypto-crypt-algorithms"/>列出了<function>crypt()</function>函数所支持的算法。
  </para>

  <table id="pgcrypto-crypt-algorithms">
<!--==========================orignal english content==========================
   <title>Supported Algorithms for <function>crypt()</function></title>
____________________________________________________________________________-->
   <title><function>crypt()</function>支持的算法</title>
   <tgroup cols="6">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Algorithm</entry>
      <entry>Max Password Length</entry>
      <entry>Adaptive?</entry>
      <entry>Salt Bits</entry>
      <entry>Output Length</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>算法</entry>
      <entry>最大口令长度</entry>
      <entry>自适应？</entry>
      <entry>Salt 位数</entry>
      <entry>输出长度</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>bf</literal></entry>
      <entry>72</entry>
      <entry>yes</entry>
      <entry>128</entry>
      <entry>60</entry>
      <entry>Blowfish-based, variant 2a</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>bf</literal></entry>
      <entry>72</entry>
      <entry>yes</entry>
      <entry>128</entry>
      <entry>60</entry>
      <entry>基于 Blowfish，变体 2a</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>md5</literal></entry>
      <entry>unlimited</entry>
      <entry>no</entry>
      <entry>48</entry>
      <entry>34</entry>
      <entry>MD5-based crypt</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>md5</literal></entry>
      <entry>unlimited</entry>
      <entry>no</entry>
      <entry>48</entry>
      <entry>34</entry>
      <entry>基于 MD5 的加密</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>xdes</literal></entry>
      <entry>8</entry>
      <entry>yes</entry>
      <entry>24</entry>
      <entry>20</entry>
      <entry>Extended DES</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>xdes</literal></entry>
      <entry>8</entry>
      <entry>yes</entry>
      <entry>24</entry>
      <entry>20</entry>
      <entry>扩展的 DES</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>des</literal></entry>
      <entry>8</entry>
      <entry>no</entry>
      <entry>12</entry>
      <entry>13</entry>
      <entry>Original UNIX crypt</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>des</literal></entry>
      <entry>8</entry>
      <entry>no</entry>
      <entry>12</entry>
      <entry>13</entry>
      <entry>原生 UNIX 加密</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>crypt()</function></title>
____________________________________________________________________________-->
   <title><function>crypt()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>crypt</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>crypt</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
crypt(password text, salt text) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
crypt(password text, salt text) 返回 text
</synopsis>

<!--==========================orignal english content==========================
   <para>
    Calculates a crypt(3)-style hash of <parameter>password</parameter>.
    When storing a new password, you need to use
    <function>gen_salt()</function> to generate a new <parameter>salt</parameter> value.
    To check a password, pass the stored hash value as <parameter>salt</parameter>,
    and test whether the result matches the stored value.
   </para>
____________________________________________________________________________-->
   <para>
    计算<parameter>password</parameter>的一个 crypt(3) 风格的哈希。在存储一个新口令时，你需要使用<function>gen_salt()</function>产生一个新的<parameter>salt</parameter>值。要检查一个口令，把存储的哈希值作为<parameter>salt</parameter>，并且测试结果是否匹配存储的值。
   </para>
<!--==========================orignal english content==========================
   <para>
    Example of setting a new password:
<programlisting>
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    设置一个新口令的例子：
<programlisting>
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
</programlisting>
   </para>
<!--==========================orignal english content==========================
   <para>
    Example of authentication:
<programlisting>
SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;
</programlisting>
    This returns <literal>true</literal> if the entered password is correct.
   </para>
____________________________________________________________________________-->
   <para>
    认证的例子：
<programlisting>
SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;
</programlisting>
    如果输入的口令正确，这会返回<literal>true</literal>。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>gen_salt()</function></title>
____________________________________________________________________________-->
   <title><function>gen_salt()</function></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>gen_salt</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>gen_salt</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
gen_salt(type text [, iter_count integer ]) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
gen_salt(type text [, iter_count integer ]) 返回 text
</synopsis>

<!--==========================orignal english content==========================
   <para>
    Generates a new random salt string for use in <function>crypt()</function>.
    The salt string also tells <function>crypt()</function> which algorithm to use.
   </para>
____________________________________________________________________________-->
   <para>
    产生一个在<function>crypt()</function>中使用的新随机 salt 字符串。该 salt 字符串也告诉了<function>crypt()</function>要使用哪种算法。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <parameter>type</parameter> parameter specifies the hashing algorithm.
    The accepted types are: <literal>des</literal>, <literal>xdes</literal>,
    <literal>md5</literal> and <literal>bf</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>type</parameter>参数指定哈希算法。可接受的类型是：<literal>des</literal>、<literal>xdes</literal>、<literal>md5</literal>以及<literal>bf</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <parameter>iter_count</parameter> parameter lets the user specify the iteration
    count, for algorithms that have one.
    The higher the count, the more time it takes to hash
    the password and therefore the more time to break it.  Although with
    too high a count the time to calculate a hash may be several years
    &mdash; which is somewhat impractical.  If the <parameter>iter_count</parameter>
    parameter is omitted, the default iteration count is used.
    Allowed values for <parameter>iter_count</parameter> depend on the algorithm and
    are shown in <xref linkend="pgcrypto-icfc-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>iter_count</parameter>参数让用户可以为使用迭代计数的算法指定迭代计数。计数越高，哈希口令花的时间更长并且因而需要更多时间去攻破它。不过使用太高的计数会导致计算一个哈希的时间高达数年 &mdash; 这并不使用。如果<parameter>iter_count</parameter>参数被忽略，将使用默认的迭代计数。允许的<parameter>iter_count</parameter>值与算法相关，如<xref linkend="pgcrypto-icfc-table"/>所示。
   </para>

   <table id="pgcrypto-icfc-table">
<!--==========================orignal english content==========================
    <title>Iteration Counts for <function>crypt()</function></title>
____________________________________________________________________________-->
    <title><function>crypt()</function>的迭代计数</title>
    <tgroup cols="4">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Algorithm</entry>
       <entry>Default</entry>
       <entry>Min</entry>
       <entry>Max</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>算法</entry>
       <entry>默认值</entry>
       <entry>最小值</entry>
       <entry>最大值</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>xdes</literal></entry>
       <entry>725</entry>
       <entry>1</entry>
       <entry>16777215</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>xdes</literal></entry>
       <entry>725</entry>
       <entry>1</entry>
       <entry>16777215</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>bf</literal></entry>
       <entry>6</entry>
       <entry>4</entry>
       <entry>31</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>bf</literal></entry>
       <entry>6</entry>
       <entry>4</entry>
       <entry>31</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    For <literal>xdes</literal> there is an additional limitation that the
    iteration count must be an odd number.
   </para>
____________________________________________________________________________-->
   <para>
    对<literal>xdes</literal>算法还有额外的限制：迭代计数必须是一个奇数。
   </para>

<!--==========================orignal english content==========================
   <para>
    To pick an appropriate iteration count, consider that
    the original DES crypt was designed to have the speed of 4 hashes per
    second on the hardware of that time.
    Slower than 4 hashes per second would probably dampen usability.
    Faster than 100 hashes per second is probably too fast.
   </para>
____________________________________________________________________________-->
   <para>
    要选取一个合适的迭代计数，考虑最初的 DES 加密被设计成在当时的硬件上每秒钟完成 4 次哈希。低于每秒 4 次哈希的速度很可能会损害可用性。而超过每秒 100 次哈希又可能太快了。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="pgcrypto-hash-speed-table"/> gives an overview of the relative slowness
    of different hashing algorithms.
    The table shows how much time it would take to try all
    combinations of characters in an 8-character password, assuming
    that the password contains either only lower case letters, or
    upper- and lower-case letters and numbers.
    In the <literal>crypt-bf</literal> entries, the number after a slash is
    the <parameter>iter_count</parameter> parameter of
    <function>gen_salt</function>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="pgcrypto-hash-speed-table"/>给出了不同哈希算法的相对慢度的综述。该表展示了在假设口令只含有小写字母或者大小写字母及数字的情况下，在一个 8 字符口令中尝试所有字符组合所需要的时间。在<literal>crypt-bf</literal>项中，在一个斜线之后的数字是<function>gen_salt</function>的<parameter>iter_count</parameter>参数
   </para>

   <table id="pgcrypto-hash-speed-table">
<!--==========================orignal english content==========================
    <title>Hash Algorithm Speeds</title>
____________________________________________________________________________-->
    <title>哈希算法速度</title>
    <tgroup cols="5">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Algorithm</entry>
       <entry>Hashes/sec</entry>
       <entry>For <literal>[a-z]</literal></entry>
       <entry>For <literal>[A-Za-z0-9]</literal></entry>
       <entry>Duration relative to <literal>md5 hash</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>算法</entry>
       <entry>次哈希/秒</entry>
       <entry>对于<literal>[a-z]</literal></entry>
       <entry>对于<literal>[A-Za-z0-9]</literal></entry>
       <entry>相对于<literal>md5 hash</literal>的持续时间</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-bf/8</literal></entry>
       <entry>1792</entry>
       <entry>4 years</entry>
       <entry>3927 years</entry>
       <entry>100k</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-bf/8</literal></entry>
       <entry>1792</entry>
       <entry>4 年</entry>
       <entry>3927 年</entry>
       <entry>100k</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-bf/7</literal></entry>
       <entry>3648</entry>
       <entry>2 years</entry>
       <entry>1929 years</entry>
       <entry>50k</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-bf/7</literal></entry>
       <entry>3648</entry>
       <entry>2 年</entry>
       <entry>1929 年</entry>
       <entry>50k</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-bf/6</literal></entry>
       <entry>7168</entry>
       <entry>1 year</entry>
       <entry>982 years</entry>
       <entry>25k</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-bf/6</literal></entry>
       <entry>7168</entry>
       <entry>1 年</entry>
       <entry>982 年</entry>
       <entry>25k</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-bf/5</literal></entry>
       <entry>13504</entry>
       <entry>188 days</entry>
       <entry>521 years</entry>
       <entry>12.5k</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-bf/5</literal></entry>
       <entry>13504</entry>
       <entry>188 天</entry>
       <entry>521 年</entry>
       <entry>12.5k</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-md5</literal></entry>
       <entry>171584</entry>
       <entry>15 days</entry>
       <entry>41 years</entry>
       <entry>1k</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-md5</literal></entry>
       <entry>171584</entry>
       <entry>15 天</entry>
       <entry>41 年</entry>
       <entry>1k</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>crypt-des</literal></entry>
       <entry>23221568</entry>
       <entry>157.5 minutes</entry>
       <entry>108 days</entry>
       <entry>7</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>crypt-des</literal></entry>
       <entry>23221568</entry>
       <entry>157.5 分</entry>
       <entry>108 天</entry>
       <entry>7</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>sha1</literal></entry>
       <entry>37774272</entry>
       <entry>90 minutes</entry>
       <entry>68 days</entry>
       <entry>4</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>sha1</literal></entry>
       <entry>37774272</entry>
       <entry>90 分</entry>
       <entry>68 天</entry>
       <entry>4</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry><literal>md5</literal> (hash)</entry>
       <entry>150085504</entry>
       <entry>22.5 minutes</entry>
       <entry>17 days</entry>
       <entry>1</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><literal>md5</literal>(hash)</entry>
       <entry>150085504</entry>
       <entry>22.5 分</entry>
       <entry>17 天</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Notes:
   </para>
____________________________________________________________________________-->
   <para>
    注意：
   </para>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
     The machine used is an Intel Mobile Core i3.
     </para>
____________________________________________________________________________-->
     <para>
     使用的机器是一台 Intel Mobile Core i3。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>crypt-des</literal> and <literal>crypt-md5</literal> algorithm numbers are
      taken from John the Ripper v1.6.38 <literal>-test</literal> output.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>crypt-des</literal>和<literal>crypt-md5</literal>算法的数字是取自 John the Ripper v1.6.38 <literal>-test</literal>输出。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>md5 hash</literal> numbers are from mdcrack 1.2.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>md5 hash</literal>的数字来自于 mdcrack 1.2。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>sha1</literal> numbers are from lcrack-20031130-beta.
     </para>
____________________________________________________________________________-->
     <para>
      <literal>sha1</literal>的数字来自于 lcrack-20031130-beta.
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>crypt-bf</literal> numbers are taken using a simple program that
      loops over 1000 8-character passwords.  That way I can show the speed
      with different numbers of iterations.  For reference: <literal>john
      -test</literal> shows 13506 loops/sec for <literal>crypt-bf/5</literal>.
      (The very small
      difference in results is in accordance with the fact that the
      <literal>crypt-bf</literal> implementation in <filename>pgcrypto</filename>
      is the same one used in John the Ripper.)
     </para>
____________________________________________________________________________-->
     <para>
      <literal>crypt-bf</literal>的数字是采用一个在 1000 个 8 字符口令上循环的简单程序采集到的。用那种方法我能展示不同迭代次数的速度。供参考：<literal>john-test</literal>对于<literal>crypt-bf/5</literal>显示 13506 次循环/秒（结果中的微小差异符合<filename>pgcrypto</filename>中的<literal>crypt-bf</literal>实现与 John the Ripper 中的一致这一情况）。
     </para>
    </listitem>
   </itemizedlist>

<!--==========================orignal english content==========================
   <para>
    Note that <quote>try all combinations</quote> is not a realistic exercise.
    Usually password cracking is done with the help of dictionaries, which
    contain both regular words and various mutations of them.  So, even
    somewhat word-like passwords could be cracked much faster than the above
    numbers suggest, while a 6-character non-word-like password may escape
    cracking.  Or not.
   </para>
____________________________________________________________________________-->
   <para>
    注意<quote>尝试所有组合</quote>并非是现实中会采用的方式。通常口令破解都是在词典的帮助下完成的，词典中会包含常用词以及它们的多种变化。因此，甚至有些像词的口令被破解的时间可能会大大小于上面建议的数字，而一个 6 字符的不像词的口令可能会逃过破解，也可能不能逃脱。
   </para>
  </sect3>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>PGP Encryption Functions</title>
____________________________________________________________________________-->
  <title>PGP 加密函数</title>

<!--==========================orignal english content==========================
  <para>
   The functions here implement the encryption part of the OpenPGP (RFC 4880)
   standard.  Supported are both symmetric-key and public-key encryption.
  </para>
____________________________________________________________________________-->
  <para>
   这里的函数实现了OpenPGP (RFC 4880) 标准的加密部分。对称密钥和公钥加密都被支持。
  </para>

<!--==========================orignal english content==========================
  <para>
   An encrypted PGP message consists of 2 parts, or <firstterm>packets</firstterm>:
  </para>
____________________________________________________________________________-->
  <para>
   一个加密的 PGP 消息由两个部分或者<firstterm>包</firstterm>组成：
  </para>
  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Packet containing a session key &mdash; either symmetric-key or public-key
     encrypted.
    </para>
____________________________________________________________________________-->
    <para>
     包含一个会话密钥的包 &mdash; 加密过的对称密钥或者公钥。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Packet containing data encrypted with the session key.
    </para>
____________________________________________________________________________-->
    <para>
     包含用会话密钥加密过的数据的包。
    </para>
   </listitem>
  </itemizedlist>

<!--==========================orignal english content==========================
  <para>
   When encrypting with a symmetric key (i.e., a password):
  </para>
____________________________________________________________________________-->
  <para>
   当用一个对称密钥（即一个口令）加密时：
  </para>
  <orderedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     The given password is hashed using a String2Key (S2K) algorithm.  This is
     rather similar to <function>crypt()</function> algorithms &mdash; purposefully
     slow and with random salt &mdash; but it produces a full-length binary
     key.
    </para>
____________________________________________________________________________-->
    <para>
     给定的口令被使用一个 String2Key (S2K) 算法哈希。这更像<function>crypt()</function>算法 &mdash; 有目的地慢并且使用随机 salt &mdash; 但是它会产生一个全长度的二进制密钥。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     If a separate session key is requested, a new random key will be
     generated.  Otherwise the S2K key will be used directly as the session
     key.
    </para>
____________________________________________________________________________-->
    <para>
     如果要求一个独立的会话密钥，将会生成一个新的随机密钥。否则该 S2K 密钥将被直接用作会话密钥。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     If the S2K key is to be used directly, then only S2K settings will be put
     into the session key packet.  Otherwise the session key will be encrypted
     with the S2K key and put into the session key packet.
    </para>
____________________________________________________________________________-->
    <para>
     如果直接使用 S2K 密钥，那么只有 S2K 设置将被放入会话密钥包中。否则会话密钥会用 S2K 密钥加密并且放入会话密钥包中。
    </para>
   </listitem>
  </orderedlist>

<!--==========================orignal english content==========================
  <para>
   When encrypting with a public key:
  </para>
____________________________________________________________________________-->
  <para>
   当使用一个公共密钥加密时：
  </para>
  <orderedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     A new random session key is generated.
    </para>
____________________________________________________________________________-->
    <para>
     一个新的随机会话密钥会被生成。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     It is encrypted using the public key and put into the session key packet.
    </para>
____________________________________________________________________________-->
    <para>
     它被用公共密钥加密并且放入到会话密钥包中。
    </para>
   </listitem>
  </orderedlist>

<!--==========================orignal english content==========================
  <para>
   In either case the data to be encrypted is processed as follows:
  </para>
____________________________________________________________________________-->
  <para>
   在两种情况下，要被加密的数据按下列步骤被处理：
  </para>
  <orderedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Optional data-manipulation: compression, conversion to UTF-8,
     and/or conversion of line-endings.
    </para>
____________________________________________________________________________-->
    <para>
     可选的数据操纵：压缩、转换成 UTF-8 或者行末转换。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     The data is prefixed with a block of random bytes.  This is equivalent
     to using a random IV.
    </para>
____________________________________________________________________________-->
    <para>
     数据会被加上一个随机字节的块作为前缀。这等效于使用一个随机 IV。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     An SHA1 hash of the random prefix and data is appended.
    </para>
____________________________________________________________________________-->
    <para>
     追加一个随机前缀和数据的 SHA1 哈希。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     All this is encrypted with the session key and placed in the data packet.
    </para>
____________________________________________________________________________-->
    <para>
     所有这些都用会话密钥加密并且放在数据包中。
    </para>
   </listitem>
  </orderedlist>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_sym_encrypt()</function></title>
____________________________________________________________________________-->
   <title><function>pgp_sym_encrypt()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_sym_encrypt</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_sym_encrypt</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_sym_encrypt_bytea</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_sym_encrypt_bytea</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
</synopsis>
<!--==========================orignal english content==========================
   <para>
    Encrypt <parameter>data</parameter> with a symmetric PGP key <parameter>psw</parameter>.
    The <parameter>options</parameter> parameter can contain option settings,
    as described below.
   </para>
____________________________________________________________________________-->
   <para>
    使用一个对称 PGP 密钥 <parameter>psw</parameter>加密<parameter>data</parameter>。<parameter>options</parameter>参数可以包含下文所述的选项设置。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_sym_decrypt()</function></title>
____________________________________________________________________________-->
   <title><function>pgp_sym_decrypt()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_sym_decrypt</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_sym_decrypt</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_sym_decrypt_bytea</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_sym_decrypt_bytea</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_sym_decrypt(msg bytea, psw text [, options text ]) 返回 text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
</synopsis>
<!--==========================orignal english content==========================
   <para>
    Decrypt a symmetric-key-encrypted PGP message.
   </para>
____________________________________________________________________________-->
   <para>
    解密一个用对称密钥加密过的 PGP 消息。
   </para>
<!--==========================orignal english content==========================
   <para>
    Decrypting <type>bytea</type> data with <function>pgp_sym_decrypt</function> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_sym_decrypt_bytea</function> is fine.
   </para>
____________________________________________________________________________-->
   <para>
    不允许使用<function>pgp_sym_decrypt</function>解密<type>bytea</type>数据。这是为了避免输出非法的字符数据。使用<function>pgp_sym_decrypt_bytea</function>解密原始文本数据是好的。
   </para>
<!--==========================orignal english content==========================
   <para>
    The <parameter>options</parameter> parameter can contain option settings,
    as described below.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>options</parameter>参数可以包含下文所述的选项设置。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_pub_encrypt()</function></title>
____________________________________________________________________________-->
   <title><function>pgp_pub_encrypt()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_pub_encrypt</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_pub_encrypt</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_pub_encrypt_bytea</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_pub_encrypt_bytea</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
</synopsis>
<!--==========================orignal english content==========================
   <para>
    Encrypt <parameter>data</parameter> with a public PGP key <parameter>key</parameter>.
    Giving this function a secret key will produce an error.
   </para>
____________________________________________________________________________-->
   <para>
    用一个公共 PGP 密钥 <parameter>key</parameter>加密<parameter>data</parameter>。给这个函数一个私钥会产生一个错误。
   </para>
<!--==========================orignal english content==========================
   <para>
    The <parameter>options</parameter> parameter can contain option settings,
    as described below.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>options</parameter>参数可以包含下文所述的选项设置。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_pub_decrypt()</function></title>
____________________________________________________________________________-->
   <title><function>pgp_pub_decrypt()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_pub_decrypt</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_pub_decrypt</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_pub_decrypt_bytea</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_pub_decrypt_bytea</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) 返回 text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea
</synopsis>
<!--==========================orignal english content==========================
   <para>
    Decrypt a public-key-encrypted message.  <parameter>key</parameter> must be the
    secret key corresponding to the public key that was used to encrypt.
    If the secret key is password-protected, you must give the password in
    <parameter>psw</parameter>.  If there is no password, but you want to specify
    options, you need to give an empty password.
   </para>
____________________________________________________________________________-->
   <para>
    解密一个公共密钥加密的消息。<parameter>key</parameter>必须是对应于用来加密的公钥的私钥。如果私钥是用口令保护的，你必须在<parameter>psw</parameter>中给出该口令。如果没有口令，但你想要指定选项，你需要给出一个空口令。
   </para>
<!--==========================orignal english content==========================
   <para>
    Decrypting <type>bytea</type> data with <function>pgp_pub_decrypt</function> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_pub_decrypt_bytea</function> is fine.
   </para>
____________________________________________________________________________-->
   <para>
    不允许使用<function>pgp_pub_decrypt</function>解密<type>bytea</type>数据。这是为了避免输出非法的字符数据。使用<function>pgp_pub_decrypt_bytea</function>解密原始文本数据是好的。
   </para>
<!--==========================orignal english content==========================
   <para>
    The <parameter>options</parameter> parameter can contain option settings,
    as described below.
   </para>
____________________________________________________________________________-->
   <para>
    <parameter>options</parameter>参数可以包含下文所述的选项设置。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_key_id()</function></title>
____________________________________________________________________________-->
   <title><function>pgp_key_id()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_key_id</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_key_id</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_key_id(bytea) returns text
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_key_id(bytea) 返回 text
</synopsis>
<!--==========================orignal english content==========================
   <para>
    <function>pgp_key_id</function> extracts the key ID of a PGP public or secret key.
    Or it gives the key ID that was used for encrypting the data, if given
    an encrypted message.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pgp_key_id</function>抽取一个 PGP 公钥或私钥的密钥 ID。或者如果给定了一个加密过的消息，它给出一个用来加密数据的密钥 ID。
   </para>
<!--==========================orignal english content==========================
   <para>
    It can return 2 special key IDs:
   </para>
____________________________________________________________________________-->
   <para>
    它能够返回 2 个特殊密钥 ID：
   </para>
   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>SYMKEY</literal>
     </para>
____________________________________________________________________________-->
     <para>
      <literal>SYMKEY</literal>
     </para>
<!--==========================orignal english content==========================
     <para>
      The message is encrypted with a symmetric key.
     </para>
____________________________________________________________________________-->
     <para>
      该消息是用一个对称密钥加密的。
     </para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <literal>ANYKEY</literal>
     </para>
____________________________________________________________________________-->
     <para>
      <literal>ANYKEY</literal>
     </para>
<!--==========================orignal english content==========================
     <para>
      The message is public-key encrypted, but the key ID has been removed.
      That means you will need to try all your secret keys on it to see
      which one decrypts it.  <filename>pgcrypto</filename> itself does not produce
      such messages.
     </para>
____________________________________________________________________________-->
     <para>
      该消息是用公钥加密的，但是密钥 ID 已经被移除。这意味着你将需要尝试你所有的密钥来看看哪个能解密该消息。<filename>pgcrypto</filename>本身不产生这样的消息。
     </para>
    </listitem>
   </itemizedlist>
<!--==========================orignal english content==========================
   <para>
    Note that different keys may have the same ID.   This is rare but a normal
    event. The client application should then try to decrypt with each one,
    to see which fits &mdash; like handling <literal>ANYKEY</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    注意不同的密钥可能具有相同的 ID。这很少见但是是一种正常事件。客户端应用则应该尝试用每一个去解密，看看哪个合适 &mdash; 像处理<literal>ANYKEY</literal>一样。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>armor()</function>, <function>dearmor()</function></title>
____________________________________________________________________________-->
   <title><function>armor()</function>, <function>dearmor()</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>armor</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>armor</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>dearmor</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>dearmor</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
armor(data bytea [ , keys text[], values text[] ]) 返回 text
dearmor(data text) returns bytea
</synopsis>
<!--==========================orignal english content==========================
   <para>
    These functions wrap/unwrap binary data into PGP ASCII-armor format,
    which is basically Base64 with CRC and additional formatting.
   </para>
____________________________________________________________________________-->
   <para>
    这些函数把二进制数据包装/解包成 PGP ASCII-armored 格式，其基本上是带有 CRC 和额外格式化的 Base64。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    If the <parameter>keys</parameter> and <parameter>values</parameter> arrays are specified,
    an <firstterm>armor header</firstterm> is added to the armored format for each
    key/value pair. Both arrays must be single-dimensional, and they must
    be of the same length.  The keys and values cannot contain any non-ASCII
    characters.
   </para>
____________________________________________________________________________-->
   <para>
    如果指定了<parameter>keys</parameter>和<parameter>values</parameter>数组，每一个
    键/值对的 armored 格式上会增加一个<firstterm>armor header</firstterm>。两个
    数组都必须是单一维度的，并且它们的长度必须相同。键和值不能包含任何
    非 ASCII 字符。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title><function>pgp_armor_headers</function></title>
____________________________________________________________________________-->
   <title><function>pgp_armor_headers</function></title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>pgp_armor_headers</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>pgp_armor_headers</primary>
   </indexterm>

<!--==========================orignal english content==========================
<synopsis>
pgp_armor_headers(data text, key out text, value out text) returns setof record
</synopsis>
____________________________________________________________________________-->
<synopsis>
pgp_armor_headers(data text, key out text, value out text) returns setof record
</synopsis>
<!--==========================orignal english content==========================
   <para>
    <function>pgp_armor_headers()</function> extracts the armor headers from
    <parameter>data</parameter>.  The return value is a set of rows with two columns,
    key and value.  If the keys or values contain any non-ASCII characters,
    they are treated as UTF-8.
   </para>
____________________________________________________________________________-->
   <para>
    <function>pgp_armor_headers()</function>从<parameter>data</parameter>中抽取
    armor header。返回值是一个有两列的行集合，包括键和值。如果键或值
    包含任何非-ASCII 字符，它们会被视作 UTF-8。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Options for PGP Functions</title>
____________________________________________________________________________-->
   <title>PGP 函数的选项</title>

<!--==========================orignal english content==========================
   <para>
    Options are named to be similar to GnuPG.  An option's value should be
    given after an equal sign; separate options from each other with commas.
    For example:
<programlisting>
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    选项被命名为与 GnuPG 类似的形式。一个选项的值应该在一个等号后给出，各个选项之间用逗号分隔。例如：
<programlisting>
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    All of the options except <literal>convert-crlf</literal> apply only to
    encrypt functions.  Decrypt functions get the parameters from the PGP
    data.
   </para>
____________________________________________________________________________-->
   <para>
    除了<literal>convert-crlf</literal>之外所有这些选项只适用于加密函数。解密函数会从 PGP 数据中得到这些参数。
   </para>

<!--==========================orignal english content==========================
   <para>
    The most interesting options are probably
    <literal>compress-algo</literal> and <literal>unicode-mode</literal>.
    The rest should have reasonable defaults.
   </para>
____________________________________________________________________________-->
   <para>
    最有趣的选项可能是<literal>compress-algo</literal>和<literal>unicode-mode</literal>。其余的应该可以使用合理的默认值。
   </para>

  <sect4>
<!--==========================orignal english content==========================
   <title>cipher-algo</title>
____________________________________________________________________________-->
   <title>cipher-algo</title>

<!--==========================orignal english content==========================
   <para>
    Which cipher algorithm to use.
   </para>
____________________________________________________________________________-->
   <para>
    要用哪个密码算法。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: bf, aes128, aes192, aes256 (OpenSSL-only: <literal>3des</literal>, <literal>cast5</literal>)
Default: aes128
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：bf, aes128, aes192, aes256 (只用于 OpenSSL：<literal>3des</literal>, <literal>cast5</literal>)
默认：aes128
适用于：pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>compress-algo</title>
____________________________________________________________________________-->
   <title>compress-algo</title>

<!--==========================orignal english content==========================
   <para>
    Which compression algorithm to use.  Only available if
    <productname>PostgreSQL</productname> was built with zlib.
   </para>
____________________________________________________________________________-->
   <para>
    要使用哪种压缩算法。只有<productname>PostgreSQL</productname>编译时使用了 zlib 时才可用。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values:
  0 - no compression
  1 - ZIP compression
  2 - ZLIB compression (= ZIP plus meta-data and block CRCs)
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：
  0 - 不压缩
  1 - ZIP 压缩
  2 - ZLIB 压缩 （= ZIP 外加元数据和块 CRC）
默认：0
适用于：pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>compress-level</title>
____________________________________________________________________________-->
   <title>compress-level</title>

<!--==========================orignal english content==========================
   <para>
    How much to compress.  Higher levels compress smaller but are slower.
    0 disables compression.
   </para>
____________________________________________________________________________-->
   <para>
    压缩多少。级别越高压缩得越小但是速度也越慢。0 表示禁用压缩。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: 0, 1-9
Default: 6
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：0, 1-9
默认：6
适用于：pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>convert-crlf</title>
____________________________________________________________________________-->
   <title>convert-crlf</title>

<!--==========================orignal english content==========================
   <para>
    Whether to convert <literal>\n</literal> into <literal>\r\n</literal> when
    encrypting and <literal>\r\n</literal> to <literal>\n</literal> when
    decrypting.  RFC 4880 specifies that text data should be stored using
    <literal>\r\n</literal> line-feeds.  Use this to get fully RFC-compliant
    behavior.
   </para>
____________________________________________________________________________-->
   <para>
    加密时是否把<literal>\n</literal>转换成<literal>\r\n</literal>以及解密时是否把<literal>\r\n</literal>转换成<literal>\n</literal>。RFC 4880 指定文本数据存储时应该使用<literal>\r\n</literal>换行。使用这个选项能够得到完全 RFC 兼容的行为。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：0, 1
默认：0
适用于：pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>disable-mdc</title>
____________________________________________________________________________-->
   <title>disable-mdc</title>

<!--==========================orignal english content==========================
   <para>
    Do not protect data with SHA-1.  The only good reason to use this
    option is to achieve compatibility with ancient PGP products, predating
    the addition of SHA-1 protected packets to RFC 4880.
    Recent gnupg.org and pgp.com software supports it fine.
   </para>
____________________________________________________________________________-->
   <para>
    不用 SHA-1 保护数据。使用这个选项的唯一好的理由是实现与古董级别 PGP 产品的兼容，这些产品在受 SHA-1 保护的包被加入到 RFC 4880 之前就已经存在了。最近的 gnupg.org 和 pgp.com 软件能很好地支持它。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：0，1
默认：0
适用于：pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>sess-key</title>
____________________________________________________________________________-->
   <title>sess-key</title>

<!--==========================orignal english content==========================
   <para>
    Use separate session key.  Public-key encryption always uses a separate
    session key; this option is for symmetric-key encryption, which by default
    uses the S2K key directly.
   </para>
____________________________________________________________________________-->
   <para>
    使用单独的会话密钥。公钥加密总是使用一个单独的会话密钥。这个选项是用于对称密钥加密的，对称密钥加密默认直接使用 S2K 密钥。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：0，1
默认：0
适用于：pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>s2k-mode</title>
____________________________________________________________________________-->
   <title>s2k-mode</title>

<!--==========================orignal english content==========================
   <para>
    Which S2K algorithm to use.
   </para>
____________________________________________________________________________-->
   <para>
    要使用哪一种 S2K 算法。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values:
  0 - Without salt.  Dangerous!
  1 - With salt but with fixed iteration count.
  3 - Variable iteration count.
Default: 3
Applies to: pgp_sym_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：
  0 - 不用 salt。危险！
  1 - 用 salt 但是使用固定的迭代计数。
  3 - 可变的迭代计数。
默认：3
适用于：pgp_sym_encrypt
</literallayout>
  </sect4>
  
  <sect4>
<!--==========================orignal english content==========================
   <title>s2k-count</title>
____________________________________________________________________________-->
   <title>s2k-count</title>

<!--==========================orignal english content==========================
   <para>
    The number of iterations of the S2K algorithm to use.  It must
    be a value between 1024 and 65011712, inclusive.
   </para>
____________________________________________________________________________-->
   <para>
    S2K 算法要使用的迭代次数。它必须是一个位于 1024 和 65011712 之间的值，
    首尾两个值包括在内。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Default: A random value between 65536 and 253952
Applies to: pgp_sym_encrypt, only with s2k-mode=3
</literallayout>
____________________________________________________________________________-->
<literallayout>
默认：65536 和 253952 之间的一个随机值
适用于：pgp_sym_encrypt，只能用于 s2k-mode=3
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>s2k-digest-algo</title>
____________________________________________________________________________-->
   <title>s2k-digest-algo</title>

<!--==========================orignal english content==========================
   <para>
    Which digest algorithm to use in S2K calculation.
   </para>
____________________________________________________________________________-->
   <para>
    要在 S2K 计算中使用哪种摘要算法。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: md5, sha1
Default: sha1
Applies to: pgp_sym_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：md5, sha1
默认：sha1
适用于：pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>s2k-cipher-algo</title>
____________________________________________________________________________-->
   <title>s2k-cipher-algo</title>

<!--==========================orignal english content==========================
   <para>
    Which cipher to use for encrypting separate session key.
   </para>
____________________________________________________________________________-->
   <para>
    要用哪种密码来加密独立的会话密钥。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: bf, aes, aes128, aes192, aes256
Default: use cipher-algo
Applies to: pgp_sym_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：bf, aes, aes128, aes192, aes256
默认：use cipher-algo
适用于：pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
<!--==========================orignal english content==========================
   <title>unicode-mode</title>
____________________________________________________________________________-->
   <title>unicode-mode</title>

<!--==========================orignal english content==========================
   <para>
    Whether to convert textual data from database internal encoding to
    UTF-8 and back.  If your database already is UTF-8, no conversion will
    be done, but the message will be tagged as UTF-8.  Without this option
    it will not be.
   </para>
____________________________________________________________________________-->
   <para>
    是否把文本数据在数据库内部编码和 UTF-8 之间来回转换。如果你的数据库已经是 UTF-8，将不会转换，但是消息将被标记为 UTF-8。没有这个选项它将不会被标记。
   </para>
<!--==========================orignal english content==========================
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
____________________________________________________________________________-->
<literallayout>
值：0，1
默认：0
适用于：pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>
  </sect3>

 <sect3>
<!--==========================orignal english content==========================
  <title>Generating PGP Keys with GnuPG</title>
____________________________________________________________________________-->
  <title>用 GnuPG 生成 PGP 密钥</title>

<!--==========================orignal english content==========================
  <para>
   To generate a new key:
<programlisting>
gpg -&minus;gen-key
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要生成一个新密钥：
<programlisting>
gpg --gen-key
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   The preferred key type is <quote>DSA and Elgamal</quote>.
  </para>
____________________________________________________________________________-->
  <para>
   更好的密钥类型是<quote>DSA 和 Elgamal</quote>。
  </para>
<!--==========================orignal english content==========================
  <para>
   For RSA encryption you must create either DSA or RSA sign-only key
   as master and then add an RSA encryption subkey with
   <literal>gpg -&minus;edit-key</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   对于 RSA 密钥，你必须创建仅用于签名的 DSA 或 RSA 密钥作为主控密钥，然后用<literal>gpg --edit-key</literal>增加一个 RSA 加密子密钥。
  </para>
<!--==========================orignal english content==========================
  <para>
   To list keys:
<programlisting>
gpg -&minus;list-secret-keys
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要列举密钥：
<programlisting>
gpg --list-secret-keys
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   To export a public key in ASCII-armor format:
<programlisting>
gpg -a -&minus;export KEYID > public.key
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要以 ASCII-保护格式导出一个公钥：
<programlisting>
gpg -a --export KEYID > public.key
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   To export a secret key in ASCII-armor format:
<programlisting>
gpg -a -&minus;export-secret-keys KEYID > secret.key
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   要以 ASCII-保护格式导出一个私钥：
<programlisting>
gpg -a --export-secret-keys KEYID > secret.key
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   You need to use <function>dearmor()</function> on these keys before giving them to
   the PGP functions.  Or if you can handle binary data, you can drop
   <literal>-a</literal> from the command.
  </para>
____________________________________________________________________________-->
  <para>
   在把这些密钥交给 PGP 函数之前，你需要对它们使用<function>dearmor()</function>。或者如果你能处理二进制数据，你可以从命令中去掉<literal>-a</literal>。
  </para>
<!--==========================orignal english content==========================
  <para>
   For more details see <literal>man gpg</literal>,
   <ulink url="https://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink> and other documentation on
   <ulink url="https://www.gnupg.org/"></ulink>.
  </para>
____________________________________________________________________________-->
  <para>
   更多细节请参考<literal>man gpg</literal>、
   <ulink url="https://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink>以及
   <ulink url="https://www.gnupg.org/"></ulink>上的其他文档。
  </para>
 </sect3>

 <sect3>
<!--==========================orignal english content==========================
  <title>Limitations of PGP Code</title>
____________________________________________________________________________-->
  <title>PGP 代码的限制</title>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    No support for signing.  That also means that it is not checked
    whether the encryption subkey belongs to the master key.
    </para>
____________________________________________________________________________-->
    <para>
    不支持签名。这也意味着它不检查加密子密钥是否属于主控密钥。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    No support for encryption key as master key.  As such practice
    is generally discouraged, this should not be a problem.
    </para>
____________________________________________________________________________-->
    <para>
    不支持加密密钥作为主控密钥。由于通常并不鼓励那种用法，这应该不是问题。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    No support for several subkeys.  This may seem like a problem, as this
    is common practice.  On the other hand, you should not use your regular
    GPG/PGP keys with <filename>pgcrypto</filename>, but create new ones,
    as the usage scenario is rather different.
    </para>
____________________________________________________________________________-->
    <para>
    不支持多个子密钥。这可能看起来像一个问题，因为在实践中普遍需要多个子密钥。在另一方面，你不能把你的常规 GPG/PGP 密钥用于<filename>pgcrypto</filename>，而是创建一些新的密钥，因为使用场景相当不同。
    </para>
   </listitem>
  </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Raw Encryption Functions</title>
____________________________________________________________________________-->
  <title>原始的加密函数</title>

<!--==========================orignal english content==========================
  <para>
   These functions only run a cipher over data; they don't have any advanced
   features of PGP encryption.  Therefore they have some major problems:
  </para>
____________________________________________________________________________-->
  <para>
   这些函数只在数据上运行一次加密，它们不具有 PGP 加密的任何先进特性。因此它们有一些主要的问题：
  </para>
  <orderedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    They use user key directly as cipher key.
    </para>
____________________________________________________________________________-->
    <para>
    它们直接把用户密钥用作加密密钥。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    They don't provide any integrity checking, to see
    if the encrypted data was modified.
    </para>
____________________________________________________________________________-->
    <para>
    它们不提供任何完整性检查来查看被加密数据是否被修改。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    They expect that users manage all encryption parameters
    themselves, even IV.
    </para>
____________________________________________________________________________-->
    <para>
    它们希望用户自己管理所有加密参数，甚至是 IV。
    </para>
   </listitem>
   <listitem>
<!--==========================orignal english content==========================
    <para>
    They don't handle text.
    </para>
____________________________________________________________________________-->
    <para>
    它们无法处理文本。
    </para>
   </listitem>
  </orderedlist>
<!--==========================orignal english content==========================
  <para>
   So, with the introduction of PGP encryption, usage of raw
   encryption functions is discouraged.
  </para>
____________________________________________________________________________-->
  <para>
   因此，在介绍了 PGP 加密后，我们不鼓励使用原始的加密函数。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>encrypt</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>encrypt</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>decrypt</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>decrypt</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>encrypt_iv</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>encrypt_iv</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>decrypt_iv</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>decrypt_iv</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
</synopsis>

<!--==========================orignal english content==========================
  <para>
   Encrypt/decrypt data using the cipher method specified by
   <parameter>type</parameter>.  The syntax of the
   <parameter>type</parameter> string is:

<synopsis>
<replaceable>algorithm</replaceable> <optional> <literal>-</literal> <replaceable>mode</replaceable> </optional> <optional> <literal>/pad:</literal> <replaceable>padding</replaceable> </optional>
</synopsis>
   where <replaceable>algorithm</replaceable> is one of:

  <itemizedlist>
   <listitem><para><literal>bf</literal> &mdash; Blowfish</para></listitem>
   <listitem><para><literal>aes</literal> &mdash; AES (Rijndael-128, -192 or -256)</para></listitem>
  </itemizedlist>
   and <replaceable>mode</replaceable> is one of:
  <itemizedlist>
   <listitem>
    <para>
    <literal>cbc</literal> &mdash; next block depends on previous (default)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>ecb</literal> &mdash; each block is encrypted separately (for
    testing only)
    </para>
   </listitem>
  </itemizedlist>
   and <replaceable>padding</replaceable> is one of:
  <itemizedlist>
   <listitem>
    <para>
    <literal>pkcs</literal> &mdash; data may be any length (default)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>none</literal> &mdash; data must be multiple of cipher block size
    </para>
   </listitem>
  </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   使用<parameter>type</parameter>指定的密码方法加密/解密数据。<parameter>type</parameter>字符串的语法是：

<synopsis>
<replaceable>algorithm</replaceable> <optional> <literal>-</literal> <replaceable>mode</replaceable> </optional> <optional> <literal>/pad:</literal> <replaceable>padding</replaceable> </optional>
</synopsis>
   其中<replaceable>algorithm</replaceable>是下列之一：

  <itemizedlist>
   <listitem><para><literal>bf</literal> &mdash; Blowfish</para></listitem>
   <listitem><para><literal>aes</literal> &mdash; AES (Rijndael-128, -192 或 -256)</para></listitem>
  </itemizedlist>
   并且<replaceable>mode</replaceable>是下列之一：
  <itemizedlist>
   <listitem>
    <para>
    <literal>cbc</literal> &mdash; 下一个块依赖前一个（默认）
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>ecb</literal> &mdash; 每一个块被独立加密（只用于测试）
    </para>
   </listitem>
  </itemizedlist>
   并且<replaceable>padding</replaceable>是下列之一：
  <itemizedlist>
   <listitem>
    <para>
    <literal>pkcs</literal> &mdash; 数据可以是任意长度（默认）
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>none</literal> &mdash; 数据必须是密码块尺寸的倍数
    </para>
   </listitem>
  </itemizedlist>
  </para>
<!--==========================orignal english content==========================
  <para>
   So, for example, these are equivalent:
<programlisting>
encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   因此，例如这些是等效的：
<programlisting>
encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
</programlisting>
  </para>
<!--==========================orignal english content==========================
  <para>
   In <function>encrypt_iv</function> and <function>decrypt_iv</function>, the
   <parameter>iv</parameter> parameter is the initial value for the CBC mode;
   it is ignored for ECB.
   It is clipped or padded with zeroes if not exactly block size.
   It defaults to all zeroes in the functions without this parameter.
  </para>
____________________________________________________________________________-->
  <para>
   在<function>encrypt_iv</function>和<function>decrypt_iv</function>中，<parameter>iv</parameter>参数是 CBC 模式的初始值，ECB 会忽略它。如果不是准确的块尺寸，它会被修剪或用零填充。在没有这个参数的函数中，它的值都被默认为零。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Random-Data Functions</title>
____________________________________________________________________________-->
  <title>随机数据函数</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>gen_random_bytes</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>gen_random_bytes</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
gen_random_bytes(count integer) returns bytea
</synopsis>
____________________________________________________________________________-->
<synopsis>
gen_random_bytes(count integer) returns bytea
</synopsis>
<!--==========================orignal english content==========================
  <para>
   Returns <parameter>count</parameter> cryptographically strong random bytes.
   At most 1024 bytes can be extracted at a time.  This is to avoid
   draining the randomness generator pool.
  </para>
____________________________________________________________________________-->
  <para>
   返回<parameter>count</parameter>个密码上强壮的随机字节。一次最多可以抽取 1024 个字节。这是为了避免耗尽随机数发生池。
  </para>
  
<!--==========================orignal english content==========================
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

<!--==========================orignal english content==========================
<synopsis>
gen_random_uuid() returns uuid
</synopsis>
____________________________________________________________________________-->
<synopsis>
gen_random_uuid() 返回 uuid
</synopsis>
<!--==========================orignal english content==========================
  <para>
   Returns a version 4 (random) UUID.
  </para>
____________________________________________________________________________-->
  <para>
   返回一个版本 4 的（随机的）UUID。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Notes</title>
____________________________________________________________________________-->
  <title>注解</title>

  <sect3>
<!--==========================orignal english content==========================
   <title>Configuration</title>
____________________________________________________________________________-->
   <title>配置</title>

<!--==========================orignal english content==========================
   <para>
    <filename>pgcrypto</filename> configures itself according to the findings of the
    main PostgreSQL <literal>configure</literal> script.  The options that
    affect it are <literal>-&minus;with-zlib</literal> and
    <literal>-&minus;with-openssl</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <filename>pgcrypto</filename>会根据查找主 PostgreSQL <literal>configure</literal>脚本配置它自身。影响它的选项是<literal>--with-zlib</literal>以及<literal>--with-openssl</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    When compiled with zlib, PGP encryption functions are able to
    compress data before encrypting.
   </para>
____________________________________________________________________________-->
   <para>
    在编译了 zlib 时，PGP 加密函数能够在加密前压缩数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    When compiled with OpenSSL, there will be more algorithms available.
    Also public-key encryption functions will be faster as OpenSSL
    has more optimized BIGNUM functions.
   </para>
____________________________________________________________________________-->
   <para>
    在编译了 OpenSSL 时，会有更多可用算法。公钥加密函数也会更快，因为 OpenSSL 有优化得更好的 BIGNUM 函数。
   </para>

   <table id="pgcrypto-with-without-openssl">
<!--==========================orignal english content==========================
    <title>Summary of Functionality with and without OpenSSL</title>
____________________________________________________________________________-->
    <title>使用和不用 OpenSSL 的功能总结</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Functionality</entry>
       <entry>Built-in</entry>
       <entry>With OpenSSL</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>功能</entry>
       <entry>内建</entry>
       <entry>使用 OpenSSL</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>MD5</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>MD5</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>SHA1</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>SHA1</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>Other digest algorithms</entry>
       <entry>no</entry>
       <entry>yes (Note 1)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>其他摘要算法</entry>
       <entry>no</entry>
       <entry>yes (注意 1)</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>Blowfish</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>Blowfish</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>AES</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>AES</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>no</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>no</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>Raw encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>原始加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>PGP Symmetric encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>PGP 对称加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
<!--==========================orignal english content==========================
      <row>
       <entry>PGP Public-Key encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>PGP 公钥加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Notes:
   </para>
____________________________________________________________________________-->
   <para>
    注意：
   </para>

   <orderedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      Any digest algorithm OpenSSL supports is automatically picked up.
      This is not possible with ciphers, which need to be supported
      explicitly.
     </para>
____________________________________________________________________________-->
     <para>
      OpenSSL 支持的任何摘要算法都是自动选取的。这对于使用密码来说是不可能的，因为需要被显式地支持。
     </para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>NULL Handling</title>
____________________________________________________________________________-->
   <title>NULL 处理</title>

<!--==========================orignal english content==========================
   <para>
    As is standard in SQL, all functions return NULL, if any of the arguments
    are NULL.  This may create security risks on careless usage.
   </para>
____________________________________________________________________________-->
   <para>
    按照 SQL 中的标准，只要任何参数是 NULL， 所有的函数都会返回 NULL。在不当使用时这可能会导致安全风险。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Security Limitations</title>
____________________________________________________________________________-->
   <title>安全性限制</title>

<!--==========================orignal english content==========================
   <para>
    All <filename>pgcrypto</filename> functions run inside the database server.
    That means that all
    the data and passwords move between <filename>pgcrypto</filename> and client
    applications in clear text.  Thus you must:
   </para>
____________________________________________________________________________-->
   <para>
    所有<filename>pgcrypto</filename>函数都在数据库服务器内部运行。这意味着在<filename>pgcrypto</filename>和客户端应用之间移动的所有数据和口令都是明文。因此，你必须：
   </para>

   <orderedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para>Connect locally or use SSL connections.</para>
____________________________________________________________________________-->
     <para>本地连接或者使用 SSL 连接。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>Trust both system and database administrator.</para>
____________________________________________________________________________-->
     <para>信任系统管理员和数据库管理员。</para>
    </listitem>
   </orderedlist>

<!--==========================orignal english content==========================
   <para>
    If you cannot, then better do crypto inside client application.
   </para>
____________________________________________________________________________-->
   <para>
    如果你不能这样做，那么最好在客户端应用中进行加密。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    The implementation does not resist
    <ulink url="https://en.wikipedia.org/wiki/Side-channel_attack">side-channel
    attacks</ulink>.  For example, the time required for
    a <filename>pgcrypto</filename> decryption function to complete varies among
    ciphertexts of a given size.
   </para>
____________________________________________________________________________-->
   <para>
    该实现无法抵抗
    <ulink url="https://en.wikipedia.org/wiki/Side-channel_attack">
    侧信道攻击</ulink>。例如，一个<filename>pgcrypto</filename>解密函
    数完成所需的时间是随着密文尺寸变化的。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Useful Reading</title>
____________________________________________________________________________-->
   <title>有益的读物</title>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="https://www.gnupg.org/gph/en/manual.html"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="https://www.gnupg.org/gph/en/manual.html"></ulink></para>
<!--==========================orignal english content==========================
     <para>The GNU Privacy Handbook.</para>
____________________________________________________________________________-->
     <para>The GNU Privacy Handbook.</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="http://www.openwall.com/crypt/"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="http://www.openwall.com/crypt/"></ulink></para>
<!--==========================orignal english content==========================
     <para>Describes the crypt-blowfish algorithm.</para>
____________________________________________________________________________-->
     <para>描述 crypt-blowfish 算法。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <ulink url="http://www.iusmentis.com/security/passphrasefaq/"></ulink>
     </para>
____________________________________________________________________________-->
     <para>
      <ulink url="http://www.iusmentis.com/security/passphrasefaq/"></ulink>
     </para>
<!--==========================orignal english content==========================
     <para>How to choose a good password.</para>
____________________________________________________________________________-->
     <para>如何选取一个好的口令。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="http://world.std.com/~reinhold/diceware.html"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="http://world.std.com/~reinhold/diceware.html"></ulink></para>
<!--==========================orignal english content==========================
     <para>Interesting idea for picking passwords.</para>
____________________________________________________________________________-->
     <para>选择口令的有趣的想法。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>
     </para>
____________________________________________________________________________-->
     <para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>
     </para>
<!--==========================orignal english content==========================
     <para>Describes good and bad cryptography.</para>
____________________________________________________________________________-->
     <para>描述好的和不好的加密。</para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Technical References</title>
____________________________________________________________________________-->
   <title>技术性参考</title>

   <itemizedlist>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="https://tools.ietf.org/html/rfc4880"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="https://tools.ietf.org/html/rfc4880"></ulink></para>
<!--==========================orignal english content==========================
     <para>OpenPGP message format.</para>
____________________________________________________________________________-->
     <para>OpenPGP 消息格式。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="https://tools.ietf.org/html/rfc1321"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="https://tools.ietf.org/html/rfc1321"></ulink></para>
<!--==========================orignal english content==========================
     <para>The MD5 Message-Digest Algorithm.</para>
____________________________________________________________________________-->
     <para>MD5 消息摘要算法。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="https://tools.ietf.org/html/rfc2104"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="https://tools.ietf.org/html/rfc2104"></ulink></para>
<!--==========================orignal english content==========================
     <para>HMAC: Keyed-Hashing for Message Authentication.</para>
____________________________________________________________________________-->
     <para>HMAC：用于消息认证的钥控哈希。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <ulink url="https://www.usenix.org/legacy/events/usenix99/provos.html"></ulink>
     </para>
____________________________________________________________________________-->
     <para>
      <ulink url="https://www.usenix.org/legacy/events/usenix99/provos.html"></ulink>
     </para>
<!--==========================orignal english content==========================
     <para>Comparison of crypt-des, crypt-md5 and bcrypt algorithms.</para>
____________________________________________________________________________-->
     <para>crypt-des、crypt-md5 以及 bcrypt 算法的比较。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <ulink url="https://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>
     </para>
____________________________________________________________________________-->
     <para>
      <ulink url="https://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>
     </para>
<!--==========================orignal english content==========================
     <para>Description of Fortuna CSPRNG.</para>
____________________________________________________________________________-->
     <para>Fortuna CSPRNG 的描述。</para>
    </listitem>
    <listitem>
<!--==========================orignal english content==========================
     <para><ulink url="http://jlcooke.ca/random/"></ulink></para>
____________________________________________________________________________-->
     <para><ulink url="http://jlcooke.ca/random/"></ulink></para>
<!--==========================orignal english content==========================
     <para>Jean-Luc Cooke Fortuna-based <filename>/dev/random</filename> driver for Linux.</para>
____________________________________________________________________________-->
     <para>Linux 的 Jean-Luc Cooke Fortuna-based <filename>/dev/random</filename>驱动。</para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Author</title>
____________________________________________________________________________-->
  <title>作者</title>

<!--==========================orignal english content==========================
  <para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>
____________________________________________________________________________-->
  <para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>

<!--==========================orignal english content==========================
  <para>
   <filename>pgcrypto</filename> uses code from the following sources:
  </para>
____________________________________________________________________________-->
  <para>
   <filename>pgcrypto</filename>使用了来自下列源码的代码：
  </para>

  <informaltable>
   <tgroup cols="3">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Algorithm</entry>
      <entry>Author</entry>
      <entry>Source origin</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>算法</entry>
      <entry>作者</entry>
      <entry>源码起源</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry>DES crypt</entry>
      <entry>David Burren and others</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>DES crypt</entry>
      <entry>David Burren 等</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>MD5 crypt</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>MD5 crypt</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>Blowfish crypt</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>Blowfish crypt</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>Blowfish cipher</entry>
      <entry>Simon Tatham</entry>
      <entry>PuTTY</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>Blowfish cipher</entry>
      <entry>Simon Tatham</entry>
      <entry>PuTTY</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>Rijndael cipher</entry>
      <entry>Brian Gladman</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>Rijndael cipher</entry>
      <entry>Brian Gladman</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>MD5 hash and SHA1</entry>
      <entry>WIDE Project</entry>
      <entry>KAME kame/sys/crypto</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>MD5 hash and SHA1</entry>
      <entry>WIDE Project</entry>
      <entry>KAME kame/sys/crypto</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>SHA256/384/512 </entry>
      <entry>Aaron D. Gifford</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>SHA256/384/512 </entry>
      <entry>Aaron D. Gifford</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry>BIGNUM math</entry>
      <entry>Michael J. Fromberger</entry>
      <entry>dartmouth.edu/~sting/sw/imath</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>BIGNUM math</entry>
      <entry>Michael J. Fromberger</entry>
      <entry>dartmouth.edu/~sting/sw/imath</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect2>

</sect1>
