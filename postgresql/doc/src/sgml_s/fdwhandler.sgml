<!-- doc/src/sgml/fdwhandler.sgml -->

 <chapter id="fdwhandler">
<!--==========================orignal english content==========================
   <title>Writing A Foreign Data Wrapper</title>
____________________________________________________________________________-->
   <title>编写一个外部数据包装器</title>

<!--==========================orignal english content==========================
   <indexterm zone="fdwhandler">
    <primary>foreign data wrapper</primary>
    <secondary>handler for</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="fdwhandler">
    <primary>foreign data wrapper</primary>
    <secondary>handler for</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    All operations on a foreign table are handled through its foreign data
    wrapper, which consists of a set of functions that the core server
    calls.  The foreign data wrapper is responsible for fetching
    data from the remote data source and returning it to the
    <productname>PostgreSQL</productname> executor.  If updating foreign
    tables is to be supported, the wrapper must handle that, too.
    This chapter outlines how to write a new foreign data wrapper.
   </para>
____________________________________________________________________________-->
   <para>
    所有在一个外部表上的操作都通过它的外部数据包装器来处理，外部数据包装器由一组被核心服务器调用的函数组成。外部数据包装器负责从远程数据源取得数据并把它返回给<productname>PostgreSQL</productname>执行器。如果要支持更新外部表，包装器也需要处理更新。本章将介绍如何编写一个新的外部数据包装器。
   </para>

<!--==========================orignal english content==========================
   <para>
    The foreign data wrappers included in the standard distribution are good
    references when trying to write your own.  Look into the
    <filename>contrib</filename> subdirectory of the source tree.
    The <xref linkend="sql-createforeigndatawrapper"/> reference page also has
    some useful details.
   </para>
____________________________________________________________________________-->
   <para>
    在你试图编写你自己的外部数据包装器时，包含在标准发布中的外部数据包装器会是很好的参考。请看看源代码树的<filename>contrib</filename>子目录。<xref linkend="sql-createforeigndatawrapper"/>参考页也会有很多有用的细节。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     The SQL standard specifies an interface for writing foreign data wrappers.
     However, PostgreSQL does not implement that API, because the effort to
     accommodate it into PostgreSQL would be large, and the standard API hasn't
     gained wide adoption anyway.
    </para>
____________________________________________________________________________-->
    <para>
     SQL 标准声明了一个接口用来编写外部数据包装器。但是，PostgreSQL 没有实现该 API，因为将其纳入到 PostgreSQL 中的工作量将会很大，并且标准的 API 并没有得到广泛地采用。
    </para>
   </note>

   <sect1 id="fdw-functions">
<!--==========================orignal english content==========================
    <title>Foreign Data Wrapper Functions</title>
____________________________________________________________________________-->
    <title>外部数据包装器函数</title>

<!--==========================orignal english content==========================
    <para>
     The FDW author needs to implement a handler function, and optionally
     a validator function. Both functions must be written in a compiled
     language such as C, using the version-1 interface.
     For details on C language calling conventions and dynamic loading,
     see <xref linkend="xfunc-c"/>.
    </para>
____________________________________________________________________________-->
    <para>
     FDW的作者需要实现一个处理器函数，并且可以有选择地实现一个验证器函数。两个函数都必须被用一种编译语言（如 C）来编写，并使用版本-1接口。关于 C 语言调用规范和动态载入的细节，请见<xref linkend="xfunc-c"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The handler function simply returns a struct of function pointers to
     callback functions that will be called by the planner, executor, and
     various maintenance commands.
     Most of the effort in writing an FDW is in implementing these callback
     functions.
     The handler function must be registered with
     <productname>PostgreSQL</productname> as taking no arguments and
     returning the special pseudo-type <type>fdw_handler</type>.  The
     callback functions are plain C functions and are not visible or
     callable at the SQL level.  The callback functions are described in
     <xref linkend="fdw-callbacks"/>.
    </para>
____________________________________________________________________________-->
    <para>
     处理器函数简单地返回一个函数指针结构给回调函数，回调函数将被规划器、执行器和多种维护命令调用。编写一个FDW的大部分工作量都在实现这些回调函数上。处理器函数必须被注册在<productname>PostgreSQL</productname>中，并且注册为不需要参数并且返回特殊的伪类型<type>fdw_handler</type>。回调函数则是普通的 C 函数并且对于 SQL 层是不可见的或者不可调用的。回调函数在<xref linkend="fdw-callbacks"/>中描述。
    </para>

<!--==========================orignal english content==========================
    <para>
     The validator function is responsible for validating options given in
     <command>CREATE</command> and <command>ALTER</command> commands for its
     foreign data wrapper, as well as foreign servers, user mappings, and
     foreign tables using the wrapper.
     The validator function must be registered as taking two arguments, a
     text array containing the options to be validated, and an OID
     representing the type of object the options are associated with (in
     the form of the OID of the system catalog the object would be stored
     in, either
     <literal>ForeignDataWrapperRelationId</literal>,
     <literal>ForeignServerRelationId</literal>,
     <literal>UserMappingRelationId</literal>,
     or <literal>ForeignTableRelationId</literal>).
     If no validator function is supplied, options are not checked at object
     creation time or object alteration time.
    </para>
____________________________________________________________________________-->
    <para>
     验证器函数负责验证<command>CREATE</command>和<command>ALTER</command>命令中对它的外部数据包装器给出的选项，以及使用该包装器的外部服务器、用户映射和外部表。验证器函数必须被注册为要求两个参数：一个包含需要被验证的选项的文本数组，以及一个表示与这些选项相关联的对象类型的OID（以该对象可能被存储的系统目录的OID的形式，可以是<literal>ForeignDataWrapperRelationId</literal>、<literal>ForeignServerRelationId</literal>、<literal>UserMappingRelationId</literal>或<literal>ForeignTableRelationId</literal>）。如果没有提供验证器函数，在对象创建或修改时选项不会被检查。
    </para>

   </sect1>

   <sect1 id="fdw-callbacks">
<!--==========================orignal english content==========================
    <title>Foreign Data Wrapper Callback Routines</title>
____________________________________________________________________________-->
    <title>外部数据包装器回调例程</title>

<!--==========================orignal english content==========================
    <para>
     The FDW handler function returns a palloc'd <structname>FdwRoutine</structname>
     struct containing pointers to the callback functions described below.
     The scan-related functions are required, the rest are optional.
    </para>
____________________________________________________________________________-->
    <para>
     FDW处理器函数返回一个palloc过的<structname>FdwRoutine</structname>结构，它包含下文描述的回调函数的指针。扫描相关的函数是必需的，剩下的是可选的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <structname>FdwRoutine</structname> struct type is declared in
     <filename>src/include/foreign/fdwapi.h</filename>, which see for additional
     details.
    </para>
____________________________________________________________________________-->
    <para>
     <structname>FdwRoutine</structname>结构类型被声明在<filename>src/include/foreign/fdwapi.h</filename>中，可以查看它来获得额外的信息。
    </para>

   <sect2 id="fdw-callbacks-scan">
<!--==========================orignal english content==========================
    <title>FDW Routines For Scanning Foreign Tables</title>
____________________________________________________________________________-->
    <title>用于扫描外部表的FDW例程</title>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
GetForeignRelSize(PlannerInfo *root,
                  RelOptInfo *baserel,
                  Oid foreigntableid);
</programlisting>

     Obtain relation size estimates for a foreign table.  This is called
     at the beginning of planning for a query that scans a foreign table.
     <literal>root</literal> is the planner's global information about the query;
     <literal>baserel</literal> is the planner's information about this table; and
     <literal>foreigntableid</literal> is the <structname>pg_class</structname> OID of the
     foreign table.  (<literal>foreigntableid</literal> could be obtained from the
     planner data structures, but it's passed explicitly to save effort.)
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
GetForeignRelSize(PlannerInfo *root,
                  RelOptInfo *baserel,
                  Oid foreigntableid);
</programlisting>

     获取一个外部表的关系尺寸估计。在对一个扫描外部表的查询进行规划的开头将调用该函数。<literal>root</literal>是规划器的关于该查询的全局信息；<literal>baserel</literal>是规划器的关于该表的信息；<literal>foreigntableid</literal>是外部表在<structname>pg_class</structname>中的 OID （<literal>foreigntableid</literal>可以从规划器的数据结构中获得，但是为了减少工作量，这里直接显式地将它传递给函数）。
    </para>

<!--==========================orignal english content==========================
    <para>
     This function should update <literal>baserel-&gt;rows</literal> to be the
     expected number of rows returned by the table scan, after accounting for
     the filtering done by the restriction quals.  The initial value of
     <literal>baserel-&gt;rows</literal> is just a constant default estimate, which
     should be replaced if at all possible.  The function may also choose to
     update <literal>baserel-&gt;width</literal> if it can compute a better estimate
     of the average result row width.
    </para>
____________________________________________________________________________-->
    <para>
     这个函数应该更新<literal>baserel-&gt;rows</literal>为表扫描根据限制条件完成了过滤后将返回的预期行数。<literal>baserel-&gt;rows</literal>的初始值只是一个常数的默认估计值，应该尽可能把它替换掉。如果该函数能够计算出一个平均结果行宽度的更好的估计值，该函数也可能选择更新<literal>baserel-&gt;width</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
GetForeignPaths(PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid);
</programlisting>

     Create possible access paths for a scan on a foreign table.
     This is called during query planning.
     The parameters are the same as for <function>GetForeignRelSize</function>,
     which has already been called.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
GetForeignPaths(PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid);
</programlisting>

     为一个外部表上的扫描创建可能的访问路径。这个函数在查询规划过程中被调用。参数和<function>GetForeignRelSize</function>相同，后者已经被调用过了。
    </para>

<!--==========================orignal english content==========================
    <para>
     This function must generate at least one access path
     (<structname>ForeignPath</structname> node) for a scan on the foreign table and
     must call <function>add_path</function> to add each such path to
     <literal>baserel-&gt;pathlist</literal>.  It's recommended to use
     <function>create_foreignscan_path</function> to build the
     <structname>ForeignPath</structname> nodes.  The function can generate multiple
     access paths, e.g., a path which has valid <literal>pathkeys</literal> to
     represent a pre-sorted result.  Each access path must contain cost
     estimates, and can contain any FDW-private information that is needed to
     identify the specific scan method intended.
    </para>
____________________________________________________________________________-->
    <para>
     这个函数必须为外部表上的扫描生成至少一个访问路径（<structname>ForeignPath</structname>节点），并且必须调用<function>add_path</function>把每一个这样的路径加入到<literal>baserel-&gt;pathlist</literal>中。我们推荐使用<function>create_foreignscan_path</function>来建立<structname>ForeignPath</structname>节点。该函数可以生成多个访问路径，例如一个具有合法<literal>pathkeys</literal>的路径表示一个预排序好的结果。每一个反问路径必须包含代价估计，并且能包含任何FDW的私有信息，这种信息被用来标识想要使用的指定扫描方法。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignScan *
GetForeignPlan(PlannerInfo *root,
               RelOptInfo *baserel,
               Oid foreigntableid,
               ForeignPath *best_path,
               List *tlist,
               List *scan_clauses,
               Plan *outer_plan);
</programlisting>

     Create a <structname>ForeignScan</structname> plan node from the selected foreign
     access path.  This is called at the end of query planning.
     The parameters are as for <function>GetForeignRelSize</function>, plus
     the selected <structname>ForeignPath</structname> (previously produced by
     <function>GetForeignPaths</function>, <function>GetForeignJoinPaths</function>,
     or <function>GetForeignUpperPaths</function>),
     the target list to be emitted by the plan node,
     the restriction clauses to be enforced by the plan node,
     and the outer subplan of the <structname>ForeignScan</structname>,
     which is used for rechecks performed by <function>RecheckForeignScan</function>.
     (If the path is for a join rather than a base
     relation, <literal>foreigntableid</literal> is <literal>InvalidOid</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses,
                Plan *outer_plan);
</programlisting>

     从选择的外部访问路径创建一个<structname>ForeignScan</structname>计划节点。这个函数在查询规划的末尾被调用。参数和<function>GetForeignRelSize</function>的一样，外加选中的<structname>ForeignPath</structname>（在前面由<function>GetForeignPaths</function>、<function>GetForeignJoinPaths</function>或者<function>GetForeignUpperPaths</function>产生）、被计划节点发出的目标列表以及计划节点强制的限制子句以及被<function>RecheckForeignScan</function>执行的复查所使用的<structname>ForeignScan</structname>的外子计划（如果该路径是用于一个连接而非基本关系，则<literal>foreigntableid</literal>是<literal>InvalidOid</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     This function must create and return a <structname>ForeignScan</structname> plan
     node; it's recommended to use <function>make_foreignscan</function> to build the
     <structname>ForeignScan</structname> node.
    </para>
____________________________________________________________________________-->
    <para>
     这个函数必须创建并返回一个<structname>ForeignScan</structname>计划节点，我们对剑使用<function>make_foreignscan</function>来建立<structname>ForeignScan</structname>节点。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息见<xref linkend="fdw-planning"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
BeginForeignScan(ForeignScanState *node,
                 int eflags);
</programlisting>

     Begin executing a foreign scan. This is called during executor startup.
     It should perform any initialization needed before the scan can start,
     but not start executing the actual scan (that should be done upon the
     first call to <function>IterateForeignScan</function>).
     The <structname>ForeignScanState</structname> node has already been created, but
     its <structfield>fdw_state</structfield> field is still NULL.  Information about
     the table to scan is accessible through the
     <structname>ForeignScanState</structname> node (in particular, from the underlying
     <structname>ForeignScan</structname> plan node, which contains any FDW-private
     information provided by <function>GetForeignPlan</function>).
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignScan(ForeignScanState *node,
                 int eflags);
</programlisting>

     开始执行一个外部扫描。这个函数在执行器启动阶段被调用。它应该执行任何在扫描能够开始之前需要完成的初始化工作，但是并不开始执行真正的扫描（会在第一次调用<function>IterateForeignScan</function>时完成）。<structname>ForeignScanState</structname>节点已经被创建好了，但是它的<structfield>fdw_state</structfield>域仍然为 NULL。关于要被扫描的表的信息可以通过<structname>ForeignScanState</structname>节点访问（特殊地，从底层的<structname>ForeignScan</structname>计划节点，它包含任何由<function>GetForeignPlan</function>提供的FDW私有信息）。<literal>eflags</literal>包含描述执行器对该计划节点操作模式的标志位。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignScan</function> and <function>EndForeignScan</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真时，这个函数不应该执行任何外部可见的动作；它应当只做最少的事情来创建对<function>ExplainForeignScan</function>和<function>EndForeignScan</function>有效的节点状态。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan(ForeignScanState *node);
</programlisting>

     Fetch one row from the foreign source, returning it in a tuple table slot
     (the node's <structfield>ScanTupleSlot</structfield> should be used for this
     purpose).  Return NULL if no more rows are available.  The tuple table
     slot infrastructure allows either a physical or virtual tuple to be
     returned; in most cases the latter choice is preferable from a
     performance standpoint.  Note that this is called in a short-lived memory
     context that will be reset between invocations.  Create a memory context
     in <function>BeginForeignScan</function> if you need longer-lived storage, or use
     the <structfield>es_query_cxt</structfield> of the node's <structname>EState</structname>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
IterateForeignScan(ForeignScanState *node);
</programlisting>

     从外部源获得一行，将它放在一个元组表槽中返回（节点的<structfield>ScanTupleSlot</structfield>应当被用于此目的）。如果没有更多的行可用则返回 NULL。元组表槽设施允许一个物理的或者虚拟的元组被返回；在大部分情况下出于性能的考虑会倾向于选择后者。注意这是在一个短期存在的内存上下文中被调用的，该内存上下文会在调用之间被重置。如果你需要长期存在的存储，请在<function>BeginForeignScan</function>中创建内存上下文，或者使用节点的<structname>EState</structname>中的<structfield>es_query_cxt</structfield>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The rows returned must match the <structfield>fdw_scan_tlist</structfield> target
     list if one was supplied, otherwise they must match the row type of the
     foreign table being scanned.  If you choose to optimize away fetching
     columns that are not needed, you should insert nulls in those column
     positions, or else generate a <structfield>fdw_scan_tlist</structfield> list with
     those columns omitted.
    </para>
____________________________________________________________________________-->
    <para>
     如果提供了<structfield>fdw_scan_tlist</structfield>目标列表，被返回的行必须匹配它，如果没有提供则它们必须匹配被扫描的外部表的行类型。如果选择优化掉不需要的列，你应该在那些列的位置上插入控制或者生成一个忽略了那些列的<structfield>fdw_scan_tlist</structfield>列表。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that <productname>PostgreSQL</productname>'s executor doesn't care
     whether the rows returned violate any constraints that were defined on
     the foreign table &mdash; but the planner does care, and may optimize
     queries incorrectly if there are rows visible in the foreign table that
     do not satisfy a declared constraint.  If a constraint is violated when
     the user has declared that the constraint should hold true, it may be
     appropriate to raise an error (just as you would need to do in the case
     of a data type mismatch).
    </para>
____________________________________________________________________________-->
    <para>
     注意<productname>PostgreSQL</productname>的执行器并不在乎被返回的行是否违背了定义在该外部表上的任何约束 &mdash; 但是规划器会在乎这一点，并且如果在外部表中有可见行不满足一个约束，规划器可能会错误地优化查询。如果当用户已经声明一个约束应该为真时它却被违背，最合适的处理可能是产生一个错误（就像在数据类型失配的情况下所作的那样）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
ReScanForeignScan(ForeignScanState *node);
</programlisting>

     Restart the scan from the beginning.  Note that any parameters the
     scan depends on may have changed value, so the new scan does not
     necessarily return exactly the same rows.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
ReScanForeignScan(ForeignScanState *node);
</programlisting>

     从头开始重启一个扫描。注意扫描所依赖的任何参数可能已经改变了值，因此新扫描不一定会返回完全相同的行。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
EndForeignScan(ForeignScanState *node);
</programlisting>

     End the scan and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
EndForeignScan(ForeignScanState *node);
</programlisting>

     结束扫描并释放资源。通常释放palloc过的内存并不重要，但是打开的文件和到远程服务器的连接等应该被清理。
    </para>

   </sect2>
   
   <sect2 id="fdw-callbacks-join-scan">
<!--==========================orignal english content==========================
    <title>FDW Routines For Scanning Foreign Joins</title>
____________________________________________________________________________-->
    <title>用于扫描外部连接的 FDW 例程</title>

<!--==========================orignal english content==========================
    <para>
     If an FDW supports performing foreign joins remotely (rather than
     by fetching both tables' data and doing the join locally), it should
     provide this callback function:
    </para>
____________________________________________________________________________-->
    <para>
     如果一个 FDW 支持远程执行外部连接（而不是先把两个表的数据取到本地然后做本地连接），它应该提供这个回调函数：
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
GetForeignJoinPaths(PlannerInfo *root,
                    RelOptInfo *joinrel,
                    RelOptInfo *outerrel,
                    RelOptInfo *innerrel,
                    JoinType jointype,
                    JoinPathExtraData *extra);
</programlisting>
     Create possible access paths for a join of two (or more) foreign tables
     that all belong to the same foreign server.  This optional
     function is called during query planning.  As
     with <function>GetForeignPaths</function>, this function should
     generate <structname>ForeignPath</structname> path(s) for the
     supplied <literal>joinrel</literal>, and call <function>add_path</function> to add these
     paths to the set of paths considered for the join.  But unlike
     <function>GetForeignPaths</function>, it is not necessary that this function
     succeed in creating at least one path, since paths involving local
     joining are always possible.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
GetForeignJoinPaths(PlannerInfo *root,
                    RelOptInfo *joinrel,
                    RelOptInfo *outerrel,
                    RelOptInfo *innerrel,
                    JoinType jointype,
                    JoinPathExtraData *extra);
</programlisting>
     它为两个（或更多）同属于一台外部服务器的外部表的连接创建可能的访问路径。这个可选的函数会在查询规划过程中被调用。和<function>GetForeignPaths</function>一样，这个函数应该为提供的<literal>joinrel</literal>生成<structname>ForeignPath</structname>路径，并且调用<function>add_path</function>把这些路径加入到该连接应该考虑的路径集合中。但是和<function>GetForeignPaths</function>不一样的是，不需要这个函数产生最少一个路径，因为涉及本地连接的路径总是可用的。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that this function will be invoked repeatedly for the same join
     relation, with different combinations of inner and outer relations; it is
     the responsibility of the FDW to minimize duplicated work.
    </para>
____________________________________________________________________________-->
    <para>
     注意为相同的连接关系将会重复地调用这个函数用来生成内外关系的不同组合。FDW 需要负责最小化其中重复的工作。
    </para>

<!--==========================orignal english content==========================
    <para>
     If a <structname>ForeignPath</structname> path is chosen for the join, it will
     represent the entire join process; paths generated for the component
     tables and subsidiary joins will not be used.  Subsequent processing of
     the join path proceeds much as it does for a path scanning a single
     foreign table.  One difference is that the <structfield>scanrelid</structfield> of
     the resulting <structname>ForeignScan</structname> plan node should be set to zero,
     since there is no single relation that it represents; instead,
     the <structfield>fs_relids</structfield> field of the <structname>ForeignScan</structname>
     node represents the set of relations that were joined.  (The latter field
     is set up automatically by the core planner code, and need not be filled
     by the FDW.)  Another difference is that, because the column list for a
     remote join cannot be found from the system catalogs, the FDW must
     fill <structfield>fdw_scan_tlist</structfield> with an appropriate list
     of <structfield>TargetEntry</structfield> nodes, representing the set of columns
     it will supply at run time in the tuples it returns.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个<structname>ForeignPath</structname>路径被选中用于该连接，它将在整个连接处理中存在，为其中的成分表和子连接产生的路径将不会被使用。后续对该连接路径的处理大部分和扫描单个外部表的路径一样。一点不同是<structname>ForeignScan</structname>计划节点的<structfield>scanrelid</structfield>应该被设置为零，因为它表示的不是单个关系，而是用<structname>ForeignScan</structname>节点的<structfield>fs_relids</structfield>域来表示被连接的关系集合（后一个域会被核心规划器代码自动设置，不需要由 FDW 填充）。另一点不同是，由于一个远程连接的列列表无法在系统目录中找到，FDW 必须用一个合适的<structfield>TargetEntry</structfield>节点列表来填充<structfield>fdw_scan_tlist</structfield>，表示运行时它返回的元组中提供的列的集合。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>

   </sect2>
   
   <sect2 id="fdw-callbacks-upper-planning">
<!--==========================orignal english content==========================
    <title>FDW Routines For Planning Post-Scan/Join Processing</title>
____________________________________________________________________________-->
    <title>用于规划扫描/连接后处理的 FDW 例程</title>

<!--==========================orignal english content==========================
    <para>
     If an FDW supports performing remote post-scan/join processing, such as
     remote aggregation, it should provide this callback function:
    </para>
____________________________________________________________________________-->
    <para>
     如果一个 FDW 支持执行远程的扫描/连接后处理，例如远程聚集，那么它应该提供这个回调函数：
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);
</programlisting>
     Create possible access paths for <firstterm>upper relation</firstterm> processing,
     which is the planner's term for all post-scan/join query processing, such
     as aggregation, window functions, sorting, and table updates.  This
     optional function is called during query planning.  Currently, it is
     called only if all base relation(s) involved in the query belong to the
     same FDW.  This function should generate <structname>ForeignPath</structname>
     path(s) for any post-scan/join processing that the FDW knows how to
     perform remotely, and call <function>add_path</function> to add these paths to
     the indicated upper relation.  As with <function>GetForeignJoinPaths</function>,
     it is not necessary that this function succeed in creating any paths,
     since paths involving local processing are always possible.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
GetForeignUpperPaths(PlannerInfo *root,
                     UpperRelationKind stage,
                     RelOptInfo *input_rel,
                     RelOptInfo *output_rel,
                     void *extra);
</programlisting>
     为<firstterm>上层关系</firstterm>处理创建可能的访问路径，这是规划器针对所有扫描/连接后查询处理的术语，例如聚集、窗口函数、排序和表更新。在查询规划期间会调用这个可选的函数。当前，只有当该查询中涉及的所有基本关系都属于同一个 FDW 时才会调用这个函数。这个函数应该为 FDW 知道如何远程执行的任何扫描/连接后处理生成<structname>ForeignPath</structname>路径，并且调用<function>add_path</function>把这些路径加入到上层关系中。就<function>GetForeignJoinPaths</function>来说，并不要求这个函数在创建任何路径时都能成功，因为路径总是有可能涉及到本地处理。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>stage</literal> parameter identifies which post-scan/join step is
     currently being considered.  <literal>output_rel</literal> is the upper relation
     that should receive paths representing computation of this step,
     and <literal>input_rel</literal> is the relation representing the input to this
     step.  The <literal>extra</literal> parameter provides additional details,
     currently, it is set only for <literal>UPPERREL_PARTIAL_GROUP_AGG</literal>
     or <literal>UPPERREL_GROUP_AGG</literal>, in which case it points to a
     <literal>GroupPathExtraData</literal> structure.
     (Note that <structname>ForeignPath</structname> paths added
     to <literal>output_rel</literal> would typically not have any direct dependency
     on paths of the <literal>input_rel</literal>, since their processing is expected
     to be done externally.  However, examining paths previously generated for
     the previous processing step can be useful to avoid redundant planning
     work.)
    </para>
____________________________________________________________________________-->
    <para>
     <literal>stage</literal>参数表示当前正在考虑的是哪一个扫描/连接后处理步骤。<literal>output_rel</literal>是接收表示这一个步骤的路径的上层关系，而<literal>input_rel</literal>是表示这个步骤输入的关系。<literal>extra</literal>参数提供额外的细节，当前只会为<literal>UPPERREL_PARTIAL_GROUP_AGG</literal>或者<literal>UPPERREL_GROUP_AGG</literal>设置它，这种情况下它会指向一个<literal>GroupPathExtraData</literal>结构（注意被加入到<literal>output_rel</literal>中的<structname>ForeignPath</structname>路径通常对<literal>input_rel</literal>的路径没有直接的依赖，因为它们的处理被认为是在外部处理的。不过，检查为前一个处理步骤生成的路径有助于避免冗余的规划工作）。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>
   </sect2>

   <sect2 id="fdw-callbacks-update">
<!--==========================orignal english content==========================
    <title>FDW Routines For Updating Foreign Tables</title>
____________________________________________________________________________-->
    <title>更新外部表的FDW例程</title>

<!--==========================orignal english content==========================
    <para>
     If an FDW supports writable foreign tables, it should provide
     some or all of the following callback functions depending on
     the needs and capabilities of the FDW:
    </para>
____________________________________________________________________________-->
    <para>
     如果一个FDW支持可写的外部表，根据FDW的需要和功能它应该提供某些或者全部下列回调函数：
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
AddForeignUpdateTargets(Query *parsetree,
                        RangeTblEntry *target_rte,
                        Relation target_relation);
</programlisting>

     <command>UPDATE</command> and <command>DELETE</command> operations are performed
     against rows previously fetched by the table-scanning functions.  The
     FDW may need extra information, such as a row ID or the values of
     primary-key columns, to ensure that it can identify the exact row to
     update or delete.  To support that, this function can add extra hidden,
     or <quote>junk</quote>, target columns to the list of columns that are to be
     retrieved from the foreign table during an <command>UPDATE</command> or
     <command>DELETE</command>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
AddForeignUpdateTargets(Query *parsetree,
                        RangeTblEntry *target_rte,
                        Relation target_relation);
</programlisting>

     <command>UPDATE</command>和<command>DELETE</command>操作是在之前由表扫描函数取出的行上被执行的。FDW可能需要额外的信息（例如一个行ID或主键列的值）来保证它能够找到要更新或删除的准确行。要支持这些要求，这个函数可以项列列表中增加额外的隐藏或<quote>junk</quote>的目标列，它们在一个<command>UPDATE</command>或<command>DELETE</command>期间会被从外部表中获取。
    </para>

<!--==========================orignal english content==========================
    <para>
     To do that, add <structname>TargetEntry</structname> items to
     <literal>parsetree-&gt;targetList</literal>, containing expressions for the
     extra values to be fetched.  Each such entry must be marked
     <structfield>resjunk</structfield> = <literal>true</literal>, and must have a distinct
     <structfield>resname</structfield> that will identify it at execution time.
     Avoid using names matching <literal>ctid<replaceable>N</replaceable></literal>,
     <literal>wholerow</literal>, or
     <literal>wholerow<replaceable>N</replaceable></literal>, as the core system can
     generate junk columns of these names.
     If the extra expressions are more complex than simple Vars, they
     must be run through <function>eval_const_expressions</function>
     before adding them to the targetlist.
    </para>
____________________________________________________________________________-->
    <para>
     要做到这一点，向<literal>parsetree-&gt;targetList</literal>中增加<structname>TargetEntry</structname>项，它们包含要被获取的额外值的表达式。每一个这样的项必须被标记为<structfield>resjunk</structfield> = <literal>true</literal>，并且必须有一个可区分的<structfield>resname</structfield>用于在执行期间标识它。请避免使用匹配<literal>ctid<replaceable>N</replaceable></literal>、<literal>wholerow</literal>或<literal>wholerow<replaceable>N</replaceable></literal>的名字，因为核心系统可能会生成使用这些名字的junk列。如果额外的表达式比简单的Var更加复杂，在把它们加入到目标列表之前必须把它们用<function>eval_const_expressions</function>进行处理。
    </para>

<!--==========================orignal english content==========================
    <para>
     Although this function is called during planning, the
     information provided is a bit different from that available to other
     planning routines.
     <literal>parsetree</literal> is the parse tree for the <command>UPDATE</command> or
     <command>DELETE</command> command, while <literal>target_rte</literal> and
     <literal>target_relation</literal> describe the target foreign table.
    </para>
____________________________________________________________________________-->
    <para>
     尽管这个函数在规划过程中被调用，但所提供的信息与其他规划例程可用的信息有点区别。<literal>parsetree</literal>是<command>UPDATE</command>或<command>DELETE</command>命令的分析树，而<literal>target_rte</literal>和<literal>target_relation</literal>描述目标外部表。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>AddForeignUpdateTargets</function> pointer is set to
     <literal>NULL</literal>, no extra target expressions are added.
     (This will make it impossible to implement <command>DELETE</command>
     operations, though <command>UPDATE</command> may still be feasible if the FDW
     relies on an unchanging primary key to identify rows.)
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>AddForeignUpdateTargets</function>指针被设置为<literal>NULL</literal>，则不会有额外的目标表达式被加入（这将使得我们不可能实现<command>DELETE</command>操作，而<command>UPDATE</command>则还有可能是可行的，前提是FDW依赖一个未改变的主键来标识行）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
List *
PlanForeignModify(PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);
</programlisting>

     Perform any additional planning actions needed for an insert, update, or
     delete on a foreign table.  This function generates the FDW-private
     information that will be attached to the <structname>ModifyTable</structname> plan
     node that performs the update action.  This private information must
     have the form of a <literal>List</literal>, and will be delivered to
     <function>BeginForeignModify</function> during the execution stage.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
List *
PlanForeignModify(PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);
</programlisting>

     执行外部表上插入、更新或删除所需的任何附加规划动作。这个函数生成FDW私有信息，该信息将被附加到执行该更新动作的<structname>ModifyTable</structname>计划节点。这个私有信息的形式必须是一个<literal>List</literal>，并将会在执行阶段被传递给<function>BeginForeignModify</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
     <literal>root</literal> is the planner's global information about the query.
     <literal>plan</literal> is the <structname>ModifyTable</structname> plan node, which is
     complete except for the <structfield>fdwPrivLists</structfield> field.
     <literal>resultRelation</literal> identifies the target foreign table by its
     range table index.  <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is, counting from zero;
     use this if you want to index into <literal>plan-&gt;plans</literal> or other
     substructure of the <literal>plan</literal> node.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>root</literal>是规划器关于该查询的全局信息。<literal>plan</literal>是<structname>ModifyTable</structname>计划节点，它除了<structfield>fdwPrivLists</structfield>域之外是完整的。<literal>resultRelation</literal>通过目标外部表的范围表索引来标识它。<literal>subplan_index</literal>标识这是<structname>ModifyTable</structname>计划节点的哪个目标，从零开始计数；如果你希望索引到<literal>plan-&gt;plans</literal>或其他<literal>plan</literal>节点的子结构中，请使用它。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息见<xref linkend="fdw-planning"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>PlanForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional plan-time actions are taken, and the
     <literal>fdw_private</literal> list delivered to
     <function>BeginForeignModify</function> will be NIL.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>PlanForeignModify</function>指针被设置为<literal>NULL</literal>，则不会有额外的计划时动作被执行，并且传递给<function>BeginForeignModify</function>的<literal>fdw_private</literal>列表也将为 NIL。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
BeginForeignModify(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo,
                   List *fdw_private,
                   int subplan_index,
                   int eflags);
</programlisting>

     Begin executing a foreign table modification operation.  This routine is
     called during executor startup.  It should perform any initialization
     needed prior to the actual table modifications.  Subsequently,
     <function>ExecForeignInsert</function>, <function>ExecForeignUpdate</function> or
     <function>ExecForeignDelete</function> will be called for each tuple to be
     inserted, updated, or deleted.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignModify(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo,
                   List *fdw_private,
                   int subplan_index,
                   int eflags);
</programlisting>

     开始执行一个外部表修改操作。这个例程在执行器启动期间被调用。它应该执行任何先于实际表修改的初始化工作。随后，<function>ExecForeignInsert</function>、<function>ExecForeignUpdate</function>或<function>ExecForeignDelete</function>将被为每一个将被插入、更新或删除的元组调用。
    </para>

<!--==========================orignal english content==========================
    <para>
     <literal>mtstate</literal> is the overall state of the
     <structname>ModifyTable</structname> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</structfield> field of
     <structname>ResultRelInfo</structname> is available for the FDW to store any
     private state it needs for this operation.)
     <literal>fdw_private</literal> contains the private data generated by
     <function>PlanForeignModify</function>, if any.
     <literal>subplan_index</literal> identifies which target of
     the <structname>ModifyTable</structname> plan node this is.
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>mtstate</literal>是要被执行的<structname>ModifyTable</structname>计划节点的状态信息；通过这个结构可以得到关于规划和执行阶段的全局数据。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构（<structname>ResultRelInfo</structname>的<structfield>ri_FdwState</structfield>域用于FDW来存储它在此操作中需要的任何私有状态）。<literal>fdw_private</literal>包含<function>PlanForeignModify</function>生成的私有数据。<literal>subplan_index</literal>标识这是<structname>ModifyTable</structname>计划节点的哪个目标。<literal>eflags</literal>包含描述执行器对该计划节点操作模式的标志位。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainForeignModify</function> and <function>EndForeignModify</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真，这个函数不应执行任何外部可见的动作；它只应该做最少的工作来创建<function>ExplainForeignModify</function>和<function>EndForeignModify</function>可用的节点状态。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>BeginForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor startup.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>BeginForeignModify</function>指针被设置为<literal>NULL</literal>，在执行器启动期间将不会采取任何动作。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
TupleTableSlot *
ExecForeignInsert(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Insert one tuple into the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the tuple to be inserted; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; it differs from
     <literal>slot</literal> in possibly containing additional <quote>junk</quote>
     columns.  (The <literal>planSlot</literal> is typically of little interest
     for <command>INSERT</command> cases, but is provided for completeness.)
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignInsert(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     插入一个元组到外部表。<literal>estate</literal>是查询的全局执行状态。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。<literal>slot</literal>包含要被插入的元组；它将匹配外部表的行类型定义。<literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组；它与<literal>slot</literal>不同，它可能包含额外的<quote>junk</quote>列（<command>INSERT</command>情况通常不关心<literal>planSlot</literal>，但是为了完整性还是在这里提供它）。
    </para>

<!--==========================orignal english content==========================
    <para>
     The return value is either a slot containing the data that was actually
     inserted (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually inserted
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>
____________________________________________________________________________-->
    <para>
     返回值可以是一个包含实际被插入的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有插入行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The data in the returned slot is used only if the <command>INSERT</command>
     query has a <literal>RETURNING</literal> clause or the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</literal> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
____________________________________________________________________________-->
    <para>
     在返回槽中的数据只有在<command>INSERT</command>查询具有一个<literal>RETURNING</literal>子句或者外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExecForeignInsert</function> pointer is set to
     <literal>NULL</literal>, attempts to insert into the foreign table will fail
     with an error message.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExecForeignInsert</function>指针被设置为<literal>NULL</literal>，尝试向外部表插入将会失败并报告一个错误消息。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Update one tuple in the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains the new data for the tuple; it will match the
     row-type definition of the foreign table.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; it differs from
     <literal>slot</literal> in possibly containing additional <quote>junk</quote>
     columns.  In particular, any junk columns that were requested by
     <function>AddForeignUpdateTargets</function> will be available from this slot.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignUpdate(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     更新外部表中的一个元组。<literal>estate</literal>是查询的全局执行状态。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。<literal>slot</literal>包含元组的新数据；它将匹配外部表的行类型定义。<literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组；它与<literal>slot</literal>不同，它可能包含额外的<quote>junk</quote>列（<command>INSERT</command>情况通常不关心<literal>planSlot</literal>，但是为了完整性还是在这里提供它）。特殊地，任何<function>AddForeignUpdateTargets</function>所要求的junk列在这个槽中都是有效的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The return value is either a slot containing the row as it was actually
     updated (this might differ from the data supplied, for example as a
     result of trigger actions), or NULL if no row was actually updated
     (again, typically as a result of triggers).  The passed-in
     <literal>slot</literal> can be re-used for this purpose.
    </para>
____________________________________________________________________________-->
    <para>
     返回值可以是一个包含实际被更新的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有更新行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The data in the returned slot is used only if the <command>UPDATE</command>
     query has a <literal>RETURNING</literal> clause or the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</literal> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
____________________________________________________________________________-->
    <para>
    在返回槽中的数据只有在<command>UPDATE</command>查询具有一个<literal>RETURNING</literal>子句或者外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExecForeignUpdate</function> pointer is set to
     <literal>NULL</literal>, attempts to update the foreign table will fail
     with an error message.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExecForeignUpdate</function>指针被设置为<literal>NULL</literal>，尝试更新外部表将会失败并报告一个错误消息。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
TupleTableSlot *
ExecForeignDelete(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     Delete one tuple from the foreign table.
     <literal>estate</literal> is global execution state for the query.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.
     <literal>slot</literal> contains nothing useful upon call, but can be used to
     hold the returned tuple.
     <literal>planSlot</literal> contains the tuple that was generated by the
     <structname>ModifyTable</structname> plan node's subplan; in particular, it will
     carry any junk columns that were requested by
     <function>AddForeignUpdateTargets</function>.  The junk column(s) must be used
     to identify the tuple to be deleted.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
ExecForeignDelete(EState *estate,
                  ResultRelInfo *rinfo,
                  TupleTableSlot *slot,
                  TupleTableSlot *planSlot);
</programlisting>

     从外部表删除一个元组。<literal>estate</literal>是查询的全局执行状态。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构。<literal>slot</literal>在调用时不包含任何有用的东西，但是可以被用于保持被返回的元组。<literal>planSlot</literal>包含由<structname>ModifyTable</structname>计划节点的子计划生成的元组；特殊地，它将携带<function>AddForeignUpdateTargets</function>所要求的任意垃圾列。垃圾列被用来标识要被删除的元组。
    </para>

<!--==========================orignal english content==========================
    <para>
     The return value is either a slot containing the row that was deleted,
     or NULL if no row was deleted (typically as a result of triggers).  The
     passed-in <literal>slot</literal> can be used to hold the tuple to be returned.
    </para>
____________________________________________________________________________-->
    <para>
     返回值可以是一个包含实际被删除的数据的槽（这可能会和所提供的数据不同，例如一个触发器动作的结果），或者为 NULL 表示实际没有删除行（还是触发器的结果）。被传入的<literal>slot</literal>可以被重用于这个目的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The data in the returned slot is used only if the <command>DELETE</command>
     query has a <literal>RETURNING</literal> clause or the foreign table has
     an <literal>AFTER ROW</literal> trigger.  Triggers require all columns, but the
     FDW could choose to optimize away returning some or all columns depending
     on the contents of the <literal>RETURNING</literal> clause.  Regardless, some
     slot must be returned to indicate success, or the query's reported row
     count will be wrong.
    </para>
____________________________________________________________________________-->
    <para>
    在返回槽中的数据只有在<command>DELETE</command>查询具有一个<literal>RETURNING</literal>子句或者外部表具有一个<literal>AFTER ROW</literal>触发器时才被使用。触发器要求所有的列，但是 FDW 应该选择优化成根据<literal>RETURNING</literal>子句的内容返回某些或全部列。不管怎样，某些槽必须被返回来指示成功，或者查询报告的行计数将会是错误的。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExecForeignDelete</function> pointer is set to
     <literal>NULL</literal>, attempts to delete from the foreign table will fail
     with an error message.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExecForeignDelete</function>指针被设置为<literal>NULL</literal>，尝试从外部表中删除将会失败并报告一个错误消息。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
EndForeignModify(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     End the table update and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
EndForeignModify(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     结束表更新并释放资源。通常释放palloc的内存并不重要，但是打开的文件和到远程服务器的连接等应当被清除。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>EndForeignModify</function> pointer is set to
     <literal>NULL</literal>, no action is taken during executor shutdown.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>EndForeignModify</function>指针被设置为<literal>NULL</literal>，在执行器关闭期间不会采取任何动作。
    </para>

<!--==========================orignal english content==========================
    <para>
     Tuples inserted into a partitioned table by <command>INSERT</command> or
     <command>COPY FROM</command> are routed to partitions.  If an FDW
     supports routable foreign-table partitions, it should also provide the
     following callback functions.  These functions are also called when
     <command>COPY FROM</command> is executed on a foreign table.
    </para>
____________________________________________________________________________-->
    <para>
     被<command>INSERT</command>或者<command>COPY FROM</command>插入到分区表中的元组会被路由到分区。如果一个FDW支持可路由的外部表分区，它还应该提供下面的回调函数。当在外部表上执行<command>COPY FROM</command>时，也会调用这些函数。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);
</programlisting>

     Begin executing an insert operation on a foreign table.  This routine is
     called right before the first tuple is inserted into the foreign table
     in both cases when it is the partition chosen for tuple routing and the
     target specified in a <command>COPY FROM</command> command.  It should
     perform any initialization needed prior to the actual insertion.
     Subsequently, <function>ExecForeignInsert</function> will be called for
     each tuple to be inserted into the foreign table.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
BeginForeignInsert(ModifyTableState *mtstate,
                   ResultRelInfo *rinfo);
</programlisting>

     开始在外部表上执行插入操作。当外部表被选中作为元组路由的分区以及<command>COPY FROM</command>命令中指定的目标时，在第一个元组被插入到该外部表之前会调用这个例程。它应该执行实际插入之前所需的任何初始化工作。随后，为每一个被插入到该外部表的元组都将调用<function>ExecForeignInsert</function>。
    </para>

<!--==========================orignal english content==========================
    <para>
     <literal>mtstate</literal> is the overall state of the
     <structname>ModifyTable</structname> plan node being executed; global data about
     the plan and execution state is available via this structure.
     <literal>rinfo</literal> is the <structname>ResultRelInfo</structname> struct describing
     the target foreign table.  (The <structfield>ri_FdwState</structfield> field of
     <structname>ResultRelInfo</structname> is available for the FDW to store any
     private state it needs for this operation.)
    </para>
____________________________________________________________________________-->
    <para>
     <literal>mtstate</literal>是正在被执行的<structname>ModifyTable</structname>计划节点的总体状态，通过这个结构可以得到有关计划和执行的全局数据。<literal>rinfo</literal>是描述目标外部表的<structname>ResultRelInfo</structname>结构（对于FDW，<structname>ResultRelInfo</structname>的<structfield>ri_FdwState</structfield>字段用来存放这个操作所需要的私有状态）。
    </para>

<!--==========================orignal english content==========================
    <para>
     When this is called by a <command>COPY FROM</command> command, the
     plan-related global data in <literal>mtstate</literal> is not provided
     and the <literal>planSlot</literal> parameter of
     <function>ExecForeignInsert</function> subsequently called for each
     inserted tuple is <literal>NULL</literal>, whether the foreign table is
     the partition chosen for tuple routing or the target specified in the
     command.
    </para>
____________________________________________________________________________-->
    <para>
     当这个例程被一个<command>COPY FROM</command>命令调用时，不会提供<literal>mtstate</literal>中与计划相关的全局数据，并且后续为每个插入元组调用的<function>ExecForeignInsert</function>的<literal>planSlot</literal>参数为<literal>NULL</literal>，不管该外部表是为元组路由选中的分区还是命令中指定的目标。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>BeginForeignInsert</function> pointer is set to
     <literal>NULL</literal>, no action is taken for the initialization.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>BeginForeignInsert</function>指针被设置为<literal>NULL</literal>，则不会采取初始化动作。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     End the insert operation and release resources.  It is normally not important
     to release palloc'd memory, but for example open files and connections
     to remote servers should be cleaned up.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
EndForeignInsert(EState *estate,
                 ResultRelInfo *rinfo);
</programlisting>

     结束插入操作并且释放资源。通常释放palloc的内存并不重要，但是打开的文件和与远程服务器的连接应该被清除。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>EndForeignInsert</function> pointer is set to
     <literal>NULL</literal>, no action is taken for the termination.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>EndForeignInsert</function>指针被设置为<literal>NULL</literal>，则不会采取终止动作。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
int
IsForeignRelUpdatable(Relation rel);
</programlisting>

     Report which update operations the specified foreign table supports.
     The return value should be a bit mask of rule event numbers indicating
     which operations are supported by the foreign table, using the
     <literal>CmdType</literal> enumeration; that is,
     <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal> for <command>UPDATE</command>,
     <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal> for <command>INSERT</command>, and
     <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal> for <command>DELETE</command>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
int
IsForeignRelUpdatable(Relation rel);
</programlisting>

     报告指定的外部表支持哪些更新操作。返回值应该是一个规则事件编号的位掩码，它指示了哪些操作被外部表支持，它使用<literal>CmdType</literal>枚举，即：
     <literal>(1 &lt;&lt; CMD_UPDATE) = 4</literal>表示<command>UPDATE</command>、
     <literal>(1 &lt;&lt; CMD_INSERT) = 8</literal>表示<command>INSERT</command>以及
     <literal>(1 &lt;&lt; CMD_DELETE) = 16</literal>表示<command>DELETE</command>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>IsForeignRelUpdatable</function> pointer is set to
     <literal>NULL</literal>, foreign tables are assumed to be insertable, updatable,
     or deletable if the FDW provides <function>ExecForeignInsert</function>,
     <function>ExecForeignUpdate</function>, or <function>ExecForeignDelete</function>
     respectively.  This function is only needed if the FDW supports some
     tables that are updatable and some that are not.  (Even then, it's
     permissible to throw an error in the execution routine instead of
     checking in this function.  However, this function is used to determine
     updatability for display in the <literal>information_schema</literal> views.)
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>IsForeignRelUpdatable</function>指针被设置为<literal>NULL</literal>，而FDW提供了<function>ExecForeignInsert</function>、<function>ExecForeignUpdate</function>或<function>ExecForeignDelete</function>，则外部表分别被假定为可插入、可更新或可删除。只有在FDW支持某些表是可更新的而某些不是可更新的时候，才需要这个函数（即便如此，也允许在执行例程中抛出一个错误而不是在这个函数中检查。但是，这个函数被用来决定显示在<literal>information_schema</literal>视图中的可更新性）。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     Some inserts, updates, and deletes to foreign tables can be optimized
     by implementing an alternative set of interfaces.  The ordinary
     interfaces for inserts, updates, and deletes fetch rows from the remote
     server and then modify those rows one at a time.  In some cases, this
     row-by-row approach is necessary, but it can be inefficient.  If it is
     possible for the foreign server to determine which rows should be
     modified without actually retrieving them, and if there are no local
     triggers which would affect the operation, then it is possible to
     arrange things so that the entire operation is performed on the remote
     server.  The interfaces described below make this possible.
    </para>
____________________________________________________________________________-->
    <para>
     一些对于外部表的插入、更新和删除可以通过实现另一组接口来优化。普通的插入、更新和删除接口会从远程服务器取得行，然后一次修改其中一行。在某些情况下，这种逐行的方式是必要的，但是可能效率不高。如果有可能让外部服务器判断哪些行可以直接修改而无需先检索它们并且没有本地触发器会影响该操作，那么可以让整个操作在远程服务器上执行。下面介绍的接口能让这种做法变成可能。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
bool
PlanDirectModify(PlannerInfo *root,
                 ModifyTable *plan,
                 Index resultRelation,
                 int subplan_index);
</programlisting>

     Decide whether it is safe to execute a direct modification
     on the remote server.  If so, return <literal>true</literal> after performing
     planning actions needed for that.  Otherwise, return <literal>false</literal>.
     This optional function is called during query planning.
     If this function succeeds, <function>BeginDirectModify</function>,
     <function>IterateDirectModify</function> and <function>EndDirectModify</function> will
     be called at the execution stage, instead.  Otherwise, the table
     modification will be executed using the table-updating functions
     described above.
     The parameters are the same as for <function>PlanForeignModify</function>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
bool
PlanDirectModify(PlannerInfo *root,
                 ModifyTable *plan,
                 Index resultRelation,
                 int subplan_index);
</programlisting>

     决定在远程服务器上执行直接修改是否安全。如果安全，执行所需的规划动作然后返回<literal>true</literal>。否则返回<literal>false</literal>。这个可选的函数在查询规划期间被调用。如果这个函数成功，在执行阶段将会调用<function>BeginDirectModify</function>、<function>IterateDirectModify</function>和<function>EndDirectModify</function>。否则，对表的修改将采用上文描述的表更新函数来执行。参数和<function>PlanForeignModify</function>的相同。
    </para>

<!--==========================orignal english content==========================
    <para>
     To execute the direct modification on the remote server, this function
     must rewrite the target subplan with a <structname>ForeignScan</structname> plan
     node that executes the direct modification on the remote server.  The
     <structfield>operation</structfield> field of the <structname>ForeignScan</structname> must
     be set to the <literal>CmdType</literal> enumeration appropriately; that is,
     <literal>CMD_UPDATE</literal> for <command>UPDATE</command>,
     <literal>CMD_INSERT</literal> for <command>INSERT</command>, and
     <literal>CMD_DELETE</literal> for <command>DELETE</command>.
    </para>
____________________________________________________________________________-->
    <para>
     要在远程服务器上执行直接修改，这个函数必须用一个<structname>ForeignScan</structname>计划节点（它在远程服务器上执行直接修改）重写目标子计划。<structname>ForeignScan</structname>的<structfield>operation</structfield>域必须被合适地设置为<literal>CmdType</literal>枚举值，即<literal>CMD_UPDATE</literal>表示<command>UPDATE</command>、<literal>CMD_INSERT</literal>表示<command>INSERT</command>而<literal>CMD_DELETE</literal>表示<command>DELETE</command>。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-planning"/> for additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-planning"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>PlanDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>PlanDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
BeginDirectModify(ForeignScanState *node,
                  int eflags);
</programlisting>

     Prepare to execute a direct modification on the remote server.
     This is called during executor startup.  It should perform any
     initialization needed prior to the direct modification (that should be
     done upon the first call to <function>IterateDirectModify</function>).
     The <structname>ForeignScanState</structname> node has already been created, but
     its <structfield>fdw_state</structfield> field is still NULL.  Information about
     the table to modify is accessible through the
     <structname>ForeignScanState</structname> node (in particular, from the underlying
     <structname>ForeignScan</structname> plan node, which contains any FDW-private
     information provided by <function>PlanDirectModify</function>).
     <literal>eflags</literal> contains flag bits describing the executor's
     operating mode for this plan node.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
BeginDirectModify(ForeignScanState *node,
                  int eflags);
</programlisting>

     准备在远程服务器上执行一次直接修改。这个函数会在执行器启动时被调用。它应该执行直接修改所需的任何初始化工作（应该在第一次<function>IterateDirectModify</function>调用之前完成）。<structname>ForeignScanState</structname>节点已经被创建，但是它的<structfield>fdw_state</structfield>域仍然为 NULL。有关要被修改的表的信息可以通过<structname>ForeignScanState</structname>节点（具体地，从底层的<structname>ForeignScan</structname>计划节点，它包含了<function>PlanDirectModify</function>提供的 FDW-私有信息）访问。<literal>eflags</literal>包含描述执行器对于这个计划节点操作模式的标志位。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that when <literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal> is
     true, this function should not perform any externally-visible actions;
     it should only do the minimum required to make the node state valid
     for <function>ExplainDirectModify</function> and <function>EndDirectModify</function>.
    </para>
____________________________________________________________________________-->
    <para>
     注意当<literal>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</literal>为真时，这个函数不应该执行任何外部可见的动作。它应当只做最少的工作让该节点状态对<function>ExplainDirectModify</function>和<function>EndDirectModify</function>有效。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>BeginDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>BeginDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
TupleTableSlot *
IterateDirectModify(ForeignScanState *node);
</programlisting>

     When the <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command>
     query doesn't have a <literal>RETURNING</literal> clause, just return NULL
     after a direct modification on the remote server.
     When the query has the clause, fetch one result containing the data
     needed for the <literal>RETURNING</literal> calculation, returning it in a
     tuple table slot (the node's <structfield>ScanTupleSlot</structfield> should be
     used for this purpose).  The data that was actually inserted, updated
     or deleted must be stored in the
     <literal>es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal>
     of the node's <structname>EState</structname>.
     Return NULL if no more rows are available.
     Note that this is called in a short-lived memory context that will be
     reset between invocations.  Create a memory context in
     <function>BeginDirectModify</function> if you need longer-lived storage, or use
     the <structfield>es_query_cxt</structfield> of the node's <structname>EState</structname>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
TupleTableSlot *
IterateDirectModify(ForeignScanState *node);
</programlisting>

     当<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>查询没有<literal>RETURNING</literal>子句时，完成远程服务器上的直接修改后返回 NULL。当查询有该子句时，取出一个包含<literal>RETURNING</literal>计算所需数据的结果，用一个元组表槽返回它（节点的<structfield>ScanTupleSlot</structfield>应被用于这一目的）。实际被插入、更新或者删除的数据必须被存储在该节点的<structname>EState</structname>的<literal>es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</literal>中。如果没有更多行可用，则返回 NULL。注意这个函数会在一个短期生存的内存上下文中被调用，该上下文会在两次调用之间被重置。如果需要一个长期存在的存储，可以在<function>BeginDirectModify</function>中创建一个内存上下文，或者使用该节点的<structname>EState</structname>中的<structfield>es_query_cxt</structfield>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The rows returned must match the <structfield>fdw_scan_tlist</structfield> target
     list if one was supplied, otherwise they must match the row type of the
     foreign table being updated.  If you choose to optimize away fetching
     columns that are not needed for the <literal>RETURNING</literal> calculation,
     you should insert nulls in those column positions, or else generate a
     <structfield>fdw_scan_tlist</structfield> list with those columns omitted.
    </para>
____________________________________________________________________________-->
    <para>
     如果提供了<structfield>fdw_scan_tlist</structfield>目标列表，则被返回的行必须匹配它。否则，被返回的行必须匹配被更新的外部表的行类型。如果选择优化掉<literal>RETURNING</literal>计算不需要的列，应该在这些列的位置上插入空值，或者生成一个忽略这些列的<structfield>fdw_scan_tlist</structfield>列表。
    </para>

<!--==========================orignal english content==========================
    <para>
     Whether the query has the clause or not, the query's reported row count
     must be incremented by the FDW itself.  When the query doesn't have the
     clause, the FDW must also increment the row count for the
     <structname>ForeignScanState</structname> node in the <command>EXPLAIN ANALYZE</command>
     case.
    </para>
____________________________________________________________________________-->
    <para>
     不管该查询是否具有<literal>RETURNING</literal>子句，查询所报告的行计数必须由 FDW 本身增加。当查询没有该子句时，FDW 还必须为<command>EXPLAIN ANALYZE</command>情况下的<structname>ForeignScanState</structname>节点增加行计数。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>IterateDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>IterateDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
EndDirectModify(ForeignScanState *node);
</programlisting>

     Clean up following a direct modification on the remote server.  It is
     normally not important to release palloc'd memory, but for example open
     files and connections to the remote server should be cleaned up.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
EndDirectModify(ForeignScanState *node);
</programlisting>

     在远程服务器上的直接修改后进行清理。通常释放用 palloc 分配的内存并不重要，但是诸如打开的文件和到远程服务器的连接应该被清除。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>EndDirectModify</function> pointer is set to
     <literal>NULL</literal>, no attempts to execute a direct modification on the
     remote server are taken.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>EndDirectModify</function>指针被设置为<literal>NULL</literal>，不会尝试在远程服务器上执行直接修改。
    </para>

   </sect2>
   
   <sect2 id="fdw-callbacks-row-locking">
<!--==========================orignal english content==========================
    <title>FDW Routines For Row Locking</title>
____________________________________________________________________________-->
    <title>用于行锁定的 FDW 例程</title>

<!--==========================orignal english content==========================
    <para>
     If an FDW wishes to support <firstterm>late row locking</firstterm> (as described
     in <xref linkend="fdw-row-locking"/>), it must provide the following
     callback functions:
    </para>
____________________________________________________________________________-->
    <para>
     如果一个 FDW 希望支持<firstterm>后期行锁定</firstterm>（如<xref linkend="fdw-row-locking"/>中所述），它必须提供下列回调函数：
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
                      LockClauseStrength strength);
</programlisting>

     Report which row-marking option to use for a foreign table.
     <literal>rte</literal> is the <structname>RangeTblEntry</structname> node for the table
     and <literal>strength</literal> describes the lock strength requested by the
     relevant <literal>FOR UPDATE/SHARE</literal> clause, if any.  The result must be
     a member of the <literal>RowMarkType</literal> enum type.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
RowMarkType
GetForeignRowMarkType(RangeTblEntry *rte,
                      LockClauseStrength strength);
</programlisting>

     报告要对一个外部表使用哪个行标记选项。<literal>rte</literal>是该表的<structname>RangeTblEntry</structname>节点，而<literal>strength</literal>描述<literal>FOR UPDATE/SHARE</literal>子句（如果有）所要求的锁长度。结果必须是<literal>RowMarkType</literal>枚举类型的一个成员。
    </para>

<!--==========================orignal english content==========================
    <para>
     This function is called during query planning for each foreign table that
     appears in an <command>UPDATE</command>, <command>DELETE</command>, or <command>SELECT
     FOR UPDATE/SHARE</command> query and is not the target of <command>UPDATE</command>
     or <command>DELETE</command>.
    </para>
____________________________________________________________________________-->
    <para>
     这个函数在查询规划期间会为每一个出现在<command>UPDATE</command>、<command>DELETE</command>或者<command>SELECT FOR UPDATE/SHARE</command>查询中的外部表调用，并且该外部表不是<command>UPDATE</command>和<command>DELETE</command>的目标。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>GetForeignRowMarkType</function> pointer is set to
     <literal>NULL</literal>, the <literal>ROW_MARK_COPY</literal> option is always used.
     (This implies that <function>RefetchForeignRow</function> will never be called,
     so it need not be provided either.)
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>GetForeignRowMarkType</function>指针被设置为<literal>NULL</literal>，将总是使用<literal>ROW_MARK_COPY</literal>选项（这意味着将不会调用<function>RefetchForeignRow</function>，因此也不必提供它）。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-row-locking"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
HeapTuple
RefetchForeignRow(EState *estate,
                  ExecRowMark *erm,
                  Datum rowid,
                  bool *updated);
</programlisting>

     Re-fetch one tuple from the foreign table, after locking it if required.
     <literal>estate</literal> is global execution state for the query.
     <literal>erm</literal> is the <structname>ExecRowMark</structname> struct describing
     the target foreign table and the row lock type (if any) to acquire.
     <literal>rowid</literal> identifies the tuple to be fetched.
     <literal>updated</literal> is an output parameter.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
HeapTuple
RefetchForeignRow(EState *estate,
                  ExecRowMark *erm,
                  Datum rowid,
                  bool *updated);
</programlisting>

     从外部表中重新取得一个元组，如有必要先锁定它。<literal>estate</literal>是该查询的全局执行状态。<literal>erm</literal>是描述目标外部表以及要获取的行锁类型（如果有）的<structname>ExecRowMark</structname>结构。<literal>rowid</literal>标识要取得的元组。<literal>updated</literal>是一个输出参数。
    </para>

<!--==========================orignal english content==========================
    <para>
     This function should return a palloc'ed copy of the fetched tuple,
     or <literal>NULL</literal> if the row lock couldn't be obtained.  The row lock
     type to acquire is defined by <literal>erm-&gt;markType</literal>, which is the
     value previously returned by <function>GetForeignRowMarkType</function>.
     (<literal>ROW_MARK_REFERENCE</literal> means to just re-fetch the tuple without
     acquiring any lock, and <literal>ROW_MARK_COPY</literal> will never be seen by
     this routine.)
    </para>
____________________________________________________________________________-->
    <para>
     这个函数应该返回被取得的元组的一个已经分配内存的拷贝，如果无法得到行锁则返回<literal>NULL</literal>。要获得的行锁由<literal>erm-&gt;markType</literal>定义，它是之前由<function>GetForeignRowMarkType</function>返回的值（<literal>ROW_MARK_REFERENCE</literal>标识只重新取得元组但不获得任何锁，这个例程将不会看到<literal>ROW_MARK_COPY</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     In addition, <literal>*updated</literal> should be set to <literal>true</literal>
     if what was fetched was an updated version of the tuple rather than
     the same version previously obtained.  (If the FDW cannot be sure about
     this, always returning <literal>true</literal> is recommended.)
    </para>
____________________________________________________________________________-->
    <para>
     此外，如果取得的是一个更新过的版本而不是之前获得的同一版本，<literal>*updated</literal>应被设置为<literal>true</literal>（如果 FDW 无法确定这一点，推荐总是返回<literal>true</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Note that by default, failure to acquire a row lock should result in
     raising an error; a <literal>NULL</literal> return is only appropriate if
     the <literal>SKIP LOCKED</literal> option is specified
     by <literal>erm-&gt;waitPolicy</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     注意在默认情况下，获取行锁失败应该导致产生错误。如果<literal>erm-&gt;waitPolicy</literal>指定了<literal>SKIP LOCKED</literal>，只有返回<literal>NULL</literal>才是合适的。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>rowid</literal> is the <structfield>ctid</structfield> value previously read
     for the row to be re-fetched.  Although the <literal>rowid</literal> value is
     passed as a <type>Datum</type>, it can currently only be a <type>tid</type>.  The
     function API is chosen in hopes that it may be possible to allow other
     data types for row IDs in future.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>rowid</literal>是要被重新取得的行之前读到的<structfield>ctid</structfield>值。尽管<literal>rowid</literal>值被作为<type>Datum</type>传递，但是目前它只能被读作<type>tid</type>。选择该函数 API 是希望未来能允许其他的行 ID 数据类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>RefetchForeignRow</function> pointer is set to
     <literal>NULL</literal>, attempts to re-fetch rows will fail
     with an error message.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>RefetchForeignRow</function>指针被设置为<literal>NULL</literal>，重新取得行的尝试将会失败并伴随有一个错误消息。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <xref linkend="fdw-row-locking"/> for more information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息请见<xref linkend="fdw-row-locking"/>。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
bool
RecheckForeignScan(ForeignScanState *node,
                   TupleTableSlot *slot);
</programlisting>
     Recheck that a previously-returned tuple still matches the relevant
     scan and join qualifiers, and possibly provide a modified version of
     the tuple.  For foreign data wrappers which do not perform join pushdown,
     it will typically be more convenient to set this to <literal>NULL</literal> and
     instead set <structfield>fdw_recheck_quals</structfield> appropriately.
     When outer joins are pushed down, however, it isn't sufficient to
     reapply the checks relevant to all the base tables to the result tuple,
     even if all needed attributes are present, because failure to match some
     qualifier might result in some attributes going to NULL, rather than in
     no tuple being returned.  <literal>RecheckForeignScan</literal> can recheck
     qualifiers and return true if they are still satisfied and false
     otherwise, but it can also store a replacement tuple into the supplied
     slot.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
bool
RecheckForeignScan(ForeignScanState *node, TupleTableSlot *slot);
</programlisting>
     重新检查之前返回的元组是否仍然匹配相关的扫描和连接条件，并且可能提供该元组的一个修改版本。对于不执行连接下推的外部数据包装器，通常把这设置为<literal>NULL</literal>并且恰当地设置<structfield>fdw_recheck_quals</structfield>会更方便。不过当外部连接被下推时，把与所有基表相关的检查重新应用在结果元组上是不够的，即便所有需要的属性都存在也是如此，因为匹配某个条件失败可能会导致某些属性变成 NULL，而不是没有元组被返回。<literal>RecheckForeignScan</literal>能够重新检查条件，并且在它们仍然满足时返回真，否则返回假，但是它也能够在提供的槽中存储一个替换元组。
    </para>

<!--==========================orignal english content==========================
    <para>
     To implement join pushdown, a foreign data wrapper will typically
     construct an alternative local join plan which is used only for
     rechecks; this will become the outer subplan of the
     <literal>ForeignScan</literal>.  When a recheck is required, this subplan
     can be executed and the resulting tuple can be stored in the slot.
     This plan need not be efficient since no base table will return more
     than one row; for example, it may implement all joins as nested loops.
     The function <literal>GetExistingLocalJoinPath</literal> may be used to search
     existing paths for a suitable local join path, which can be used as the
     alternative local join plan.  <literal>GetExistingLocalJoinPath</literal>
     searches for an unparameterized path in the path list of the specified
     join relation.  (If it does not find such a path, it returns NULL, in
     which case a foreign data wrapper may build the local path by itself or
     may choose not to create access paths for that join.)
    </para>
____________________________________________________________________________-->
    <para>
     要实现连接下推，外部数据包装器通常将构造一个可替代的本地连接计划，它只被用来做重新检查。这将变成<literal>ForeignScan</literal>的外子计划。在需要一次重新检查时，这个子计划可以被执行并且结果元组可以被存储在槽中。这个计划不需要效率很高，因为不会有基表返回超过一行。例如，它可以把所有的连接实现为嵌套循环。函数<literal>GetExistingLocalJoinPath</literal>可以被用来在已有的路径中搜索合适的本地连接路径，它可以被用作替换的本地连接计划。<literal>GetExistingLocalJoinPath</literal>会在指定连接关系的路径列表中搜索一个非参数化路径（如果没有找到这样的路径，它会返回 NULL，这种情况下外部数据包装器可以自行构造本地路径或者可以选择不为这个连接创建访问路径）。
    </para>
   </sect2>

   <sect2 id="fdw-callbacks-explain">
<!--==========================orignal english content==========================
    <title>FDW Routines for <command>EXPLAIN</command></title>
____________________________________________________________________________-->
    <title><command>EXPLAIN</command>的FDW例程</title>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
ExplainForeignScan(ForeignScanState *node,
                   ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table scan.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
ExplainForeignScan(ForeignScanState *node,
                   ExplainState *es);
</programlisting>

     为一个外部表扫描打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来向<command>EXPLAIN</command>输出中增加域。<literal>es</literal>中的标志域可以被用来决定什么将被打印，并且<structname>ForeignScanState</structname>节点的状态可以被检查来为<command>EXPLAIN ANALYZE</command>提供运行时统计数据。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExplainForeignScan</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExplainForeignScan</function>指针被设置为<literal>NULL</literal>，在<command>EXPLAIN</command>期间不会打印任何额外的信息。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
ExplainForeignModify(ModifyTableState *mtstate,
                     ResultRelInfo *rinfo,
                     List *fdw_private,
                     int subplan_index,
                     struct ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a foreign table update.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ModifyTableState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.  The first four arguments are the same as for
     <function>BeginForeignModify</function>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
ExplainForeignModify(ModifyTableState *mtstate,
                     ResultRelInfo *rinfo,
                     List *fdw_private,
                     int subplan_index,
                     struct ExplainState *es);
</programlisting>

     为一个外部表更新打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来向<command>EXPLAIN</command>输出中增加域。<literal>es</literal>中的标志域可以被用来决定什么将被打印，并且<structname>ModifyTableState</structname>节点的状态可以被检查来为<command>EXPLAIN ANALYZE</command>提供运行时统计数据。前四个参数和<function>BeginForeignModify</function>相同。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExplainForeignModify</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExplainForeignModify</function>指针被设置为<literal>NULL</literal>，在<command>EXPLAIN</command>期间不会打印任何额外的信息。
    </para>
    
<!--==========================orignal english content==========================
    <para>
<programlisting>
void
ExplainDirectModify(ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     Print additional <command>EXPLAIN</command> output for a direct modification
     on the remote server.
     This function can call <function>ExplainPropertyText</function> and
     related functions to add fields to the <command>EXPLAIN</command> output.
     The flag fields in <literal>es</literal> can be used to determine what to
     print, and the state of the <structname>ForeignScanState</structname> node
     can be inspected to provide run-time statistics in the <command>EXPLAIN
     ANALYZE</command> case.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
ExplainDirectModify(ForeignScanState *node,
                    ExplainState *es);
</programlisting>

     为远程服务器上的直接修改打印额外的<command>EXPLAIN</command>输出。这个函数可以调用<function>ExplainPropertyText</function>和相关函数来为<command>EXPLAIN</command>输出增加域。<literal>es</literal>中的标志域可以被用来判断要打印什么，并且在<command>EXPLAIN ANALYZE</command>情况中可以观察<structname>ForeignScanState</structname>节点的状态来提供运行时统计信息。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the <function>ExplainDirectModify</function> pointer is set to
     <literal>NULL</literal>, no additional information is printed during
     <command>EXPLAIN</command>.
    </para>
____________________________________________________________________________-->
    <para>
     如果<function>ExplainDirectModify</function>指针被设置为<literal>NULL</literal>，<command>EXPLAIN</command>期间不会打印出额外的信息。
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-analyze">
<!--==========================orignal english content==========================
    <title>FDW Routines for <command>ANALYZE</command></title>
____________________________________________________________________________-->
    <title><command>ANALYZE</command>的FDW例程</title>

<!--==========================orignal english content==========================
    <para>
<programlisting>
bool
AnalyzeForeignTable(Relation relation,
                    AcquireSampleRowsFunc *func,
                    BlockNumber *totalpages);
</programlisting>

     This function is called when <xref linkend="sql-analyze"/> is executed on
     a foreign table.  If the FDW can collect statistics for this
     foreign table, it should return <literal>true</literal>, and provide a pointer
     to a function that will collect sample rows from the table in
     <parameter>func</parameter>, plus the estimated size of the table in pages in
     <parameter>totalpages</parameter>.  Otherwise, return <literal>false</literal>.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
bool
AnalyzeForeignTable(Relation relation,
                    AcquireSampleRowsFunc *func,
                    BlockNumber *totalpages);
</programlisting>

     当<xref linkend="sql-analyze"/>被执行在一个外部表上时会调用这个函数。如果FDW可以为这个外部表收集统计信息，它会返回<literal>true</literal>并提供一个函数指针，该函数将将从<parameter>func</parameter>中的表上收集采样行，外加<parameter>totalpages</parameter>中页面中的表尺寸估计值。否则，返回<literal>false</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the FDW does not support collecting statistics for any tables, the
     <function>AnalyzeForeignTable</function> pointer can be set to <literal>NULL</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     如果FDW不支持为任何表收集统计信息，<function>AnalyzeForeignTable</function>指针可以被设置为<literal>NULL</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If provided, the sample collection function must have the signature
<programlisting>
int
AcquireSampleRowsFunc(Relation relation,
                      int elevel,
                      HeapTuple *rows,
                      int targrows,
                      double *totalrows,
                      double *totaldeadrows);
</programlisting>

     A random sample of up to <parameter>targrows</parameter> rows should be collected
     from the table and stored into the caller-provided <parameter>rows</parameter>
     array.  The actual number of rows collected must be returned.  In
     addition, store estimates of the total numbers of live and dead rows in
     the table into the output parameters <parameter>totalrows</parameter> and
     <parameter>totaldeadrows</parameter>.  (Set <parameter>totaldeadrows</parameter> to zero
     if the FDW does not have any concept of dead rows.)
    </para>
____________________________________________________________________________-->
    <para>
     如果提供，采样收集函数必须具有签名
<programlisting>
int
AcquireSampleRowsFunc(Relation relation, int elevel,
                      HeapTuple *rows, int targrows,
                      double *totalrows,
                      double *totaldeadrows);
</programlisting>

     应该从该表上收集最多<parameter>targrows</parameter>行的一个随机采样并将它存放到调用者提供的<parameter>rows</parameter>数组中。实际被收集的行的数量必须被返回。另外，将表中有效行和死亡行的总数存储到输出参数<parameter>totalrows</parameter>和<parameter>totaldeadrows</parameter>中（如果FDW没有死亡行的概念，将<parameter>totaldeadrows</parameter>设置为 0 ）。
    </para>

   </sect2>

   <sect2 id="fdw-callbacks-import">
<!--==========================orignal english content==========================
    <title>FDW Routines For <command>IMPORT FOREIGN SCHEMA</command></title>
____________________________________________________________________________-->
    <title><command>IMPORT FOREIGN SCHEMA</command>的 FDW 例程</title>

<!--==========================orignal english content==========================
    <para>
<programlisting>
List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     Obtain a list of foreign table creation commands.  This function is
     called when executing <xref linkend="sql-importforeignschema"/>, and is
     passed the parse tree for that statement, as well as the OID of the
     foreign server to use.  It should return a list of C strings, each of
     which must contain a <xref linkend="sql-createforeigntable"/> command.
     These strings will be parsed and executed by the core server.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
List *
ImportForeignSchema(ImportForeignSchemaStmt *stmt, Oid serverOid);
</programlisting>

     取得一个外部表创建命令的列表。在执行<xref linkend="sql-importforeignschema"/>时会调用这个函数，并且会把该语句的解析树以及要使用的外部服务器的 OID 传递给它。它应该返回一个 C 字符串的列表，每一个必须包含一个<xref linkend="sql-createforeigntable"/>命令。这些命令将被核心服务器所解析和执行。
    </para>

<!--==========================orignal english content==========================
    <para>
     Within the <structname>ImportForeignSchemaStmt</structname> struct,
     <structfield>remote_schema</structfield> is the name of the remote schema from
     which tables are to be imported.
     <structfield>list_type</structfield> identifies how to filter table names:
     <literal>FDW_IMPORT_SCHEMA_ALL</literal> means that all tables in the remote
     schema should be imported (in this case <structfield>table_list</structfield> is
     empty), <literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal> means to include only
     tables listed in <structfield>table_list</structfield>,
     and <literal>FDW_IMPORT_SCHEMA_EXCEPT</literal> means to exclude the tables
     listed in <structfield>table_list</structfield>.
     <structfield>options</structfield> is a list of options used for the import process.
     The meanings of the options are up to the FDW.
     For example, an FDW could use an option to define whether the
     <literal>NOT NULL</literal> attributes of columns should be imported.
     These options need not have anything to do with those supported by the
     FDW as database object options.
    </para>
____________________________________________________________________________-->
    <para>
     在<structname>ImportForeignSchemaStmt</structname>结构中，<structfield>remote_schema</structfield>是要从其中导入这些表的远程模式的名称。<structfield>list_type</structfield>标识如何过滤表名：<literal>FDW_IMPORT_SCHEMA_ALL</literal>表示该远程模式中的所有表都应该被导入（这种情况下<structfield>table_list</structfield>为空），<literal>FDW_IMPORT_SCHEMA_LIMIT_TO</literal>表示只包括<structfield>table_list</structfield>中列出的表，而<literal>FDW_IMPORT_SCHEMA_EXCEPT</literal>则表示排除<structfield>table_list</structfield>中列出的表。<structfield>options</structfield>是一个用于该导入处理的选项列表。选项的含义由 FDW 决定。例如，一个 FDW 可以用一个选项来定义是否应该导入列的<literal>NOT NULL</literal>属性。这些选项不需要与那些 FDW 支持的数据库对象选项有什么关系。
    </para>

<!--==========================orignal english content==========================
    <para>
     The FDW may ignore the <structfield>local_schema</structfield> field of
     the <structname>ImportForeignSchemaStmt</structname>, because the core server
     will automatically insert that name into the parsed <command>CREATE
     FOREIGN TABLE</command> commands.
    </para>
____________________________________________________________________________-->
    <para>
     FDW 可能会忽略<structname>ImportForeignSchemaStmt</structname>的<structfield>local_schema</structfield>域，因为核心服务器会自动地向解析好的<command>CREATE FOREIGN TABLE</command>命令中插入本地模式的名称。
    </para>

<!--==========================orignal english content==========================
    <para>
     The FDW does not have to concern itself with implementing the filtering
     specified by <structfield>list_type</structfield> and <structfield>table_list</structfield>,
     either, as the core server will automatically skip any returned commands
     for tables excluded according to those options.  However, it's often
     useful to avoid the work of creating commands for excluded tables in the
     first place.  The function <function>IsImportableForeignTable()</function> may be
     useful to test whether a given foreign-table name will pass the filter.
    </para>
____________________________________________________________________________-->
    <para>
     FDW 也不必担心实现<structfield>list_type</structfield>以及<structfield>table_list</structfield>所指定的过滤，因为核心服务器将自动根据那些选项跳过为被排除的表所返回的命令。不过，起初就避免为被排除的表创建命令当然更好。函数<function>IsImportableForeignTable()</function>可以用来测试一个给定的外部表名是否能通过该过滤器。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the FDW does not support importing table definitions, the
     <function>ImportForeignSchema</function> pointer can be set to <literal>NULL</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     如果 FDW 不支持导入表定义，<function>ImportForeignSchema</function>指针可以被设置为<literal>NULL</literal>。
    </para>

   </sect2>
   
   <sect2 id="fdw-callbacks-parallel">
<!--==========================orignal english content==========================
    <title>FDW Routines for Parallel Execution</title>
____________________________________________________________________________-->
    <title>并行执行的 FDW 例程</title>
<!--==========================orignal english content==========================
    <para>
     A <structname>ForeignScan</structname> node can, optionally, support parallel
     execution.  A parallel <structname>ForeignScan</structname> will be executed
     in multiple processes and must return each row exactly once across
     all cooperating processes.  To do this, processes can coordinate through
     fixed-size chunks of dynamic shared memory.  This shared memory is not
     guaranteed to be mapped at the same address in every process, so it
     must not contain pointers.  The following functions are all optional,
     but most are required if parallel execution is to be supported.
    </para>
____________________________________________________________________________-->
    <para>
     <structname>ForeignScan</structname>节点可以选择支持并行执行。一个并行的<structname>ForeignScan</structname>将在多个进程中被执行并且在相互合作的进程中每一个元组必须只被返回一次。要做到这样，进程可以通过动态共享内存的固定尺寸块来协作。并不保证在每一个进程中这部份共享内存都被映射到相同的地址，因此不能包含指针。下面的函数通常都是可选的，但是如果要支持并行执行就必须提供其中的大部分。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);
</programlisting>
    Test whether a scan can be performed within a parallel worker.  This
    function will only be called when the planner believes that a parallel
    plan might be possible, and should return true if it is safe for that scan
    to run within a parallel worker.  This will generally not be the case if
    the remote data source has transaction semantics, unless the worker's
    connection to the data can somehow be made to share the same transaction
    context as the leader.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);
</programlisting>
    测试一个扫描是否可以在一个并行工作者中被执行。只有当规划器相信可以使用并行计划时才会调用这个函数，如果该扫描在并行工作者中可以安全运行这个函数应该返回真。如果远程数据源具有事务语义，情况通常都不是这样，除非工作者到数据的连接能够以某种方式共享与领导者相同的事务环境。
    </para>

<!--==========================orignal english content==========================
    <para>
    If this function is not defined, it is assumed that the scan must take
    place within the parallel leader.  Note that returning true does not mean
    that the scan itself can be done in parallel, only that the scan can be
    performed within a parallel worker.  Therefore, it can be useful to define
    this method even when parallel execution is not supported.
    </para>
____________________________________________________________________________-->
    <para>
    如果没有定义这个函数，则假定该扫描必须被放置在并行领导者中。注意返回真并不意味着该扫描本身可以被并行完成，只是说明该扫描可以在一个并行工作者中执行。因此，即便当不支持并行执行时，定义这个方法也是有用的。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
</programlisting>
    Estimate the amount of dynamic shared memory that will be required
    for parallel operation.  This may be higher than the amount that will
    actually be used, but it must not be lower.  The return value is in bytes.
    This function is optional, and can be omitted if not needed; but if it
    is omitted, the next three functions must be omitted as well, because
    no shared memory will be allocated for the FDW's use.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);
</programlisting>
    估算并行操作所需的动态共享内存的数量。这可能比实际要用的数量更大，但是绝不能更小。返回值的单位是字节。这个函数是可选的，并且在不需要时可以省略。但是如果它被省略，接下来的三个函数也必须被省略，因为不会为FDW分配共享内存。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);
</programlisting>
    Initialize the dynamic shared memory that will be required for parallel
    operation.  <literal>coordinate</literal> points to a shared memory area of
    size equal to the return value of <function>EstimateDSMForeignScan</function>.
    This function is optional, and can be omitted if not needed.
   </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);
</programlisting>
    初始化并行操作所需的动态共享内存。<literal>coordinate</literal>指向一块共享内存区域，其尺寸等于<function>EstimateDSMForeignScan</function>的返回值。这个函数是可选的，并且在不需要时可以省略。
   </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);
</programlisting>
    Re-initialize the dynamic shared memory required for parallel operation
    when the foreign-scan plan node is about to be re-scanned.
    This function is optional, and can be omitted if not needed.
    Recommended practice is that this function reset only shared state,
    while the <function>ReScanForeignScan</function> function resets only local
    state.  Currently, this function will be called
    before <function>ReScanForeignScan</function>, but it's best not to rely on
    that ordering.
   </para>
____________________________________________________________________________-->
    <para>
<programlisting>
void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);
</programlisting>
    当外部扫描计划将要被重新扫描时，重新初始化并行操作所要求的动态共享内存。这个函数是可选的，并且在不需要时可以省略。推荐的措施是这个函数只重置共享状态，而<function>ReScanForeignScan</function>函数仅重置本地状态。当前，这个函数将在<function>ReScanForeignScan</function>之前被调用，但是最好不要依赖于这种顺序。
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);
</programlisting>
    Initialize a parallel worker's local state based on the shared state
    set up by the leader during <function>InitializeDSMForeignScan</function>.
    This function is optional, and can be omitted if not needed.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);
</programlisting>
    基于领导者在<function>InitializeDSMForeignScan</function>期间建立的共享状态初始化并行工作者的本地状态。这个函数是可选的，并且在不需要时可以省略。
   </para>

<!--==========================orignal english content==========================
   <para>
<programlisting>
void
ShutdownForeignScan(ForeignScanState *node);
</programlisting>
    Release resources when it is anticipated the node will not be executed
    to completion.  This is not called in all cases; sometimes,
    <literal>EndForeignScan</literal> may be called without this function having
    been called first.  Since the DSM segment used by parallel query is
    destroyed just after this callback is invoked, foreign data wrappers that
    wish to take some action before the DSM segment goes away should implement
    this method.
   </para>
____________________________________________________________________________-->
   <para>
<programlisting>
void
ShutdownForeignScan(ForeignScanState *node);
</programlisting>
    在预见到节点将不会被执行完时释放资源。这个函数不会在所有的情况中执行，有时会在没有先调用这个函数之前调用<literal>EndForeignScan</literal>。由于在这个回调被调用之后并行查询使用的DSM段将被销毁，希望在DMS段消失前采取某种行动的外部数据包装器应该实现这个方法。
   </para>
   </sect2>

   <sect2 id="fdw-callbacks-reparameterize-paths">
<!--==========================orignal english content==========================
    <title>FDW Routines For reparameterization of paths</title>
____________________________________________________________________________-->
    <title>用于路径重新参数化的FDW例程</title>

<!--==========================orignal english content==========================
    <para>
<programlisting>
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);
</programlisting>
    This function is called while converting a path parameterized by the
    top-most parent of the given child relation <literal>child_rel</literal> to be
    parameterized by the child relation. The function is used to reparameterize
    any paths or translate any expression nodes saved in the given
    <literal>fdw_private</literal> member of a <structname>ForeignPath</structname>. The
    callback may use <literal>reparameterize_path_by_child</literal>,
    <literal>adjust_appendrel_attrs</literal> or
    <literal>adjust_appendrel_attrs_multilevel</literal> as required.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
List *
ReparameterizeForeignPathByChild(PlannerInfo *root, List *fdw_private,
                                 RelOptInfo *child_rel);
</programlisting>
    在把一个由给定子关系<literal>child_rel</literal>的最顶层父关系参数化的路径转换成由该子关系参数化的路径时会调用这个函数。该函数被用于重新参数化任意路径或者转化一个<structname>ForeignPath</structname>的给定<literal>fdw_private</literal>成员中保存的任意表达式节点。该回调可能会根据需要使用<literal>reparameterize_path_by_child</literal>、<literal>adjust_appendrel_attrs</literal>或者<literal>adjust_appendrel_attrs_multilevel</literal>。
   </para>
   </sect2>
   
   </sect1>

   <sect1 id="fdw-helpers">
<!--==========================orignal english content==========================
    <title>Foreign Data Wrapper Helper Functions</title>
____________________________________________________________________________-->
    <title>外部数据包装器助手函数</title>

<!--==========================orignal english content==========================
    <para>
     Several helper functions are exported from the core server so that
     authors of foreign data wrappers can get easy access to attributes of
     FDW-related objects, such as FDW options.
     To use any of these functions, you need to include the header file
     <filename>foreign/foreign.h</filename> in your source file.
     That header also defines the struct types that are returned by
     these functions.
    </para>
____________________________________________________________________________-->
    <para>
     多个助手函数被从核心服务器输出，这样外部数据包装器的作者们可以很容易访问到FDW相关对象的属性，例如FDW选项。要使用任何其中一个函数，你需要在你的源文件中包括头文件<filename>foreign/foreign.h</filename>。这个头也定义了被这些函数返回的结构类型。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given OID.  A
     <structname>ForeignDataWrapper</structname> object contains properties
     of the FDW (see <filename>foreign/foreign.h</filename> for details).
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapper(Oid fdwid);
</programlisting>

     这个函数为具有给定 OID 的外部数据包装器返回一个<structname>ForeignDataWrapper</structname>对象。一个<structname>ForeignDataWrapper</structname>对象包含该FDW的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given OID.  A
     <structname>ForeignServer</structname> object contains properties
     of the server (see <filename>foreign/foreign.h</filename> for details).
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignServer *
GetForeignServer(Oid serverid);
</programlisting>

     这个函数为一个具有给定 OID 的外部服务器返回<structname>ForeignServer</structname>对象。一个<structname>ForeignServer</structname>对象包含该服务器的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     This function returns a <structname>UserMapping</structname> object for
     the user mapping of the given role on the given server.  (If there is no
     mapping for the specific user, it will return the mapping for
     <literal>PUBLIC</literal>, or throw error if there is none.)  A
     <structname>UserMapping</structname> object contains properties of the
     user mapping (see <filename>foreign/foreign.h</filename> for details).
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
UserMapping *
GetUserMapping(Oid userid, Oid serverid);
</programlisting>

     这个函数为在给定服务器上的给定角色的用户映射返回<structname>UserMapping</structname>对象（如果指定用户没有映射，它将返回<literal>PUBLIC</literal>的映射，如果也没有则抛出错误）。一个<structname>UserMapping</structname>对象包含该用户映射的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     This function returns a <structname>ForeignTable</structname> object for
     the foreign table with the given OID.  A
     <structname>ForeignTable</structname> object contains properties of the
     foreign table (see <filename>foreign/foreign.h</filename> for details).
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignTable *
GetForeignTable(Oid relid);
</programlisting>

     该函数为一个具有给定 OID 的外部表返回<structname>ForeignTable</structname>对象。一个<structname>ForeignTable</structname>对象包含该外部表的特性（详见<filename>foreign/foreign.h</filename>）。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     This function returns the per-column FDW options for the column with the
     given foreign table OID and attribute number, in the form of a list of
     <structname>DefElem</structname>.  NIL is returned if the column has no
     options.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
List *
GetForeignColumnOptions(Oid relid, AttrNumber attnum);
</programlisting>

     这个函数为一个具有给定外部表 OID 和属性号的列返回针对每一列的FDW选项，形式为一个<structname>DefElem</structname>列表。如果该列没有选项则返回 NIL。
    </para>

<!--==========================orignal english content==========================
    <para>
     Some object types have name-based lookup functions in addition to the
     OID-based ones:
    </para>
____________________________________________________________________________-->
    <para>
     某些对象类型除了基于OID的查找函数之外，还具有基于名称的查找函数：
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignDataWrapper</structname>
     object for the foreign-data wrapper with the given name.  If the wrapper
     is not found, return NULL if missing_ok is true, otherwise raise an
     error.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignDataWrapper *
GetForeignDataWrapperByName(const char *name, bool missing_ok);
</programlisting>

     这个函数为一个具有给定名称的外部数据包装器返回<structname>ForeignDataWrapper</structname>对象。如果包装器没有找到，在missing_ok为真时返回 NULL，否则抛出一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     This function returns a <structname>ForeignServer</structname> object
     for the foreign server with the given name.  If the server is not found,
     return NULL if missing_ok is true, otherwise raise an error.
    </para>
____________________________________________________________________________-->
    <para>
<programlisting>
ForeignServer *
GetForeignServerByName(const char *name, bool missing_ok);
</programlisting>

     这个函数为一个具有给定名称的外部服务器返回<structname>ForeignServer</structname>对象。如果该服务器没有被找到，在missing_ok为真时返回 NULL，否则抛出一个错误。
    </para>

   </sect1>

   <sect1 id="fdw-planning">
<!--==========================orignal english content==========================
    <title>Foreign Data Wrapper Query Planning</title>
____________________________________________________________________________-->
    <title>外部数据包装器查询规划</title>

<!--==========================orignal english content==========================
    <para>
     The FDW callback functions <function>GetForeignRelSize</function>,
     <function>GetForeignPaths</function>, <function>GetForeignPlan</function>,
     <function>PlanForeignModify</function>, <function>GetForeignJoinPaths</function>,
     <function>GetForeignUpperPaths</function>, and <function>PlanDirectModify</function>
     must fit into the workings of the <productname>PostgreSQL</productname> planner.
     Here are some notes about what they must do.
    </para>
____________________________________________________________________________-->
    <para>
     FDW回调函数<function>GetForeignRelSize</function>、<function>GetForeignPaths</function>、<function>GetForeignPlan</function>、<function>PlanForeignModify</function>、<function>GetForeignJoinPaths</function>、<function>GetForeignUpperPaths</function>以及<function>PlanDirectModify</function>必须适合<productname>PostgreSQL</productname>规划器的工作。这里有一些关于它们必须做什么的注记。
    </para>

<!--==========================orignal english content==========================
    <para>
     The information in <literal>root</literal> and <literal>baserel</literal> can be used
     to reduce the amount of information that has to be fetched from the
     foreign table (and therefore reduce the cost).
     <literal>baserel-&gt;baserestrictinfo</literal> is particularly interesting, as
     it contains restriction quals (<literal>WHERE</literal> clauses) that should be
     used to filter the rows to be fetched.  (The FDW itself is not required
     to enforce these quals, as the core executor can check them instead.)
     <literal>baserel-&gt;reltarget-&gt;exprs</literal> can be used to determine which
     columns need to be fetched; but note that it only lists columns that
     have to be emitted by the <structname>ForeignScan</structname> plan node, not
     columns that are used in qual evaluation but not output by the query.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>root</literal>和<literal>baserel</literal>中的信息可以被用来减少必须从外部表获得的信息量（并且因此降低代价）。<literal>baserel-&gt;baserestrictinfo</literal>是特别有趣的，因为它包含限制条件（<literal>WHERE</literal>）子句，它应该被用来过滤要被获取的行（FDW本身并不要求强制这些条件，因为核心执行器可以检查它们）。<literal>baserel-&gt;reltarget-&gt;exprs</literal>可以被用来决定哪些类需要被获取；但是注意它仅列出了<structname>ForeignScan</structname>计划节点所发出的列，不包含在条件计算中使用但并不被查询输出的列。
    </para>

<!--==========================orignal english content==========================
    <para>
     Various private fields are available for the FDW planning functions to
     keep information in.  Generally, whatever you store in FDW private fields
     should be palloc'd, so that it will be reclaimed at the end of planning.
    </para>
____________________________________________________________________________-->
    <para>
     有多个私有域可以给FDW规划函数来保存信息。通常，不管你存储什么在FDW私有域中，它们都应该被palloc，这样它会在规划结束时被回收。    </para>

<!--==========================orignal english content==========================
    <para>
     <literal>baserel-&gt;fdw_private</literal> is a <type>void</type> pointer that is
     available for FDW planning functions to store information relevant to
     the particular foreign table.  The core planner does not touch it except
     to initialize it to NULL when the <literal>RelOptInfo</literal> node is created.
     It is useful for passing information forward from
     <function>GetForeignRelSize</function> to <function>GetForeignPaths</function> and/or
     <function>GetForeignPaths</function> to <function>GetForeignPlan</function>, thereby
     avoiding recalculation.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>baserel-&gt;fdw_private</literal>是一个<type>void</type>指针，它可以被FDW规划函数用来存储与特定外部表相关的信息。核心规划器不会碰它除非当<literal>RelOptInfo</literal>节点被创建时把它初始化为NULL。它对从<function>GetForeignRelSize</function>传递信息给<function>GetForeignPaths</function>和/或从<function>GetForeignPaths</function>传递信息给<function>GetForeignPlan</function>非常有用，这样避免了重新计算。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>GetForeignPaths</function> can identify the meaning of different
     access paths by storing private information in the
     <structfield>fdw_private</structfield> field of <structname>ForeignPath</structname> nodes.
     <structfield>fdw_private</structfield> is declared as a <type>List</type> pointer, but
     could actually contain anything since the core planner does not touch
     it.  However, best practice is to use a representation that's dumpable
     by <function>nodeToString</function>, for use with debugging support available
     in the backend.
    </para>
____________________________________________________________________________-->
    <para>
     <function>GetForeignPaths</function>可以通过在<structname>ForeignPath</structname>节点的<structfield>fdw_private</structfield>域中存储私有信息来标识不同的访问路径。<structfield>fdw_private</structfield>被声明为一个<type>List</type>指针，但是可能实际上包含任何东西，因为规划器不会触碰它。但是，最好是使用一种<function>nodeToString</function>可导出的形式，这样在后端可以用于调试支持。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>GetForeignPlan</function> can examine the <structfield>fdw_private</structfield>
     field of the selected <structname>ForeignPath</structname> node, and can generate
     <structfield>fdw_exprs</structfield> and <structfield>fdw_private</structfield> lists to be
     placed in the <structname>ForeignScan</structname> plan node, where they will be
     available at execution time.  Both of these lists must be
     represented in a form that <function>copyObject</function> knows how to copy.
     The <structfield>fdw_private</structfield> list has no other restrictions and is
     not interpreted by the core backend in any way.  The
     <structfield>fdw_exprs</structfield> list, if not NIL, is expected to contain
     expression trees that are intended to be executed at run time.  These
     trees will undergo post-processing by the planner to make them fully
     executable.
    </para>
____________________________________________________________________________-->
    <para>
     <function>GetForeignPlan</function>可以检查选中的<structname>ForeignPath</structname>节点的<structfield>fdw_private</structfield>域，并且可以生成被放置于<structname>ForeignPath</structname>计划节点中的<structfield>fdw_exprs</structfield>和<structfield>fdw_private</structfield>列表。这两个列表必须被表示为一种<function>copyObject</function>可复制的形式。<structfield>fdw_private</structfield>列表没有任何其他限制并且不会被核心后端以任何形式解释。非 NIL 的<structfield>fdw_exprs</structfield>应该包含表达式树，该树会在运行时被执行。这些树将由规划器在后期处理，以便让它们变成完全可执行的。
    </para>

<!--==========================orignal english content==========================
    <para>
     In <function>GetForeignPlan</function>, generally the passed-in target list can
     be copied into the plan node as-is.  The passed <literal>scan_clauses</literal> list
     contains the same clauses as <literal>baserel-&gt;baserestrictinfo</literal>,
     but may be re-ordered for better execution efficiency.  In simple cases
     the FDW can just strip <structname>RestrictInfo</structname> nodes from the
     <literal>scan_clauses</literal> list (using <function>extract_actual_clauses</function>) and put
     all the clauses into the plan node's qual list, which means that all the
     clauses will be checked by the executor at run time.  More complex FDWs
     may be able to check some of the clauses internally, in which case those
     clauses can be removed from the plan node's qual list so that the
     executor doesn't waste time rechecking them.
    </para>
____________________________________________________________________________-->
    <para>
     在<function>GetForeignPlan</function>中，通常被传入的目标列表可以被照样复制到计划节点中。被传入的<literal>scan_clauses</literal> 列表包含和<literal>baserel-&gt;baserestrictinfo</literal>相同的子句，但是可能为了更好的执行效率会被重新排序。在简单情况下，FDW可以只把<structname>RestrictInfo</structname>节点从<literal>scan_clauses</literal> 列表剥离（使用<function>extract_actual_clauses</function>）并且把所有子句放到计划节点的条件列表中，这意味着所有子句将在运行时由执行器检查。更复杂的FDW可能可以在内部检查某些子句，着这种情况下哪些子句可以从计划节点的条件列表中删除，这样执行器就不用浪费时间去检查它们。
    </para>

<!--==========================orignal english content==========================
    <para>
     As an example, the FDW might identify some restriction clauses of the
     form <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>sub_expression</replaceable>, which it determines can be executed on
     the remote server given the locally-evaluated value of the
     <replaceable>sub_expression</replaceable>.  The actual identification of such a
     clause should happen during <function>GetForeignPaths</function>, since it would
     affect the cost estimate for the path.  The path's
     <structfield>fdw_private</structfield> field would probably include a pointer to
     the identified clause's <structname>RestrictInfo</structname> node.  Then
     <function>GetForeignPlan</function> would remove that clause from <literal>scan_clauses</literal>,
     but add the <replaceable>sub_expression</replaceable> to <structfield>fdw_exprs</structfield>
     to ensure that it gets massaged into executable form.  It would probably
     also put control information into the plan node's
     <structfield>fdw_private</structfield> field to tell the execution functions what
     to do at run time.  The query transmitted to the remote server would
     involve something like <literal>WHERE <replaceable>foreign_variable</replaceable> =
     $1</literal>, with the parameter value obtained at run time from
     evaluation of the <structfield>fdw_exprs</structfield> expression tree.
    </para>
____________________________________________________________________________-->
    <para>
     作为一个例子，FDW可以标识某些<replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>sub_expression</replaceable>形式的限制子句，它决定哪些可以使用由<replaceable>sub_expression</replaceable>给出的本地计算值在远程服务器上被执行。这样一个子句的实际标识应该在<function>GetForeignPaths</function>期间发生，因为它可能会影响路径的代价估计。路径的<structfield>fdw_private</structfield>域可能包括一个已标识的子句的<structname>RestrictInfo</structname>节点。然后<function>GetForeignPlan</function>将从<literal>scan_clauses</literal> 中移除该子句，但是将<replaceable>sub_expression</replaceable>加到<structfield>fdw_exprs</structfield>来保证它被揉成可执行的形式。它可能还将把控制信息放入到计划节点的<structfield>fdw_private</structfield>域来告诉执行函数在运行时要做什么。传递给远程服务器的查询将涉及类似<literal>WHERE <replaceable>foreign_variable</replaceable> = $1</literal>的东西，使用在运行时从<structfield>fdw_exprs</structfield>表达式树获得的参数值。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     Any clauses removed from the plan node's qual list must instead be added
     to <literal>fdw_recheck_quals</literal> or rechecked by
     <literal>RecheckForeignScan</literal> in order to ensure correct behavior
     at the <literal>READ COMMITTED</literal> isolation level.  When a concurrent
     update occurs for some other table involved in the query, the executor
     may need to verify that all of the original quals are still satisfied for
     the tuple, possibly against a different set of parameter values.  Using
     <literal>fdw_recheck_quals</literal> is typically easier than implementing checks
     inside <literal>RecheckForeignScan</literal>, but this method will be
     insufficient when outer joins have been pushed down, since the join tuples
     in that case might have some fields go to NULL without rejecting the
     tuple entirely.
    </para>
____________________________________________________________________________-->
    <para>
     任何从该计划节点的条件列表移除的子句必须被加入到<literal>fdw_recheck_quals</literal>或者由<literal>RecheckForeignScan</literal>重新检查以便确保在<literal>READ COMMITTED</literal>隔离级别的正确行为。当查询中涉及的某个其他表上发生并发更新时，执行器可能需要验证原来的所有条件仍然对该元组满足（可能用一组不同的参数值）。使用<literal>fdw_recheck_quals</literal>通常比在<literal>RecheckForeignScan</literal>中实现检查要更容易，但是这种方法不足以应付外连接被下推的情况，因为那种情况下的连接元组可能会有一些域具有 NULL 但是不会导致整个元组被拒绝。
    </para>

<!--==========================orignal english content==========================
    <para>
     Another <structname>ForeignScan</structname> field that can be filled by FDWs
     is <structfield>fdw_scan_tlist</structfield>, which describes the tuples returned by
     the FDW for this plan node.  For simple foreign table scans this can be
     set to <literal>NIL</literal>, implying that the returned tuples have the
     row type declared for the foreign table.  A non-<symbol>NIL</symbol> value must be a
     target list (list of <structname>TargetEntry</structname>s) containing Vars and/or
     expressions representing the returned columns.  This might be used, for
     example, to show that the FDW has omitted some columns that it noticed
     won't be needed for the query.  Also, if the FDW can compute expressions
     used by the query more cheaply than can be done locally, it could add
     those expressions to <structfield>fdw_scan_tlist</structfield>.  Note that join
     plans (created from paths made by <function>GetForeignJoinPaths</function>) must
     always supply <structfield>fdw_scan_tlist</structfield> to describe the set of
     columns they will return.
    </para>
____________________________________________________________________________-->
    <para>
     另一个可以由 FDW 填充的<structname>ForeignScan</structname>域是<structfield>fdw_scan_tlist</structfield>，它描述 FDW 为这个计划节点返回的元组。对于简单的外部表扫描这可以设置为<literal>NIL</literal>，表示返回的元组具有为外部表声明的行类型。非-<symbol>NIL</symbol>值必须是一个包含表示返回列的 Var 或表达式的目标列表（<structname>TargetEntry</structname>的列表）。例如，这可以被用来显示 FDW 省略了某些查询不需要的列。还有，如果 FDW 计算表达式比在本地计算代价更低，可以把那些表达式加入到<structfield>fdw_scan_tlist</structfield>。注意连接计划（从<function>GetForeignJoinPaths</function>创建的路径得到）必须总是提供<structfield>fdw_scan_tlist</structfield>来描述它们将返回的列集合。
    </para>

<!--==========================orignal english content==========================
    <para>
     The FDW should always construct at least one path that depends only on
     the table's restriction clauses.  In join queries, it might also choose
     to construct path(s) that depend on join clauses, for example
     <replaceable>foreign_variable</replaceable> <literal>=</literal>
     <replaceable>local_variable</replaceable>.  Such clauses will not be found in
     <literal>baserel-&gt;baserestrictinfo</literal> but must be sought in the
     relation's join lists.  A path using such a clause is called a
     <quote>parameterized path</quote>.  It must identify the other relations
     used in the selected join clause(s) with a suitable value of
     <literal>param_info</literal>; use <function>get_baserel_parampathinfo</function>
     to compute that value.  In <function>GetForeignPlan</function>, the
     <replaceable>local_variable</replaceable> portion of the join clause would be added
     to <structfield>fdw_exprs</structfield>, and then at run time the case works the
     same as for an ordinary restriction clause.
    </para>
____________________________________________________________________________-->
    <para>
     FDW应该总是只依靠表的限制子句构建至少一个路径。在连接查询中，它可能还会选择依靠连接子句构建路径，例如<replaceable>foreign_variable</replaceable> <literal>=</literal> <replaceable>local_variable</replaceable>。这样的子句将不会在<literal>baserel-&gt;baserestrictinfo</literal>中找到，但是必须出现在关系的连接列表中。使用这样一个子句的路径被称为一个<quote>参数化路径</quote>。它必须用一个合适的<literal>param_info</literal>值来标识其他被使用在选中的连接子句中的关系；使用<function>get_baserel_parampathinfo</function>来计算该值。在<function>GetForeignPlan</function>中，连接子句的<replaceable>local_variable</replaceable>部分将被加到<structfield>fdw_exprs</structfield>中，并且接着在运行时和一个普通限制子句一样工作。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     If an FDW supports remote joins, <function>GetForeignJoinPaths</function> should
     produce <structname>ForeignPath</structname>s for potential remote joins in much
     the same way as <function>GetForeignPaths</function> works for base tables.
     Information about the intended join can be passed forward
     to <function>GetForeignPlan</function> in the same ways described above.
     However, <structfield>baserestrictinfo</structfield> is not relevant for join
     relations; instead, the relevant join clauses for a particular join are
     passed to <function>GetForeignJoinPaths</function> as a separate parameter
     (<literal>extra-&gt;restrictlist</literal>).
    </para>
____________________________________________________________________________-->
    <para>
     如果一个 FDW 支持远程连接，<function>GetForeignJoinPaths</function>应该和<function>GetForeignPaths</function>对基本表所作的那样为潜在的远程连接产生<structname>ForeignPath</structname>。有关想要进行的连接的信息可以以上述相同的方式传递给<function>GetForeignPlan</function>。不过，<structfield>baserestrictinfo</structfield>与连接关系无关，一个特定连接的相关连接子句将被作为一个独立的参数（<literal>extra-&gt;restrictlist</literal>）被传递给<function>GetForeignJoinPaths</function>。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     An FDW might additionally support direct execution of some plan actions
     that are above the level of scans and joins, such as grouping or
     aggregation.  To offer such options, the FDW should generate paths and
     insert them into the appropriate <firstterm>upper relation</firstterm>.  For
     example, a path representing remote aggregation should be inserted into
     the <literal>UPPERREL_GROUP_AGG</literal> relation, using <function>add_path</function>.
     This path will be compared on a cost basis with local aggregation
     performed by reading a simple scan path for the foreign relation (note
     that such a path must also be supplied, else there will be an error at
     plan time).  If the remote-aggregation path wins, which it usually would,
     it will be converted into a plan in the usual way, by
     calling <function>GetForeignPlan</function>.  The recommended place to generate
     such paths is in the <function>GetForeignUpperPaths</function>
     callback function, which is called for each upper relation (i.e., each
     post-scan/join processing step), if all the base relations of the query
     come from the same FDW.
    </para>
____________________________________________________________________________-->
    <para>
     FDW 可能会额外地支持直接执行某些在扫描和连接层次之上的计划动作，例如分组或者聚集。为了提供这类选项，FDW 应该生成路径并且把它们插入到合适的<firstterm>上层关系中</firstterm>。例如，一条表示远程聚集的路径应该被使用<function>add_path</function>插入到<literal>UPPERREL_GROUP_AGG</literal>关系中。这条路径的代价将会与通过读取外部关系的简单扫描路径的本地聚集（注意这样一条路径也必须被提供，否则规划时会有错误）进行比较。如果远程聚集路径胜出（通常是这样），它会被以通常的方式（调用<function>GetForeignPlan</function>）转化成计划。如果该查询的所有基本关系都来自于同一个 FDW，推荐在<function>GetForeignUpperPaths</function>回调函数中生成这种路径，该函数会为每一个上层关系被调用（即每一次扫描/连接后处理步骤）。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>PlanForeignModify</function> and the other callbacks described in
     <xref linkend="fdw-callbacks-update"/> are designed around the assumption
     that the foreign relation will be scanned in the usual way and then
     individual row updates will be driven by a local <literal>ModifyTable</literal>
     plan node.  This approach is necessary for the general case where an
     update requires reading local tables as well as foreign tables.
     However, if the operation could be executed entirely by the foreign
     server, the FDW could generate a path representing that and insert it
     into the <literal>UPPERREL_FINAL</literal> upper relation, where it would
     compete against the <literal>ModifyTable</literal> approach.  This approach
     could also be used to implement remote <literal>SELECT FOR UPDATE</literal>,
     rather than using the row locking callbacks described in
     <xref linkend="fdw-callbacks-row-locking"/>.  Keep in mind that a path
     inserted into <literal>UPPERREL_FINAL</literal> is responsible for
     implementing <emphasis>all</emphasis> behavior of the query.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="fdw-callbacks-update"/>中描述的<function>PlanForeignModify</function>以及其他回调的设计是建立在这样一个假设之上：外部表将以通常的方式被扫描并且行更新将被一个本地<literal>ModifyTable</literal>计划节点所驱动。这种方法对于更新需要读取本地表以及外部表的一般情况下是必要的。不过，如果操作可以完全由外部服务器执行，FDW 可以产生一个表示这种操作的计划并且把它插入到<literal>UPPERREL_FINAL</literal>上层关系中，在其中它会与<literal>ModifyTable</literal>方法竞争。这种方法还可以被用来实现远程<literal>SELECT FOR UPDATE</literal>，而不使用<xref linkend="fdw-callbacks-row-locking"/>中描述的行锁定回调。记住插入到<literal>UPPERREL_FINAL</literal>中的路径负责实现查询的<emphasis>所有</emphasis>行为。
    </para>

<!--==========================orignal english content==========================
    <para>
     When planning an <command>UPDATE</command> or <command>DELETE</command>,
     <function>PlanForeignModify</function> and <function>PlanDirectModify</function>
     can look up the <structname>RelOptInfo</structname>
     struct for the foreign table and make use of the
     <literal>baserel-&gt;fdw_private</literal> data previously created by the
     scan-planning functions.  However, in <command>INSERT</command> the target
     table is not scanned so there is no <structname>RelOptInfo</structname> for it.
     The <structname>List</structname> returned by <function>PlanForeignModify</function> has
     the same restrictions as the <structfield>fdw_private</structfield> list of a
     <structname>ForeignScan</structname> plan node, that is it must contain only
     structures that <function>copyObject</function> knows how to copy.
    </para>
____________________________________________________________________________-->
    <para>
     在规划一个<command>UPDATE</command>或<command>DELETE</command>时，<function>PlanForeignModify</function>和<function>PlanDirectModify</function>能为外部表查找<structname>RelOptInfo</structname>结构，并利用之前由扫描规划函数创建的<literal>baserel-&gt;fdw_private</literal>数据。但是，在<command>INSERT</command>中目标表不会被扫描，因此不会有它的<structname>RelOptInfo</structname>。由<function>PlanForeignModify</function>返回的<structname>List</structname>具有和<structname>ForeignScan</structname>计划节点的<structfield>fdw_private</structfield>列表相同的限制，即它必须只包含<function>copyObject</function>知道怎么拷贝的结构。
    </para>

<!--==========================orignal english content==========================
    <para>
     <command>INSERT</command> with an <literal>ON CONFLICT</literal> clause does not
     support specifying the conflict target, as unique constraints or
     exclusion constraints on remote tables are not locally known. This
     in turn implies that <literal>ON CONFLICT DO UPDATE</literal> is not supported,
     since the specification is mandatory there.
    </para>
____________________________________________________________________________-->
    <para>
     带有一个<literal>ON CONFLICT</literal>子句的<command>INSERT</command>不支持指定冲突目标，因为本地不知道远程表上的唯一约束和排除约束的情况。然后这也意味着<literal>ON CONFLICT DO UPDATE</literal>不被支持，因为该说明是强制性的。
    </para>

   </sect1>

   <sect1 id="fdw-row-locking">
<!--==========================orignal english content==========================
    <title>Row Locking in Foreign Data Wrappers</title>
____________________________________________________________________________-->
    <title>外部数据包装器中的行锁定</title>

<!--==========================orignal english content==========================
    <para>
     If an FDW's underlying storage mechanism has a concept of locking
     individual rows to prevent concurrent updates of those rows, it is
     usually worthwhile for the FDW to perform row-level locking with as
     close an approximation as practical to the semantics used in
     ordinary <productname>PostgreSQL</productname> tables.  There are multiple
     considerations involved in this.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个 FDW 的底层存储机制具有锁定行的概念来阻止对行的并发更新，通常值得 FDW 去执行行级锁定以尽可能接近在普通<productname>PostgreSQL</productname>表中所实际使用的语义。涉及这个问题有多种考虑。
    </para>

<!--==========================orignal english content==========================
    <para>
     One key decision to be made is whether to perform <firstterm>early
     locking</firstterm> or <firstterm>late locking</firstterm>.  In early locking, a row is
     locked when it is first retrieved from the underlying store, while in
     late locking, the row is locked only when it is known that it needs to
     be locked.  (The difference arises because some rows may be discarded by
     locally-checked restriction or join conditions.)  Early locking is much
     simpler and avoids extra round trips to a remote store, but it can cause
     locking of rows that need not have been locked, resulting in reduced
     concurrency or even unexpected deadlocks.  Also, late locking is only
     possible if the row to be locked can be uniquely re-identified later.
     Preferably the row identifier should identify a specific version of the
     row, as <productname>PostgreSQL</productname> TIDs do.
    </para>
____________________________________________________________________________-->
    <para>
     要做出的一个关键决定是执行<firstterm>早期锁定</firstterm>还是<firstterm>晚期锁定</firstterm>。在早期锁定中，当一行被第一次从底层存储中检索到时，它会被锁定；而在晚期锁定中，只有当行需要被锁定时才锁定它（由于某些行可能被本地检查的限制或者连接条件抛弃，所以会出现不同）。早期锁定更加简单并且能避免额外地与远程存储交互，但是可能会导致一些不需要锁定的行也被锁定，最终造成并发性下降甚至意外的死锁。还有，只有在要被锁定的行可以在后期唯一地重新标识时才可以用晚期锁定。较好的行标识符应该能标识行的特定版本，就像<productname>PostgreSQL</productname> TID 那样。
    </para>

<!--==========================orignal english content==========================
    <para>
     By default, <productname>PostgreSQL</productname> ignores locking considerations
     when interfacing to FDWs, but an FDW can perform early locking without
     any explicit support from the core code.  The API functions described
     in <xref linkend="fdw-callbacks-row-locking"/>, which were added
     in <productname>PostgreSQL</productname> 9.5, allow an FDW to use late locking if
     it wishes.
    </para>
____________________________________________________________________________-->
    <para>
     默认情况下，<productname>PostgreSQL</productname>在与 FDW 交互时会忽略锁定考虑，但是 FDW 可以在没有核心代码显式支持的情况下执行早期锁定。<xref linkend="fdw-callbacks-row-locking"/>中描述的 API 函数（在<productname>PostgreSQL</productname> 9.5 中加入）允许 FDW 按照意愿使用晚期锁定。
    </para>

<!--==========================orignal english content==========================
    <para>
     An additional consideration is that in <literal>READ COMMITTED</literal>
     isolation mode, <productname>PostgreSQL</productname> may need to re-check
     restriction and join conditions against an updated version of some
     target tuple.  Rechecking join conditions requires re-obtaining copies
     of the non-target rows that were previously joined to the target tuple.
     When working with standard <productname>PostgreSQL</productname> tables, this is
     done by including the TIDs of the non-target tables in the column list
     projected through the join, and then re-fetching non-target rows when
     required.  This approach keeps the join data set compact, but it
     requires inexpensive re-fetch capability, as well as a TID that can
     uniquely identify the row version to be re-fetched.  By default,
     therefore, the approach used with foreign tables is to include a copy of
     the entire row fetched from a foreign table in the column list projected
     through the join.  This puts no special demands on the FDW but can
     result in reduced performance of merge and hash joins.  An FDW that is
     capable of meeting the re-fetch requirements can choose to do it the
     first way.
    </para>
____________________________________________________________________________-->
    <para>
     一个额外的考虑是在<literal>READ COMMITTED</literal>隔离模式中，<productname>PostgreSQL</productname>可能需要对某个目标元组的更新版本进行限制以及连接条件的重新检查。重新检查连接条件要求重新获得之前连接成目标元组的非目标行拷贝。在标准<productname>PostgreSQL</productname>表的情况下，这可以通过在连接投影出的列列表中包括非目标表的 TID 并且在需要时重新取得非目标行来做到。这种方法可以让连接数据集保持紧凑，但是它要求代价较低的重新取得元组的功能，还有 TID 要能够唯一地标识要被重新取得的行版本。因此，默认情况下用于外部表的方法是将整个外部表元组的拷贝包括在从连接投影出的列列表中。这不会对 FDW 有特殊的要求，但是会导致归并和哈希连接性能下降。要满足重新取得元组需求的 FDW 可以选择第一种方式。
    </para>

<!--==========================orignal english content==========================
    <para>
     For an <command>UPDATE</command> or <command>DELETE</command> on a foreign table, it
     is recommended that the <literal>ForeignScan</literal> operation on the target
     table perform early locking on the rows that it fetches, perhaps via the
     equivalent of <command>SELECT FOR UPDATE</command>.  An FDW can detect whether
     a table is an <command>UPDATE</command>/<command>DELETE</command> target at plan time
     by comparing its relid to <literal>root-&gt;parse-&gt;resultRelation</literal>,
     or at execution time by using <function>ExecRelationIsTargetRelation()</function>.
     An alternative possibility is to perform late locking within the
     <function>ExecForeignUpdate</function> or <function>ExecForeignDelete</function>
     callback, but no special support is provided for this.
    </para>
____________________________________________________________________________-->
    <para>
     对于在外部表上的<command>UPDATE</command>或者<command>DELETE</command>，推荐目标表上的<literal>ForeignScan</literal>操作在它取得的行上执行早期锁定（可能通过<command>SELECT FOR UPDATE</command>的等效体）。通过在规划时比较一个表的 relid 和<literal>root-&gt;parse-&gt;resultRelation</literal>或在执行时使用<function>ExecRelationIsTargetRelation()</function>，一个 FDW 可以检测该表是否为<command>UPDATE</command>/<command>DELETE</command>的目标。另一种可能性是在<function>ExecForeignUpdate</function>或者<function>ExecForeignDelete</function>回调中执行晚期锁定，但是对此没有特别的支持。
    </para>

<!--==========================orignal english content==========================
    <para>
     For foreign tables that are specified to be locked by a <command>SELECT
     FOR UPDATE/SHARE</command> command, the <literal>ForeignScan</literal> operation can
     again perform early locking by fetching tuples with the equivalent
     of <command>SELECT FOR UPDATE/SHARE</command>.  To perform late locking
     instead, provide the callback functions defined
     in <xref linkend="fdw-callbacks-row-locking"/>.
     In <function>GetForeignRowMarkType</function>, select rowmark option
     <literal>ROW_MARK_EXCLUSIVE</literal>, <literal>ROW_MARK_NOKEYEXCLUSIVE</literal>,
     <literal>ROW_MARK_SHARE</literal>, or <literal>ROW_MARK_KEYSHARE</literal> depending
     on the requested lock strength.  (The core code will act the same
     regardless of which of these four options you choose.)
     Elsewhere, you can detect whether a foreign table was specified to be
     locked by this type of command by using <function>get_plan_rowmark</function> at
     plan time, or <function>ExecFindRowMark</function> at execution time; you must
     check not only whether a non-null rowmark struct is returned, but that
     its <structfield>strength</structfield> field is not <literal>LCS_NONE</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     对于通过<command>SELECT FOR UPDATE/SHARE</command>命令指定要被锁定的外部表，<literal>ForeignScan</literal>操作同样可以通过用<command>SELECT FOR UPDATE/SHARE</command>的等效体取元组来执行早期锁定。要执行晚期锁定，请提供<xref linkend="fdw-callbacks-row-locking"/>中定义的回调函数。在<function>GetForeignRowMarkType</function>中，根据请求的锁长度来选择行标记选项<literal>ROW_MARK_EXCLUSIVE</literal>、<literal>ROW_MARK_NOKEYEXCLUSIVE</literal>、<literal>ROW_MARK_SHARE</literal>或者<literal>ROW_MARK_KEYSHARE</literal>（不管选择哪一种选项，核心代码都会做同样的事情）。在别的地方，可以在规划时用<function>get_plan_rowmark</function>或者在执行时用<function>ExecFindRowMark</function>来检测一个外部表是否被指定由这种类型的命令锁定。你必须不仅仅检测是否返回了一个非空的行标记结构，还要检测它的<structfield>strength</structfield>域不是<literal>LCS_NONE</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Lastly, for foreign tables that are used in an <command>UPDATE</command>,
     <command>DELETE</command> or <command>SELECT FOR UPDATE/SHARE</command> command but
     are not specified to be row-locked, you can override the default choice
     to copy entire rows by having <function>GetForeignRowMarkType</function> select
     option <literal>ROW_MARK_REFERENCE</literal> when it sees lock strength
     <literal>LCS_NONE</literal>.  This will cause <function>RefetchForeignRow</function> to
     be called with that value for <structfield>markType</structfield>; it should then
     re-fetch the row without acquiring any new lock.  (If you have
     a <function>GetForeignRowMarkType</function> function but don't wish to re-fetch
     unlocked rows, select option <literal>ROW_MARK_COPY</literal>
     for <literal>LCS_NONE</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     最后，对于在<command>UPDATE</command>、<command>DELETE</command>或者<command>SELECT FOR UPDATE/SHARE</command>命令中使用但是没有被指定要行锁定的外部表，你可以在看到锁长度<literal>LCS_NONE</literal>时通过使用<function>GetForeignRowMarkType</function>选择选项<literal>ROW_MARK_REFERENCE</literal>来把默认选择覆盖为拷贝整个行。 这将导致用那个值作为<structfield>markType</structfield>来调用<function>RefetchForeignRow</function>。它应该接着重新取得该行而不获取任何新锁（如果你有一个<function>GetForeignRowMarkType</function>函数，但是不想重新取未锁定的行，可为<literal>LCS_NONE</literal>选择选项<literal>ROW_MARK_COPY</literal>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     See <filename>src/include/nodes/lockoptions.h</filename>, the comments
     for <type>RowMarkType</type> and <type>PlanRowMark</type>
     in <filename>src/include/nodes/plannodes.h</filename>, and the comments for
     <type>ExecRowMark</type> in <filename>src/include/nodes/execnodes.h</filename> for
     additional information.
    </para>
____________________________________________________________________________-->
    <para>
     更多信息可见<filename>src/include/nodes/lockoptions.h</filename>，以及<filename>src/include/nodes/plannodes.h</filename>中<type>RowMarkType</type>和<type>PlanRowMark</type>的注释，还有<filename>src/include/nodes/execnodes.h</filename>中<type>ExecRowMark</type>的注释。
    </para>

  </sect1>

 </chapter>
