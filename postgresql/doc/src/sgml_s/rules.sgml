<!-- doc/src/sgml/rules.sgml -->

<chapter id="rules">
<!--==========================orignal english content==========================
<title>The Rule System</title>
____________________________________________________________________________-->
<title>规则系统</title>

<!--==========================orignal english content==========================
 <indexterm zone="rules">
  <primary>rule</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="rules">
  <primary>规则</primary>
 </indexterm>

<!--==========================orignal english content==========================
<para>
     This chapter discusses the rule system in
     <productname>PostgreSQL</productname>.  Production rule systems
     are conceptually simple, but there are many subtle points
     involved in actually using them.
</para>
____________________________________________________________________________-->
<para>
     本章讨论<productname>PostgreSQL</productname>中的规则系统。产生规则系统的概念很简单，但是在实际使用的时候会碰到很多细节问题。
</para>

<!--==========================orignal english content==========================
<para>
     Some other database systems define active database rules, which
     are usually stored procedures and triggers.  In
     <productname>PostgreSQL</productname>, these can be implemented
     using functions and triggers as well.
</para>
____________________________________________________________________________-->
<para>
     某些其它数据库系统定义活动的数据库规则，通常是存储过程和触发器。在<productname>PostgreSQL</productname>中，这些东西可以通过函数和触发器来实现。
</para>

<!--==========================orignal english content==========================
<para>
     The rule system (more precisely speaking, the query rewrite rule
     system) is totally different from stored procedures and triggers.
     It modifies queries to take rules into consideration, and then
     passes the modified query to the query planner for planning and
     execution.  It is very powerful, and can be used for many things
     such as query language procedures, views, and versions.  The
     theoretical foundations and the power of this rule system are
     also discussed in <xref linkend="ston90b"/> and <xref
     linkend="ong90"/>.
</para>
____________________________________________________________________________-->
<para>
     规则系统（更准确地说是查询重写规则系统）与存储过程和触发器完全不同。它把查询修改为需要考虑规则，并且然后把修改过的查询传递给查询规划器进行规划和执行。它非常强大，并且可以被用于许多东西如查询语言过程、视图和版本。这个规则系统的理论基础和能力也在<xref linkend="ston90b"/>和<xref linkend="ong90"/>中讨论。
</para>

<sect1 id="querytree">
<!--==========================orignal english content==========================
<title>The Query Tree</title>
____________________________________________________________________________-->
<title>查询树</title>

<!--==========================orignal english content==========================
<indexterm zone="querytree">
 <primary>query tree</primary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="querytree">
 <primary>查询树</primary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    To understand how the rule system works it is necessary to know
    when it is invoked and what its input and results are.
</para>
____________________________________________________________________________-->
<para>
    要了解规则系统是如何工作的，必须要知道它什么时候被调用以及它的输入和结果是什么。
</para>

<!--==========================orignal english content==========================
<para>
    The rule system is located between the parser and the planner.
    It takes the output of the parser, one query tree, and the user-defined
    rewrite rules, which are also
    query trees with some extra information, and creates zero or more
    query trees as result. So its input and output are always things
    the parser itself could have produced and thus, anything it sees
    is basically representable as an <acronym>SQL</acronym> statement.
</para>
____________________________________________________________________________-->
<para>
    规则系统位于解析器和规划器之间。它采用解析器的输出（即一个查询树）和用户定义的重写规则（也是查询树，不过带有一些额外信息），并且常见零个或者更多个查询树作为结果。因此它的输入和输出总是那些规划器自身就能产生的东西，并且因此它看到的任何东西都可以被表示成一个<acronym>SQL</acronym>语句。
</para>

<!--==========================orignal english content==========================
<para>
    Now what is a query tree? It is an internal representation of an
    <acronym>SQL</acronym> statement where the single parts that it is
    built from are stored separately. These query trees can be shown
    in the server log if you set the configuration parameters
    <varname>debug_print_parse</varname>,
    <varname>debug_print_rewritten</varname>, or
    <varname>debug_print_plan</varname>.  The rule actions are also
    stored as query trees, in the system catalog
    <structname>pg_rewrite</structname>.  They are not formatted like
    the log output, but they contain exactly the same information.
</para>
____________________________________________________________________________-->
<para>
    那么什么是一个查询树？它是一个<acronym>SQL</acronym>语句的一种内部表示，其中用于创建它的每一个单独的部分都被独立存储。如果你设置了配置参数<varname>debug_print_parse</varname>、<varname>debug_print_rewritten</varname>或<varname>debug_print_plan</varname>，这些查询树可以被显示在服务器日志中。规则动作也被做为查询树存储在系统目录<structname>pg_rewrite</structname>中。它们没有被格式化为日志输出的形式，但是它们包含完全相同的信息。
</para>

<!--==========================orignal english content==========================
<para>
    Reading a raw query tree requires some experience.  But since
    <acronym>SQL</acronym> representations of query trees are
    sufficient to understand the rule system, this chapter will not
    teach how to read them.
</para>
____________________________________________________________________________-->
<para>
    阅读一棵未加工的查询树需要要一些经验。但是由于查询树的<acronym>SQL</acronym>表示形式足以用来理解规则系统，本章将不会教授如何阅读查询树。
</para>

<!--==========================orignal english content==========================
<para>
    When reading the <acronym>SQL</acronym> representations of the
    query trees in this chapter it is necessary to be able to identify
    the parts the statement is broken into when it is in the query tree
    structure. The parts of a query tree are

<variablelist>
    <varlistentry>
    <term>
        the command type
    </term>
    <listitem>
    <para>
        This is a simple value telling which command
        (<command>SELECT</command>, <command>INSERT</command>,
        <command>UPDATE</command>, <command>DELETE</command>) produced
        the query tree.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the range table
      <indexterm><primary>range table</primary></indexterm>
    </term>
    <listitem>
    <para>
        The range table is a list of relations that are used in the query.
        In a <command>SELECT</command> statement these are the relations given after
        the <literal>FROM</literal> key word.
    </para>

    <para>
        Every range table entry identifies a table or view and tells
        by which name it is called in the other parts of the query.
        In the query tree, the range table entries are referenced by
        number rather than by name, so here it doesn't matter if there
        are duplicate names as it would in an <acronym>SQL</acronym>
        statement. This can happen after the range tables of rules
        have been merged in. The examples in this chapter will not have
        this situation.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the result relation
    </term>
    <listitem>
    <para>
        This is an index into the range table that identifies the
        relation where the results of the query go.
    </para>

    <para>
        <command>SELECT</command> queries don't have a result
        relation. (The special case of <command>SELECT INTO</command> is
        mostly identical to <command>CREATE TABLE</command> followed by
        <literal>INSERT ... SELECT</literal>, and is not discussed
        separately here.)
    </para>

    <para>
        For <command>INSERT</command>, <command>UPDATE</command>, and
        <command>DELETE</command> commands, the result relation is the table
        (or view!) where the changes are to take effect.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the target list
    <indexterm><primary>target list</primary></indexterm>
    </term>
    <listitem>
    <para>
        The target list is a list of expressions that define the
        result of the query.  In the case of a
        <command>SELECT</command>, these expressions are the ones that
        build the final output of the query.  They correspond to the
        expressions between the key words <command>SELECT</command>
        and <command>FROM</command>.  (<literal>*</literal> is just an
        abbreviation for all the column names of a relation.  It is
        expanded by the parser into the individual columns, so the
        rule system never sees it.)
    </para>

    <para>
        <command>DELETE</command> commands don't need a normal target list
        because they don't produce any result.  Instead, the planner
        adds a special <acronym>CTID</acronym> entry to the empty target list,
        to allow the executor to find the row to be deleted.
        (<acronym>CTID</acronym> is added when the result relation is an ordinary
        table.  If it is a view, a whole-row variable is added instead, by
        the rule system, as described in <xref linkend="rules-views-update"/>.)
    </para>

    <para>
        For <command>INSERT</command> commands, the target list describes
        the new rows that should go into the result relation. It consists of the
        expressions in the <literal>VALUES</literal> clause or the ones from the
        <command>SELECT</command> clause in <literal>INSERT
        ... SELECT</literal>.  The first step of the rewrite process adds
        target list entries for any columns that were not assigned to by
        the original command but have defaults.  Any remaining columns (with
        neither a given value nor a default) will be filled in by the
        planner with a constant null expression.
    </para>

    <para>
        For <command>UPDATE</command> commands, the target list
        describes the new rows that should replace the old ones. In the
        rule system, it contains just the expressions from the <literal>SET
        column = expression</literal> part of the command.  The planner will
        handle missing columns by inserting expressions that copy the values
        from the old row into the new one.  Just as for <command>DELETE</command>,
        a <acronym>CTID</acronym> or whole-row variable is added so that
        the executor can identify the old row to be updated.
    </para>

    <para>
        Every entry in the target list contains an expression that can
        be a constant value, a variable pointing to a column of one
        of the relations in the range table, a parameter, or an expression
        tree made of function calls, constants, variables, operators, etc.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the qualification
    </term>
    <listitem>
    <para>
        The query's qualification is an expression much like one of
        those contained in the target list entries. The result value of
        this expression is a Boolean that tells whether the operation
        (<command>INSERT</command>, <command>UPDATE</command>,
        <command>DELETE</command>, or <command>SELECT</command>) for the
        final result row should be executed or not. It corresponds to the <literal>WHERE</literal> clause
        of an <acronym>SQL</acronym> statement.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the join tree
    </term>
    <listitem>
    <para>
        The query's join tree shows the structure of the <literal>FROM</literal> clause.
        For a simple query like <literal>SELECT ... FROM a, b, c</literal>, the join tree is just
        a list of the <literal>FROM</literal> items, because we are allowed to join them in
        any order.  But when <literal>JOIN</literal> expressions, particularly outer joins,
        are used, we have to join in the order shown by the joins.
        In that case, the join tree shows the structure of the <literal>JOIN</literal> expressions.  The
        restrictions associated with particular <literal>JOIN</literal> clauses (from <literal>ON</literal> or
        <literal>USING</literal> expressions) are stored as qualification expressions attached
        to those join-tree nodes.  It turns out to be convenient to store
        the top-level <literal>WHERE</literal> expression as a qualification attached to the
        top-level join-tree item, too.  So really the join tree represents
        both the <literal>FROM</literal> and <literal>WHERE</literal> clauses of a <command>SELECT</command>.
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        the others
    </term>
    <listitem>
    <para>
        The other parts of the query tree like the <literal>ORDER BY</literal>
        clause aren't of interest here. The rule system
        substitutes some entries there while applying rules, but that
        doesn't have much to do with the fundamentals of the rule
        system.
    </para>
    </listitem>
    </varlistentry>

</variablelist>
</para>
____________________________________________________________________________-->
<para>
    在阅读本章中查询树的<acronym>SQL</acronym>表现形式时，读者需要能够知道语句被分解成了哪些部分并且能在查询树结构中标识它们。一棵查询树的部分有：

<variablelist>
    <varlistentry>
    <term>
        命令类型
    </term>
    <listitem>
    <para>
        这是一个简单的值来说明是哪一种命令（<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）产生了该查询树。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        范围表
        <indexterm><primary>范围表</primary></indexterm>
    </term>      
    <listitem>
    <para>
        范围表是被使用在该查询中的关系的列表。在一个<command>SELECT</command>语句中，范围表是在关键词<literal>FROM</literal>后面给出的关系。
    </para>

    <para>
        每一个范围表项标识一个表或视图，并且说明在该查询的其他部分要以哪个名称调用它。在查询树中，范围表项被使用编号而不是名称来引用，因此在一个<acronym>SQL</acronym>语句中出现重复的名字也没有关系。在规则的范围表被合并以后可能会发生这种情况。本章中的例子将不会有这种情况。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        结果关系
    </term>
    <listitem>
    <para>
        这是一个指向范围表的索引，它标识了该查询的结果应该去哪个关系。
    </para>

    <para>
        <command>SELECT</command>查询没有结果关系（特殊情况<command>SELECT INTO</command>几乎等于<command>CREATE TABLE</command>后面跟上<literal>INSERT ... SELECT</literal>，并且不在这里单独讨论）。
    </para>

    <para>
        对于<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>命令，结果关系是修改要进行的表（或视图！）。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        目标列表
        <indexterm><primary>目标列表</primary></indexterm>
    </term>
    <listitem>
    <para>
        目标列表是一个表达式的列表，它定义了查询的结果。在一个<command>SELECT</command>的情况下，这些表达式会构建出该查询最终的输出。它们对应于关键字<command>SELECT</command>和<command>FROM</command>之间的表达式（<literal>*</literal>是一个关系所有列名的缩写。解析器会把它扩展成独立的列，因此规则系统永远见不到它）。
    </para>

    <para>
        <command>DELETE</command>命令不需要一个目标列表，因为它们不产生任何结果。相反，规划器会向空的目标列表中加入一个特殊的<acronym>CTID</acronym>项来允许执行器找到要被删除的行（当结果关系是一个普通表时才加入<acronym>CTID</acronym>。如果结果关系是一个视图，则会被规则系统加入一个整行变量，如<xref linkend="rules-views-update"/>所述）。
    </para>

    <para>
        对于<command>INSERT</command>命令，目标列表描述了将要进入到结果关系中的新行。它由<literal>VALUES</literal>子句中的表达式或来自<literal>INSERT ... SELECT</literal>中<command>SELECT</command>子句的表达式构成。重写处理的第一步会为那些没有被原始命令赋值但有默认值的列增加目标列项。任何剩余的列（既没有给定值也没有默认值）将被规划器用一个常量空值表达式填充。
    </para>

    <para>
        对于<command>UPDATE</command>命令，目标列表描述要替换旧行的新行。在规则系统中，它只包含来自命令的<literal>SET column = expression</literal>部分的表达式。规划器将处理缺失的列，做法是为它们插入表达式，这种表达式会把旧行的值复制到新行。正如<command>DELETE</command>一样，会增加一个<acronym>CTID</acronym>或整行变量，这样执行器能够标识要被更新的旧行。
    </para>

    <para>
        目标列表中的每一个项所包含的表达式可以是一个常量值、一个指向范围表中关系的列的变量、一个参数或一个由函数调用、常量、变量、操作符等构成的表达式树。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        条件
    </term>
    <listitem>
    <para>
        查询的条件是一个表达式，它很像包含在目标列表项中的表达式。这个表达式的结果值是一个布尔值，它说明对最终结果行的操作（<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>或<command>SELECT</command>）是否应该被执行。它对应于一个<acronym>SQL</acronym>语句的<literal>WHERE</literal>子句。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        连接树
    </term>
    <listitem>
    <para>
        查询的连接树展示了<literal>FROM</literal>子句的结构。对于一个<literal>SELECT ... FROM a, b, c</literal>这样的简单查询，连接树就是<literal>FROM</literal>项的一个列表，因为我们被允许以任何顺序连接它们。但是当<literal>JOIN</literal>表达式（特别是外连接）被使用时，我们必须按照连接显示的顺序来连接。在这种情况下，连接树展示了<literal>JOIN</literal>表达式的结构。与特定<literal>JOIN</literal>子句（来自<literal>ON</literal>或<literal>USING</literal>）相关的限制被存储为附加到那些连接树节点的条件表达式。我们发现把顶层<literal>WHERE</literal>表达式存储为附加到顶层连接树项的一个条件也很方便。这样实际上连接树表达了一个<command>SELECT</command>的<literal>FROM</literal>和<literal>WHERE</literal>子句。
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
    <term>
        其他
    </term>
    <listitem>
    <para>
        查询树的其他部分（如<literal>ORDER BY</literal>子句）在这里并不受到关注。规则系统在应用规则时会替换这里的某些项，但是这些与规则系统的基础没有什么关系。
    </para>
    </listitem>
    </varlistentry>

</variablelist>
</para>
</sect1>

<sect1 id="rules-views">
<!--==========================orignal english content==========================
<title>Views and the Rule System</title>
____________________________________________________________________________-->
<title>视图和规则系统</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-views">
 <primary>rule</primary>
 <secondary>and views</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-views">
 <primary>规则</primary>
 <secondary>和视图</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-views">
 <primary>view</primary>
 <secondary>implementation through rules</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-views">
 <primary>视图</primary>
 <secondary>通过规则实现</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Views in <productname>PostgreSQL</productname> are implemented
    using the rule system. In fact, there is essentially no difference
    between:

<programlisting>
CREATE VIEW myview AS SELECT * FROM mytab;
</programlisting>

    compared against the two commands:

<programlisting>
CREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);
CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD
    SELECT * FROM mytab;
</programlisting>

    because this is exactly what the <command>CREATE VIEW</command>
    command does internally.  This has some side effects. One of them
    is that the information about a view in the
    <productname>PostgreSQL</productname> system catalogs is exactly
    the same as it is for a table. So for the parser, there is
    absolutely no difference between a table and a view. They are the
    same thing: relations.
</para>
____________________________________________________________________________-->
<para>
    <productname>PostgreSQL</productname>中的视图是通过规则系统来实现的。事实上，下面的命令

<programlisting>
CREATE VIEW myview AS SELECT * FROM mytab;
</programlisting>

    与下面两个命令相比没有不同：

<programlisting>
CREATE TABLE myview (<replaceable>same column list as mytab</replaceable>);
CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD
    SELECT * FROM mytab;
</programlisting>

    因为这就是<command>CREATE VIEW</command>命令在内部所作的。 这样做有一些副作用。其中之一就是在<productname>PostgreSQL</productname>系统目录中的视图信息与表的信息完全一样。所以对于解析器来说，表和视图之间完全没有区别。它们是同样的事物：关系。
</para>

<sect2 id="rules-select">
<!--==========================orignal english content==========================
<title>How <command>SELECT</command> Rules Work</title>
____________________________________________________________________________-->
<title><command>SELECT</command>规则如何工作</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-select">
 <primary>rule</primary>
 <secondary sortas="SELECT">for SELECT</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-select">
 <primary>rule</primary>
 <secondary sortas="SELECT">for SELECT</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Rules <literal>ON SELECT</literal> are applied to all queries as the last step, even
    if the command given is an <command>INSERT</command>,
    <command>UPDATE</command> or <command>DELETE</command>. And they
    have different semantics from rules on the other command types in that they modify the
    query tree in place instead of creating a new one.  So
    <command>SELECT</command> rules are described first.
</para>
____________________________________________________________________________-->
<para>
    规则<literal>ON SELECT</literal>被应用于所有查询作为最后一步，即使给出的是一条<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>命令。而且它们与其他命令类型上的规则有着不同的语义，它们会就地修改查询树而不是创建一个新的查询树。因此我们首先描述<command>SELECT</command>规则。
</para>

<!--==========================orignal english content==========================
<para>
    Currently, there can be only one action in an <literal>ON SELECT</literal> rule, and it must
    be an unconditional <command>SELECT</command> action that is <literal>INSTEAD</literal>. This restriction was
    required to make rules safe enough to open them for ordinary users, and
    it restricts <literal>ON SELECT</literal> rules to act like views.
</para>
____________________________________________________________________________-->
<para>
    目前，一个<literal>ON SELECT</literal>规则中只能有一个动作， 而且它必须是一个无条件的<literal>INSTEAD</literal>的<command>SELECT</command>动作。 这个限制是为了令规则足够安全，以便普通用户也可以打开它们，并且它限制<literal>ON SELECT</literal>规则使之行为类似视图。
</para>

<!--==========================orignal english content==========================
<para>
    The examples for this chapter are two join views that do some
    calculations and some more views using them in turn.  One of the
    two first views is customized later by adding rules for
    <command>INSERT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> operations so that the final result will
    be a view that behaves like a real table with some magic
    functionality.  This is not such a simple example to start from and
    this makes things harder to get into. But it's better to have one
    example that covers all the points discussed step by step rather
    than having many different ones that might mix up in mind.
</para>
____________________________________________________________________________-->
<para>
    本章的例子是两个连接视图，它们做一些运算并且某些更多视图会轮流使用它们。最前面的两个视图之一后面将利用对<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>操作增加规则的方法被自定义，这样最终结果将是一个视图，它表现得像一个具有魔力的真正的表。这个例子不适合于作为简单易懂的例子，它可能会让本章更难懂。但是用一个覆盖所有关键点的例子来一步一步讨论要比举很多例子搞乱思维好。
</para>

<!--==========================orignal english content==========================
<para>
For the example, we need a little <literal>min</literal> function that
returns the lower of 2 integer values. We create that as:

<programlisting>
CREATE FUNCTION min(integer, integer) RETURNS integer AS $$
    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END
$$ LANGUAGE SQL STRICT;
</programlisting>
</para>
____________________________________________________________________________-->
<para>
例如，我们需要一个小巧的<literal>min</literal>函数用于返回两个整数值中较小的那个。我们这样创建它：

<programlisting>
CREATE FUNCTION min(integer, integer) RETURNS integer AS $$
    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END
$$ LANGUAGE SQL STRICT;
</programlisting>
</para>

<!--==========================orignal english content==========================
<para>
    The real tables we need in the first two rule system descriptions
    are these:

<programlisting>
CREATE TABLE shoe_data (
    shoename   text,          -&minus; primary key
    sh_avail   integer,       -&minus; available number of pairs
    slcolor    text,          -&minus; preferred shoelace color
    slminlen   real,          -&minus; minimum shoelace length
    slmaxlen   real,          -&minus; maximum shoelace length
    slunit     text           -&minus; length unit
);

CREATE TABLE shoelace_data (
    sl_name    text,          -&minus; primary key
    sl_avail   integer,       -&minus; available number of pairs
    sl_color   text,          -&minus; shoelace color
    sl_len     real,          -&minus; shoelace length
    sl_unit    text           -&minus; length unit
);

CREATE TABLE unit (
    un_name    text,          -&minus; primary key
    un_fact    real           -&minus; factor to transform to cm
);
</programlisting>

    As you can see, they represent shoe-store data.
</para>
____________________________________________________________________________-->
<para>
    在前两个规则系统描述中我们需要真实表是：

<programlisting>
CREATE TABLE shoe_data (
    shoename   text,          -- 主键
    sh_avail   integer,       -- 可用的双数
    slcolor    text,          -- 首选的鞋带颜色
    slminlen   real,          -- 最小鞋带长度
    slmaxlen   real,          -- 最大鞋带长度
    slunit     text           -- 长度单位
);

CREATE TABLE shoelace_data (
    sl_name    text,          -- 主键
    sl_avail   integer,       -- 可用的双数
    sl_color   text,          -- 鞋带颜色
    sl_len     real,          -- 鞋带长度
    sl_unit    text           -- 长度单位
);

CREATE TABLE unit (
    un_name    text,          -- 主键
    un_fact    real           -- 转换到厘米的参数
);
</programlisting>

    如你所见，它们表示鞋店的数据。
</para>

<!--==========================orignal english content==========================
<para>
    The views are created as:

<programlisting>
CREATE VIEW shoe AS
    SELECT sh.shoename,
           sh.sh_avail,
           sh.slcolor,
           sh.slminlen,
           sh.slminlen * un.un_fact AS slminlen_cm,
           sh.slmaxlen,
           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
           sh.slunit
      FROM shoe_data sh, unit un
     WHERE sh.slunit = un.un_name;

CREATE VIEW shoelace AS
    SELECT s.sl_name,
           s.sl_avail,
           s.sl_color,
           s.sl_len,
           s.sl_unit,
           s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;

CREATE VIEW shoe_ready AS
    SELECT rsh.shoename,
           rsh.sh_avail,
           rsl.sl_name,
           rsl.sl_avail,
           min(rsh.sh_avail, rsl.sl_avail) AS total_avail
      FROM shoe rsh, shoelace rsl
     WHERE rsl.sl_color = rsh.slcolor
       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
</programlisting>

    The <command>CREATE VIEW</command> command for the
    <literal>shoelace</literal> view (which is the simplest one we
    have) will create a relation <literal>shoelace</literal> and an entry in
    <structname>pg_rewrite</structname> that tells that there is a
    rewrite rule that must be applied whenever the relation <literal>shoelace</literal>
    is referenced in a query's range table.  The rule has no rule
    qualification (discussed later, with the non-<command>SELECT</command> rules, since
    <command>SELECT</command> rules currently cannot have them) and it is <literal>INSTEAD</literal>. Note
    that rule qualifications are not the same as query qualifications.
    The action of our rule has a query qualification.
    The action of the rule is one query tree that is a copy of the
    <command>SELECT</command> statement in the view creation command.
</para>
____________________________________________________________________________-->
<para>
    视图被创建为：

<programlisting>
CREATE VIEW shoe AS
    SELECT sh.shoename,
           sh.sh_avail,
           sh.slcolor,
           sh.slminlen,
           sh.slminlen * un.un_fact AS slminlen_cm,
           sh.slmaxlen,
           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
           sh.slunit
      FROM shoe_data sh, unit un
     WHERE sh.slunit = un.un_name;

CREATE VIEW shoelace AS
    SELECT s.sl_name,
           s.sl_avail,
           s.sl_color,
           s.sl_len,
           s.sl_unit,
           s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;

CREATE VIEW shoe_ready AS
    SELECT rsh.shoename,
           rsh.sh_avail,
           rsl.sl_name,
           rsl.sl_avail,
           min(rsh.sh_avail, rsl.sl_avail) AS total_avail
      FROM shoe rsh, shoelace rsl
     WHERE rsl.sl_color = rsh.slcolor
       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;
</programlisting>

    创建<literal>shoelace</literal>视图的<command>CREATE VIEW</command>命令（也是最简单的一个）将创建一个<literal>shoelace</literal>关系和一个<structname>pg_rewrite</structname>项， 这个<structname>pg_rewrite</structname>项说明有一个重写规则，只要一个查询的范围表中引用了关系<literal>shoelace</literal>，就必须应用它。该规则没有规则条件（稍后和非<command>SELECT</command>规则一起讨论，因为目前的<command>SELECT</command>规则不能有规则条件）并且它是<literal>INSTEAD</literal>规则。要注意规则条件与查询条件不一样。我们的规则的动作有一个查询条件。该规则的动作是一个查询树，这个查询是视图创建命令中的<command>SELECT</command>语句的一个拷贝。
</para>

    <note>
<!--==========================orignal english content==========================
    <para>
    The two extra range
    table entries for <literal>NEW</literal> and <literal>OLD</literal> that you can see in
    the <structname>pg_rewrite</structname> entry aren't of interest
    for <command>SELECT</command> rules.
    </para>
____________________________________________________________________________-->
    <para>
    你在<structname>pg_rewrite</structname>项中看到的两个额外的用于<literal>NEW</literal>和<literal>OLD</literal>的范围表项不是<command>SELECT</command>规则感兴趣的东西。
    </para>
    </note>

<!--==========================orignal english content==========================
<para>
    Now we populate <literal>unit</literal>, <literal>shoe_data</literal>
    and <literal>shoelace_data</literal> and run a simple query on a view:

<programlisting>
INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);

INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');

INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');

SELECT * FROM shoelace;

 sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl1       |        5 | black    |     80 | cm      |        80
 sl2       |        6 | black    |    100 | cm      |       100
 sl7       |        7 | brown    |     60 | cm      |        60
 sl3       |        0 | black    |     35 | inch    |      88.9
 sl4       |        8 | black    |     40 | inch    |     101.6
 sl8       |        1 | brown    |     40 | inch    |     101.6
 sl5       |        4 | brown    |      1 | m       |       100
 sl6       |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    现在我们填充<literal>unit</literal>、<literal>shoe_data</literal>和<literal>shoelace_data</literal>，并且在视图上运行一个简单的查询：

<programlisting>
INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);

INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');

INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');

SELECT * FROM shoelace;

 sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-----------+----------+----------+--------+---------+-----------
 sl1       |        5 | black    |     80 | cm      |        80
 sl2       |        6 | black    |    100 | cm      |       100
 sl7       |        7 | brown    |     60 | cm      |        60
 sl3       |        0 | black    |     35 | inch    |      88.9
 sl4       |        8 | black    |     40 | inch    |     101.6
 sl8       |        1 | brown    |     40 | inch    |     101.6
 sl5       |        4 | brown    |      1 | m       |       100
 sl6       |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    This is the simplest <command>SELECT</command> you can do on our
    views, so we take this opportunity to explain the basics of view
    rules.  The <literal>SELECT * FROM shoelace</literal> was
    interpreted by the parser and produced the query tree:

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM shoelace shoelace;
</programlisting>

    and this is given to the rule system. The rule system walks through the
    range table and checks if there are rules
    for any relation. When processing the range table entry for
    <literal>shoelace</literal> (the only one up to now) it finds the
    <literal>_RETURN</literal> rule with the query tree:

<programlisting>
SELECT s.sl_name, s.sl_avail,
       s.sl_color, s.sl_len, s.sl_unit,
       s.sl_len * u.un_fact AS sl_len_cm
  FROM shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_unit = u.un_name;
</programlisting>
</para>
____________________________________________________________________________-->
   <para>
    这是你可以在我们的视图上做的最简单的<command>SELECT</command>，所以我们用这次机会来解释视图规则的基本要素。<literal>SELECT * FROM shoelace</literal>会被解析器解释并生成下面的查询树：

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM shoelace shoelace;
</programlisting>

    然后这将被交给规则系统。规则系统遍历范围表，检查有没有可用于任何关系的规则。在为<literal>shoelace</literal>（到目前为止的唯一一个）处理范围表时， 它会发现查询树里有<literal>_RETURN</literal>规则：

<programlisting>
SELECT s.sl_name, s.sl_avail,
       s.sl_color, s.sl_len, s.sl_unit,
       s.sl_len * u.un_fact AS sl_len_cm
  FROM shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_unit = u.un_name;
</programlisting>
</para>

<!--==========================orignal english content==========================
<para>
    To expand the view, the rewriter simply creates a subquery range-table
    entry containing the rule's action query tree, and substitutes this
    range table entry for the original one that referenced the view.  The
    resulting rewritten query tree is almost the same as if you had typed:

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM (SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name) shoelace;
</programlisting>

     There is one difference however: the subquery's range table has two
     extra entries <literal>shoelace old</literal> and <literal>shoelace new</literal>.  These entries don't
     participate directly in the query, since they aren't referenced by
     the subquery's join tree or target list.  The rewriter uses them
     to store the access privilege check information that was originally present
     in the range-table entry that referenced the view.  In this way, the
     executor will still check that the user has proper privileges to access
     the view, even though there's no direct use of the view in the rewritten
     query.
</para>
____________________________________________________________________________-->
<para>
    要扩展该视图，重写器简单地创建一个子查询范围表项，它包含规则的动作的查询树，然后用这个范围表记录取代原来引用视图的那个。作为结果的重写后的查询树几乎与你键入的那个一样：

<programlisting>
SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM (SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name) shoelace;
</programlisting>

     不过有一个区别：子查询的范围表有两个额外的项<literal>shoelace old</literal>和<literal>shoelace new</literal>。这些项并不直接参与到查询中，因为它们没有被子查询的连接树或者目标列表引用。重写器用它们存储最初出现在引用视图的范围表项中表达的访问权限检查信息。以这种方式，执行器仍然会检查该用户是否有访问视图的正确权限，尽管在重写后的查询中没有对视图的直接使用。
</para>

<!--==========================orignal english content==========================
<para>
    That was the first rule applied.  The rule system will continue checking
    the remaining range-table entries in the top query (in this example there
    are no more), and it will recursively check the range-table entries in
    the added subquery to see if any of them reference views.  (But it
    won't expand <literal>old</literal> or <literal>new</literal> &mdash; otherwise we'd have infinite recursion!)
    In this example, there are no rewrite rules for <literal>shoelace_data</literal> or <literal>unit</literal>,
    so rewriting is complete and the above is the final result given to
    the planner.
</para>
____________________________________________________________________________-->
<para>
    这是被应用的第一个规则。规则系统将继续检查顶层查询里剩下的范围表项（本例中没有了），并且它将递归的检查增加的子查询中的范围表项，看看其中有没有引用视图的（不过这样不会扩展<literal>old</literal>或<literal>new</literal> &mdash; 否则我们会得到无限递归！）。在这个例子中，没有用于<literal>shoelace_data</literal>或<literal>unit</literal>的重写规则，所以重写结束并且上面得到的就是给规划器的最终结果。
</para>

<!--==========================orignal english content==========================
<para>
    Now we want to write a query that finds out for which shoes currently in the store
    we have the matching shoelaces (color and length) and where the
    total number of exactly matching pairs is greater or equal to two.

<programlisting>
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;

 shoename | sh_avail | sl_name | sl_avail | total_avail
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 sh1      |        2 | sl1     |        5 |           2
 sh3      |        4 | sl7     |        7 |           4
(2 rows)
</programlisting>
</para>
____________________________________________________________________________-->
<para>
    现在我们想写一个查询，它找出目前在店里哪些鞋子有匹配的（颜色和长度）鞋带并且完全匹配的鞋带双数大于等于二。

<programlisting>
SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;

 shoename | sh_avail | sl_name | sl_avail | total_avail
----------+----------+---------+----------+-------------
 sh1      |        2 | sl1     |        5 |           2
 sh3      |        4 | sl7     |        7 |           4
(2 rows)
</programlisting>
</para>

<!--==========================orignal english content==========================
<para>
    The output of the parser this time is the query tree:

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM shoe_ready shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

    The first rule applied will be the one for the
    <literal>shoe_ready</literal> view and it results in the
    query tree:

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

    Similarly, the rules for <literal>shoe</literal> and
    <literal>shoelace</literal> are substituted into the range table of
    the subquery, leading to a three-level final query tree:

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM (SELECT sh.shoename,
                       sh.sh_avail,
                       sh.slcolor,
                       sh.slminlen,
                       sh.slminlen * un.un_fact AS slminlen_cm,
                       sh.slmaxlen,
                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                       sh.slunit
                  FROM shoe_data sh, unit un
                 WHERE sh.slunit = un.un_name) rsh,
               (SELECT s.sl_name,
                       s.sl_avail,
                       s.sl_color,
                       s.sl_len,
                       s.sl_unit,
                       s.sl_len * u.un_fact AS sl_len_cm
                  FROM shoelace_data s, unit u
                 WHERE s.sl_unit = u.un_name) rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt; 2;
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    这词解析器的输出是查询树：

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM shoe_ready shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

    第一个被应用的规则将是用于<literal>shoe_ready</literal>的规则并且它会导致查询树：

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;
</programlisting>

    相似地，用于<literal>shoe</literal>和<literal>shoelace</literal>的规则被替换到子查询的范围表中，得到一个三层的最终查询树：

<programlisting>
SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM (SELECT sh.shoename,
                       sh.sh_avail,
                       sh.slcolor,
                       sh.slminlen,
                       sh.slminlen * un.un_fact AS slminlen_cm,
                       sh.slmaxlen,
                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                       sh.slunit
                  FROM shoe_data sh, unit un
                 WHERE sh.slunit = un.un_name) rsh,
               (SELECT s.sl_name,
                       s.sl_avail,
                       s.sl_color,
                       s.sl_len,
                       s.sl_unit,
                       s.sl_len * u.un_fact AS sl_len_cm
                  FROM shoelace_data s, unit u
                 WHERE s.sl_unit = u.un_name) rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt; 2;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    It turns out that the planner will collapse this tree into a
    two-level query tree: the bottommost <command>SELECT</command>
    commands will be <quote>pulled up</quote> into the middle
    <command>SELECT</command> since there's no need to process them
    separately.  But the middle <command>SELECT</command> will remain
    separate from the top, because it contains aggregate functions.
    If we pulled those up it would change the behavior of the topmost
    <command>SELECT</command>, which we don't want.  However,
    collapsing the query tree is an optimization that the rewrite
    system doesn't have to concern itself with.
   </para>
____________________________________________________________________________-->
   <para>
    最后规划器会把这个树折叠成一个两层查询树： 最下层的<command>SELECT</command>命令将被<quote>提升</quote>到中间的<command>SELECT</command>中，因为没有必要分别处理它们。但是中间的<command>SELECT</command>仍然和顶层的分开，因为它包含聚集函数。如果我们把它们也提升，它将改变顶层<command>SELECT</command>的行为，这不是我们想要的。不过，折叠查询树是一种优化，重写系统不需要关心它。   </para>
</sect2>

<sect2>
<!--==========================orignal english content==========================
<title>View Rules in Non-<command>SELECT</command> Statements</title>
____________________________________________________________________________-->
<title>非<command>SELECT</command>语句中的视图规则</title>

<!--==========================orignal english content==========================
<para>
    Two details of the query tree aren't touched in the description of
    view rules above. These are the command type and the result relation.
    In fact, the command type is not needed by view rules, but the result
    relation may affect the way in which the query rewriter works, because
    special care needs to be taken if the result relation is a view.
</para>
____________________________________________________________________________-->
<para>
    有两个查询树的细节在上面的视图规则的描述中没有涉及。它们是命令类型和结果关系。实际上，视图规则不需要命令类型，但是结果关系可能会影响查询重写器工作的方式，因为如果结果关系是一个视图，我们需要采取特殊的措施。
</para>

<!--==========================orignal english content==========================
<para>
    There are only a few differences between a query tree for a
    <command>SELECT</command> and one for any other
    command. Obviously, they have a different command type and for a
    command other than a <command>SELECT</command>, the result
    relation points to the range-table entry where the result should
    go.  Everything else is absolutely the same.  So having two tables
    <literal>t1</literal> and <literal>t2</literal> with columns <literal>a</literal> and
    <literal>b</literal>, the query trees for the two statements:

<programlisting>
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

    are nearly identical.  In particular:

    <itemizedlist>
        <listitem>
        <para>
            The range tables contain entries for the tables <literal>t1</literal> and <literal>t2</literal>.
        </para>
        </listitem>

        <listitem>
        <para>
            The target lists contain one variable that points to column
            <literal>b</literal> of the range table entry for table <literal>t2</literal>.
        </para>
        </listitem>

        <listitem>
        <para>
            The qualification expressions compare the columns <literal>a</literal> of both
            range-table entries for equality.
        </para>
        </listitem>

        <listitem>
        <para>
            The join trees show a simple join between <literal>t1</literal> and <literal>t2</literal>.
        </para>
        </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
<para>
    一个<command>SELECT</command>的查询树和其它命令的查询树之间很少的几处不同。显然，它们有不同的命令类型并且对于<command>SELECT</command>之外的命令，结果关系指向结果将进入的范围表项。其它所有东西都完全相同。所以如果有两个表<literal>t1</literal>和<literal>t2</literal>分别有列<literal>a</literal>和<literal>b</literal>，下面两个语句的查询树：

<programlisting>
SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

    几乎是一样的。特别是：

    <itemizedlist>
        <listitem>
        <para>
            范围表包含表<literal>t1</literal>和<literal>t2</literal>的项。
        </para>
        </listitem>

        <listitem>
        <para>
            目标列表包含一个变量，该变量指向表<literal>t2</literal>的范围表项的列<literal>b</literal>。
        </para>
        </listitem>

        <listitem>
        <para>
            条件表达式比较两个范围表项的列<literal>a</literal>以寻找相等。
        </para>
        </listitem>

        <listitem>
        <para>
            连接树展示了<literal>t1</literal>和<literal>t2</literal>之间的一次简单连接。
        </para>
        </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The consequence is, that both query trees result in similar
    execution plans: They are both joins over the two tables. For the
    <command>UPDATE</command> the missing columns from <literal>t1</literal> are added to
    the target list by the planner and the final query tree will read
    as:

<programlisting>
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

    and thus the executor run over the join will produce exactly the
    same result set as:

<programlisting>
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

    But there is a little problem in
    <command>UPDATE</command>: the part of the executor plan that does
    the join does not care what the results from the join are
    meant for. It just produces a result set of rows. The fact that
    one is a <command>SELECT</command> command and the other is an
    <command>UPDATE</command> is handled higher up in the executor, where
    it knows that this is an <command>UPDATE</command>, and it knows that
    this result should go into table <literal>t1</literal>. But which of the rows
    that are there has to be replaced by the new row?
</para>
____________________________________________________________________________-->
   <para>
    结果是，两个查询树生成相似的执行计划：它们都是两个表的连接。 对于<command>UPDATE</command>语句，规划器把<literal>t1</literal>缺失的列加到目标列并且最终查询树读起来是：

<programlisting>
UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;
</programlisting>

    因此在连接上运行的执行器将产生完全相同的结果集：

<programlisting>
SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

    但是在<command>UPDATE</command>中有个小问题：执行器计划中执行连接的部分不关心连接的结果的含义。它只是产生一个行的结果集。一个是<command>SELECT</command>命令而另一个是由执行器中的更高层处理的<command>UPDATE</command>命令，在那里执行器知道这是一个<command>UPDATE</command>，并且它知道这个结果应该进入表<literal>t1</literal>。但是这里的哪些行必须被新行替换呢？
</para>

<!--==========================orignal english content==========================
<para>
    To resolve this problem, another entry is added to the target list
    in <command>UPDATE</command> (and also in
    <command>DELETE</command>) statements: the current tuple ID
    (<acronym>CTID</acronym>).<indexterm><primary>CTID</primary></indexterm>
    This is a system column containing the
    file block number and position in the block for the row. Knowing
    the table, the <acronym>CTID</acronym> can be used to retrieve the
    original row of <literal>t1</literal> to be updated.  After adding the
    <acronym>CTID</acronym> to the target list, the query actually looks like:

<programlisting>
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

    Now another detail of <productname>PostgreSQL</productname> enters
    the stage. Old table rows aren't overwritten, and this
    is why <command>ROLLBACK</command> is fast. In an <command>UPDATE</command>,
    the new result row is inserted into the table (after stripping the
    <acronym>CTID</acronym>) and in the row header of the old row, which the
    <acronym>CTID</acronym> pointed to, the <literal>cmax</literal> and
    <literal>xmax</literal> entries are set to the current command counter
    and current transaction ID. Thus the old row is hidden, and after
    the transaction commits the vacuum cleaner can eventually remove
    the dead row.
</para>
____________________________________________________________________________-->
<para>
    要解决这个问题，在<command>UPDATE</command>和<command>DELETE</command>语句的目标列表里面增加了另外一个项：当前元组 ID（<acronym>CTID</acronym>）。<indexterm><primary>CTID</primary></indexterm>这是一个系统列，它包含行所在的文件块编号和在块中的位置。在已知表的情况下，<acronym>CTID</acronym>可以被用来检索要被更新的<literal>t1</literal>的原始行。在添加<acronym>CTID</acronym>到目标列之后，该查询实际看起来像：

<programlisting>
SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;
</programlisting>

    现在，另一个<productname>PostgreSQL</productname>的细节进入到这个阶段了。表中的旧行还没有被覆盖，这就是为什么<command>ROLLBACK</command>很快的原因。在一个<command>UPDATE</command>中，新的结果行被插入到表中（在剥除<acronym>CTID</acronym>之后），并且把<acronym>CTID</acronym>指向的旧行的行头部中的<literal>cmax</literal>和<literal>xmax</literal>项设置为当前命令计数器和当前事务 ID 。这样旧的行就被隐藏起来，并且在事务提交之后 vacuum 清理器就可以最终移除死亡的行。
</para>

<!--==========================orignal english content==========================
<para>
    Knowing all that, we can simply apply view rules in absolutely
    the same way to any command. There is no difference.
</para>
____________________________________________________________________________-->
<para>
    知道了所有这些，我们就可以用完全相同的方式简单地把视图规则应用到任意命令中。没有任何区别。
</para>
</sect2>

<sect2>
<!--==========================orignal english content==========================
<title>The Power of Views in <productname>PostgreSQL</productname></title>
____________________________________________________________________________-->
<title><productname>PostgreSQL</productname>中视图的能力</title>

<!--==========================orignal english content==========================
<para>
    The above demonstrates how the rule system incorporates view
    definitions into the original query tree. In the second example, a
    simple <command>SELECT</command> from one view created a final
    query tree that is a join of 4 tables (<literal>unit</literal> was used twice with
    different names).
</para>
____________________________________________________________________________-->
<para>
    上文演示了规则系统如何把视图定义整合到原始的查询树中。在第二个例子中，一个来自于一个视图的简单<command>SELECT</command>创建了一个四表连接（<literal>unit</literal>以不同的名字被用了两次）的最终查询树。
</para>

<!--==========================orignal english content==========================
<para>
    The benefit of implementing views with the rule system is,
    that the planner has all
    the information about which tables have to be scanned plus the
    relationships between these tables plus the restrictive
    qualifications from the views plus the qualifications from
    the original query
    in one single query tree. And this is still the situation
    when the original query is already a join over views.
    The planner has to decide which is
    the best path to execute the query, and the more information
    the planner has, the better this decision can be. And
    the rule system as implemented in <productname>PostgreSQL</productname>
    ensures, that this is all information available about the query
    up to that point.
</para>
____________________________________________________________________________-->
<para>
    用规则系统实现视图的好处是，规划器拥有关于哪些表必须被扫描、这些表之间的联系、来自于视图的限制性条件、一个单一查询树中原始查询的条件等所有信息。当原始查询已经是一个视图上的连接时仍然是这样。规划器必须决定执行查询的最优路径，而且规划器拥有越多信息，该决定就越好。并且<productname>PostgreSQL</productname>中实现的规则系统保证这些信息是此时能获得的有关该查询的所有信息。
</para>
</sect2>

<sect2 id="rules-views-update">
<!--==========================orignal english content==========================
<title>Updating a View</title>
____________________________________________________________________________-->
<title>更新一个视图</title>

<!--==========================orignal english content==========================
<para>
    What happens if a view is named as the target relation for an
    <command>INSERT</command>, <command>UPDATE</command>, or
    <command>DELETE</command>?  Doing the substitutions
    described above would give a query tree in which the result
    relation points at a subquery range-table entry, which will not
    work.  There are several ways in which <productname>PostgreSQL</productname>
    can support the appearance of updating a view, however.
</para>
____________________________________________________________________________-->
<para>
    如果视图是<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>的目标关系会怎样？使用上文所述的替换将给出一个查询树，其中的结果关系指向一个子查询范围表项，这样无法工作。不过，<productname>PostgreSQL</productname>中有几种方法来支持更新视图。
</para>

<!--==========================orignal english content==========================
<para>
    If the subquery selects from a single base relation and is simple
    enough, the rewriter can automatically replace the subquery with the
    underlying base relation so that the <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> is applied to
    the base relation in the appropriate way.  Views that are
    <quote>simple enough</quote> for this are called <firstterm>automatically
    updatable</firstterm>.  For detailed information on the kinds of view that can
    be automatically updated, see <xref linkend="sql-createview"/>.
</para>
____________________________________________________________________________-->
<para>
    如果子查询从一个单一基本关系选择并且该关系足够简单，重写器会自动地把该子查询替换成底层的基本关系，这样<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>会被以适当的方式应用到该基本关系。其中<quote>足够简单</quote>的视图被称为<firstterm>自动可更新</firstterm>。有关这种可以被自动更新的视图类别的详细信息，请见<xref linkend="sql-createview"/>。
</para>

<!--==========================orignal english content==========================
<para>
    Alternatively, the operation may be handled by a user-provided
    <literal>INSTEAD OF</literal> trigger on the view.
    Rewriting works slightly differently
    in this case.  For <command>INSERT</command>, the rewriter does
    nothing at all with the view, leaving it as the result relation
    for the query.  For <command>UPDATE</command> and
    <command>DELETE</command>, it's still necessary to expand the
    view query to produce the <quote>old</quote> rows that the command will
    attempt to update or delete.  So the view is expanded as normal,
    but another unexpanded range-table entry is added to the query
    to represent the view in its capacity as the result relation.
</para>
____________________________________________________________________________-->
<para>
    或者，该操作可以被定义在视图上的一个用户提供的<literal>INSTEAD OF</literal>触发器处理。在这种情况下重写工作有一点点不同。对于<command>INSERT</command>，重写器对视图什么也不做，让它作为查询的结果关系。对于<command>UPDATE</command>和<command>DELETE</command>，仍有必要扩展该视图查询来产生命令将尝试更新或删除的<quote>旧</quote>行。因此该视图被按照通常的方式扩展，但是另一个未被扩展的范围表项会被增加到查询来表示该视图会尽其所能作为结果关系。
</para>

<!--==========================orignal english content==========================
<para>
    The problem that now arises is how to identify the rows to be
    updated in the view. Recall that when the result relation
    is a table, a special <acronym>CTID</acronym> entry is added to the target
    list to identify the physical locations of the rows to be updated.
    This does not work if the result relation is a view, because a view
    does not have any <acronym>CTID</acronym>, since its rows do not have
    actual physical locations. Instead, for an <command>UPDATE</command>
    or <command>DELETE</command> operation, a special <literal>wholerow</literal>
    entry is added to the target list, which expands to include all
    columns from the view. The executor uses this value to supply the
    <quote>old</quote> row to the <literal>INSTEAD OF</literal> trigger.  It is
    up to the trigger to work out what to update based on the old and
    new row values.
</para>
____________________________________________________________________________-->
<para>
    现在出现的问题是如何标识在视图中要被更新的行。回忆一下，当结果关系是一个表时，一个特殊的<acronym>CTID</acronym>项会被加入到目标列表来标识要被更新的行的物理位置。如果结果关系是一个视图这就行不通，因为一个视图根本就没有<acronym>CTID</acronym>，它的行没有实际的物理位置。对于一个<command>UPDATE</command>或<command>DELETE</command>操作，一个特殊的<literal>wholerow</literal>项会被增加到目标列表中，它会扩展来包括来自该视图的所有列。执行器使用这个值来提供<quote>旧</quote>行给<literal>INSTEAD OF</literal>触发器。现在就轮到触发器来基于新旧行值来找出要更新什么了。
</para>

<!--==========================orignal english content==========================
<para>
    Another possibility is for the user to define <literal>INSTEAD</literal>
    rules that specify substitute actions for <command>INSERT</command>,
    <command>UPDATE</command>, and <command>DELETE</command> commands on
    a view. These rules will rewrite the command, typically into a command
    that updates one or more tables, rather than views. That is the topic
    of <xref linkend="rules-update"/>.
</para>
____________________________________________________________________________-->
<para>
    另外一种可能性是让用户定义<literal>INSTEAD</literal>规则，这种规则指定对视图上的<command>INSERT</command>\<command>UPDATE</command>和<command>DELETE</command>命令的替代动作。这些规则将重写该命令，通常是重写成一个更新一个或多个表（而不是视图）的命令。这是<xref linkend="rules-update"/>的主题。
</para>

<!--==========================orignal english content==========================
<para>
    Note that rules are evaluated first, rewriting the original query
    before it is planned and executed. Therefore, if a view has
    <literal>INSTEAD OF</literal> triggers as well as rules on <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command>, then the rules will be
    evaluated first, and depending on the result, the triggers may not be
    used at all.
</para>
____________________________________________________________________________-->
<para>
    注意规则会首先被计算，然后在原始查询被规划和执行之前重写它。因此，如果一个视图上同时有<literal>INSTEAD OF</literal>触发器和<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>规则，那么首先会计算规则，然后根据其结果决定是否执行触发器，触发器可能完全都不会被使用。
</para>

<!--==========================orignal english content==========================
<para>
    Automatic rewriting of an <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> query on a
    simple view is always tried last. Therefore, if a view has rules or
    triggers, they will override the default behavior of automatically
    updatable views.
</para>
____________________________________________________________________________-->
<para>
    Automatic rewriting of an 在一个简单视图上的<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>查询的自动重写总是在最后尝试。因此，如果一个视图有规则或触发器，它们将重载自动可更新视图的默认行为。
</para>

<!--==========================orignal english content==========================
<para>
    If there are no <literal>INSTEAD</literal> rules or <literal>INSTEAD OF</literal>
    triggers for the view, and the rewriter cannot automatically rewrite
    the query as an update on the underlying base relation, an error will
    be thrown because the executor cannot update a view as such.
</para>
____________________________________________________________________________-->
<para>
    如果对该视图没有<literal>INSTEAD</literal>规则或<literal>INSTEAD OF</literal>触发器，并且重写器不能自动地把该查询重写成一个底层基本关系上的更新，将会抛出一个错误，因为执行器不能更新一个这样的视图。
</para>

</sect2>

</sect1>

<sect1 id="rules-materializedviews">
<!--==========================orignal english content==========================
<title>Materialized Views</title>
____________________________________________________________________________-->
<title>物化视图</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-materializedviews">
 <primary>rule</primary>
 <secondary>and materialized views</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-materializedviews">
 <primary>规则</primary>
 <secondary>和物化视图</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-materializedviews">
 <primary>materialized view</primary>
 <secondary>implementation through rules</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-materializedviews">
 <primary>物化视图</primary>
 <secondary>通过规则实现</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-materializedviews">
 <primary>view</primary>
 <secondary>materialized</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-materializedviews">
 <primary>视图</primary>
 <secondary>物化</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Materialized views in <productname>PostgreSQL</productname> use the
    rule system like views do, but persist the results in a table-like form.
    The main differences between:

<programlisting>
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
</programlisting>

    and:

<programlisting>
CREATE TABLE mymatview AS SELECT * FROM mytab;
</programlisting>

    are that the materialized view cannot subsequently be directly updated
    and that the query used to create the materialized view is stored in
    exactly the same way that a view's query is stored, so that fresh data
    can be generated for the materialized view with:

<programlisting>
REFRESH MATERIALIZED VIEW mymatview;
</programlisting>

    The information about a materialized view in the
    <productname>PostgreSQL</productname> system catalogs is exactly
    the same as it is for a table or view. So for the parser, a
    materialized view is a relation, just like a table or a view.  When
    a materialized view is referenced in a query, the data is returned
    directly from the materialized view, like from a table; the rule is
    only used for populating the materialized view.
</para>
____________________________________________________________________________-->
<para>
    <productname>PostgreSQL</productname>中的物化视图像视图一样使用了规则系统，但是以一种类表的形式保留了结果。在物化视图：

<programlisting>
CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;
</programlisting>

    和视图：

<programlisting>
CREATE TABLE mymatview AS SELECT * FROM mytab;
</programlisting>

    之间的主要区别是物化视图不能直接被更新，并且用于创建物化视图的查询的存储方式和视图查询的存储方式完全相同，因此要为物化视图生成新鲜的数据：

<programlisting>
REFRESH MATERIALIZED VIEW mymatview;
</programlisting>

    The information about a materialized view in the
    有关一个<productname>PostgreSQL</productname>系统目录中的物化视图的信息和一个表或视图的信息完全相同。因此对于解析器，一个物化视图就是一个关系，就像一个表或一个视图。当一个物化视图被一个查询引用时，数据直接从物化视图中返回，如同表一样；规则只被用来填充物化视图。
</para>

<!--==========================orignal english content==========================
<para>
    While access to the data stored in a materialized view is often much
    faster than accessing the underlying tables directly or through a view,
    the data is not always current; yet sometimes current data is not needed.
    Consider a table which records sales:

<programlisting>
CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       -&minus; ID of salesperson
    invoice_date  date,          -&minus; date of sale
    invoice_amt   numeric(13,2)  -&minus; amount of sale
);
</programlisting>

    If people want to be able to quickly graph historical sales data, they
    might want to summarize, and they may not care about the incomplete data
    for the current date:

<programlisting>
CREATE MATERIALIZED VIEW sales_summary AS
  SELECT
      seller_no,
      invoice_date,
      sum(invoice_amt)::numeric(13,2) as sales_amt
    FROM invoice
    WHERE invoice_date &lt; CURRENT_DATE
    GROUP BY
      seller_no,
      invoice_date
    ORDER BY
      seller_no,
      invoice_date;

CREATE UNIQUE INDEX sales_summary_seller
  ON sales_summary (seller_no, invoice_date);
</programlisting>

    This materialized view might be useful for displaying a graph in the
    dashboard created for salespeople.  A job could be scheduled to update
    the statistics each night using this SQL statement:

<programlisting>
REFRESH MATERIALIZED VIEW sales_summary;
</programlisting>
</para>
____________________________________________________________________________-->
<para>
    虽然对物化视图中存储的数据的访问常常要快于直接访问底层表或通过一个视图访问，但是数据并不总是最新的；但是某些时候并不需要当前数据。考虑一个记录销售情况的表：

<programlisting>
CREATE TABLE invoice (
    invoice_no    integer        PRIMARY KEY,
    seller_no     integer,       -- 销售员的 ID
    invoice_date  date,          -- 销售日期
    invoice_amt   numeric(13,2)  -- 销售量
);
</programlisting>

    如果人们想快速绘制历史销售数据，他们可能希望汇总，并且他们可能并不关心当前日期的不完整数据：

<programlisting>
CREATE MATERIALIZED VIEW sales_summary AS
  SELECT
      seller_no,
      invoice_date,
      sum(invoice_amt)::numeric(13,2) as sales_amt
    FROM invoice
    WHERE invoice_date &lt; CURRENT_DATE
    GROUP BY
      seller_no,
      invoice_date
    ORDER BY
      seller_no,
      invoice_date;

CREATE UNIQUE INDEX sales_summary_seller
  ON sales_summary (seller_no, invoice_date);
</programlisting>

    这个物化视图可能对在为销售员创建的控制面板上显示一个图表非常有用。可以用一个计划任务在每晚使用这个 SQL 语句更新该统计信息：

<programlisting>
REFRESH MATERIALIZED VIEW sales_summary;
</programlisting>
</para>

<!--==========================orignal english content==========================
<para>
    Another use for a materialized view is to allow faster access to data
    brought across from a remote system through a foreign data wrapper.
    A simple example using <literal>file_fdw</literal> is below, with timings,
    but since this is using cache on the local system the performance
    difference compared to access to a remote system would usually be greater
    than shown here.  Notice we are also exploiting the ability to put an
    index on the materialized view, whereas <literal>file_fdw</literal> does
    not support indexes; this advantage might not apply for other sorts of
    foreign data access.
</para>
____________________________________________________________________________-->
<para>
    物化视图的另一种使用是允许通过一个外部数据包装器对来
    自一个远程系统的数据进行更快的访问。下面有一个使用
    <literal>file_fdw</literal>的简单例子，但是由于本地系
    统上可以使用高速缓存，因此比起访问一个远程系统的性
    能差异可能会比这里所展示的更大。注意鉴于
    <literal>file_fdw</literal>不支持索引，我们也使用这种
    能力来在物化视图上放置索引。这种优势可能不适用于其
    他种类的外部数据访问。
</para>

<!--==========================orignal english content==========================
<para>
    Setup:

<programlisting>
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
  SERVER local_file
  OPTIONS (filename '/usr/share/dict/words');
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
</programlisting>

    Now let's spell-check a word.  Using <literal>file_fdw</literal> directly:

<programlisting>
SELECT count(*) FROM words WHERE word = 'caterpiler';

 count 
-&minus;-&minus;-&minus;-
     0
(1 row)
</programlisting>

    With <command>EXPLAIN ANALYZE</command>, we see:

<programlisting>
 Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)
   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)
         Filter: (word = 'caterpiler'::text)
         Rows Removed by Filter: 479829
         Foreign File: /usr/share/dict/words
         Foreign File Size: 4953699
 Planning time: 0.118 ms
 Execution time: 188.273 ms
</programlisting>

    If the materialized view is used instead, the query is much faster:

<programlisting>
 Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)
         Index Cond: (word = 'caterpiler'::text)
         Heap Fetches: 0
 Planning time: 0.164 ms
 Execution time: 0.117 ms
</programlisting>

    Either way, the word is spelled wrong, so let's look for what we might
    have wanted.  Again using <literal>file_fdw</literal>:

<programlisting>
SELECT word FROM words ORDER BY word &lt;-&gt; 'caterpiler' LIMIT 10;

     word     
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 cater
 caterpillar
 Caterpillar
 caterpillars
 caterpillar's
 Caterpillar's
 caterer
 caterer's
 caters
 catered
(10 rows)
</programlisting>

<programlisting>
 Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)
   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)
         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))
         Sort Method: top-N heapsort  Memory: 25kB
         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)
               Foreign File: /usr/share/dict/words
               Foreign File Size: 4953699
 Planning time: 0.128 ms
 Execution time: 1431.679 ms
</programlisting>

    Using the materialized view:

<programlisting>
 Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)
   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)
         Order By: (word &lt;-&gt; 'caterpiler'::text)
 Planning time: 0.196 ms
 Execution time: 198.640 ms
</programlisting>

    If you can tolerate periodic update of the remote data to the local
    database, the performance benefit can be substantial.
</para>
____________________________________________________________________________-->
<para>

    建立：

<programlisting>
CREATE EXTENSION file_fdw;
CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;
CREATE FOREIGN TABLE words (word text NOT NULL)
  SERVER local_file
  OPTIONS (filename '/usr/share/dict/words');
CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;
CREATE UNIQUE INDEX wrd_word ON wrd (word);
CREATE EXTENSION pg_trgm;
CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);
VACUUM ANALYZE wrd;
</programlisting>

    现在让我们对一个词进行拼写检查。直接使用<literal>file_fdw</literal>：

<programlisting>
SELECT count(*) FROM words WHERE word = 'caterpiler';

 count 
-------
     0
(1 row)
</programlisting>

    通过<command>EXPLAIN ANALYZE</command>，我们可以看到：

<programlisting>
 Aggregate  (cost=21763.99..21764.00 rows=1 width=0) (actual time=188.180..188.181 rows=1 loops=1)
   -&gt;  Foreign Scan on words  (cost=0.00..21761.41 rows=1032 width=0) (actual time=188.177..188.177 rows=0 loops=1)
         Filter: (word = 'caterpiler'::text)
         Rows Removed by Filter: 479829
         Foreign File: /usr/share/dict/words
         Foreign File Size: 4953699
 Planning time: 0.118 ms
 Execution time: 188.273 ms
</programlisting>

    如果使用物化视图，该查询会快很多：

<programlisting>
 Aggregate  (cost=4.44..4.45 rows=1 width=0) (actual time=0.042..0.042 rows=1 loops=1)
   -&gt;  Index Only Scan using wrd_word on wrd  (cost=0.42..4.44 rows=1 width=0) (actual time=0.039..0.039 rows=0 loops=1)
         Index Cond: (word = 'caterpiler'::text)
         Heap Fetches: 0
 Planning time: 0.164 ms
 Execution time: 0.117 ms
</programlisting>

    不管哪种方式，单词都是被拼错的，因此让我们看看什么是我们可能想要的。再次使用<literal>file_fdw</literal>：

<programlisting>
SELECT word FROM words ORDER BY word &lt;-&gt; 'caterpiler' LIMIT 10;

     word     
---------------
 cater
 caterpillar
 Caterpillar
 caterpillars
 caterpillar's
 Caterpillar's
 caterer
 caterer's
 caters
 catered
(10 rows)
</programlisting>

<programlisting>
 Limit  (cost=11583.61..11583.64 rows=10 width=32) (actual time=1431.591..1431.594 rows=10 loops=1)
   -&gt;  Sort  (cost=11583.61..11804.76 rows=88459 width=32) (actual time=1431.589..1431.591 rows=10 loops=1)
         Sort Key: ((word &lt;-&gt; 'caterpiler'::text))
         Sort Method: top-N heapsort  Memory: 25kB
         -&gt;  Foreign Scan on words  (cost=0.00..9672.05 rows=88459 width=32) (actual time=0.057..1286.455 rows=479829 loops=1)
               Foreign File: /usr/share/dict/words
               Foreign File Size: 4953699
 Planning time: 0.128 ms
 Execution time: 1431.679 ms
</programlisting>

    使用物化视图：

<programlisting>
 Limit  (cost=0.29..1.06 rows=10 width=10) (actual time=187.222..188.257 rows=10 loops=1)
   -&gt;  Index Scan using wrd_trgm on wrd  (cost=0.29..37020.87 rows=479829 width=10) (actual time=187.219..188.252 rows=10 loops=1)
         Order By: (word &lt;-&gt; 'caterpiler'::text)
 Planning time: 0.196 ms
 Execution time: 198.640 ms
</programlisting>

    如果你能够忍受定期把远程数据更新到本地数据库，其性能收益可能是巨大的。
</para>

</sect1>

<sect1 id="rules-update">
<!--==========================orignal english content==========================
<title>Rules on <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command></title>
____________________________________________________________________________-->
<title><command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>上的规则</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="INSERT">for INSERT</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="INSERT">for INSERT</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="UPDATE">for UPDATE</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="UPDATE">for UPDATE</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="DELETE">for DELETE</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-update">
 <primary>rule</primary>
 <secondary sortas="DELETE">for DELETE</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Rules that are defined on <command>INSERT</command>, <command>UPDATE</command>,
    and <command>DELETE</command> are significantly different from the view rules
    described in the previous section. First, their <command>CREATE
    RULE</command> command allows more:

    <itemizedlist>
        <listitem>
        <para>
            They are allowed to have no action.
        </para>
        </listitem>

        <listitem>
        <para>
            They can have multiple actions.
        </para>
        </listitem>

        <listitem>
        <para>
            They can be <literal>INSTEAD</literal> or <literal>ALSO</literal> (the default).
        </para>
        </listitem>

        <listitem>
        <para>
            The pseudorelations <literal>NEW</literal> and <literal>OLD</literal> become useful.
        </para>
        </listitem>

        <listitem>
        <para>
            They can have rule qualifications.
        </para>
        </listitem>
    </itemizedlist>

    Second, they don't modify the query tree in place. Instead they
    create zero or more new query trees and can throw away the
    original one.
</para>
____________________________________________________________________________-->
<para>
    定义在<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>上的规则与前一节描述的视图规则有明显的不同。首先，它们的<command>CREATE RULE</command>命令允许更多：

    <itemizedlist>
        <listitem>
        <para>
            它们可以没有动作。
        </para>
        </listitem>

        <listitem>
        <para>
            它们可以有多个动作。
        </para>
        </listitem>

        <listitem>
        <para>
            它们可以是<literal>INSTEAD</literal>或<literal>ALSO</literal>（缺省）。
        </para>
        </listitem>

        <listitem>
        <para>
            伪关系<literal>NEW</literal>和<literal>OLD</literal>变得有用了。
        </para>
        </listitem>

        <listitem>
        <para>
            它们可以有规则条件。
        </para>
        </listitem>
    </itemizedlist>

    第二，它们不是就地修改查询树，而是创建零个或多个新查询树并且可能把原始的那个查询树扔掉。
</para>

<caution>
<!--==========================orignal english content==========================
 <para>
  In many cases, tasks that could be performed by rules
  on <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> are better done
  with triggers.  Triggers are notationally a bit more complicated, but their
  semantics are much simpler to understand.  Rules tend to have surprising
  results when the original query contains volatile functions: volatile
  functions may get executed more times than expected in the process of
  carrying out the rules.
 </para>
____________________________________________________________________________-->
 <para>
  在很多情况下，由<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>上的规则执行的任务用触发器能做得更好。触发器在记法上要更复杂些，但是它们的语义理解起来更简单些。当原始查询包含不稳定函数时，规则容易产生令人惊讶的结果：在执行规则的过程中不稳定函数的执行次数可能比语气中的更多。
 </para>

<!--==========================orignal english content==========================
 <para>
  Also, there are some cases that are not supported by these types of rules at
  all, notably including <literal>WITH</literal> clauses in the original query and
  multiple-assignment sub-<literal>SELECT</literal>s in the <literal>SET</literal> list
  of <command>UPDATE</command> queries.  This is because copying these constructs
  into a rule query would result in multiple evaluations of the sub-query,
  contrary to the express intent of the query's author.
 </para>
____________________________________________________________________________-->
 <para>
  还有，有些情况根本无法用这些类型的规则支持，典型的是在原始查询中包括<literal>WITH</literal>子句以及在<command>UPDATE</command>查询的<literal>SET</literal>列表中包括多个赋值的子<literal>SELECT</literal>。这是因为把这些结构复制到一个规则查询中可能导致子查询的多次计算，这与查询作者表达的意图相悖。
 </para>
</caution>

<sect2>
<!--==========================orignal english content==========================
<title>How Update Rules Work</title>
____________________________________________________________________________-->
<title>更新规则如何工作</title>

<!--==========================orignal english content==========================
<para>
    Keep the syntax:

<programlisting>
CREATE [ OR REPLACE ] RULE <replaceable class="parameter">name</replaceable> AS ON <replaceable class="parameter">event</replaceable>
    TO <replaceable class="parameter">table</replaceable> [ WHERE <replaceable class="parameter">condition</replaceable> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class="parameter">command</replaceable> | ( <replaceable class="parameter">command</replaceable> ; <replaceable class="parameter">command</replaceable> ... ) }
</programlisting>

    in mind.
    In the following, <firstterm>update rules</firstterm> means rules that are defined
    on <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>.
</para>
____________________________________________________________________________-->
<para>
    记住以下语法：

<programlisting>
CREATE [ OR REPLACE ] RULE <replaceable class="parameter">name</replaceable> AS ON <replaceable class="parameter">event</replaceable>
    TO <replaceable class="parameter">table</replaceable> [ WHERE <replaceable class="parameter">condition</replaceable> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <replaceable class="parameter">command</replaceable> | ( <replaceable class="parameter">command</replaceable> ; <replaceable class="parameter">command</replaceable> ... ) }
</programlisting>

    在随后的内容中，<firstterm>更新规则</firstterm>表示定义在<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>上的规则。 
</para>

<!--==========================orignal english content==========================
<para>
    Update rules get applied by the rule system when the result
    relation and the command type of a query tree are equal to the
    object and event given in the <command>CREATE RULE</command> command.
    For update rules, the rule system creates a list of query trees.
    Initially the query-tree list is empty.
    There can be zero (<literal>NOTHING</literal> key word), one, or multiple actions.
    To simplify, we will look at a rule with one action. This rule
    can have a qualification or not and it can be <literal>INSTEAD</literal> or
    <literal>ALSO</literal> (the default).
</para>
____________________________________________________________________________-->
<para>
    如果查询树的结果关系和命令类型等于<command>CREATE RULE</command>命令中给出的对象和事件，规则系统就会应用更新规则。对于更新规则，规则系统会创建一个查询树列表。一开始该查询树列表是空的。更新规则中可以有零个（<literal>NOTHING</literal>关键字）、一个或多个动作。为简单起见，我们先看一个只有一个动作的规则。这个规则可以有条件或者没有条件，并且它可以是<literal>INSTEAD</literal>或<literal>ALSO</literal>（缺省）。
</para>

<!--==========================orignal english content==========================
<para>
    What is a rule qualification? It is a restriction that tells
    when the actions of the rule should be done and when not. This
    qualification can only reference the pseudorelations <literal>NEW</literal> and/or <literal>OLD</literal>,
    which basically represent the relation that was given as object (but with a
    special meaning).
</para>
____________________________________________________________________________-->
<para>
    什么是规则条件？它是一个限制，告诉规则动作什么时候做、什么时候不做。这个条件只能引用<literal>NEW</literal>和/或<literal>OLD</literal>伪关系，它们基本上代表作为对象给定的关系（但是有着特殊含义）。
</para>

<!--==========================orignal english content==========================
   <para>
    So we have three cases that produce the following query trees for
    a one-action rule.

    <variablelist>
     <varlistentry>
      <term>No qualification, with either <literal>ALSO</literal> or
      <literal>INSTEAD</literal></term>
      <listitem>
       <para>
        the query tree from the rule action with the original query
        tree's qualification added
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Qualification given and <literal>ALSO</literal></term>
      <listitem>
       <para>
        the query tree from the rule action with the rule
        qualification and the original query tree's qualification
        added
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Qualification given and <literal>INSTEAD</literal></term>
      <listitem>
       <para>
        the query tree from the rule action with the rule
        qualification and the original query tree's qualification; and
        the original query tree with the negated rule qualification
        added
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    Finally, if the rule is <literal>ALSO</literal>, the unchanged original query tree is
    added to the list. Since only qualified <literal>INSTEAD</literal> rules already add the
    original query tree, we end up with either one or two output query trees
    for a rule with one action.
</para>
____________________________________________________________________________-->
   <para>
    所以，对这个单动作的规则生成下面的查询树，我们有三种情况。

    <variablelist>
     <varlistentry>
      <term>没有条件，有<literal>ALSO</literal>或<literal>INSTEAD</literal></term>
      <listitem>
       <para>
        来自规则动作的查询树，在其上增加原始查询树的条件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>给出了条件，有<literal>ALSO</literal></term>
      <listitem>
       <para>
        来自规则动作的查询树，在其上加入规则条件和原始查询树的条件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>给出了条件，有<literal>INSTEAD</literal></term>
      <listitem>
       <para>
        来自规则动作的查询树，在其上加入规则条件和原始查询树的条件；以及带有反规则条件的原始查询树
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    最后，如果规则是<literal>ALSO</literal>，那么未修改的原始查询树也被加入到列表。因为只有合格的<literal>INSTEAD</literal>规则已经被加入到原始查询树中，对于单动作的规则，我们将结束于一个或两个输出查询树。
</para>

<!--==========================orignal english content==========================
<para>
    For <literal>ON INSERT</literal> rules, the original query (if not suppressed by <literal>INSTEAD</literal>)
    is done before any actions added by rules.  This allows the actions to
    see the inserted row(s).  But for <literal>ON UPDATE</literal> and <literal>ON
    DELETE</literal> rules, the original query is done after the actions added by rules.
    This ensures that the actions can see the to-be-updated or to-be-deleted
    rows; otherwise, the actions might do nothing because they find no rows
    matching their qualifications.
</para>
____________________________________________________________________________-->
<para>
    对于<literal>ON INSERT</literal>规则，原始查询（如果没有被<literal>INSTEAD</literal>取代）是在任何规则增加的动作之前完成的。这样就允许动作看到被插入的行。但是对<literal>ON UPDATE</literal> 和<literal>ON DELETE</literal>规则，原始查询是在规则增加的动作之后完成的。这样就确保动作可以看到将要更新或者将要删除的行；否则，动作可能什么也不做，因为它们无法发现符合它们要求的行。
</para>

<!--==========================orignal english content==========================
<para>
    The query trees generated from rule actions are thrown into the
    rewrite system again, and maybe more rules get applied resulting
    in more or less query trees.
    So a rule's actions must have either a different
    command type or a different result relation than the rule itself is
    on, otherwise this recursive process will end up in an infinite loop.
    (Recursive expansion of a rule will be detected and reported as an
    error.)
</para>
____________________________________________________________________________-->
<para>
    从规则动作生成的查询树会被再次丢给重写系统，并且可能有更多规则被应用而得到更多或更少的查询树。所以一个规则的动作必须有一种不同的命令类型或者和规则所在的关系不同的另一个结果关系。 否则这样的递归处理就会没完没了（规则的递规展开会被检测到，并当作一个错误报告）。 
</para>

<!--==========================orignal english content==========================
<para>
    The query trees found in the actions of the
    <structname>pg_rewrite</structname> system catalog are only
    templates. Since they can reference the range-table entries for
    <literal>NEW</literal> and <literal>OLD</literal>, some substitutions have to be made before they can be
    used. For any reference to <literal>NEW</literal>, the target list of the original
    query is searched for a corresponding entry. If found, that
    entry's expression replaces the reference. Otherwise, <literal>NEW</literal> means the
    same as <literal>OLD</literal> (for an <command>UPDATE</command>) or is replaced by
    a null value (for an <command>INSERT</command>). Any reference to <literal>OLD</literal> is
    replaced by a reference to the range-table entry that is the
    result relation.
</para>
____________________________________________________________________________-->
<para>
    在<structname>pg_rewrite</structname>系统目录中的动作中的查询树只是模板。因为它们可以引用<literal>NEW</literal>和<literal>OLD</literal>的范围表项，在使用它们之前必须做一些替换。对于任何<literal>NEW</literal>的引用，都要先在原始查询的目标列表中搜索对应的项。如果找到，该项的表达式将会替换该引用。否则<literal>NEW</literal>和<literal>OLD</literal>的含义一样（对于<command>UPDATE</command>）或者被替换成一个空值（对于<command>INSERT</command>）。 任何对<literal>OLD</literal>的引用都用结果关系的范围表项的引用替换。 
</para>

<!--==========================orignal english content==========================
<para>
    After the system is done applying update rules, it applies view rules to the
    produced query tree(s).  Views cannot insert new update actions so
    there is no need to apply update rules to the output of view rewriting.
</para>
____________________________________________________________________________-->
<para>
    在系统完成应用更新规则后，它再应用视图规则到生成的查询树上。视图无法插入新的更新动作，所以没有必要向视图重写的输出应用更新规则。
</para>

<sect3>
<!--==========================orignal english content==========================
<title>A First Rule Step by Step</title>
____________________________________________________________________________-->
<title>第一个规则循序渐进</title>

<!--==========================orignal english content==========================
<para>
    Say we want to trace changes to the <literal>sl_avail</literal> column in the
    <literal>shoelace_data</literal> relation. So we set up a log table
    and a rule that conditionally writes a log entry when an
    <command>UPDATE</command> is performed on
    <literal>shoelace_data</literal>.

<programlisting>
CREATE TABLE shoelace_log (
    sl_name    text,          -&minus; shoelace changed
    sl_avail   integer,       -&minus; new available value
    log_who    text,          -&minus; who did it
    log_when   timestamp      -&minus; when
);

CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
    DO INSERT INTO shoelace_log VALUES (
                                    NEW.sl_name,
                                    NEW.sl_avail,
                                    current_user,
                                    current_timestamp
                                );
</programlisting>
</para>
____________________________________________________________________________-->
<para>
    假设我们想要跟踪<literal>shoelace_data</literal>关系中的<literal>sl_avail</literal>列。所以我们建立一个日志表和一条规则，这条规则每次在<literal>shoelace_data</literal>上执行<command>UPDATE</command>时有条件地写入一个日志项。

<programlisting>
CREATE TABLE shoelace_log (
    sl_name    text,          -- 改变的鞋带
    sl_avail   integer,       -- 新的可用值
    log_who    text,          -- 谁做的
    log_when   timestamp      -- 何时做的
);

CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
    DO INSERT INTO shoelace_log VALUES (
                                    NEW.sl_name,
                                    NEW.sl_avail,
                                    current_user,
                                    current_timestamp
                                );
</programlisting>
</para>

<!--==========================orignal english content==========================
<para>
    Now someone does:

<programlisting>
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';
</programlisting>

    and we look at the log table:

<programlisting>
SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who | log_when                        
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST
(1 row)
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    现在有人做：

<programlisting>
UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';
</programlisting>

    然后看看日志表：

<programlisting>
SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who | log_when                        
---------+----------+---------+----------------------------------
 sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST
(1 row)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    That's what we expected. What happened in the background is the following.
    The parser created the query tree:

<programlisting>
UPDATE shoelace_data SET sl_avail = 6
  FROM shoelace_data shoelace_data
 WHERE shoelace_data.sl_name = 'sl7';
</programlisting>

    There is a rule <literal>log_shoelace</literal> that is <literal>ON UPDATE</literal> with the rule
    qualification expression:

<programlisting>
NEW.sl_avail &lt;&gt; OLD.sl_avail
</programlisting>

    and the action:

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old;
</programlisting>

    (This looks a little strange since you cannot normally write
    <literal>INSERT ... VALUES ... FROM</literal>.  The <literal>FROM</literal>
    clause here is just to indicate that there are range-table entries
    in the query tree for <literal>new</literal> and <literal>old</literal>.
    These are needed so that they can be referenced by variables in
    the <command>INSERT</command> command's query tree.)
</para>
____________________________________________________________________________-->
   <para>
    这就是我们所期望的。在后台发生的的事情如下。解析器创建查询树：

<programlisting>
UPDATE shoelace_data SET sl_avail = 6
  FROM shoelace_data shoelace_data
 WHERE shoelace_data.sl_name = 'sl7';
</programlisting>

    这是一个带有规则条件表达式的<literal>ON UPDATE</literal>规则<literal>log_shoelace</literal> ，条件是：

<programlisting>
NEW.sl_avail &lt;&gt; OLD.sl_avail
</programlisting>

    它的动作是：

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old;
</programlisting>

    （这看起来有点奇怪，因为你通常不能写<literal>INSERT ... VALUES ... FROM</literal>。这里的<literal>FROM</literal>子句只是表示查询树里有用于<literal>new</literal>和<literal>old</literal>的范围表项。这些东西是必需的，这样它们就可以被<command>INSERT</command>命令的查询树中的变量引用）。
</para>

<!--==========================orignal english content==========================
<para>
    The rule is a qualified <literal>ALSO</literal> rule, so the rule system
    has to return two query trees: the modified rule action and the original
    query tree. In step 1, the range table of the original query is
    incorporated into the rule's action query tree. This results in:

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       <emphasis>shoelace_data shoelace_data</emphasis>;
</programlisting>

    In step 2, the rule qualification is added to it, so the result set
    is restricted to rows where <literal>sl_avail</literal> changes:

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;
</programlisting>

    (This looks even stranger, since <literal>INSERT ... VALUES</literal> doesn't have
    a <literal>WHERE</literal> clause either, but the planner and executor will have no
    difficulty with it.  They need to support this same functionality
    anyway for <literal>INSERT ... SELECT</literal>.)
   </para>
____________________________________________________________________________-->
<para>
    该规则是一个有条件的<literal>ALSO</literal>规则，所以规则系统必须返回两个查询树：更改过的规则动作和原始查询树。在第 1 步里，原始查询的范围表被集成到规则动作的查询树中。得到：

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       <emphasis>shoelace_data shoelace_data</emphasis>;
</programlisting>

    第 2 步把规则条件增加进去，所以结果集被限制为<literal>sl_avail</literal>改变了的行：

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 <emphasis>WHERE new.sl_avail &lt;&gt; old.sl_avail</emphasis>;
</programlisting>

    （这看起来更奇怪，因为<literal>INSERT ... VALUES</literal>也没有<literal>WHERE</literal>子句，但是规划器和执行器处理它没有任何难度。不管怎样，它们需要为<literal>INSERT ... SELECT</literal>支持这种相同功能）。
   </para>

<!--==========================orignal english content==========================
   <para>
    In step 3, the original query tree's qualification is added,
    restricting the result set further to only the rows that would have been touched
    by the original query:

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE new.sl_avail &lt;&gt; old.sl_avail
   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    第 3 步把原始查询树的条件加进去，把结果集进一步限制成只有被初始查询树改变的行：

<programlisting>
INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE new.sl_avail &lt;&gt; old.sl_avail
   <emphasis>AND shoelace_data.sl_name = 'sl7'</emphasis>;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Step 4 replaces references to <literal>NEW</literal> by the target list entries from the
    original query tree or by the matching variable references
    from the result relation:

<programlisting>
INSERT INTO shoelace_log VALUES (
       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

   </para>
____________________________________________________________________________-->
   <para>
    第 4 步把<literal>NEW</literal>引用替换为来自原始查询树的目标列表项或来自结果关系的相匹配的变量引用：

<programlisting>
INSERT INTO shoelace_log VALUES (
       <emphasis>shoelace_data.sl_name</emphasis>, <emphasis>6</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE <emphasis>6</emphasis> &lt;&gt; old.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

   </para>

<!--==========================orignal english content==========================
   <para>
    Step 5 changes <literal>OLD</literal> references into result relation references:

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>
   AND shoelace_data.sl_name = 'sl7';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    第 5 步，用结果关系引用把<literal>OLD</literal>引用替换掉：

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE 6 &lt;&gt; <emphasis>shoelace_data.sl_avail</emphasis>
   AND shoelace_data.sl_name = 'sl7';
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    That's it.  Since the rule is <literal>ALSO</literal>, we also output the
    original query tree.  In short, the output from the rule system
    is a list of two query trees that correspond to these statements:

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE 6 &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';

UPDATE shoelace_data SET sl_avail = 6
 WHERE sl_name = 'sl7';
</programlisting>

    These are executed in this order, and that is exactly what
    the rule was meant to do.
   </para>
____________________________________________________________________________-->
   <para>
    这就完成了。因为规则是<literal>ALSO</literal>，我们还要输出原始查询树。简而言之，从规则系统输出的是一个包含两个查询树的列表，它们与下面语句相对应：

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE 6 &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';

UPDATE shoelace_data SET sl_avail = 6
 WHERE sl_name = 'sl7';
</programlisting>

    这些会按照这个顺序被执行，并且这也正是规则要做的事情。
   </para>

<!--==========================orignal english content==========================
   <para>
    The substitutions and the added qualifications
    ensure that, if the original query would be, say:

<programlisting>
UPDATE shoelace_data SET sl_color = 'green'
 WHERE sl_name = 'sl7';
</programlisting>

    no log entry would get written.  In that case, the original query
    tree does not contain a target list entry for
    <literal>sl_avail</literal>, so <literal>NEW.sl_avail</literal> will get
    replaced by <literal>shoelace_data.sl_avail</literal>.  Thus, the extra
    command generated by the rule is:

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

    and that qualification will never be true.
   </para>
____________________________________________________________________________-->
   <para>
    做的替换和追加的条件用于确保对于下面这样的原始查询不会有日志记录被写入：

<programlisting>
UPDATE shoelace_data SET sl_color = 'green'
 WHERE sl_name = 'sl7';
</programlisting>

    在这种情况下，原始查询树不包含<literal>sl_avail</literal>的目标列表项，因此<literal>NEW.sl_avail</literal>将被<literal>shoelace_data.sl_avail</literal>代替。所以，规则生成的额外命令是：

<programlisting>
INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, <emphasis>shoelace_data.sl_avail</emphasis>,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE <emphasis>shoelace_data.sl_avail</emphasis> &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';
</programlisting>

    并且条件将永远不可能为真。
   </para>

<!--==========================orignal english content==========================
   <para>
    It will also work if the original query modifies multiple rows. So
    if someone issued the command:

<programlisting>
UPDATE shoelace_data SET sl_avail = 0
 WHERE sl_color = 'black';
</programlisting>

    four rows in fact get updated (<literal>sl1</literal>, <literal>sl2</literal>, <literal>sl3</literal>, and <literal>sl4</literal>).
    But <literal>sl3</literal> already has <literal>sl_avail = 0</literal>.   In this case, the original
    query trees qualification is different and that results
    in the extra query tree:

<programlisting>
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
       current_user, current_timestamp
  FROM shoelace_data
 WHERE 0 &lt;&gt; shoelace_data.sl_avail
   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;
</programlisting>

    being generated by the rule.  This query tree will surely insert
    three new log entries. And that's absolutely correct.
</para>
____________________________________________________________________________-->
   <para>
    如果原始查询修改多个行，这也能争产工作。所以如果某人发出命令：

<programlisting>
UPDATE shoelace_data SET sl_avail = 0
 WHERE sl_color = 'black';
</programlisting>

    实际上有四行（<literal>sl1</literal>、<literal>sl2</literal>、<literal>sl3</literal>和<literal>sl4</literal>）被更新。但<literal>sl3</literal>已经是<literal>sl_avail = 0</literal>。在这种情况下，原始查询树的条件不同并且导致规则产生额外的查询树：

<programlisting>
INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
       current_user, current_timestamp
  FROM shoelace_data
 WHERE 0 &lt;&gt; shoelace_data.sl_avail
   AND <emphasis>shoelace_data.sl_color = 'black'</emphasis>;
</programlisting>

    这个查询树将肯定插入三个新的日志项。这也是完全正确的。
</para>

<!--==========================orignal english content==========================
<para>
    Here we can see why it is important that the original query tree
    is executed last.  If the <command>UPDATE</command> had been
    executed first, all the rows would have already been set to zero, so the
    logging <command>INSERT</command> would not find any row where
    <literal>0 &lt;&gt; shoelace_data.sl_avail</literal>.
</para>
____________________________________________________________________________-->
<para>
    到这里我们就能明白为什么原始查询树最后执行非常重要。如果<command>UPDATE</command>先被执行，则所有的行都已经被设为零，所以记日志的<command>INSERT</command>将无法找到任何符合<literal>0 &lt;&gt; shoelace_data.sl_avail</literal>的行。
</para>
</sect3>

</sect2>

<sect2 id="rules-update-views">
<!--==========================orignal english content==========================
<title>Cooperation with Views</title>
____________________________________________________________________________-->
<title>与视图合作</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-update-views"><primary>view</primary><secondary>updating</secondary></indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-update-views"><primary>view</primary><secondary>updating</secondary></indexterm>

<!--==========================orignal english content==========================
<para>
    A simple way to protect view relations from the mentioned
    possibility that someone can try to run <command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command> on them is
    to let those query trees get thrown away.  So we could create the rules:

<programlisting>
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
    DO INSTEAD NOTHING;
</programlisting>

    If someone now tries to do any of these operations on the view
    relation <literal>shoe</literal>, the rule system will
    apply these rules. Since the rules have
    no actions and are <literal>INSTEAD</literal>, the resulting list of
    query trees will be empty and the whole query will become
    nothing because there is nothing left to be optimized or
    executed after the rule system is done with it.
</para>
____________________________________________________________________________-->
<para>
    要保护一个视图关系不被<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>，一种简单的方法是让那些查询树被丢掉。因此我们可以创建规则：

<programlisting>
CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
    DO INSTEAD NOTHING;
</programlisting>

    如果现在某人尝试对视图关系<literal>shoe</literal>做任何这些操作，规则系统将应用这些规则。因为这些规则没有动作而且是<literal>INSTEAD</literal>，作为的查询树列表将是空的并且整个查询将变得什么也不做，因为经过规则系统处理后没有什么东西剩下来被优化或执行了。
</para>

<!--==========================orignal english content==========================
<para>
    A more sophisticated way to use the rule system is to
    create rules that rewrite the query tree into one that
    does the right operation on the real tables. To do that
    on the <literal>shoelace</literal> view, we create
    the following rules:

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    );

CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
    DO INSTEAD
    UPDATE shoelace_data
       SET sl_name = NEW.sl_name,
           sl_avail = NEW.sl_avail,
           sl_color = NEW.sl_color,
           sl_len = NEW.sl_len,
           sl_unit = NEW.sl_unit
     WHERE sl_name = OLD.sl_name;

CREATE RULE shoelace_del AS ON DELETE TO shoelace
    DO INSTEAD
    DELETE FROM shoelace_data
     WHERE sl_name = OLD.sl_name;
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    一个更好的使用规则系统的方法是创建一些规则，这些规则把查询树重写成一个在真实表上进行正确的操作的查询树。 要在视图<literal>shoelace</literal>上做这件事，我们创建下列规则：

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    );

CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
    DO INSTEAD
    UPDATE shoelace_data
       SET sl_name = NEW.sl_name,
           sl_avail = NEW.sl_avail,
           sl_color = NEW.sl_color,
           sl_len = NEW.sl_len,
           sl_unit = NEW.sl_unit
     WHERE sl_name = OLD.sl_name;

CREATE RULE shoelace_del AS ON DELETE TO shoelace
    DO INSTEAD
    DELETE FROM shoelace_data
     WHERE sl_name = OLD.sl_name;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    If you want to support <literal>RETURNING</literal> queries on the view,
    you need to make the rules include <literal>RETURNING</literal> clauses that
    compute the view rows.  This is usually pretty trivial for views on a
    single table, but it's a bit tedious for join views such as
    <literal>shoelace</literal>.  An example for the insert case is:

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    )
    RETURNING
           shoelace_data.*,
           (SELECT shoelace_data.sl_len * u.un_fact
            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
</programlisting>

    Note that this one rule supports both <command>INSERT</command> and
    <command>INSERT RETURNING</command> queries on the view &mdash; the
    <literal>RETURNING</literal> clause is simply ignored for <command>INSERT</command>.
   </para>
____________________________________________________________________________-->
   <para>
    如果你要在视图上支持<literal>RETURNING</literal>查询，你需要让规则包含<literal>RETURNING</literal>子句来计算视图行。这对于基于单个表的视图来说通常非常简单，但是对于连接视图（如<literal>shoelace</literal>）就有点冗长了。对于插入的一个例子：

<programlisting>
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    )
    RETURNING
           shoelace_data.*,
           (SELECT shoelace_data.sl_len * u.un_fact
            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);
</programlisting>

    注意，这个规则同时支持该视图上的<command>INSERT</command>和<command>INSERT RETURNING</command>查询 &mdash; 对于<command>INSERT</command>会简单地忽略<literal>RETURNING</literal>子句。
   </para>

<!--==========================orignal english content==========================
   <para>
    Now assume that once in a while, a pack of shoelaces arrives at
    the shop and a big parts list along with it.  But you don't want
    to manually update the <literal>shoelace</literal> view every
    time.  Instead we set up two little tables: one where you can
    insert the items from the part list, and one with a special
    trick. The creation commands for these are:

<programlisting>
CREATE TABLE shoelace_arrive (
    arr_name    text,
    arr_quant   integer
);

CREATE TABLE shoelace_ok (
    ok_name     text,
    ok_quant    integer
);

CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
    DO INSTEAD
    UPDATE shoelace
       SET sl_avail = sl_avail + NEW.ok_quant
     WHERE sl_name = NEW.ok_name;
</programlisting>

    Now you can fill the table <literal>shoelace_arrive</literal> with
    the data from the parts list:

<programlisting>
SELECT * FROM shoelace_arrive;

 arr_name | arr_quant
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl3      |        10
 sl6      |        20
 sl8      |        20
(3 rows)
</programlisting>

    Take a quick look at the current data:

<programlisting>
SELECT * FROM shoelace;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl3      |        0 | black    |     35 | inch    |      88.9
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl8      |        1 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>

    Now move the arrived shoelaces in:

<programlisting>
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
</programlisting>

    and check the results:

<programlisting>
SELECT * FROM shoelace ORDER BY sl_name;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl3      |       10 | black    |     35 | inch    |      88.9
 sl8      |       21 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |       20 | brown    |    0.9 | m       |        90
(8 rows)

SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who| log_when                        
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST
 sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    现在假设有时一包鞋带抵达了商店，并且随着它有一个大的清单。但是你不想每次都手工更新<literal>shoelace</literal>视图。取而代之的是我们建立两个小表：一个用来从清单向其中插入东西，另一个则用了一个特殊的技巧。这些东西的创建命令如下：

<programlisting>
CREATE TABLE shoelace_arrive (
    arr_name    text,
    arr_quant   integer
);

CREATE TABLE shoelace_ok (
    ok_name     text,
    ok_quant    integer
);

CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
    DO INSTEAD
    UPDATE shoelace
       SET sl_avail = sl_avail + NEW.ok_quant
     WHERE sl_name = NEW.ok_name;
</programlisting>

    现在你可以用来自清单的数据填充表<literal>shoelace_arrive</literal>：

<programlisting>
SELECT * FROM shoelace_arrive;

 arr_name | arr_quant
----------+-----------
 sl3      |        10
 sl6      |        20
 sl8      |        20
(3 rows)
</programlisting>

    快速地看一看当前的数据：

<programlisting>
SELECT * FROM shoelace;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl3      |        0 | black    |     35 | inch    |      88.9
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl8      |        1 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |        0 | brown    |    0.9 | m       |        90
(8 rows)
</programlisting>

    现在把到的货鞋带移到：

<programlisting>
INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;
</programlisting>

    并检查结果：

<programlisting>
SELECT * FROM shoelace ORDER BY sl_name;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl3      |       10 | black    |     35 | inch    |      88.9
 sl8      |       21 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |       20 | brown    |    0.9 | m       |        90
(8 rows)

SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who| log_when                        
---------+----------+--------+----------------------------------
 sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST
 sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST
(4 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    It's a long way from the one <literal>INSERT ... SELECT</literal>
    to these results. And the description of the query-tree
    transformation will be the last in this chapter.  First, there is
    the parser's output:

<programlisting>
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
</programlisting>

    Now the first rule <literal>shoelace_ok_ins</literal> is applied and turns this
    into:

<programlisting>
UPDATE shoelace
   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace
 WHERE shoelace.sl_name = shoelace_arrive.arr_name;
</programlisting>

    and throws away the original <command>INSERT</command> on
    <literal>shoelace_ok</literal>.  This rewritten query is passed to
    the rule system again, and the second applied rule
    <literal>shoelace_upd</literal> produces:

<programlisting>
UPDATE shoelace_data
   SET sl_name = shoelace.sl_name,
       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
       sl_color = shoelace.sl_color,
       sl_len = shoelace.sl_len,
       sl_unit = shoelace.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data
 WHERE shoelace.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = shoelace.sl_name;
</programlisting>

    Again it's an <literal>INSTEAD</literal> rule and the previous query tree is trashed.
    Note that this query still uses the view <literal>shoelace</literal>.
    But the rule system isn't finished with this step, so it continues
    and applies the <literal>_RETURN</literal> rule on it, and we get:

<programlisting>
UPDATE shoelace_data
   SET sl_name = s.sl_name,
       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
       sl_color = s.sl_color,
       sl_len = s.sl_len,
       sl_unit = s.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

    Finally, the rule <literal>log_shoelace</literal> gets applied,
    producing the extra query tree:

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u,
       shoelace_data old, shoelace_data new
       shoelace_log shoelace_log
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
</programlisting>

    After that the rule system runs out of rules and returns the
    generated query trees.
   </para>
____________________________________________________________________________-->
   <para>
    从一个<literal>INSERT ... SELECT</literal>到这些结果经过了很长的过程。并且该查询树转换的描述将出现在本章的最后。首先，这里是解析器的输出：

<programlisting>
INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;
</programlisting>

    现在应用第一条规则<literal>shoelace_ok_ins</literal>被应用并且把这个输出转换成：

<programlisting>
UPDATE shoelace
   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace
 WHERE shoelace.sl_name = shoelace_arrive.arr_name;
</programlisting>

    并且丢掉<literal>shoelace_ok</literal>上的<command>INSERT</command>。这个被重写后的查询被再次传递给规则系统，并且第二个被应用的规则<literal>shoelace_upd</literal>会产生：

<programlisting>
UPDATE shoelace_data
   SET sl_name = shoelace.sl_name,
       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
       sl_color = shoelace.sl_color,
       sl_len = shoelace.sl_len,
       sl_unit = shoelace.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data
 WHERE shoelace.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = shoelace.sl_name;
</programlisting>

    同样这是一个<literal>INSTEAD</literal>规则并且前一个查询树会被丢弃掉。注意这个查询仍然使用视图<literal>shoelace</literal>。但是规则系统还没有完成这一步，所以它会继续并在其上应用<literal>_RETURN</literal>规则，并且我们得到：

<programlisting>
UPDATE shoelace_data
   SET sl_name = s.sl_name,
       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
       sl_color = s.sl_color,
       sl_len = s.sl_len,
       sl_unit = s.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

    最后，规则<literal>log_shoelace</literal>被应用，生成额外的查询树：

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u,
       shoelace_data old, shoelace_data new
       shoelace_log shoelace_log
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;
</programlisting>

    完成这些之后，规则系统用完了所有的规则并且返回生成的查询树。
   </para>

<!--==========================orignal english content==========================
   <para>
    So we end up with two final query trees that are equivalent to the
    <acronym>SQL</acronym> statements:

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;

UPDATE shoelace_data
   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive,
       shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.sl_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

    The result is that data coming from one relation inserted into another,
    changed into updates on a third, changed into updating
    a fourth plus logging that final update in a fifth
    gets reduced into two queries.
</para>
____________________________________________________________________________-->
   <para>
    所以我们结束于两个最终查询树，它们等效于<acronym>SQL</acronym>语句：

<programlisting>
INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;

UPDATE shoelace_data
   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive,
       shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.sl_name
   AND shoelace_data.sl_name = s.sl_name;
</programlisting>

    结果是从一个关系来的数据插入了到另一个中，改变成第三个上的更新，改变成更新第四个外加做日志，在第五个中的最后更新缩减为两个查询。
</para>

<!--==========================orignal english content==========================
<para>
    There is a little detail that's a bit ugly. Looking at the two
    queries, it turns out that the <literal>shoelace_data</literal>
    relation appears twice in the range table where it could
    definitely be reduced to one. The planner does not handle it and
    so the execution plan for the rule systems output of the
    <command>INSERT</command> will be

<literallayout class="monospaced">
Nested Loop
  -&gt;  Merge Join
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on s
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on shoelace_arrive
  -&gt;  Seq Scan on shoelace_data
</literallayout>

    while omitting the extra range table entry would result in a

<literallayout class="monospaced">
Merge Join
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on s
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on shoelace_arrive
</literallayout>

    which produces exactly the same entries in the log table.  Thus,
    the rule system caused one extra scan on the table
    <literal>shoelace_data</literal> that is absolutely not
    necessary. And the same redundant scan is done once more in the
    <command>UPDATE</command>. But it was a really hard job to make
    that all possible at all.
</para>
____________________________________________________________________________-->
<para>
    有一个小细节有点丑陋。看看那两个查询，我们会发现<literal>shoelace_data</literal>关系在范围表中出现了两次而实际上绝对可以缩为出现一次。规划器不会处理它，因此<command>INSERT</command>的规则系统输出的执行规划会是

<literallayout class="monospaced">
Nested Loop
  -&gt;  Merge Join
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on s
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on shoelace_arrive
  -&gt;  Seq Scan on shoelace_data
</literallayout>

    在省略额外的范围表项后会得到

<literallayout class="monospaced">
Merge Join
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on s
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on shoelace_arrive
</literallayout>

    这在日志表中生成完全一样的项。因此，规则系统导致了<literal>shoelace_data</literal>表上的一次绝对不必要的扫描。并且同样的冗余扫描会在<command>UPDATE</command>中进行。但是要把这些全部实现实在是一项很困难的工作。
</para>

<!--==========================orignal english content==========================
<para>
    Now we make a final demonstration of the
    <productname>PostgreSQL</productname> rule system and its power.
    Say you add some shoelaces with extraordinary colors to your
    database:

<programlisting>
INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
</programlisting>

    We would like to make a view to check which
    <literal>shoelace</literal> entries do not fit any shoe in color.
    The view for this is:

<programlisting>
CREATE VIEW shoelace_mismatch AS
    SELECT * FROM shoelace WHERE NOT EXISTS
        (SELECT shoename FROM shoe WHERE slcolor = sl_color);
</programlisting>

    Its output is:

<programlisting>
SELECT * FROM shoelace_mismatch;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl9     |        0 | pink     |     35 | inch    |      88.9
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    现在我们对<productname>PostgreSQL</productname>规则系统及其能力做最后一个演示。假设你向你的数据库中添加一些有特别颜色的鞋带：

<programlisting>
INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
</programlisting>

    我们想要建立一个视图来检查哪些<literal>shoelace</literal>项在颜色上不配任何鞋子。适用的视图是：

<programlisting>
CREATE VIEW shoelace_mismatch AS
    SELECT * FROM shoelace WHERE NOT EXISTS
        (SELECT shoename FROM shoe WHERE slcolor = sl_color);
</programlisting>

    它的输出是：

<programlisting>
SELECT * FROM shoelace_mismatch;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl9     |        0 | pink     |     35 | inch    |      88.9
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Now we want to set it up so that mismatching shoelaces that are
    not in stock are deleted from the database.
    To make it a little harder for <productname>PostgreSQL</productname>,
    we don't delete it directly. Instead we create one more view:

<programlisting>
CREATE VIEW shoelace_can_delete AS
    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
</programlisting>

    and do it this way:

<programlisting>
DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_can_delete
             WHERE sl_name = shoelace.sl_name);
</programlisting>

    <foreignphrase>Voil&agrave;</foreignphrase>:

<programlisting>
SELECT * FROM shoelace;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 sl1     |        5 | black    |     80 | cm      |        80
 sl2     |        6 | black    |    100 | cm      |       100
 sl7     |        6 | brown    |     60 | cm      |        60
 sl4     |        8 | black    |     40 | inch    |     101.6
 sl3     |       10 | black    |     35 | inch    |      88.9
 sl8     |       21 | brown    |     40 | inch    |     101.6
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
 sl5     |        4 | brown    |      1 | m       |       100
 sl6     |       20 | brown    |    0.9 | m       |        90
(9 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    现在我们想建立它，这样没有库存的不匹配的鞋带都会被从数据库中删除。为了对<productname>PostgreSQL</productname>有点难度，我们不直接删除它们。而是我们再创建一个视图：

<programlisting>
CREATE VIEW shoelace_can_delete AS
    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;
</programlisting>

    然后用下面方法：

<programlisting>
DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_can_delete
             WHERE sl_name = shoelace.sl_name);
</programlisting>

    <foreignphrase>Voil&agrave;</foreignphrase>:

<programlisting>
SELECT * FROM shoelace;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl1     |        5 | black    |     80 | cm      |        80
 sl2     |        6 | black    |    100 | cm      |       100
 sl7     |        6 | brown    |     60 | cm      |        60
 sl4     |        8 | black    |     40 | inch    |     101.6
 sl3     |       10 | black    |     35 | inch    |      88.9
 sl8     |       21 | brown    |     40 | inch    |     101.6
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
 sl5     |        4 | brown    |      1 | m       |       100
 sl6     |       20 | brown    |    0.9 | m       |        90
(9 rows)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    A <command>DELETE</command> on a view, with a subquery qualification that
    in total uses 4 nesting/joined views, where one of them
    itself has a subquery qualification containing a view
    and where calculated view columns are used,
    gets rewritten into
    one single query tree that deletes the requested data
    from a real table.
</para>
____________________________________________________________________________-->
   <para>
    对一个视图上的<command>DELETE</command>，这个命令带有一个总共使用了四个嵌套/连接视图的子查询条件， 这四个视图之一本身有一个包含一个视图的子查询条件，该条件计算使用的视图列； 这个命令被重写成了一个查询树，该查询树从一个真正的表里面把需要删除的数据删除。
</para>

<!--==========================orignal english content==========================
<para>
    There are probably only a few situations out in the real world
    where such a construct is necessary. But it makes you feel
    comfortable that it works.
</para>
____________________________________________________________________________-->
<para>
    在现实世界里只有很少的情况需要上面的这样的构造。但这些东西能运转肯定让你感觉不错。
</para>
</sect2>

</sect1>

<sect1 id="rules-privileges">
<!--==========================orignal english content==========================
<title>Rules and Privileges</title>
____________________________________________________________________________-->
<title>规则和权限</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-privileges">
 <primary>privilege</primary>
 <secondary sortas="Regeln">with rules</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-privileges">
 <primary>权限</primary>
 <secondary sortas="Regeln">与规则</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-privileges">
 <primary>privilege</primary>
 <secondary sortas="Sichten">with views</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-privileges">
 <primary>权限</primary>
 <secondary sortas="Sichten">与视图</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Due to rewriting of queries by the <productname>PostgreSQL</productname>
    rule system, other tables/views than those used in the original
    query get accessed. When update rules are used, this can include write access
    to tables.
</para>
____________________________________________________________________________-->
<para>
    由于<productname>PostgreSQL</productname>规则系统对查询的重写，会访问没有在原始查询中指定的表/视图。使用更新规则时，这可能包括对表的写权限。
</para>

<!--==========================orignal english content==========================
<para>
    Rewrite rules don't have a separate owner. The owner of
    a relation (table or view) is automatically the owner of the
    rewrite rules that are defined for it.
    The <productname>PostgreSQL</productname> rule system changes the
    behavior of the default access control system. Relations that
    are used due to rules get checked against the
    privileges of the rule owner, not the user invoking the rule.
    This means that users only need the required privileges
    for the tables/views that are explicitly named in their queries.
</para>
____________________________________________________________________________-->
<para>
    重写规则并不拥有一个独立的所有者。关系（表或视图）的所有者自动成为为其所定义的重写规则的所有者。<productname>PostgreSQL</productname>规则系统改变了默认的访问控制系统的行为。由于规则被使用的关系会按照规则所有者的权限来检查，而不是调用规则的用户。这表示用户只需要在其查询中显式指定的表/视图上的所需权限。
</para>

<!--==========================orignal english content==========================
<para>
    For example: A user has a list of phone numbers where some of
    them are private, the others are of interest for the assistant of the office.
    The user can construct the following:

<programlisting>
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
    SELECT person, CASE WHEN NOT private THEN phone END AS phone
    FROM phone_data;
GRANT SELECT ON phone_number TO assistant;
</programlisting>

    Nobody except that user (and the database superusers) can access the
    <literal>phone_data</literal> table. But because of the <command>GRANT</command>,
    the assistant can run a <command>SELECT</command> on the
    <literal>phone_number</literal> view. The rule system will rewrite the
    <command>SELECT</command> from <literal>phone_number</literal> into a
    <command>SELECT</command> from <literal>phone_data</literal>.
    Since the user is the owner of
    <literal>phone_number</literal> and therefore the owner of the rule, the
    read access to <literal>phone_data</literal> is now checked against the user's
    privileges and the query is permitted. The check for accessing
    <literal>phone_number</literal> is also performed, but this is done
    against the invoking user, so nobody but the user and the
    assistant can use it.
</para>
____________________________________________________________________________-->
<para>
    例如：某用户有一个电话号码列表，其中一些是私人的，另外的一些是办公室助理需要的。该用户可以构建下面的东西：

<programlisting>
CREATE TABLE phone_data (person text, phone text, private boolean);
CREATE VIEW phone_number AS
    SELECT person, CASE WHEN NOT private THEN phone END AS phone
    FROM phone_data;
GRANT SELECT ON phone_number TO assistant;
</programlisting>

    除了该用户以外（还有数据库超级用户）没有人可以访问<literal>phone_data</literal>表。但因为<command>GRANT</command>的原因，助理可以在<literal>phone_number</literal>视图上运行<command>SELECT</command>。规则系统将把<literal>phone_number</literal>上的<command>SELECT</command>重写为<literal>phone_data</literal>上的<command>SELECT</command>。因为该用户是<literal>phone_number</literal>的所有者，因此也是规则的所有者，对<literal>phone_data</literal>的读访问现在被根据该用户的权限检查，并且该查询被允许。同时也要检查访问<literal>phone_number</literal>的权限，但这是针对调用用户进行的，所以除了用户自己和助理外没有人可以使用它。
</para>

<!--==========================orignal english content==========================
<para>
    The privileges are checked rule by rule. So the assistant is for now the
    only one who can see the public phone numbers. But the assistant can set up
    another view and grant access to that to the public. Then, anyone
    can see the <literal>phone_number</literal> data through the assistant's view.
    What the assistant cannot do is to create a view that directly
    accesses <literal>phone_data</literal>.  (Actually the assistant can, but it will not work since
    every access will be denied during the permission checks.)
    And as soon as the user notices that the assistant opened
    their <literal>phone_number</literal> view, the user can revoke the assistant's access. Immediately, any
    access to the assistant's view would fail.
</para>
____________________________________________________________________________-->
<para>
    权限检查是按规则逐条进行的。所以此时助理是唯一的一个可以看到公共电话号码的人。 但助理可以建立另一个视图并且赋予该视图公共权限。这样，任何人都可以通过助理的视图看到<literal>phone_number</literal>数据。 助理不能做的事情是创建一个直接访问<literal>phone_data</literal>的视图（实际上助理是可以的，但没有任何作用，因为每次访问都会因通不过权限检查而被否定）。而且该用户一旦注意到助理开放了他的<literal>phone_number</literal>视图，该用户还可以收回助理的访问权限。立刻，所有对助理视图的访问将会失败。
</para>

<!--==========================orignal english content==========================
<para>
    One might think that this rule-by-rule checking is a security
    hole, but in fact it isn't.   But if it did not work this way, the assistant
    could set up a table with the same columns as <literal>phone_number</literal> and
    copy the data to there once per day. Then it's the assistant's own data and
    the assistant can grant access to everyone they want. A
    <command>GRANT</command> command means, <quote>I trust you</quote>.
    If someone you trust does the thing above, it's time to
    think it over and then use <command>REVOKE</command>.
</para>
____________________________________________________________________________-->
<para>
    有人可能会认为这种逐条规则的检查是一个安全漏洞，但事实上不是。 如果这样做不能奏效，助理将必须建立一个与<literal>phone_number</literal>有相同列的表并且每天拷贝一次数据进去。 那么这是助理自己的数据因而助理可以为每一个想要访问的人授权。一个<command>GRANT</command>意味着<quote>我信任你</quote>。 如果某个你信任的人做了上面的事情，那么是时候认为信任已经结束并且要使用<command>REVOKE</command>。
</para>

<!--==========================orignal english content==========================
<para>
    Note that while views can be used to hide the contents of certain
    columns using the technique shown above, they cannot be used to reliably
    conceal the data in unseen rows unless the
    <literal>security_barrier</literal> flag has been set.  For example,
    the following view is insecure:
<programlisting>
CREATE VIEW phone_number AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
    This view might seem secure, since the rule system will rewrite any
    <command>SELECT</command> from <literal>phone_number</literal> into a
    <command>SELECT</command> from <literal>phone_data</literal> and add the
    qualification that only entries where <literal>phone</literal> does not begin
    with 412 are wanted.  But if the user can create their own functions,
    it is not difficult to convince the planner to execute the user-defined
    function prior to the <function>NOT LIKE</function> expression.
    For example:
<programlisting>
CREATE FUNCTION tricky(text, text) RETURNS bool AS $$
BEGIN
    RAISE NOTICE '% =&gt; %', $1, $2;
    RETURN true;
END
$$ LANGUAGE plpgsql COST 0.0000000000000000000001;

SELECT * FROM phone_number WHERE tricky(person, phone);
</programlisting>
    Every person and phone number in the <literal>phone_data</literal> table will be
    printed as a <literal>NOTICE</literal>, because the planner will choose to
    execute the inexpensive <function>tricky</function> function before the
    more expensive <function>NOT LIKE</function>.  Even if the user is
    prevented from defining new functions, built-in functions can be used in
    similar attacks.  (For example, most casting functions include their
    input values in the error messages they produce.)
</para>
____________________________________________________________________________-->
<para>
    需要注意的是，虽然视图可以用前文展示的技术来隐藏特定列的内容，它们不能可靠地在不可见行上隐藏数据，除非标志被设置。 例如，下面的视图是不安全的：
<programlisting>
CREATE VIEW phone_number AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
    这个视图看起来是安全的，因为规则系统会把任何<literal>phone_number</literal>上的<command>SELECT</command>重写成 <literal>phone_data</literal>上的<command>SELECT</command>，并且增加限制使得只有<literal>phone</literal> 不以 412 开头的项才被处理。但是如果用户可以创建自己的函数，那就不难让规划器在<function>NOT LIKE</function>表达式之前先执行用户自定义函数。例如：
<programlisting>
CREATE FUNCTION tricky(text, text) RETURNS bool AS $$
BEGIN
    RAISE NOTICE '% =&gt; %', $1, $2;
    RETURN true;
END
$$ LANGUAGE plpgsql COST 0.0000000000000000000001;

SELECT * FROM phone_number WHERE tricky(person, phone);
</programlisting>
    <literal>phone_data</literal>表中的每一个人和电话号码会被打印成一个<literal>NOTICE</literal>，因为规划器会选择在执行<function>NOT LIKE</function>之前先执行<function>tricky</function>，因为前者的开销大。 即使禁止用户自定义一个新函数，内置函数也可以用在类似的攻击中（例如，大部分造型函数会在它们产生的错误信息中包含它们的输入值）。
</para>

<!--==========================orignal english content==========================
<para>
    Similar considerations apply to update rules. In the examples of
    the previous section, the owner of the tables in the example
    database could grant the privileges <literal>SELECT</literal>,
    <literal>INSERT</literal>, <literal>UPDATE</literal>, and <literal>DELETE</literal> on
    the <literal>shoelace</literal> view to someone else, but only
    <literal>SELECT</literal> on <literal>shoelace_log</literal>. The rule action to
    write log entries will still be executed successfully, and that
    other user could see the log entries.  But they could not create fake
    entries, nor could they manipulate or remove existing ones.  In this
    case, there is no possibility of subverting the rules by convincing
    the planner to alter the order of operations, because the only rule
    which references <literal>shoelace_log</literal> is an unqualified
    <literal>INSERT</literal>.  This might not be true in more complex scenarios.
</para>
____________________________________________________________________________-->
<para>
    类似的考虑应用于更新规则。在前一节的例子中，例子数据库中表的所有者可以把<literal>shoelace</literal>视图上的<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>和<literal>DELETE</literal>权限授予其他人，但对<literal>shoelace_log</literal>只有<literal>SELECT</literal>权限。写日志项的规则动作将仍然可以被成功地执行，并且其它用户可以看到日志项。但他们不能创建伪造的项，并且他们也不能操纵或移除现有的项。在这种情况下，不可能通过让规划器改变操作的顺序来推翻规则，因为引用<literal>shoelace_log</literal>的唯一规则是无限制的<literal>INSERT</literal>。在更复杂的情景中，这可能不正确。
</para>

<!--==========================orignal english content==========================
<para>
    When it is necessary for a view to provide row level security, the
    <literal>security_barrier</literal> attribute should be applied to
    the view.  This prevents maliciously-chosen functions and operators from
    being passed values from rows until after the view has done its work.  For
    example, if the view shown above had been created like this, it would
    be secure:
<programlisting>
CREATE VIEW phone_number WITH (security_barrier) AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
    Views created with the <literal>security_barrier</literal> may perform
    far worse than views created without this option.  In general, there is
    no way to avoid this: the fastest possible plan must be rejected
    if it may compromise security.  For this reason, this option is not
    enabled by default.
</para>
____________________________________________________________________________-->
<para>
    当需要对一个视图提供行级安全时，<literal>security_barrier</literal>属性应该被应用到该视图。这会阻止恶意选择的函数和操作符通过行被传递，直到视图完成其工作。例如，如果前文所示的视图被创建成这样，它就是安全的：
<programlisting>
CREATE VIEW phone_number WITH (security_barrier) AS
    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';
</programlisting>
    Views created with the 使用<literal>security_barrier</literal>创建的视图的性能会远差于没有使用该选项的视图。通常，没有办法来避免这种现状：如果最快的候选计划可能在安全性上折衷，它就必须被拒绝。出于该原因，这个选在在默认情况下是没有启用的。
</para>

<!--==========================orignal english content==========================
<para>
    The query planner has more flexibility when dealing with functions that
    have no side effects.  Such functions are referred to as <literal>LEAKPROOF</literal>, and
    include many simple, commonly used operators, such as many equality
    operators.  The query planner can safely allow such functions to be evaluated
    at any point in the query execution process, since invoking them on rows
    invisible to the user will not leak any information about the unseen rows.
    Further, functions which do not take arguments or which are not passed any
    arguments from the security barrier view do not have to be marked as
    <literal>LEAKPROOF</literal> to be pushed down, as they never receive data
    from the view.  In contrast, a function that might throw an error depending
    on the values received as arguments (such as one that throws an error in the
    event of overflow or division by zero) is not leak-proof, and could provide
    significant information about the unseen rows if applied before the security
    view's row filters.
</para>
____________________________________________________________________________-->
<para>
    当处理没有副作用的函数时，查询规划器有更多的灵活性。这类函数被称为<literal>LEAKPROOF</literal>，并且包括很多简单常用的操作符，例如很多等于操作符。查询规划器可以安全地允许这类函数在查询执行过程中的任何点被计算，因为在用户不可见的行上调用它们将不会泄露关于不可见行的任何信息。更进一步，不接收参数或者不从安全屏障视图得到任何参数的函数不必被标记为<literal>LEAKPROOF</literal>以便被下推，因为它们从来不会从该视图接收数据。相反，一个可能会基于接收到的参数值抛出错误的函数（例如在溢出或被零除事件中抛出错误的函数）不是防泄漏的，并且如果它被应用在安全性视图的行过滤器之前，它可能会提供有关不可见行的有效信息。
</para>

<!--==========================orignal english content==========================
<para>
    It is important to understand that even a view created with the
    <literal>security_barrier</literal> option is intended to be secure only
    in the limited sense that the contents of the invisible tuples will not be
    passed to possibly-insecure functions.  The user may well have other means
    of making inferences about the unseen data; for example, they can see the
    query plan using <command>EXPLAIN</command>, or measure the run time of
    queries against the view.  A malicious attacker might be able to infer
    something about the amount of unseen data, or even gain some information
    about the data distribution or most common values (since these things may
    affect the run time of the plan; or even, since they are also reflected in
    the optimizer statistics, the choice of plan).  If these types of "covert
    channel" attacks are of concern, it is probably unwise to grant any access
    to the data at all.
</para>
____________________________________________________________________________-->
<para>
    有一点很重要的是理解：即使一个视图使用<literal>security_barrier</literal>选项创建，它也只在不可见元组不会被传递给可能不安全的函数的前提下才是安全的。用户可能也有其他方式来推断不可见数据；例如，他们可以使用<command>EXPLAIN</command>看到查询计划，或者针对视图来测量查询的运行时间。一个恶意攻击者可能有能力推断有关不可见数据的总量，或者甚至得到有关数据分布的某些信息或最常用值（因为这些东西可以影响计划的运行时间；或者甚至计划的选择，因为它们也被反映在优化器的统计数据中）。如果这类“隐通道”攻击很重要，那么授予任何到该数据的访问都可能是不明智的。
</para>
</sect1>

<sect1 id="rules-status">
<!--==========================orignal english content==========================
<title>Rules and Command Status</title>
____________________________________________________________________________-->
<title>规则和命令状态</title>

<!--==========================orignal english content==========================
<para>
    The <productname>PostgreSQL</productname> server returns a command
    status string, such as <literal>INSERT 149592 1</literal>, for each
    command it receives.  This is simple enough when there are no rules
    involved, but what happens when the query is rewritten by rules?
</para>
____________________________________________________________________________-->
<para>
    <productname>PostgreSQL</productname>服务器为它收到的每个命令返回一个命令状态字符串，例如<literal>INSERT 149592 1</literal>。没有涉及规则时这很简单，但是查询被规则重写时会发生什么呢？
</para>

<!--==========================orignal english content==========================
<para>
    Rules affect the command status as follows:

    <itemizedlist>
     <listitem>
      <para>
       If there is no unconditional <literal>INSTEAD</literal> rule for the query, then
       the originally given query will be executed, and its command
       status will be returned as usual.  (But note that if there were
       any conditional <literal>INSTEAD</literal> rules, the negation of their qualifications
       will have been added to the original query.  This might reduce the
       number of rows it processes, and if so the reported status will
       be affected.)
      </para>
     </listitem>

     <listitem>
      <para>
       If there is any unconditional <literal>INSTEAD</literal> rule for the query, then
       the original query will not be executed at all.  In this case,
       the server will return the command status for the last query
       that was inserted by an <literal>INSTEAD</literal> rule (conditional or
       unconditional) and is of the same command type
       (<command>INSERT</command>, <command>UPDATE</command>, or
       <command>DELETE</command>) as the original query.  If no query
       meeting those requirements is added by any rule, then the
       returned command status shows the original query type and
       zeroes for the row-count and OID fields.
      </para>
     </listitem>
    </itemizedlist>
</para>
____________________________________________________________________________-->
<para>
    规则对命令状态的影响如下：

    <itemizedlist>
     <listitem>
      <para>
       如果没有查询的无条件<literal>INSTEAD</literal>规则，那么原始给出的查询将会被执行，并且它的命令状态将像平常一样被返回（但是请注意如果存在任何有条件<literal>INSTEAD</literal>规则，那么它们的反条件将被加到原始查询中。这样可能会减少它处理的行数，并且报告的状态将受影响）。
      </para>
     </listitem>

     <listitem>
      <para>
       如果有查询的任何无条件<literal>INSTEAD</literal>规则，那么原始查询将完全不被执行。在这种情况下，服务器将返回由服务器将返回由<literal>INSTEAD</literal>规则（有条件的或无条件的）插入的最后一条和原始查询命令类型（<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>）相同的查询的命令状态。如果任何规则添加的查询都不符合这些要求，那么返回的命令状态显示原始查询类型并且行计数和 OID 域为零。
      </para>
     </listitem>
    </itemizedlist>

</para>

<!--==========================orignal english content==========================
<para>
    The programmer can ensure that any desired <literal>INSTEAD</literal> rule is the one
    that sets the command status in the second case, by giving it the
    alphabetically last rule name among the active rules, so that it
    gets applied last.
</para>
____________________________________________________________________________-->
<para>
    通过为任何想要的<literal>INSTEAD</literal>规则指定在活动规则中排名最后的规则名，程序员可以确保该规则都是在第二种情况里设置命令状态的规则，因为它会被最后一个应用。
</para>
</sect1>

<sect1 id="rules-triggers">
<!--==========================orignal english content==========================
<title>Rules Versus Triggers</title>
____________________________________________________________________________-->
<title>规则 vs 触发器</title>

<!--==========================orignal english content==========================
<indexterm zone="rules-triggers">
 <primary>rule</primary>
 <secondary sortas="Trigger">compared with triggers</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-triggers">
 <primary>规则</primary>
 <secondary sortas="Trigger">与触发器比较</secondary>
</indexterm>

<!--==========================orignal english content==========================
<indexterm zone="rules-triggers">
 <primary>trigger</primary>
 <secondary sortas="Regeln">compared with rules</secondary>
</indexterm>
____________________________________________________________________________-->
<indexterm zone="rules-triggers">
 <primary>触发器</primary>
 <secondary sortas="Regeln">与规则比较</secondary>
</indexterm>

<!--==========================orignal english content==========================
<para>
    Many things that can be done using triggers can also be
    implemented using the <productname>PostgreSQL</productname>
    rule system.  One of the things that cannot be implemented by
    rules are some kinds of constraints, especially foreign keys. It is possible
    to place a qualified rule that rewrites a command to <literal>NOTHING</literal>
    if the value of a column does not appear in another table.
    But then the data is silently thrown away and that's
    not a good idea. If checks for valid values are required,
    and in the case of an invalid value an error message should
    be generated, it must be done by a trigger.
</para>
____________________________________________________________________________-->
<para>
    许多触发器可以干的事情同样也可以用<productname>PostgreSQL</productname>规则系统来实现。目前不能用规则来实现的东西之一是某些约束，特别是外键。 可以放置一个合格的规则在一列上，这个规则在列的值没有出现在另一个表中时把命令重写成<literal>NOTHING</literal>。但是这样做数据就会被不声不响地丢弃，因此也不是一个好主意。如果要求检查值的有效性，并且在出现无效值的情况下应该生成一个错误消息，这种需求就必须要用触发器来完成。
</para>

<!--==========================orignal english content==========================
<para>
    In this chapter, we focused on using rules to update views. All of
    the update rule examples in this chapter can also be implemented
    using <literal>INSTEAD OF</literal> triggers on the views.  Writing such
    triggers is often easier than writing rules, particularly if complex
    logic is required to perform the update.
</para>
____________________________________________________________________________-->
<para>
    在本章中，我们关注于使用规则来更新视图。本章中所有的更新规则的例子都可以使用视图上的<literal>INSTEAD OF</literal>触发器来实现。编写这类触发器通常比编写规则要容易，特别是在要求使用复杂逻辑来执行更新的情况下。
</para>

<!--==========================orignal english content==========================
<para>
    For the things that can be implemented by both, which is best
    depends on the usage of the database.
    A trigger is fired once for each affected row. A rule modifies
    the query or generates an additional query. So if many
    rows are affected in one statement, a rule issuing one extra
    command is likely to be faster than a trigger that is
    called for every single row and must re-determine what to do
    many times.  However, the trigger approach is conceptually far
    simpler than the rule approach, and is easier for novices to get right.
</para>
____________________________________________________________________________-->
<para>
    对于两者都可实现的情况，哪个更好取决于对数据库的使用。触发器为每一个受影响的行都执行一次。规则修改查询树或生成一个额外的查询。所以如果在一个语句中影响到很多行， 一个发出额外查询的规则通常可能会比一个触发器快，因为触发器对每一个行都要被调用，并且每次被调用时都需要重新判断要做什么样的操作。不过，触发器方法从概念上要远比规则方法简单，并且很容易让新人上手。
</para>

<!--==========================orignal english content==========================
<para>
    Here we show an example of how the choice of rules versus triggers
    plays out in one situation.  There are two tables:

<programlisting>
CREATE TABLE computer (
    hostname        text,    -&minus; indexed
    manufacturer    text     -&minus; indexed
);

CREATE TABLE software (
    software        text,    -&minus; indexed
    hostname        text     -&minus; indexed
);
</programlisting>

    Both tables have many thousands of rows and the indexes on
    <structfield>hostname</structfield> are unique.  The rule or trigger should
    implement a constraint that deletes rows from <literal>software</literal>
    that reference a deleted computer.  The trigger would use this command:

<programlisting>
DELETE FROM software WHERE hostname = $1;
</programlisting>

    Since the trigger is called for each individual row deleted from
    <literal>computer</literal>, it can prepare and save the plan for this
    command and pass the <structfield>hostname</structfield> value in the
    parameter.  The rule would be written as:

<programlisting>
CREATE RULE computer_del AS ON DELETE TO computer
    DO DELETE FROM software WHERE hostname = OLD.hostname;
</programlisting>
   </para>
____________________________________________________________________________-->
<para>
    下面我们展示一个例子，该例子说明了在同种情况下两种选择的比较。这里有两个表：

<programlisting>
CREATE TABLE computer (
    hostname        text,    -- 被索引
    manufacturer    text     -- 被索引
);

CREATE TABLE software (
    software        text,    -- 被索引
    hostname        text     -- 被索引
);
</programlisting>

    两个表都有数千行，并且在<structfield>hostname</structfield>上的索引是唯一的。规则或触发器应该实现一个约束，该约束从<literal>software</literal>中删除引用已删除计算机的行。 触发器可以用下面这条命令：

<programlisting>
DELETE FROM software WHERE hostname = $1;
</programlisting>

    因为触发器会为每一个从<literal>computer</literal>中删除的独立行调用一次， 那么它可以准备并且保存这个命令的规划，把<structfield>hostname</structfield>作为参数传入。规则应该被写为：

<programlisting>
CREATE RULE computer_del AS ON DELETE TO computer
    DO DELETE FROM software WHERE hostname = OLD.hostname;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Now we look at different types of deletes. In the case of a:

<programlisting>
DELETE FROM computer WHERE hostname = 'mypc.local.net';
</programlisting>

    the table <literal>computer</literal> is scanned by index (fast), and the
    command issued by the trigger would also use an index scan (also fast).
    The extra command from the rule would be:

<programlisting>
DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                       AND software.hostname = computer.hostname;
</programlisting>

    Since there are appropriate indexes set up, the planner
    will create a plan of

<literallayout class="monospaced">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</literallayout>

    So there would be not that much difference in speed between
    the trigger and the rule implementation.
   </para>
____________________________________________________________________________-->
   <para>
    现在看看不同类型的删除。在这种情况：

<programlisting>
DELETE FROM computer WHERE hostname = 'mypc.local.net';
</programlisting>

    表<literal>computer</literal>被使用索引（快速）扫描，并且由触发器发出的命令也将使用一个索引扫描（同样快速）。来自规则的额外查询应该是：

<programlisting>
DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                       AND software.hostname = computer.hostname;
</programlisting>

    由于已经建立了合适的索引，规划器将创建一个规划

<literallayout class="monospaced">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</literallayout>

    所以在触发器和规则的实现之间没有太多的速度差别。
   </para>

<!--==========================orignal english content==========================
   <para>
    With the next delete we want to get rid of all the 2000 computers
    where the <structfield>hostname</structfield> starts with
    <literal>old</literal>. There are two possible commands to do that. One
    is:

<programlisting>
DELETE FROM computer WHERE hostname &gt;= 'old'
                       AND hostname &lt;  'ole'
</programlisting>

    The command added by the rule will be:

<programlisting>
DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'
                       AND software.hostname = computer.hostname;
</programlisting>

    with the plan

<literallayout class="monospaced">
Hash Join
  -&gt;  Seq Scan on software
  -&gt;  Hash
    -&gt;  Index Scan using comp_hostidx on computer
</literallayout>

    The other possible command is:

<programlisting>
DELETE FROM computer WHERE hostname ~ '^old';
</programlisting>

    which results in the following executing plan for the command
    added by the rule:

<literallayout class="monospaced">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</literallayout>

    This shows, that the planner does not realize that the
    qualification for <structfield>hostname</structfield> in
    <literal>computer</literal> could also be used for an index scan on
    <literal>software</literal> when there are multiple qualification
    expressions combined with <literal>AND</literal>, which is what it does
    in the regular-expression version of the command. The trigger will
    get invoked once for each of the 2000 old computers that have to be
    deleted, and that will result in one index scan over
    <literal>computer</literal> and 2000 index scans over
    <literal>software</literal>. The rule implementation will do it with two
    commands that use indexes.  And it depends on the overall size of
    the table <literal>software</literal> whether the rule will still be faster in the
    sequential scan situation. 2000 command executions from the trigger over the SPI
    manager take some time, even if all the index blocks will soon be in the cache.
</para>
____________________________________________________________________________-->
   <para>
    在接下来的删除中，我们想要去掉所有 2000 个<structfield>hostname</structfield>以<literal>old</literal>开头的计算机。有两个命令可以来做这件事。一个是：

<programlisting>
DELETE FROM computer WHERE hostname &gt;= 'old'
                       AND hostname &lt;  'ole'
</programlisting>

    被规则增加的命令将是：

<programlisting>
DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'
                       AND software.hostname = computer.hostname;
</programlisting>

    计划是：

<literallayout class="monospaced">
Hash Join
  -&gt;  Seq Scan on software
  -&gt;  Hash
    -&gt;  Index Scan using comp_hostidx on computer
</literallayout>

    另一个可能的命令是：

<programlisting>
DELETE FROM computer WHERE hostname ~ '^old';
</programlisting>

    它会为规划增加的命令产生下面的执行计划：

<literallayout class="monospaced">
Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</literallayout>

    这表明，当有多个条件表达式被使用<literal>AND</literal>组合在一起时，规划器不能认识到表<literal>computer</literal>中<structfield>hostname</structfield>上的条件也可以被用于一个<literal>software</literal>上的索引扫描， 而在该命令的正则表达式版本中正是这样做的。触发器将为要被删除的 2000 个旧计算机中的每一个调用，并且会导致在<literal>computer</literal>上的一次索引扫描和<literal>software</literal>上的 2000 次索引扫描。采用规则的实现将会使用两个使用索引的命令来完成。 并且在顺序扫描情况下规则是否仍将更快是取决于<literal>software</literal>表的总体大小的。即使所有的索引块都将很快地进入高速缓存，通过 SPI 管理器执行来自触发器的 2000 个命令也要花不少时间。 
</para>

<!--==========================orignal english content==========================
<para>
    The last command we look at is:

<programlisting>
DELETE FROM computer WHERE manufacturer = 'bim';
</programlisting>

    Again this could result in many rows to be deleted from
    <literal>computer</literal>. So the trigger will again run many commands
    through the executor.  The command generated by the rule will be:

<programlisting>
DELETE FROM software WHERE computer.manufacturer = 'bim'
                       AND software.hostname = computer.hostname;
</programlisting>

    The plan for that command will again be the nested loop over two
    index scans, only using a different index on <literal>computer</literal>:

<programlisting>
Nestloop
  -&gt;  Index Scan using comp_manufidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</programlisting>

    In any of these cases, the extra commands from the rule system
    will be more or less independent from the number of affected rows
    in a command.
</para>
____________________________________________________________________________-->
<para>
    我们要看的最后一个命令是：

<programlisting>
DELETE FROM computer WHERE manufacturer = 'bim';
</programlisting>

    同样，这也会导致很多行被从<literal>computer</literal>中删除。所以触发器同样会通过执行器运行很多命令。规则生成的命令将会是：

<programlisting>
DELETE FROM software WHERE computer.manufacturer = 'bim'
                       AND software.hostname = computer.hostname;
</programlisting>

    这个命令的计划又将是在两个索引扫描上的嵌套循环，只不过使用了<literal>computer</literal>上的另一个索引：

<programlisting>
Nestloop
  -&gt;  Index Scan using comp_manufidx on computer
  -&gt;  Index Scan using soft_hostidx on software
</programlisting>

    在任何这些情况之一，来自规则系统的额外命令都或多或少与命令中影响的行数无关。
</para>

<!-- What's happening with this?  If it doesn't come back, remove this section. -->
<!--
<para>
    另一种情况与<command>UPDATE</command>有关，其中一个动作是否被执行取决于一个属性上的修改。要像 shoelace_log 例子中创建一个规则的唯一方法是使用一个规则条件。这会导致一个总是被执行的额外查询，即使关注的属性因为没有出现在初始查询的目标列表中而没有改变。当启用这种方式后，规则又比触发器多出一个优势。在这种情况中一个触发器的优化必定会因为其定义而失败，因为“它的动作只有当指定属性被更新时才被执行”这一事实是被隐藏在它的功能中的。一个触发器的定义只允许在行级别上指定它，因此无论何时一个行被更新，该触发器必须被调用来做其决定。规则系统将通过查看目标列表来知道这一情况，并且在属性没有被更新的情况下可以完全抑制额外的查询。因此规则（不管有没有条件）将只在需要做某事的时候才执行其扫描。
</para>
-->

<!--==========================orignal english content==========================
<para>
    The summary is, rules will only be significantly slower than
    triggers if their actions result in large and badly qualified
    joins, a situation where the planner fails.
</para>
____________________________________________________________________________-->
<para>
    概括来说，规则只有在其动作导致了大而且糟糕的条件连接时才会明显地慢于触发器，这种情况下规划器将没有什么办法。
</para>
</sect1>

</chapter>
