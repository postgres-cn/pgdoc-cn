<!-- doc/src/sgml/datetime.sgml -->

 <appendix id="datetime-appendix">
<!--==========================orignal english content==========================
  <title>Date/Time Support</title>
____________________________________________________________________________-->
  <title>日期/时间支持</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> uses an internal heuristic
   parser for all date/time input support. Dates and times are input as
   strings, and are broken up into distinct fields with a preliminary
   determination of what kind of information can be in the
   field. Each field is interpreted and either assigned a numeric
   value, ignored, or rejected.
   The parser contains internal lookup tables for all textual fields,
   including months, days of the week, and time zones.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>使用一个内部的启发式解析器来进行所有日期/时间输入的支持。日期和时间被作为字符串输入，并且被分解为不同的域，这些域都已经预定义好了要存放哪一类信息。每个域会被解释并且被分配一个数字值或者被忽略、拒绝。该解析器为所有的文本形式的域都包含了内部查找表，包括月份、一周中的日和时区。
  </para>

<!--==========================orignal english content==========================
  <para>
   This appendix includes information on the content of these
   lookup tables and describes the steps used by the parser to decode
   dates and times.
  </para>
____________________________________________________________________________-->
  <para>
   这个附录包括这些查找表内容的信息并且描述了解析器解码日期和时间所用的步骤。
  </para>

  <sect1 id="datetime-input-rules">
<!--==========================orignal english content==========================
   <title>Date/Time Input Interpretation</title>
____________________________________________________________________________-->
   <title>日期/时间输入解释</title>

<!--==========================orignal english content==========================
   <para>
    Date/time input strings are decoded using the following procedure.
   </para>
____________________________________________________________________________-->
   <para>
    日期/时间类型输入使用下面的过程解码。
   </para>

   <procedure>
    <step>
<!--==========================orignal english content==========================
     <para>
      Break the input string into tokens and categorize each token as
      a string, time, time zone, or number.
     </para>
____________________________________________________________________________-->
     <para>
      将输入字符串打断成记号并且把每一个记号分类为一个字符串、时间、时区或数字。
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        If the numeric token contains a colon (<literal>:</literal>), this is
        a time string. Include all subsequent digits and colons.
       </para>
____________________________________________________________________________-->
       <para>
        如果数字记号包含一个分号（<literal>:</literal>），那么这是一个时间字符串。包括所有后续数位和分号。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the numeric token contains a dash (<literal>-</literal>), slash
        (<literal>/</literal>), or two or more dots (<literal>.</literal>), this is
        a date string which might have a text month.  If a date token has
        already been seen, it is instead interpreted as a time zone
        name (e.g., <literal>America/New_York</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果数字记号包含一个连字符（<literal>-</literal>）、斜线（<literal>/</literal>）或两个以上的句点（<literal>.</literal>），那么这是一个日期字符串，它可能含有一个文本形式的月份。如果一个日期记号已经被看到，它会转而被解释为一个时区名（例如<literal>America/New_York</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token is numeric only, then it is either a single field
        or an ISO 8601 concatenated date (e.g.,
        <literal>19990113</literal> for January 13, 1999) or time
        (e.g., <literal>141516</literal> for 14:15:16).
       </para>
____________________________________________________________________________-->
       <para>
        如果记号只是数字，那么它要么是一个单一域，要么是一个 ISO 8601 串连日期（例如 1999年1月13日是<literal>19990113</literal>）或时间（例如 14:15:16 是<literal>141516</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token starts with a plus (<literal>+</literal>) or minus
        (<literal>-</literal>), then it is either a numeric time zone or a special
        field.
       </para>
____________________________________________________________________________-->
       <para>
        如果记号以一个加号（<literal>+</literal>）或减号（<literal>-</literal>）开始，那么它要么是一个数字的时区，要么是一个特殊域。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If the token is an alphabetic string, match up with possible strings:
     </para>
____________________________________________________________________________-->
     <para>
      如果记号是一个字母字符串，使之匹配可能的串：
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        See if the token matches any known time zone abbreviation.
        These abbreviations are supplied by the configuration file
        described in <xref linkend="datetime-config-files"/>.
       </para>
____________________________________________________________________________-->
       <para>
        查看记号是否与任何已知的时区缩写匹配。
       这些缩写由在<xref linkend ="datetime-config-files"/>中描述的配置文件提供。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If not found, search an internal table to match
        the token as either a special string (e.g., <literal>today</literal>),
        day (e.g., <literal>Thursday</literal>),
        month (e.g., <literal>January</literal>),
        or noise word (e.g., <literal>at</literal>, <literal>on</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果没有找到，搜索一个内部表来查找将该记号是否匹配为一个特殊串（例如<literal>today</literal>）、日（例如<literal>Thursday</literal>）、月（例如<literal>January</literal>）或噪音词（例如<literal>at</literal>、<literal>on</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If still not found, throw an error.
       </para>
____________________________________________________________________________-->
       <para>
        如果仍然没有找到，则抛出一个错误。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      When the token is a number or number field:
     </para>
____________________________________________________________________________-->
     <para>
      当记号是一个数字或数字域时：
     </para>

     <substeps>
      <step>
<!--==========================orignal english content==========================
       <para>
        If there are eight or six digits,
        and if no other date fields have been previously read, then interpret
        as a <quote>concatenated date</quote> (e.g.,
        <literal>19990118</literal> or <literal>990118</literal>).
        The interpretation is <literal>YYYYMMDD</literal> or <literal>YYMMDD</literal>.
       </para>
____________________________________________________________________________-->
       <para>
        如果有 8 位或 6 位，并且之前没有读到其他日期域，那么解释为一个<quote>串连日期</quote>（例如<literal>19990118</literal>或<literal>990118</literal>）。翻译是<literal>YYYYMMDD</literal>或<literal>YYMMDD</literal>。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If the token is three digits
        and a year has already been read, then interpret as day of year.
       </para>
____________________________________________________________________________-->
       <para>
        如果记号是 3 位并且已经读到了一个年域，那么解释为一年中的第几日。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If four or six digits and a year has already been read, then
        interpret as a time (<literal>HHMM</literal> or <literal>HHMMSS</literal>).
       </para>
____________________________________________________________________________-->
       <para>
        如果是 4 位或 6 位并且已经读到了一个年域，那么解释为一个时间域（<literal>HHMM</literal>或<literal>HHMMSS</literal>）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        If three or more digits and no date fields have yet been found,
        interpret as a year (this forces yy-mm-dd ordering of the remaining
        date fields).
       </para>
____________________________________________________________________________-->
       <para>
        如果是 3 位或更多位并且还没有读到日期域，解释为一个年域（这会强制剩余日期域的 yy-mm-dd 顺序）。
       </para>
      </step>

      <step>
<!--==========================orignal english content==========================
       <para>
        Otherwise the date field ordering is assumed to follow the
        <varname>DateStyle</varname> setting: mm-dd-yy, dd-mm-yy, or yy-mm-dd.
        Throw an error if a month or day field is found to be out of range.
       </para>
____________________________________________________________________________-->
       <para>
        否则日期域顺序被假定为遵循<varname>DateStyle</varname>设置：mm-dd-yy、dd-mm-yy 或 yy-mm-dd。如果一个月或日域被发现超过范围，则抛出一个错误。
       </para>
      </step>
     </substeps>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If BC has been specified, negate the year and add one for
      internal storage.  (There is no year zero in the Gregorian
      calendar, so numerically 1 BC becomes year zero.)
     </para>
____________________________________________________________________________-->
     <para>
      如果已经指定了 BC ，对年求反并且加一用于内部存储（在格里高利历中没有 0 年，因此数字的 1 BC 就是 0 年）。
     </para>
    </step>

    <step>
<!--==========================orignal english content==========================
     <para>
      If BC was not specified, and if the year field was two digits in length,
      then adjust the year to four digits. If the field is less than 70, then
      add 2000, otherwise add 1900.

      <tip>
       <para>
        Gregorian years AD 1-99 can be entered by using 4 digits with leading
        zeros (e.g., <literal>0099</literal> is AD 99).
       </para>
      </tip>
     </para>
____________________________________________________________________________-->
     <para>
      如果没有指定 BC ，并且如果该年域长度为两位，那么把该年域调整为四位。如果该域小于 70，则增加 2000，否则增加 1900。

      <tip>
       <para>
        格里高利年 AD 1-99 可以使用带有前导零的 4 位形式录入（例如<literal>0099</literal>是 AD 99）。
       </para>
      </tip>
     </para>
    </step>
   </procedure>
  </sect1>

  <sect1 id="datetime-invalid-input">
<!--==========================orignal english content==========================
   <title>Handling of Invalid or Ambiguous Timestamps</title>
____________________________________________________________________________-->
   <title>处理无效或不明确的时间戳</title>

<!--==========================orignal english content==========================
   <para>
    Ordinarily, if a date/time string is syntactically valid but contains
    out-of-range field values, an error will be thrown.  For example, input
    specifying the 31st of February will be rejected.
   </para>
____________________________________________________________________________-->
   <para>
     通常，如果日期/时间字符串在语法上有效但包含
     超出范围的字段值，将引发错误。 例如，输入2月31日将被拒绝。
   </para>

<!--==========================orignal english content==========================
   <para>
    During a daylight-savings-time transition, it is possible for a
    seemingly valid timestamp string to represent a nonexistent or ambiguous
    timestamp.  Such cases are not rejected; the ambiguity is resolved by
    determining which UTC offset to apply.  For example, supposing that the
    <xref linkend="guc-timezone"/> parameter is set
    to <literal>America/New_York</literal>, consider
<programlisting>
=&gt; SELECT '2018-03-11 02:30'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-03-11 03:30:00-04
(1 row)
</programlisting>
    Because that day was a spring-forward transition date in that time zone,
    there was no civil time instant 2:30AM; clocks jumped forward from 2AM
    EST to 3AM EDT.  <productname>PostgreSQL</productname> interprets the
    given time as if it were standard time (UTC-5), which then renders as
    3:30AM EDT (UTC-4).
   </para>
____________________________________________________________________________-->
   <para>
   在夏令时转换期间，看似有效的时间戳字符串可能表示不存在或不明确的时间戳。
   这样的输入不会被拒绝;不确定性可以通过要应用哪个UTC偏移来解决。 
   例如，假设<xref linkend="guc-timezone"/>参数设置为<literal>America/New_York</literal>，请考虑
<programlisting>
=&gt; SELECT '2018-03-11 02:30'::timestamptz;
      timestamptz
------------------------
 2018-03-11 03:30:00-04
(1 row)
</programlisting>
    因为那天是那个时区的春天过渡日期，所以没有民用时间凌晨2:30; 时钟从2AM EST跳转到3AM EDT。
    <productname>PostgreSQL</productname>将给定时间解释为标准时间（UTC-5），然后呈现为3:30AM EDT（UTC-4）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Conversely, consider the behavior during a fall-back transition:
<programlisting>
=&gt; SELECT '2018-11-04 02:30'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-11-04 02:30:00-05
(1 row)
</programlisting>
    On that date, there were two possible interpretations of 2:30AM; there
    was 2:30AM EDT, and then an hour later after the reversion to standard
    time, there was 2:30AM EST.
    Again, <productname>PostgreSQL</productname> interprets the given time
    as if it were standard time (UTC-5).  We can force the matter by
    specifying daylight-savings time:
<programlisting>
=&gt; SELECT '2018-11-04 02:30 EDT'::timestamptz;
      timestamptz
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2018-11-04 01:30:00-05
(1 row)
</programlisting>
    This timestamp could validly be rendered as either 2:30 UTC-4 or
    1:30 UTC-5; the timestamp output code chooses the latter.
   </para>
____________________________________________________________________________-->
   <para>
    相反，请考虑后向过渡期间的行为:
<programlisting>
=&gt; SELECT '2018-11-04 02:30'::timestamptz;
      timestamptz
------------------------
 2018-11-04 02:30:00-05
(1 row)
</programlisting>
    在那一天，上午2:30有两种可能的解释; 2:30AM EDT，以及一小时以后，如果转换到标准时间，即2:30AM EST。
    同样，<productname>PostgreSQL</productname>将给定时间解释为标准时间（UTC-5）。
    我们可以通过指定夏令时来强行控制:
<programlisting>
=&gt; SELECT '2018-11-04 02:30 EDT'::timestamptz;
      timestamptz
------------------------
 2018-11-04 01:30:00-05
(1 row)
</programlisting>

     此时间戳可以有效地呈现为2:30 UTC-4或1:30 UTC-5; 时间戳输出代码选择后者。
   </para>

<!--==========================orignal english content==========================
   <para>
    The precise rule that is applied in such cases is that an invalid
    timestamp that appears to fall within a jump-forward daylight savings
    transition is assigned the UTC offset that prevailed in the time zone
    just before the transition, while an ambiguous timestamp that could fall
    on either side of a jump-back transition is assigned the UTC offset that
    prevailed just after the transition.  In most time zones this is
    equivalent to saying that <quote>the standard-time interpretation is
    preferred when in doubt</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    在这些情况下应用的精确规则是，出现在前向跳转的夏令时转换中的无效时间戳被分配了转换之前的时区对应的UTC偏移；
    可能落在后向跳转的两边的不确定的时间戳被分配了转换之后的时区对应的UTC偏移。
    在大多数时区，这相当于说<quote>在有疑问时，标准时间解释是首选</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    In all cases, the UTC offset associated with a timestamp can be
    specified explicitly, using either a numeric UTC offset or a time zone
    abbreviation that corresponds to a fixed UTC offset.  The rule just
    given applies only when it is necessary to infer a UTC offset for a time
    zone in which the offset varies.
   </para>
____________________________________________________________________________-->
   <para>
    在所有情况下，可以显式使用数字UTC偏移或对应于固定UTC偏移的时区缩写明确指定与时间戳关联的UTC偏移。 
    刚刚给出的规则仅在需要推断偏移量变化的时区的UTC偏移时才适用。
   </para>
  </sect1>

  <sect1 id="datetime-keywords">
<!--==========================orignal english content==========================
   <title>Date/Time Key Words</title>
____________________________________________________________________________-->
   <title>日期/时间关键词</title>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datetime-month-table"/> shows the tokens that are
    recognized as names of months.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datetime-month-table"/>展示了被识别为月份名称的记号。
   </para>

    <table id="datetime-month-table">
<!--==========================orignal english content==========================
     <title>Month Names</title>
____________________________________________________________________________-->
     <title>月份名称</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Month</entry>
        <entry>Abbreviations</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>月份</entry>
        <entry>简写</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry>January</entry>
        <entry>Jan</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>一月</entry>
        <entry>Jan</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>February</entry>
        <entry>Feb</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>二月</entry>
        <entry>Feb</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>March</entry>
        <entry>Mar</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>三月</entry>
        <entry>Mar</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>April</entry>
        <entry>Apr</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>四月</entry>
        <entry>Apr</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>May</entry>
        <entry></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>五月</entry>
        <entry></entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>June</entry>
        <entry>Jun</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>六月</entry>
        <entry>Jun</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>July</entry>
        <entry>Jul</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>七月</entry>
        <entry>Jul</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>August</entry>
        <entry>Aug</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>八月</entry>
        <entry>Aug</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>September</entry>
        <entry>Sep, Sept</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>九月</entry>
        <entry>Sep, Sept</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>October</entry>
        <entry>Oct</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十月</entry>
        <entry>Oct</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>November</entry>
        <entry>Nov</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十一月</entry>
        <entry>Nov</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry>December</entry>
        <entry>Dec</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>十二月</entry>
        <entry>Dec</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="datetime-dow-table"/> shows the tokens that are
     recognized as names of days of the week.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="datetime-dow-table"/>展示了被识别为一周内每一天的名称的记号。
    </para>

     <table id="datetime-dow-table">
<!--==========================orignal english content==========================
      <title>Day of the Week Names</title>
____________________________________________________________________________-->
      <title>一周内每一天的名称</title>
      <tgroup cols="2">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Day</entry>
         <entry>Abbreviations</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>天</entry>
         <entry>简写</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>Sunday</entry>
         <entry>Sun</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周日</entry>
         <entry>Sun</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Monday</entry>
         <entry>Mon</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周一</entry>
         <entry>Mon</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Tuesday</entry>
         <entry>Tue, Tues</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周二</entry>
         <entry>Tue, Tues</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Wednesday</entry>
         <entry>Wed, Weds</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周三</entry>
         <entry>Wed, Weds</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Thursday</entry>
         <entry>Thu, Thur, Thurs</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周四</entry>
         <entry>Thu, Thur, Thurs</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Friday</entry>
         <entry>Fri</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周五</entry>
         <entry>Fri</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Saturday</entry>
         <entry>Sat</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>周六</entry>
         <entry>Sat</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datetime-mod-table"/> shows the tokens that serve
    various modifier purposes.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datetime-mod-table"/>展示了服务于多种修饰目的的记号。
   </para>

    <table id="datetime-mod-table">
<!--==========================orignal english content==========================
     <title>Date/Time Field Modifiers</title>
____________________________________________________________________________-->
     <title>日期/时间域修饰语</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Identifier</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>标识符</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AM</literal></entry>
        <entry>Time is before 12:00</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AM</literal></entry>
        <entry>12:00 之前的时间</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>AT</literal></entry>
        <entry>Ignored</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>AT</literal></entry>
        <entry>被忽略</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>JULIAN</literal>, <literal>JD</literal>, <literal>J</literal></entry>
        <entry>Next field is Julian Date</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>JULIAN</literal>, <literal>JD</literal>, <literal>J</literal></entry>
        <entry>下一个域是儒略日期</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>ON</literal></entry>
        <entry>Ignored</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>ON</literal></entry>
        <entry>被忽略</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>PM</literal></entry>
        <entry>Time is on or after 12:00</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>PM</literal></entry>
        <entry>12:00 之后的时间</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><literal>T</literal></entry>
        <entry>Next field is time</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><literal>T</literal></entry>
        <entry>下一个域是时间</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>

  <sect1 id="datetime-config-files">
<!--==========================orignal english content==========================
  <title>Date/Time Configuration Files</title>
____________________________________________________________________________-->
  <title>日期/时间配置文件</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>time zone</primary>
    <secondary>input abbreviations</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>time zone</primary>
    <secondary>input abbreviations</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Since timezone abbreviations are not well standardized,
    <productname>PostgreSQL</productname> provides a means to customize
    the set of abbreviations accepted by the server.  The
    <xref linkend="guc-timezone-abbreviations"/> run-time parameter
    determines the active set of abbreviations.  While this parameter
    can be altered by any database user, the possible values for it
    are under the control of the database administrator &mdash; they
    are in fact names of configuration files stored in
    <filename>.../share/timezonesets/</filename> of the installation directory.
    By adding or altering files in that directory, the administrator
    can set local policy for timezone abbreviations.
   </para>
____________________________________________________________________________-->
   <para>
    因为时区缩写并未被很好地标准化，<productname>PostgreSQL</productname>提供了一种方法来自定义服务器所接受的缩写集合。<xref linkend="guc-timezone-abbreviations"/>运行时参数决定活动的缩写集合。虽然这个参数可以被任何数据库用户修改，但它的可能值是受到数据库管理员的控制的 &mdash; 它们实际上是存储在安装目录的<filename>.../share/timezonesets/</filename>子目录中的一些配置文件。通过在那个目录中增加或修改文件，管理员可以为时区缩写设定本地策略。
   </para>

<!--==========================orignal english content==========================
   <para>
    <varname>timezone_abbreviations</varname> can be set to any file name
    found in <filename>.../share/timezonesets/</filename>, if the file's name
    is entirely alphabetic.  (The prohibition against non-alphabetic
    characters in <varname>timezone_abbreviations</varname> prevents reading
    files outside the intended directory, as well as reading editor
    backup files and other extraneous files.)
   </para>
____________________________________________________________________________-->
   <para>
    <varname>timezone_abbreviations</varname>可以被设置为任何在<filename>.../share/timezonesets/</filename>中可以找到的文件名，前提该文件的名字完全是字母的（<varname>timezone_abbreviations</varname>中禁止非字母字符防止从预期目录的外面读取文件以及读取编辑器的备份文件和其他外部文件）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A timezone abbreviation file can contain blank lines and comments
    beginning with <literal>#</literal>.  Non-comment lines must have one of
    these formats:

<synopsis>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable> D
<replaceable>zone_abbreviation</replaceable> <replaceable>time_zone_name</replaceable>
@INCLUDE <replaceable>file_name</replaceable>
@OVERRIDE
</synopsis>
   </para>
____________________________________________________________________________-->
   <para>
    一个时区缩写文件可以包含空行和以<literal>#</literal>开始的注释。非注释行必须具有下列格式之一：

<synopsis>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable>
<replaceable>zone_abbreviation</replaceable> <replaceable>offset</replaceable> D
<replaceable>zone_abbreviation</replaceable> <replaceable>time_zone_name</replaceable>
@INCLUDE <replaceable>file_name</replaceable>
@OVERRIDE
</synopsis>
   </para>

<!--==========================orignal english content==========================
   <para>
    A <replaceable>zone_abbreviation</replaceable> is just the abbreviation
    being defined.  An <replaceable>offset</replaceable> is an integer giving
    the equivalent offset in seconds from UTC, positive being east from
    Greenwich and negative being west.  For example, -18000 would be five
    hours west of Greenwich, or North American east coast standard time.
    <literal>D</literal> indicates that the zone name represents local
    daylight-savings time rather than standard time.
   </para>
____________________________________________________________________________-->
   <para>
    一个<replaceable>zone_abbreviation</replaceable>就是被定义的缩写。<replaceable>offset</replaceable>是一个整数，它给出以秒计的到 UTC 的等效偏移量，为正表示东起格林威治，为负表示西起格林威治。例如， -18000 表示格林威治西边的五个小时，或者北美东海岸标准时间。<literal>D</literal>指示该区域名表示本地夏令时而非标准时间。另外，还可以给出一个<replaceable>time_zone_name</replaceable>，在这种情况下会查阅该时区定义，并且会使用该时区中的缩写含义。这种替代方案只用于那些含义在历史上有变化的缩写，因为比起使用一个固定的整数值，查找该含义开销要大得多。
   </para>

<!--==========================orignal english content==========================
   <para>
    Alternatively, a <replaceable>time_zone_name</replaceable> can be given, referencing
    a zone name defined in the IANA timezone database.  The zone's definition
    is consulted to see whether the abbreviation is or has been in use in
    that zone, and if so, the appropriate meaning is used &mdash; that is,
    the meaning that was currently in use at the timestamp whose value is
    being determined, or the meaning in use immediately before that if it
    wasn't current at that time, or the oldest meaning if it was used only
    after that time.  This behavior is essential for dealing with
    abbreviations whose meaning has historically varied.  It is also allowed
    to define an abbreviation in terms of a zone name in which that
    abbreviation does not appear; then using the abbreviation is just
    equivalent to writing out the zone name.
   </para>
____________________________________________________________________________-->
   <para>
    另外，还可以给出一个<replaceable>time_zone_name</replaceable>，它引用 IANA 时区数据库中定义的时区名。这时会参考该时区的定义来判断在时区中是否有或者使用了该缩写。如果是，会使用适当的含义 &mdash; 也就是正在判断其值的时间戳中当前使用的含义，或者之前刚刚使用的含义（如果当时不是当前），或者最老的含义（如果只在那时之后用过）。这种行为对于处理其含义在历史上变化过的缩写是至关重要的。也允许按照缩写没有出现在其中的时区名来定义缩写，这样使用该缩写就等效于直接写出该时区名。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     Using a simple integer <replaceable>offset</replaceable> is preferred
     when defining an abbreviation whose offset from UTC has never changed,
     as such abbreviations are much cheaper to process than those that
     require consulting a time zone definition.
    </para>
____________________________________________________________________________-->
    <para>
     在定义其 UTC 偏移没有改变过的缩写时，使用简单的整数<replaceable>offset</replaceable>更好，这样的缩写在处理时代价比那些需要查阅时区定义的缩写更低。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    The <literal>@INCLUDE</literal> syntax allows inclusion of another file in the
    <filename>.../share/timezonesets/</filename> directory.  Inclusion can be nested,
    to a limited depth.
   </para>
____________________________________________________________________________-->
   <para>
 <literal>@INCLUDE</literal>语法允许包括<filename>.../share/timezonesets/</filename>目录中
    的其它文件。允许进行嵌套包括，但是嵌套深度有限制。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>@OVERRIDE</literal> syntax indicates that subsequent entries in the
    file can override previous entries (typically, entries obtained from
    included files).  Without this, conflicting definitions of the same
    timezone abbreviation are considered an error.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>@OVERRIDE</literal>语法表示文件中后续项可以覆盖前面的项（典型的：从被包括的文件中
    得到的项）。如果没有它，同一个时区缩写的相互冲突的定义会被认为是一种错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    In an unmodified installation, the file <filename>Default</filename> contains
    all the non-conflicting time zone abbreviations for most of the world.
    Additional files <filename>Australia</filename> and <filename>India</filename> are
    provided for those regions: these files first include the
    <literal>Default</literal> file and then add or modify abbreviations as needed.
   </para>
____________________________________________________________________________-->
   <para>
    在一个未被修改的安装中，文件<filename>Default</filename>包含用于世界大部分地区的非冲突时区缩
    写。附加文件<filename>Australia</filename>和<filename>India</filename>被提供给那些地区：这些文件
    首先会包括<literal>Default</literal>文件，并且接着根据需要增加或修改缩写。
   </para>

<!--==========================orignal english content==========================
   <para>
    For reference purposes, a standard installation also contains files
    <filename>Africa.txt</filename>, <filename>America.txt</filename>, etc, containing
    information about every time zone abbreviation known to be in use
    according to the IANA timezone database.  The zone name
    definitions found in these files can be copied and pasted into a custom
    configuration file as needed.  Note that these files cannot be directly
    referenced as <varname>timezone_abbreviations</varname> settings, because of
    the dot embedded in their names.
   </para>
____________________________________________________________________________-->
   <para>
    为了便于参考，标准安装也包含了<filename>Africa.txt</filename>、<filename>America.txt</filename>
    等文件，它们包含了所有根据IANA 时区数据库中已知正在使用的时区缩写信息。 如果需要，这些文件中的时区名定义可以复制并粘贴到自定义的配置文件中。注意这些文件名
    不能直接被<varname>timezone_abbreviations</varname>设置引用，因为它们的名称中嵌有句点。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If an error occurs while reading the time zone abbreviation set, no new
     value is applied and the old set is kept. If the error occurs while
     starting the database, startup fails.
    </para>
____________________________________________________________________________-->
    <para>
     如果在读取时区缩写集时发生错误，将不会应用任何新值并且保留旧的集合。如果该错误是在数据库
     启动时发生，那么启动将失败。
    </para>
   </note>

   <caution>
<!--==========================orignal english content==========================
    <para>
     Time zone abbreviations defined in the configuration file override
     non-timezone meanings built into <productname>PostgreSQL</productname>.
     For example, the <filename>Australia</filename> configuration file defines
     <literal>SAT</literal> (for South Australian Standard Time).  When this
     file is active, <literal>SAT</literal> will not be recognized as an abbreviation
     for Saturday.
    </para>
____________________________________________________________________________-->
    <para>
     配置文件中定义的时区缩写将会覆盖<productname>PostgreSQL</productname>中内建的非
     时区含义。例如<filename>Australia</filename>配置文件定义了<literal>SAT</literal>（南澳洲标准时
     间）。当该文件为活动时，<literal>SAT</literal>将不会被识别为周六的缩写。
    </para>
   </caution>

   <caution>
<!--==========================orignal english content==========================
    <para>
     If you modify files in <filename>.../share/timezonesets/</filename>,
     it is up to you to make backups &mdash; a normal database dump
     will not include this directory.
    </para>
____________________________________________________________________________-->
    <para>
     如果你修改<filename>.../share/timezonesets/</filename>中的文件， 那么你必须自己创建备份 &mdash; 因为通常的数据库转储不会包括这个目录。
    </para>
   </caution>

  </sect1>

  <sect1 id="datetime-units-history">
<!--==========================orignal english content==========================
  <title>History of Units</title>
____________________________________________________________________________-->
  <title>单位的历史</title>

<!--==========================orignal english content==========================
  <indexterm zone="datetime-units-history">
   <primary>Gregorian calendar</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datetime-units-history">
   <primary>格里高利历</primary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm zone="datetime-units-history">
   <primary>Julian date</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datetime-units-history">
   <primary>儒略日期</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The SQL standard states that <quote>Within the definition of a
   <quote>datetime literal</quote>, the <quote>datetime
   values</quote> are constrained by the natural rules for dates and
   times according to the Gregorian calendar</quote>.
   <productname>PostgreSQL</productname> follows the SQL
   standard's lead by counting dates exclusively in the Gregorian
   calendar, even for years before that calendar was in use.
   This rule is known as the <firstterm>proleptic Gregorian calendar</firstterm>.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 标准说到<quote>在一个<quote>日期时间文字</quote>的定义中，<quote>日期时间值</quote>根据格里高利历被日期和时间的自然规则所约束</quote>。<productname>PostgreSQL</productname>遵循 SQL 标准，导致只在格里高利历内计算日期，即使对于该历法开始使用之前的日期也是如此。这个规则被称作<firstterm>外推格里高利历</firstterm>。
  </para>

<!--==========================orignal english content==========================
  <para>
   The Julian calendar was introduced by Julius Caesar in 45 BC.
   It was in common use in the Western world
   until the year 1582, when countries started changing to the Gregorian
   calendar.  In the Julian calendar, the tropical year is
   approximated as 365 1/4 days = 365.25 days. This gives an error of
   about 1 day in 128 years.
  </para>
____________________________________________________________________________-->
  <para>
   儒略日期是由 Julius Caesar 在公元前 45 年引入的。直到 1582 年开始转为使用公历之前，西方世界一直使用儒略日期。 在儒略日期中，一回归年近似等于 365 又 1/4 天 = 365.25 天。它大约在128年中会出现 1 天的误差。
  </para>

<!--==========================orignal english content==========================
  <para>
   The accumulating calendar error prompted
   Pope Gregory XIII to reform the calendar in accordance with
   instructions from the Council of Trent.
   In the Gregorian calendar, the tropical year is approximated as
   365 + 97 / 400 days = 365.2425 days. Thus it takes approximately 3300
   years for the tropical year to shift one day with respect to the
   Gregorian calendar.
  </para>
____________________________________________________________________________-->
  <para>
   不断积累的历法错误促使教皇格里高利十三世按照特伦托会议的指示改革了历法。在格里高利历中，一回归年近似为 365 + 97/400 天 = 365.2425 天。因此对于格里高利历，大约要 3300 年一回归年才会积累一天的误差。
  </para>

<!--==========================orignal english content==========================
  <para>
   The approximation 365+97/400 is achieved by having 97 leap years
   every 400 years, using the following rules:

   <simplelist>
    <member>
     Every year divisible by 4 is a leap year.
    </member>
    <member>
     However, every year divisible by 100 is not a leap year.
    </member>
    <member>
     However, every year divisible by 400 is a leap year after all.
    </member>
   </simplelist>

   So, 1700, 1800, 1900, 2100, and 2200 are not leap years. But 1600,
   2000, and 2400 are leap years.

   By contrast, in the older Julian calendar all years divisible by 4 are leap
   years.
  </para>
____________________________________________________________________________-->
  <para>
   近似值 365+97/400 是通过利用下面的规则，并规定每 400 年有 97 个闰年实现的：

   <simplelist>
    <member>
     每个可被 4 整除的年是一个闰年。
    </member>
    <member>
     不过，可被 100 整除的年不是闰年。
    </member>
    <member>
     但是，可以被 400 整除的年还是闰年。
    </member>
   </simplelist>

   因此，1700、1800、1900、2100 和 2200 都不是闰年。而 1600、2000、2400 是闰年。相比而言，旧式的儒略历法里面只有能被4整除的年是闰年。

   相反，在旧的儒略历法中所有能被 4 整除的年都是闰年。
  </para>

<!--==========================orignal english content==========================
  <para>
   The papal bull of February 1582 decreed that 10 days should be dropped
   from October 1582 so that 15 October should follow immediately after
   4 October.
   This was observed in Italy, Poland, Portugal, and Spain. Other Catholic
   countries followed shortly after, but Protestant countries were
   reluctant to change, and the Greek Orthodox countries didn't change
   until the start of the 20th century.

   The reform was observed by Great Britain and its dominions (including what
   is now the USA) in 1752.
   Thus 2 September 1752 was followed by 14 September 1752.

   This is why Unix systems that have the <command>cal</command> program
   produce the following:

<screen>
$ <userinput>cal 9 1752</userinput>
   September 1752
 S  M Tu  W Th  F  S
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
</screen>

   But, of course, this calendar is only valid for Great Britain and
   dominions, not other places.
   Since it would be difficult and confusing to try to track the actual
   calendars that were in use in various places at various times,
   <productname>PostgreSQL</productname> does not try, but rather follows the Gregorian
   calendar rules for all dates, even though this method is not historically
   accurate.
  </para>
____________________________________________________________________________-->
  <para>
   罗马教皇在 1582 年 2 月宣布从 1582 年的 10 月中减除 10 天，这样 10 月 15 日就紧跟在 10 月 4 日的后面。意大利、波兰、葡萄牙和西班牙遵守了这个要求。其他天主教的国家也紧跟它们的步伐。但新教国家拒绝改变，而希腊东正教国家却一直拖延到 20 世纪开始时才逐渐遵守这个规定。

   大英帝国及其殖民地（包含今天的美国）在 1752 年开始遵守这项改革。因此 1752 年 9 月 2 日之后紧跟着 14 日。

   这就是为什么 Unix 系统上的<command>cal</command>程序 会产生如下输出的原因：

<screen>
$ <userinput>cal 9 1752</userinput>
   September 1752
 S  M Tu  W Th  F  S
       1  2 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
</screen>

   不过，这种历法只对大英帝国及其殖民地有效，对其他地方无效。因为尝试在多个地方多个时刻使用的实际历法很难并且也很让人困惑，<productname>PostgreSQL</productname>并没有做这种尝试，而是对所有日期遵循格里高利历规则，即使该方法在历史上是不精确的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Different calendars have been developed in various parts of the
   world, many predating the Gregorian system.

   For example,
   the beginnings of the Chinese calendar can be traced back to the 14th
   century BC. Legend has it that the Emperor Huangdi invented that
   calendar in 2637 BC.

   The People's Republic of China uses the Gregorian calendar
   for civil purposes. The Chinese calendar is used for determining
   festivals.
  </para>
____________________________________________________________________________-->
  <para>
   在世界的多个地方，发展了不同的历法，很多比格里高利系统还早。

   例如，中国历法的开端可以追溯到公元前 14 世纪。传说黄帝在公元前 2637 年就发明了这个历法。

   中华人民共和国把格里高利历作为民用。中国历法则被用于决定节日/节气。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <firstterm>Julian Date</firstterm> system is another type of
   calendar, unrelated to the Julian calendar though it is confusingly
   named similarly to that calendar.
   The Julian Date system was invented by the French scholar
   Joseph Justus Scaliger (1540-1609)
   and probably takes its name from Scaliger's father,
   the Italian scholar Julius Caesar Scaliger (1484-1558).
   In the Julian Date system, each day has a sequential number, starting
   from JD 0 (which is sometimes called <emphasis>the</emphasis> Julian Date).
   JD 0 corresponds to 1 January 4713 BC in the Julian calendar, or
   24 November 4714 BC in the Gregorian calendar.  Julian Date counting
   is most often used by astronomers for labeling their nightly observations,
   and therefore a date runs from noon UTC to the next noon UTC, rather than
   from midnight to midnight: JD 0 designates the 24 hours from noon UTC on
   24 November 4714 BC to noon UTC on 25 November 4714 BC.
  </para>
____________________________________________________________________________-->
  <para>
   <firstterm>儒略日期</firstterm>不是另一种类型的历法，虽然在命名上很相似，但是它和儒略历法无关。儒略日期系统是法国学者 Joseph Justus Scaliger（1540-1609）（可能是取自其父亲的名字，即意大利学者 Julius Caesar Scaliger（1484-1558））发明的。 在儒略日期系统中，每天都有一个序数，从 JD 0 开始（有时被叫做<emphasis>那个</emphasis>儒略日期）。 JD 0 在儒略历法中对应公元前 4713 年 1 月 1 日，或者在格里高利历中对应公元前 4714 年 12 月 24 日。儒略日期计数经常被天文学家用来标注夜间观测，并且因此一个日期就是从一个正午 UTC 到下一个正午 UTC，而不是从午夜到另一个午夜：JD 0 设计的 24 小时是从公元前 4714 年 12 月 24 日的正午 UTC 到公元前 4714 年 12 月 25 日的正午 UTC。
  </para>

<!--==========================orignal english content==========================
  <para>
   Although <productname>PostgreSQL</productname> supports Julian Date notation for
   input and output of dates (and also uses Julian dates for some internal
   datetime calculations), it does not observe the nicety of having dates
   run from noon to noon.  <productname>PostgreSQL</productname> treats a Julian Date
   as running from midnight to midnight.
  </para>
____________________________________________________________________________-->
  <para>
   尽管<productname>PostgreSQL</productname>在输入输出日期时支持儒略日期符号（并且也用在一些内部的日期时间计算上使用儒略日期），它不遵守从正午到正午。<productname>PostgreSQL</productname>把儒略日期当作是从午夜到午夜。
  </para>

 </sect1>
</appendix>
