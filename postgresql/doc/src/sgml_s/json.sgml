<!-- doc/src/sgml/json.sgml -->

<sect1 id="datatype-json">
<!--==========================orignal english content==========================
 <title><acronym>JSON</acronym> Types</title>
____________________________________________________________________________-->
 <title><acronym>JSON</acronym> 类型</title>

<!--==========================orignal english content==========================
 <indexterm zone="datatype-json">
  <primary>JSON</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="datatype-json">
  <primary>JSON</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="datatype-json">
  <primary>JSONB</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="datatype-json">
  <primary>JSONB</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  JSON data types are for storing JSON (JavaScript Object Notation)
  data, as specified in <ulink url="https://tools.ietf.org/html/rfc7159">RFC
  7159</ulink>. Such data can also be stored as <type>text</type>, but
  the JSON data types have the advantage of enforcing that each
  stored value is valid according to the JSON rules.  There are also
  assorted JSON-specific functions and operators available for data stored
  in these data types; see <xref linkend="functions-json"/>.
 </para>
____________________________________________________________________________-->
 <para>
  根据<ulink url="https://tools.ietf.org/html/rfc7159">RFC 7159</ulink>
  中的说明，JSON 数据类型是用来存储 JSON（JavaScript Object Notation）
  数据的。这种数据也可以被存储为<type>text</type>，但是 JSON 数据类型的
  优势在于能强制要求每个被存储的值符合 JSON 规则。也有很多 JSON 相关的函
  数和操作符可以用于存储在这些数据类型中的数据，见
  <xref linkend="functions-json"/>。
 </para>

<!--==========================orignal english content==========================
 <para>
  There are two JSON data types: <type>json</type> and <type>jsonb</type>.
  They accept <emphasis>almost</emphasis> identical sets of values as
  input.  The major practical difference is one of efficiency.  The
  <type>json</type> data type stores an exact copy of the input text,
  which processing functions must reparse on each execution; while
  <type>jsonb</type> data is stored in a decomposed binary format that
  makes it slightly slower to input due to added conversion
  overhead, but significantly faster to process, since no reparsing
  is needed.  <type>jsonb</type> also supports indexing, which can be a
  significant advantage.
 </para>
____________________________________________________________________________-->
 <para>
  有两种 JSON 数据类型：<type>json</type> 和 <type>jsonb</type>。它们
  <emphasis>几乎</emphasis>接受完全相同的值集合作为输入。主要的实际区别之一是
  效率。<type>json</type>数据类型存储输入文本的精准拷贝，处理函数必须在每
  次执行时必须重新解析该数据。而<type>jsonb</type>数据被存储在一种分解好的
  二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是
  <type>jsonb</type>在处理时要快很多，因为不需要解析。<type>jsonb</type>也支
  持索引，这也是一个令人瞩目的优势。
 </para>

<!--==========================orignal english content==========================
 <para>
  Because the <type>json</type> type stores an exact copy of the input text, it
  will preserve semantically-insignificant white space between tokens, as
  well as the order of keys within JSON objects. Also, if a JSON object
  within the value contains the same key more than once, all the key/value
  pairs are kept.  (The processing functions consider the last value as the
  operative one.)  By contrast, <type>jsonb</type> does not preserve white
  space, does not preserve the order of object keys, and does not keep
  duplicate object keys.  If duplicate keys are specified in the input,
  only the last value is kept.
 </para>
____________________________________________________________________________-->
 <para>
  由于<type>json</type>类型存储的是输入文本的准确拷贝，其中可能会保留在语法
  上不明显的、存在于记号之间的空格，还有 JSON 对象内部的键的顺序。还有，
  如果一个值中的 JSON 对象包含同一个键超过一次，所有的键/值对都会被保留（
  处理函数会把最后的值当作有效值）。相反，<type>jsonb</type>不保留空格、不
  保留对象键的顺序并且不保留重复的对象键。如果在输入中指定了重复的键，只有
  最后一个值会被保留。
 </para>

<!--==========================orignal english content==========================
 <para>
  In general, most applications should prefer to store JSON data as
  <type>jsonb</type>, unless there are quite specialized needs, such as
  legacy assumptions about ordering of object keys.
 </para>
____________________________________________________________________________-->
 <para>
  通常，除非有特别特殊的需要（例如遗留的对象键顺序假设），大多数应用应该
  更愿意把 JSON 数据存储为<type>jsonb</type>。
 </para>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> allows only one character set
  encoding per database.  It is therefore not possible for the JSON
  types to conform rigidly to the JSON specification unless the database
  encoding is UTF8. Attempts to directly include characters that
  cannot be represented in the database encoding will fail; conversely,
  characters that can be represented in the database encoding but not
  in UTF8 will be allowed.
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>对每个数据库只允许一种
  字符集编码。因此 JSON 类型不可能严格遵守 JSON 规范，除非数据库编码
  是 UTF8。尝试直接包括数据库编码中无法表示的字符将会失败。反过来，能
  在数据库编码中表示但是不在 UTF8 中的字符是被允许的。
 </para>

<!--==========================orignal english content==========================
 <para>
  RFC 7159 permits JSON strings to contain Unicode escape sequences
  denoted by <literal>\u<replaceable>XXXX</replaceable></literal>.  In the input
  function for the <type>json</type> type, Unicode escapes are allowed
  regardless of the database encoding, and are checked only for syntactic
  correctness (that is, that four hex digits follow <literal>\u</literal>).
  However, the input function for <type>jsonb</type> is stricter: it disallows
  Unicode escapes for non-ASCII characters (those above <literal>U+007F</literal>)
  unless the database encoding is UTF8.  The <type>jsonb</type> type also
  rejects <literal>\u0000</literal> (because that cannot be represented in
  <productname>PostgreSQL</productname>'s <type>text</type> type), and it insists
  that any use of Unicode surrogate pairs to designate characters outside
  the Unicode Basic Multilingual Plane be correct.  Valid Unicode escapes
  are converted to the equivalent ASCII or UTF8 character for storage;
  this includes folding surrogate pairs into a single character.
 </para>
____________________________________________________________________________-->
 <para>
  RFC 7159 允许 JSON 字符串包含<literal>\u<replaceable>XXXX</replaceable></literal>
  所标记的 Unicode 转义序列。在<type>json</type>类型的输入函数中，不管数据库
  编码如何都允许 Unicode 转义，并且只检查语法正确性（即，跟在<literal>\u</literal>
  后面的四个十六进制位）。但是，<type>jsonb</type>的输入函数更加严格：它不允
  许非 ASCII 字符的 Unicode 转义（高于<literal>U+007F</literal>的那些），除非数据
  库编码是 UTF8。<type>jsonb</type>类型也拒绝<literal>\u0000</literal>（因为
  <productname>PostgreSQL</productname>的<type>text</type>类型无法表示
  它），并且它坚持使用 Unicode 代理对来标记位于 Unicode 基本多语言平面之外
  的字符是正确的。合法的 Unicode 转义会被转换成等价的 ASCII 或 UTF8 字符进
  行存储，这包括把代理对折叠成一个单一字符。
 </para>

 <note>
<!--==========================orignal english content==========================
  <para>
   Many of the JSON processing functions described
   in <xref linkend="functions-json"/> will convert Unicode escapes to
   regular characters, and will therefore throw the same types of errors
   just described even if their input is of type <type>json</type>
   not <type>jsonb</type>. The fact that the <type>json</type> input function does
   not make these checks may be considered a historical artifact, although
   it does allow for simple storage (without processing) of JSON Unicode
   escapes in a non-UTF8 database encoding.  In general, it is best to
   avoid mixing Unicode escapes in JSON with a non-UTF8 database encoding,
   if possible.
  </para>
____________________________________________________________________________-->
  <para>
   很多<xref linkend="functions-json"/>中描述的 JSON 处理函数将把 Unicode 
   转义转换成常规字符，并且将因此抛出和刚才所描述的同样类型的错误（即使它们
   的输入是类型<type>json</type>而不是<type>jsonb</type>）。<type>json</type>的
   输入函数不做这些检查是由来已久的，不过它确实允许将 JSON Unicode 转义简单
   的（不经处理）存储在一个非 UTF8 数据库编码中。通常，最好尽可能避免在一个非 UTF8
   数据库编码的 JSON 中混入 Unicode 转义。
  </para>
 </note>

<!--==========================orignal english content==========================
 <para>
  When converting textual JSON input into <type>jsonb</type>, the primitive
  types described by <acronym>RFC</acronym> 7159 are effectively mapped onto
  native <productname>PostgreSQL</productname> types, as shown
  in <xref linkend="json-type-mapping-table"/>.
  Therefore, there are some minor additional constraints on what
  constitutes valid <type>jsonb</type> data that do not apply to
  the <type>json</type> type, nor to JSON in the abstract, corresponding
  to limits on what can be represented by the underlying data type.
  Notably, <type>jsonb</type> will reject numbers that are outside the
  range of the <productname>PostgreSQL</productname> <type>numeric</type> data
  type, while <type>json</type> will not.  Such implementation-defined
  restrictions are permitted by <acronym>RFC</acronym> 7159.  However, in
  practice such problems are far more likely to occur in other
  implementations, as it is common to represent JSON's <type>number</type>
  primitive type as IEEE 754 double precision floating point
  (which <acronym>RFC</acronym> 7159 explicitly anticipates and allows for).
  When using JSON as an interchange format with such systems, the danger
  of losing numeric precision compared to data originally stored
  by <productname>PostgreSQL</productname> should be considered.
 </para>
____________________________________________________________________________-->
 <para>
  在把文本 JSON 输入转换成<type>jsonb</type>时，<acronym>RFC</acronym> 7159描述
  的基本类型会被有效地映射到原生的
  <productname>PostgreSQL</productname>类型（如
  <xref linkend="json-type-mapping-table"/>中所示）。因此，在合法
  <type>jsonb</type>数据的组成上有一些次要额外约束，它们不适合
  <type>json</type>类型和抽象意义上的 JSON，这些约束对应于有关哪些东西不
  能被底层数据类型表示的限制。尤其是，<type>jsonb</type>将拒绝位于
  <productname>PostgreSQL</productname> <type>numeric</type>数据类型范
  围之外的数字，而<type>json</type>则不会。这类实现定义的限制是
  <acronym>RFC</acronym> 7159 所允许的。不过，实际上这类问题更可能发生在其他实
  现中，因为把 JSON 的<type>number</type>基本类型表示为 IEEE 754 双精度浮点
  是很常见的（这也是<acronym>RFC</acronym> 7159 明确期待和允许的）。当在这类系
  统间使用 JSON 作为一种交换格式时，应该考虑丢失数字精度的风险。
 </para>

<!--==========================orignal english content==========================
 <para>
  Conversely, as noted in the table there are some minor restrictions on
  the input format of JSON primitive types that do not apply to
  the corresponding <productname>PostgreSQL</productname> types.
 </para>
____________________________________________________________________________-->
 <para>
  相反地，如表中所述，有一些 JSON 基本类型输入格式上的次要限制并不适用于相
  应的<productname>PostgreSQL</productname>类型。
 </para>

  <table id="json-type-mapping-table">
<!--==========================orignal english content==========================
     <title>JSON primitive types and corresponding <productname>PostgreSQL</productname> types</title>
____________________________________________________________________________-->
     <title>JSON 基本类型和相应的<productname>PostgreSQL</productname>类型</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>JSON primitive type</entry>
        <entry><productname>PostgreSQL</productname> type</entry>
        <entry>Notes</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>JSON 基本类型</entry>
        <entry><productname>PostgreSQL</productname>类型</entry>
        <entry>注释</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>string</type></entry>
        <entry><type>text</type></entry>
        <entry><literal>\u0000</literal> is disallowed, as are non-ASCII Unicode
         escapes if database encoding is not UTF8</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>string</type></entry>
        <entry><type>text</type></entry>
        <entry>不允许<literal>\u0000</literal>，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>number</type></entry>
        <entry><type>numeric</type></entry>
        <entry><literal>NaN</literal> and <literal>infinity</literal> values are disallowed</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>number</type></entry>
        <entry><type>numeric</type></entry>
        <entry>不允许<literal>NaN</literal> 和 <literal>infinity</literal>值</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>boolean</type></entry>
        <entry><type>boolean</type></entry>
        <entry>Only lowercase <literal>true</literal> and <literal>false</literal> spellings are accepted</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>boolean</type></entry>
        <entry><type>boolean</type></entry>
        <entry>只接受小写<literal>true</literal>和<literal>false</literal>拼写</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>null</type></entry>
        <entry>(none)</entry>
        <entry>SQL <literal>NULL</literal> is a different concept</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>null</type></entry>
        <entry>(无)</entry>
        <entry>SQL <literal>NULL</literal>是一个不同的概念</entry>
       </row>
      </tbody>
     </tgroup>
   </table>

 <sect2 id="json-keys-elements">
<!--==========================orignal english content==========================
  <title>JSON Input and Output Syntax</title>
____________________________________________________________________________-->
  <title>JSON 输入和输出语法</title>
<!--==========================orignal english content==========================
  <para>
   The input/output syntax for the JSON data types is as specified in
   <acronym>RFC</acronym> 7159.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>RFC</acronym> 7159 中定义了 JSON 数据类型的输入/输出语法。
  </para>
<!--==========================orignal english content==========================
  <para>
   The following are all valid <type>json</type> (or <type>jsonb</type>) expressions:
<programlisting>
-&minus; Simple scalar/primitive value
-&minus; Primitive values can be numbers, quoted strings, true, false, or null
SELECT '5'::json;

-&minus; Array of zero or more elements (elements need not be of same type)
SELECT '[1, 2, "foo", null]'::json;

-&minus; Object containing pairs of keys and values
-&minus; Note that object keys must always be quoted strings
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-&minus; Arrays and objects can be nested arbitrarily
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   下列都是合法的<type>json</type>（或者<type>jsonb</type>）表达式：
<programlisting>
-- 简单标量/基本值
-- 基本值可以是数字、带引号的字符串、true、false或者null
SELECT '5'::json;

-- 有零个或者更多元素的数组（元素不需要为同一类型）
SELECT '[1, 2, "foo", null]'::json;

-- 包含键值对的对象
-- 注意对象键必须总是带引号的字符串
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- 数组和对象可以被任意嵌套
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   As previously stated, when a JSON value is input and then printed without
   any additional processing, <type>json</type> outputs the same text that was
   input, while <type>jsonb</type> does not preserve semantically-insignificant
   details such as whitespace.  For example, note the differences here:
<programlisting>
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json                       
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb                       
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
</programlisting>
   One semantically-insignificant detail worth noting is that
   in <type>jsonb</type>, numbers will be printed according to the behavior of the
   underlying <type>numeric</type> type.  In practice this means that numbers
   entered with <literal>E</literal> notation will be printed without it, for
   example:
<programlisting>
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb          
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
</programlisting>
   However, <type>jsonb</type> will preserve trailing fractional zeroes, as seen
   in this example, even though those are semantically insignificant for
   purposes such as equality checks.
  </para>
____________________________________________________________________________-->
  <para>
   如前所述，当一个 JSON 值被输入并且接着不做任何附加处理就输出时，
   <type>json</type>会输出和输入完全相同的文本，而<type>jsonb</type>
   则不会保留语义上没有意义的细节（例如空格）。例如，注意下面的不同：
<programlisting>
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json                       
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb                       
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
</programlisting>
   值得一提的一种语义上无意义的细节是，在<type>jsonb</type>中数据会被按照底层
   <type>numeric</type>类型的行为来打印。实际上，这意味着用<literal>E</literal>记号
   输入的数字被打印出来时就不会有该记号，例如：
<programlisting>
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb          
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
</programlisting>
   不过，如这个例子所示，<type>jsonb</type>将会保留拖尾的小数点后的零，即便这
   对于等值检查等目的来说是语义上无意义的。
  </para>
 </sect2>

 <sect2 id="json-doc-design">
<!--==========================orignal english content==========================
  <title>Designing JSON documents effectively</title>
____________________________________________________________________________-->
  <title>有效地设计 JSON 文档</title>
<!--==========================orignal english content==========================
  <para>
   Representing data as JSON can be considerably more flexible than
   the traditional relational data model, which is compelling in
   environments where requirements are fluid.  It is quite possible
   for both approaches to co-exist and complement each other within
   the same application.  However, even for applications where maximal
   flexibility is desired, it is still recommended that JSON documents
   have a somewhat fixed structure.  The structure is typically
   unenforced (though enforcing some business rules declaratively is
   possible), but having a predictable structure makes it easier to write
   queries that usefully summarize a set of <quote>documents</quote> (datums)
   in a table.
  </para>
____________________________________________________________________________-->
  <para>
   将数据表示为 JSON 比传统关系数据模型要灵活得多，在需求不固定时
   这种优势更加令人感兴趣。在同一个应用里非常有可能有两种方法共存
   并且互补。不过，即便是在要求最大灵活性的应用中，我们还是推荐
   JSON 文档有固定的结构。该结构通常是非强制的（尽管可能会强制一
   些业务规则），但是有一个可预测的结构会使书写概括一个表中的
   <quote>文档</quote>（数据）集合的查询更容易。
  </para>
<!--==========================orignal english content==========================
  <para>
   JSON data is subject to the same concurrency-control
   considerations as any other data type when stored in a table.
   Although storing large documents is practicable, keep in mind that
   any update acquires a row-level lock on the whole row.
   Consider limiting JSON documents to a
   manageable size in order to decrease lock contention among updating
   transactions.  Ideally, JSON documents should each
   represent an atomic datum that business rules dictate cannot
   reasonably be further subdivided into smaller datums that
   could be modified independently.
  </para>
____________________________________________________________________________-->
  <para>
   当被存储在表中时，JSON 数据也像其他数据类型一样服从相同的并发
   控制考虑。尽管存储大型文档是可行的，但是要记住任何更新都在整行
   上要求一个行级锁。为了在更新事务之间减少锁争夺，可考虑把 JSON
   文档限制到一个可管理的尺寸。理想情况下，JSON 文档应该每个表示
   一个原子数据，业务规则命令不会进一步把它们划分成更小的可独立修
   改的数据。
  </para>
 </sect2>

 <sect2 id="json-containment">
<!--==========================orignal english content==========================
  <title><type>jsonb</type> Containment and Existence</title>
____________________________________________________________________________-->
  <title><type>jsonb</type> 包含和存在</title>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>jsonb</primary>
    <secondary>containment</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>containment</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>jsonb</primary>
    <secondary>existence</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>existence</secondary>
  </indexterm>
<!--==========================orignal english content==========================
  <para>
    Testing <firstterm>containment</firstterm> is an important capability of
    <type>jsonb</type>.  There is no parallel set of facilities for the
    <type>json</type> type.  Containment tests whether
    one <type>jsonb</type> document has contained within it another one.
    These examples return true except as noted:
  </para>
____________________________________________________________________________-->
  <para>
    测试<firstterm>包含</firstterm>是<type>jsonb</type>的一种重要能力。对
    <type>json</type>类型没有平行的功能集。包含测试会测试一个
    <type>jsonb</type>文档是否被包含在另一个文档中。除了特别注解
    之外，这些例子都会返回真：
  </para>
<!--==========================orignal english content==========================
<programlisting>
-&minus; Simple scalar/primitive values contain only the identical value:
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-&minus; The array on the right side is contained within the one on the left:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-&minus; Order of array elements is not significant, so this is also true:
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-&minus; Duplicate array elements don't matter either:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-&minus; The object with a single pair on the right side is contained
-&minus; within the object on the left side:
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-&minus; The array on the right side is <emphasis>not</emphasis> considered contained within the
-&minus; array on the left, even though a similar array is nested within it:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -&minus; yields false

-&minus; But with a layer of nesting, it is contained:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-&minus; Similarly, containment is not reported here:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -&minus; yields false

-&minus; A top-level key and an empty object is contained:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- 简单的标量/基本值只包含相同的值：
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-- 右边的数字被包含在左边的数组中：
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-- 数组元素的顺序没有意义，因此这个例子也返回真：
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-- 重复的数组元素也没有关系：
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-- 右边具有一个单一键值对的对象被包含在左边的对象中：
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-- 右边的数组<emphasis>不</emphasis>会被认为包含在左边的数组中，
-- 即使其中嵌入了一个相似的数组：
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- 得到假

-- 但是如果同样也有嵌套，包含就成立：
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-- 类似的，这个例子也不会被认为是包含：
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"bar": "baz"}'::jsonb;  -- 得到假

-- 包含一个顶层键和一个空对象：
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   The general principle is that the contained object must match the
   containing object as to structure and data contents, possibly after
   discarding some non-matching array elements or object key/value pairs
   from the containing object.
   But remember that the order of array elements is not significant when
   doing a containment match, and duplicate array elements are effectively
   considered only once.
  </para>
____________________________________________________________________________-->
  <para>
   一般原则是被包含的对象必须在结构和数据内容上匹配包含对象，这种匹配
   可以是从包含对象中丢弃了不匹配的数组元素或者对象键值对之后成立。但
   是记住做包含匹配时数组元素的顺序是没有意义的，并且重复的数组元素实
   际也只会考虑一次。
  </para>

<!--==========================orignal english content==========================
  <para>
   As a special exception to the general principle that the structures
   must match, an array may contain a primitive value:
  </para>
____________________________________________________________________________-->
  <para>
   结构必须匹配的一般原则有一种特殊情况，一个数组可以包含一个基本值：
  </para>
<!--==========================orignal english content==========================
<programlisting>
-&minus; This array contains the primitive string value:
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-&minus; This exception is not reciprocal -&minus; non-containment is reported here:
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -&minus; yields false
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- 这个数组包含基本字符串值：
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-- 反之不然，下面的例子会报告“不包含”：
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- 得到假
</programlisting>

<!--==========================orignal english content==========================
  <para>
    <type>jsonb</type> also has an <firstterm>existence</firstterm> operator, which is
    a variation on the theme of containment: it tests whether a string
    (given as a <type>text</type> value) appears as an object key or array
    element at the top level of the <type>jsonb</type> value.
    These examples return true except as noted:
  </para>
____________________________________________________________________________-->
  <para>
    <type>jsonb</type>还有一个<firstterm>存在</firstterm>操作符，它是包含的一种
    变体：它测试一个字符串（以一个<type>text</type>值的形式给出）是否出
    现在<type>jsonb</type>值顶层的一个对象键或者数组元素中。除非特别注解，
    下面这些例子返回真：
  </para>
<!--==========================orignal english content==========================
<programlisting>
-&minus; String exists as array element:
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-&minus; String exists as object key:
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-&minus; Object values are not considered:
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -&minus; yields false

-&minus; As with containment, existence must match at the top level:
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -&minus; yields false

-&minus; A string is considered to exist if it matches a primitive JSON string:
SELECT '"foo"'::jsonb ? 'foo';
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- 字符串作为一个数组元素存在：
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- 字符串作为一个对象键存在：
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- 不考虑对象值：
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- 得到假

-- 和包含一样，存在必须在顶层匹配：
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- 得到假

-- 如果一个字符串匹配一个基本 JSON 字符串，它就被认为存在：
SELECT '"foo"'::jsonb ? 'foo';
</programlisting>

<!--==========================orignal english content==========================
  <para>
    JSON objects are better suited than arrays for testing containment or
    existence when there are many keys or elements involved, because
    unlike arrays they are internally optimized for searching, and do not
    need to be searched linearly.
  </para>
____________________________________________________________________________-->
  <para>
    当涉及很多键或元素时，JSON 对象比数组更适合于做包含或存在测试，
    因为它们不像数组，进行搜索时会进行内部优化，并且不需要被线性搜索。
  </para>
  
  <tip>
<!--==========================orignal english content==========================
   <para>
    Because JSON containment is nested, an appropriate query can skip
    explicit selection of sub-objects.  As an example, suppose that we have
    a <structfield>doc</structfield> column containing objects at the top level, with
    most objects containing <literal>tags</literal> fields that contain arrays of
    sub-objects.  This query finds entries in which sub-objects containing
    both <literal>"term":"paris"</literal> and <literal>"term":"food"</literal> appear,
    while ignoring any such keys outside the <literal>tags</literal> array:
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
</programlisting>
    One could accomplish the same thing with, say,
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
</programlisting>
    but that approach is less flexible, and often less efficient as well.
   </para>
____________________________________________________________________________-->
   <para>
    由于 JSON 的包含是嵌套的，因此一个恰当的查询可以跳过对子对象的显式选择。
    例如，假设我们在顶层有一个<structfield>doc</structfield>列包含着对象，大部分对象
    包含着<literal>tags</literal>域，其中有子对象的数组。这个查询会找到其中出现了
    同时包含<literal>"term":"paris"</literal>和<literal>"term":"food"</literal>的子对象
    的项，而忽略任何位于<literal>tags</literal>数组之外的这类键：
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
</programlisting>
    可以用下面的查询完成同样的事情：
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
</programlisting>
    但是后一种方法灵活性较差，并且常常也效率更低。
   </para>

<!--==========================orignal english content==========================
   <para>
    On the other hand, the JSON existence operator is not nested: it will
    only look for the specified key or array element at top level of the
    JSON value.
   </para>
____________________________________________________________________________-->
   <para>
    在另一方面，JSON 的存在操作符不是嵌套的：它将只在 JSON 值的顶层
    查找指定的键或数组元素。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
    The various containment and existence operators, along with all other
    JSON operators and functions are documented
    in <xref linkend="functions-json"/>.
  </para>
____________________________________________________________________________-->
  <para>
    <xref linkend="functions-json"/>中记录了多个包含和存在操作符，以及
    所有其他 JSON 操作符和函数。
  </para>
 </sect2>

 <sect2 id="json-indexing">
<!--==========================orignal english content==========================
  <title><type>jsonb</type> Indexing</title>
____________________________________________________________________________-->
  <title><type>jsonb</type> 索引</title>
<!--==========================orignal english content==========================
  <indexterm>
    <primary>jsonb</primary>
    <secondary>indexes on</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>indexes on</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
    GIN indexes can be used to efficiently search for
    keys or key/value pairs occurring within a large number of
    <type>jsonb</type> documents (datums).
    Two GIN <quote>operator classes</quote> are provided, offering different
    performance and flexibility trade-offs.
  </para>
____________________________________________________________________________-->
  <para>
    GIN 索引可以被用来有效地搜索在大量<type>jsonb</type>文档（数据）中出现
    的键或者键值对。提供了两种 GIN <quote>操作符类</quote>，它们在性能和灵活
    性方面做出了不同的平衡。
  </para>
<!--==========================orignal english content==========================
  <para>
    The default GIN operator class for <type>jsonb</type> supports queries with
    top-level key-exists operators <literal>?</literal>, <literal>?&amp;</literal>
    and <literal>?|</literal> operators and path/value-exists operator
    <literal>@&gt;</literal>.
    (For details of the semantics that these operators
    implement, see <xref linkend="functions-jsonb-op-table"/>.)
    An example of creating an index with this operator class is:
<programlisting>
CREATE INDEX idxgin ON api USING GIN (jdoc);
</programlisting>
    The non-default GIN operator class <literal>jsonb_path_ops</literal>
    supports indexing the <literal>@&gt;</literal> operator only.
    An example of creating an index with this operator class is:
<programlisting>
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
    <type>jsonb</type>的默认 GIN 操作符类支持使用<literal>@&gt;</literal>、
    <literal>?</literal>、<literal>?&amp;</literal>以及<literal>?|</literal>操作符的查询（这些
    操作符实现的详细语义请见<xref linkend="functions-jsonb-op-table"/>）。
    使用这种操作符类创建一个索引的例子：
<programlisting>
CREATE INDEX idxgin ON api USING gin (jdoc);
</programlisting>
    非默认的 GIN 操作符类<literal>jsonb_path_ops</literal>只支持索引
    <literal>@&gt;</literal>操作符。使用这种操作符类创建一个索引的例子：
<programlisting>
CREATE INDEX idxginp ON api USING gin (jdoc jsonb_path_ops);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
    Consider the example of a table that stores JSON documents
    retrieved from a third-party web service, with a documented schema
    definition.  A typical document is:
<programlisting>
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
</programlisting>
    We store these documents in a table named <structname>api</structname>,
    in a <type>jsonb</type> column named <structfield>jdoc</structfield>.
    If a GIN index is created on this column,
    queries like the following can make use of the index:
<programlisting>
-&minus; Find documents in which the key "company" has value "Magnafone"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
</programlisting>
    However, the index could not be used for queries like the
    following, because though the operator <literal>?</literal> is indexable,
    it is not applied directly to the indexed column <structfield>jdoc</structfield>:
<programlisting>
-&minus; Find documents in which the key "tags" contains key or array element "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
</programlisting>
    Still, with appropriate use of expression indexes, the above
    query can use an index.  If querying for particular items within
    the <literal>"tags"</literal> key is common, defining an index like this
    may be worthwhile:
<programlisting>
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));
</programlisting>
    Now, the <literal>WHERE</literal> clause <literal>jdoc -&gt; 'tags' ? 'qui'</literal>
    will be recognized as an application of the indexable
    operator <literal>?</literal> to the indexed
    expression <literal>jdoc -&gt; 'tags'</literal>.
    (More information on expression indexes can be found in <xref
    linkend="indexes-expressional"/>.)
  </para>
____________________________________________________________________________-->
  <para>
    考虑这样一个例子：一个表存储了从一个第三方 Web 服务检索到的 JSON
    文档，并且有一个模式定义。一个典型的文档：
<programlisting>
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
</programlisting>
    我们把这些文档存储在一个名为<structname>api</structname>的表的名为
    <structfield>jdoc</structfield>的<type>jsonb</type>列中。如果在这个列上创建一个
    GIN 索引，下面这样的查询就能利用该索引：
<programlisting>
-- 寻找键 "company" 有值 "Magnafone" 的文档
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
</programlisting>
    不过，该索引不能被用于下面这样的查询，因为尽管操作符<literal>?</literal>
    是可索引的，但它不能直接被应用于被索引列<structfield>jdoc</structfield>：
<programlisting>
-- 寻找这样的文档：其中的键 "tags" 包含键或数组元素 "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
</programlisting>
    但是，通过适当地使用表达式索引，上述查询也能使用一个索引。
    如果对<literal>"tags"</literal>键中的特定项的查询很常见，可能值得
    定义一个这样的索引：
<programlisting>
CREATE INDEX idxgintags ON api USING gin ((jdoc -&gt; 'tags'));
</programlisting>
    现在，<literal>WHERE</literal> 子句 <literal>jdoc -&gt; 'tags' ? 'qui'</literal>
    将被识别为可索引操作符<literal>?</literal>在索引表达式<literal>jdoc -&gt; 'tags'</literal>
    上的应用（更多有关表达式索引的信息可见<xref
    linkend="indexes-expressional"/>）。
  </para>
<!--==========================orignal english content==========================
  <para>
    Another approach to querying is to exploit containment, for example:
<programlisting>
-&minus; Find documents in which the key "tags" contains array element "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
</programlisting>
    A simple GIN index on the <structfield>jdoc</structfield> column can support this
    query.  But note that such an index will store copies of every key and
    value in the <structfield>jdoc</structfield> column, whereas the expression index
    of the previous example stores only data found under
    the <literal>tags</literal> key.  While the simple-index approach is far more
    flexible (since it supports queries about any key), targeted expression
    indexes are likely to be smaller and faster to search than a simple
    index.
  </para>
____________________________________________________________________________-->
  <para>
    另一种查询的方法是利用包含，例如：
<programlisting>
-- 寻找这样的文档：其中键 "tags" 包含数组元素 "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
</programlisting>
    <structfield>jdoc</structfield>列上的一个简单 GIN 索引就能支持这个查询。
    但是注意这样一个索引将会存储<structfield>jdoc</structfield>列中每一个键
    和值的拷贝，然而前一个例子的表达式索引只存储<literal>tags</literal>
    键下找到的数据。虽然简单索引的方法更加灵活（因为它支持有关任
    意键的查询），定向的表达式索引更小并且搜索速度比简单索引更快。
  </para>

<!--==========================orignal english content==========================
  <para>
    Although the <literal>jsonb_path_ops</literal> operator class supports
    only queries with the <literal>@&gt;</literal> operator, it has notable
    performance advantages over the default operator
    class <literal>jsonb_ops</literal>.  A <literal>jsonb_path_ops</literal>
    index is usually much smaller than a <literal>jsonb_ops</literal>
    index over the same data, and the specificity of searches is better,
    particularly when queries contain keys that appear frequently in the
    data.  Therefore search operations typically perform better
    than with the default operator class.
  </para>
____________________________________________________________________________-->
  <para>
    尽管<literal>jsonb_path_ops</literal>操作符类只支持用
    <literal>@&gt;</literal>操作符的查询，但它比起默认的操作符类
    <literal>jsonb_ops</literal>有更客观的性能优势。一个
    <literal>jsonb_path_ops</literal>索引通常也比一个相同数据上的
    <literal>jsonb_ops</literal>要小得多，并且搜索的专一性更好，特
    别是当查询包含频繁出现在该数据中的键时。因此，其上的搜索操作
    通常比使用默认操作符类的搜索表现更好。
  </para>

<!--==========================orignal english content==========================
  <para>
    The technical difference between a <literal>jsonb_ops</literal>
    and a <literal>jsonb_path_ops</literal> GIN index is that the former
    creates independent index items for each key and value in the data,
    while the latter creates index items only for each value in the
    data.
    <footnote>
     <para>
      For this purpose, the term <quote>value</quote> includes array elements,
      though JSON terminology sometimes considers array elements distinct
      from values within objects.
     </para>
    </footnote>
    Basically, each <literal>jsonb_path_ops</literal> index item is
    a hash of the value and the key(s) leading to it; for example to index
    <literal>{"foo": {"bar": "baz"}}</literal>, a single index item would
    be created incorporating all three of <literal>foo</literal>, <literal>bar</literal>,
    and <literal>baz</literal> into the hash value.  Thus a containment query
    looking for this structure would result in an extremely specific index
    search; but there is no way at all to find out whether <literal>foo</literal>
    appears as a key.  On the other hand, a <literal>jsonb_ops</literal>
    index would create three index items representing <literal>foo</literal>,
    <literal>bar</literal>, and <literal>baz</literal> separately; then to do the
    containment query, it would look for rows containing all three of
    these items.  While GIN indexes can perform such an AND search fairly
    efficiently, it will still be less specific and slower than the
    equivalent <literal>jsonb_path_ops</literal> search, especially if
    there are a very large number of rows containing any single one of the
    three index items.
  </para>
____________________________________________________________________________-->
  <para>
    <literal>jsonb_ops</literal>和<literal>jsonb_path_ops</literal> 
    GIN 索引之间的技术区别是前者为数据中的每一个键和值创建独立的索引项，
    而后者值为该数据中的每个值创建索引项。
    <footnote>
     <para>
      对于这种目的，术语<quote>值</quote>包括数组元素，尽管 JSON 的术语有时
      认为数组元素与对象内的值不同。
     </para>
    </footnote>
    基本上，每一个<literal>jsonb_path_ops</literal>索引项是其所对应的值和
    键的哈希。例如要索引<literal>{"foo": {"bar": "baz"}}</literal>，将创建一个
    单一的索引项，它把所有三个<literal>foo</literal>、<literal>bar</literal>、
    和<literal>baz</literal>合并到哈希值中。因此一个查找这个结构的包含查询可能
    导致极度详细的索引搜索。但是根本没有办法找到<literal>foo</literal>是否作为
    一个键出现。在另一方面，一个<literal>jsonb_ops</literal>会创建三个索引
    项分别表示<literal>foo</literal>、<literal>bar</literal>和<literal>baz</literal>。那么要
    做同样的包含查询，它将会查找包含所有三个项的行。虽然 GIN 索引能够相当
    有效地执行这种 AND 搜索，它仍然不如等效的
    <literal>jsonb_path_ops</literal>搜索那样详细和快速（特别是如果有大量
    行包含三个索引项中的任意一个时）。
  </para>

<!--==========================orignal english content==========================
  <para>
    A disadvantage of the <literal>jsonb_path_ops</literal> approach is
    that it produces no index entries for JSON structures not containing
    any values, such as <literal>{"a": {}}</literal>.  If a search for
    documents containing such a structure is requested, it will require a
    full-index scan, which is quite slow.  <literal>jsonb_path_ops</literal> is
    therefore ill-suited for applications that often perform such searches.
  </para>
____________________________________________________________________________-->
  <para>
    <literal>jsonb_path_ops</literal>方法的一个不足是它不会为不包含任何值
    的 JSON 结构创建索引项，例如<literal>{"a": {}}</literal>。如果需要搜索包
    含这样一种结构的文档，它将要求一次全索引扫描，那就非常慢。
    因此<literal>jsonb_path_ops</literal>不适合经常执行这类搜索的应用。
  </para>

<!--==========================orignal english content==========================
  <para>
    <type>jsonb</type> also supports <literal>btree</literal> and <literal>hash</literal>
    indexes.  These are usually useful only if it's important to check
    equality of complete JSON documents.
    The <literal>btree</literal> ordering for <type>jsonb</type> datums is seldom
    of great interest, but for completeness it is:
<synopsis>
<replaceable>Object</replaceable> > <replaceable>Array</replaceable> > <replaceable>Boolean</replaceable> > <replaceable>Number</replaceable> > <replaceable>String</replaceable> > <replaceable>Null</replaceable>

<replaceable>Object with n pairs</replaceable> > <replaceable>object with n - 1 pairs</replaceable>

<replaceable>Array with n elements</replaceable> > <replaceable>array with n - 1 elements</replaceable>
</synopsis>
      Objects with equal numbers of pairs are compared in the order:
<synopsis>
<replaceable>key-1</replaceable>, <replaceable>value-1</replaceable>, <replaceable>key-2</replaceable> ...
</synopsis>
      Note that object keys are compared in their storage order;
      in particular, since shorter keys are stored before longer keys, this
      can lead to results that might be unintuitive, such as:
<programlisting>
{ "aa": 1, "c": 1} > {"b": 1, "d": 1}
</programlisting>
      Similarly, arrays with equal numbers of elements are compared in the
      order:
<synopsis>
<replaceable>element-1</replaceable>, <replaceable>element-2</replaceable> ...
</synopsis>
      Primitive JSON values are compared using the same
      comparison rules as for the underlying
      <productname>PostgreSQL</productname> data type.  Strings are
      compared using the default database collation.
  </para>
____________________________________________________________________________-->
  <para>
    <type>jsonb</type>也支持<literal>btree</literal>和<literal>hash</literal>索引。
    这通常值用于检查完整 JSON 文档等值非常重要的场合。<type>jsonb</type>
    数据的<literal>btree</literal>顺序很少有人关系，但是为了完整性其顺序是：
<synopsis>
<replaceable>对象</replaceable> > <replaceable>数组</replaceable> > <replaceable>布尔</replaceable> > <replaceable>数字</replaceable> > <replaceable>字符串</replaceable> > <replaceable>空值</replaceable>

<replaceable>带有 n 对的对象</replaceable> > <replaceable>带有 n - 1 对的对象</replaceable>

<replaceable>带有 n 个元素的数组</replaceable> > <replaceable>带有 n - 1 个元素的数组</replaceable>
</synopsis>
      具有相同数量对的对象这样比较：
<synopsis>
<replaceable>key-1</replaceable>, <replaceable>value-1</replaceable>, <replaceable>key-2</replaceable> ...
</synopsis>
      注意对象键被按照它们的存储顺序进行比较，特别是由于较短的键被存储在
      较长的键之前，这可能导致结果不直观，例如：
<programlisting>
{ "aa": 1, "c": 1} > {"b": 1, "d": 1}
</programlisting>
      相似地，具有相同元素数量的数组按照以下顺序比较：
<synopsis>
<replaceable>element-1</replaceable>, <replaceable>element-2</replaceable> ...
</synopsis>
      基本 JSON 值的比较会使用低层<productname>PostgreSQL</productname>
      数据类型相同的比较规则进行。字符串的比较会使用默认的数据库排序规则。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Transforms</title>
____________________________________________________________________________-->
  <title>转换</title>

<!--==========================orignal english content==========================
  <para>
   Additional extensions are available that implement transforms for the
   <type>jsonb</type> type for different procedural languages.
  </para>
____________________________________________________________________________-->
  <para>
   有一些附加的扩展可以为不同的过程语言实现<type>jsonb</type>类型的转换。
  </para>

<!--==========================orignal english content==========================
  <para>
   The extensions for PL/Perl are called <literal>jsonb_plperl</literal> and
   <literal>jsonb_plperlu</literal>.  If you use them, <type>jsonb</type>
   values are mapped to Perl arrays, hashes, and scalars, as appropriate.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Perl的扩展被称作<literal>jsonb_plperl</literal>和<literal>jsonb_plperlu</literal>。如果使用它们，<type>jsonb</type>值会视情况被映射为Perl的数组、哈希和标量。
  </para>

<!--==========================orignal english content==========================
  <para>
   The extensions for PL/Python are called <literal>jsonb_plpythonu</literal>,
   <literal>jsonb_plpython2u</literal>, and
   <literal>jsonb_plpython3u</literal> (see <xref
   linkend="plpython-python23"/> for the PL/Python naming convention).  If you
   use them, <type>jsonb</type> values are mapped to Python dictionaries,
   lists, and scalars, as appropriate.
  </para>
____________________________________________________________________________-->
  <para>
   PL/Python的扩展被称作<literal>jsonb_plpythonu</literal>、<literal>jsonb_plpython2u</literal>和<literal>jsonb_plpython3u</literal>（PL/Python命名习惯请见<xref linkend="plpython-python23"/>）。如果使用它们，<type>jsonb</type>值会视情况被映射为Python的词典、列表和标量。
  </para>
 </sect2>
</sect1>
