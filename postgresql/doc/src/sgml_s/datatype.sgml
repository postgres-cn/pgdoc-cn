<!-- doc/src/sgml/datatype.sgml -->

 <chapter id="datatype">
<!--==========================orignal english content==========================
  <title>Data Types</title>
____________________________________________________________________________-->
  <title>数据类型</title>

<!--==========================orignal english content==========================
  <indexterm zone="datatype">
   <primary>data type</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datatype">
   <primary>数据类型</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>type</primary>
   <see>data type</see>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>类型</primary>
   <see>数据类型</see>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> has a rich set of native data
   types available to users.  Users can add new types to
   <productname>PostgreSQL</productname> using the <xref
   linkend="sql-createtype"/> command.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>有着丰富的本地数据类型可用。用户可以使用<xref linkend="sql-createtype"/>命令为 <productname>PostgreSQL</productname>增加新的数据类型。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="datatype-table"/> shows all the built-in general-purpose data
   types. Most of the alternative names listed in the
   <quote>Aliases</quote> column are the names used internally by
   <productname>PostgreSQL</productname> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but are not listed here.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="datatype-table"/>显示了所有内建的普通数据类型。大部分在<quote>别名</quote>列里列出的可选名字都是因历史原因 被<productname>PostgreSQL</productname>在内部使用的名字。另外，还有一些内部使用的或者废弃的类型也可以用，但没有在这里列出。
  </para>

   <table id="datatype-table">
<!--==========================orignal english content==========================
    <title>Data Types</title>
____________________________________________________________________________-->
    <title>数据类型</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Name</entry>
       <entry>Aliases</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>别名</entry>
       <entry>描述</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>signed eight-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>有符号的8字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>autoincrementing eight-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>自动增长的8字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>fixed-length bit string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>定长位串</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>variable-length bit string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>变长位串</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>logical Boolean (true/false)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>逻辑布尔值（真/假）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>rectangular box on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>平面上的普通方框</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>binary data (<quote>byte array</quote>)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>二进制数据（<quote>字节数组</quote>）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>fixed-length character string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>定长字符串</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>variable-length character string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>变长字符串</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IPv4 or IPv6 network address</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6网络地址</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>circle on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>平面上的圆</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>calendar date (year, month, day)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>日历日期（年、月、日）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>double precision floating-point number (8 bytes)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>双精度浮点数（8字节）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IPv4 or IPv6 host address</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6主机地址</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>signed four-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>有符号4字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>time span</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>时间段</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <entry>textual JSON data</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <entry>文本 JSON 数据</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <entry>binary JSON data, decomposed</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <entry>二进制 JSON 数据，已分解</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>infinite line on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>平面上的无限长的线</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>line segment on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>平面上的线段</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC (Media Access Control) address</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC（Media Access Control）地址</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>macaddr8</type></entry>
       <entry></entry>
       <entry>MAC (Media Access Control) address (EUI-64 format)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>macaddr8</type></entry>
       <entry></entry>
       <entry>MAC（Media Access Control）地址（EUI-64格式）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>currency amount</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>货币数量</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>exact numeric of selectable precision</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>可选择精度的精确数字</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>geometric path on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>平面上的几何路径</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <entry><productname>PostgreSQL</productname> Log Sequence Number</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <entry><productname>PostgreSQL</productname>日志序列号</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>geometric point on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>平面上的几何点</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>closed geometric path on a plane</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>平面上的封闭几何路径</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>single precision floating-point number (4 bytes)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>单精度浮点数（4字节）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>signed two-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>有符号2字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>autoincrementing two-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>自动增长的2字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>autoincrementing four-byte integer</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>自动增长的4字节整数</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>variable-length character string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>变长字符串</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>time of day (no time zone)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>一天中的时间（无时区）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>time of day, including time zone</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>一天中的时间，包括时区</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>date and time (no time zone)</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>日期和时间（无时区）</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>date and time, including time zone</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>日期和时间，包括时区</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>text search query</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>文本搜索查询</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>text search document</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>文本搜索文档</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>user-level transaction ID snapshot</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>用户级别事务ID快照</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>universally unique identifier</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>通用唯一标识码</entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>XML data</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>XML数据</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <note>
<!--==========================orignal english content==========================
   <title>Compatibility</title>
____________________________________________________________________________-->
   <title>兼容性</title>
<!--==========================orignal english content==========================
   <para>
    The following types (or spellings thereof) are specified by
    <acronym>SQL</acronym>: <type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (with or without time zone),
    <type>timestamp</type> (with or without time zone),
    <type>xml</type>.
   </para>
____________________________________________________________________________-->
   <para>
    下列类型（或者及其拼写）是<acronym>SQL</acronym>指定的：<type>bigint</type>、<type>bit</type>、<type>bit varying</type>、<type>boolean</type>、<type>char</type>、<type>character varying</type>、<type>character</type>、<type>varchar</type>、<type>date</type>、<type>double precision</type>、<type>integer</type>、<type>interval</type>、<type>numeric</type>、<type>decimal</type>、<type>real</type>、<type>smallint</type>、<type>time</type>（有时区或无时区）、<type>timestamp</type>（有时区或无时区）、<type>xml</type>。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <productname>PostgreSQL</productname>, such as geometric
   paths, or have several possible formats, such as the date
   and time types.
   Some of the input and output functions are not invertible, i.e.,
   the result of an output function might lose accuracy when compared to
   the original input.
  </para>
____________________________________________________________________________-->
  <para>
   每种数据类型都有一个由其输入和输出函数决定的外部表现形式。许多内建的类型有明显的格式。不过，许多类型要么是<productname>PostgreSQL</productname>所特有的（例如几何路径），要么可能是有几种不同的格式（例如日期和时间类型）。 有些输入和输出函数是不可逆的，即输出函数的结果和原始输入比较时可能丢失精度。
  </para>

  <sect1 id="datatype-numeric">
<!--==========================orignal english content==========================
   <title>Numeric Types</title>
____________________________________________________________________________-->
   <title>数字类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-numeric">
    <primary>data type</primary>
    <secondary>numeric</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-numeric">
    <primary>数据类型</primary>
    <secondary>数字</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and selectable-precision
    decimals.  <xref linkend="datatype-numeric-table"/> lists the
    available types.
   </para>
____________________________________________________________________________-->
   <para>
    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。<xref linkend="datatype-numeric-table"/>列出了所有可用类型。
   </para>

    <table id="datatype-numeric-table">
<!--==========================orignal english content==========================
     <title>Numeric Types</title>
____________________________________________________________________________-->
     <title>数字类型</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>smallint</type></entry>
        <entry>2 bytes</entry>
        <entry>small-range integer</entry>
        <entry>-32768 to +32767</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>smallint</type></entry>
        <entry>2字节</entry>
        <entry>小范围整数</entry>
        <entry>-32768 to +32767</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>integer</type></entry>
        <entry>4 bytes</entry>
        <entry>typical choice for integer</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>integer</type></entry>
        <entry>4字节</entry>
        <entry>整数的典型选择</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>bigint</type></entry>
        <entry>8 bytes</entry>
        <entry>large-range integer</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>bigint</type></entry>
        <entry>8字节</entry>
        <entry>大范围整数</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>decimal</type></entry>
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>decimal</type></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>numeric</type></entry>
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>numeric</type></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>real</type></entry>
        <entry>4 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>6 decimal digits precision</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>real</type></entry>
        <entry>4字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>6位十进制精度</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>double precision</type></entry>
        <entry>8 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>15 decimal digits precision</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>double precision</type></entry>
        <entry>8字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>15位十进制精度</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>smallserial</type></entry>
        <entry>2 bytes</entry>
        <entry>small autoincrementing integer</entry>
        <entry>1 to 32767</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>smallserial</type></entry>
        <entry>2字节</entry>
        <entry>自动增加的小整数</entry>
        <entry>1到32767</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>serial</type></entry>
        <entry>4 bytes</entry>
        <entry>autoincrementing integer</entry>
        <entry>1 to 2147483647</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>serial</type></entry>
        <entry>4字节</entry>
        <entry>自动增加的整数</entry>
        <entry>1到2147483647</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 bytes</entry>
        <entry>large autoincrementing integer</entry>
        <entry>1 to 9223372036854775807</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>bigserial</type></entry>
        <entry>8字节</entry>
        <entry>自动增长的大整数</entry>
        <entry>1到9223372036854775807</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    The syntax of constants for the numeric types is described in
    <xref linkend="sql-syntax-constants"/>.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <xref linkend="functions"/> for more
    information.  The following sections describe the types in detail.
   </para>
____________________________________________________________________________-->
   <para>
    数字类型常量的语法在<xref linkend="sql-syntax-constants"/>里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 <xref linkend="functions"/>。下面的几节详细描述这些类型。
   </para>

   <sect2 id="datatype-int">
<!--==========================orignal english content==========================
    <title>Integer Types</title>
____________________________________________________________________________-->
    <title>整数类型</title>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>整数</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>int4</primary>
     <see>整数</see>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The types <type>smallint</type>, <type>integer</type>, and
     <type>bigint</type> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
    </para>
____________________________________________________________________________-->
    <para>
     类型<type>smallint</type>、<type>integer</type>和<type>bigint</type>存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     The type <type>integer</type> is the common choice, as it offers
     the best balance between range, storage size, and performance.
     The <type>smallint</type> type is generally only used if disk
     space is at a premium.  The <type>bigint</type> type is designed to be
     used when the range of the <type>integer</type> type is insufficient.
    </para>
____________________________________________________________________________-->
    <para>
     常用的类型是<type>integer</type>，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 <type>smallint</type>类型。而只有在<type>integer</type>的范围不够的时候才使用<type>bigint</type>。
    </para>

<!--==========================orignal english content==========================
    <para>
     <acronym>SQL</acronym> only specifies the integer types
     <type>integer</type> (or <type>int</type>),
     <type>smallint</type>, and <type>bigint</type>.  The
     type names <type>int2</type>, <type>int4</type>, and
     <type>int8</type> are extensions, which are also used by some
     other <acronym>SQL</acronym> database systems.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>只声明了整数类型<type>integer</type>（或<type>int</type>）、<type>smallint</type>和<type>bigint</type>。类型<type>int2</type>、<type>int4</type>和<type>int8</type>都是扩展，也在许多其它<acronym>SQL</acronym>数据库系统中使用。
    </para>

   </sect2>

   <sect2 id="datatype-numeric-decimal">
<!--==========================orignal english content==========================
    <title>Arbitrary Precision Numbers</title>
____________________________________________________________________________-->
    <title>任意精度数字</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>numeric (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>数字（数据类型）</primary>
    </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>arbitrary precision numbers</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>任意精度数字</primary>
   </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The type <type>numeric</type> can store numbers with a
     very large number of digits. It is especially recommended for
     storing monetary amounts and other quantities where exactness is
     required.  Calculations with <type>numeric</type> values yield exact
     results where possible, e.g.  addition, subtraction, multiplication.
     However, calculations on <type>numeric</type> values are very slow
     compared to the integer types, or to the floating-point types
     described in the next section.
    </para>
____________________________________________________________________________-->
    <para>
     类型<type>numeric</type>可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。<type>numeric</type>值的计算在可能的情况下会得到准确的结果，例如加法、减法、乘法。不过，<type>numeric</type>类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。
    </para>

<!--==========================orignal english content==========================
    <para>
     We use the following terms below:  The
     <firstterm>precision</firstterm> of a <type>numeric</type>
     is the total count of significant digits in the whole number,
     that is, the number of digits to both sides of the decimal point.
     The <firstterm>scale</firstterm> of a <type>numeric</type> is the
     count of decimal digits in the fractional part, to the right of the
     decimal point.  So the number 23.5141 has a precision of 6 and a
     scale of 4.  Integers can be considered to have a scale of zero.
    </para>
____________________________________________________________________________-->
    <para>
     在随后的内容里，我们使用了下述术语：一个<type>numeric</type>的<firstterm>precision</firstterm>（精度）是整个数中有效位的总数，也就是小数点两边的位数。<type>numeric</type>的<firstterm>scale</firstterm>（刻度）是小数部分的数字位数，也就是小数点右边的部分。因此数字 23.5141 的精度为6而刻度为4。可以认为整数的刻度为零。
    </para>

<!--==========================orignal english content==========================
    <para>
     Both the maximum precision and the maximum scale of a
     <type>numeric</type> column can be
     configured.  To declare a column of type <type>numeric</type> use
     the syntax:
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     The precision must be positive, the scale zero or positive.
     Alternatively:
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     selects a scale of 0.  Specifying:
<programlisting>
NUMERIC
</programlisting>
     without any precision or scale creates a column in which numeric
     values of any precision and scale can be stored, up to the
     implementation limit on precision.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <type>numeric</type> columns with a declared scale will coerce
     input values to that scale.  (The <acronym>SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
    </para>
____________________________________________________________________________-->
    <para>
     <type>numeric</type>列的最大精度和最大比例都是可以配置的。要声明一个类型为<type>numeric</type>的列，你可以用下面的语法：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     精度必须为正数，比例可以为零或者正数。另外：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     选择比例为 0 。如果使用
<programlisting>
NUMERIC
</programlisting>
     创建一个列时不使用精度或比例，则该列可以存储任何精度和比例的数字值，并且值的范围最多可以到实现精度的上限。一个这种列将不会把输入值转化成任何特定的比例，而带有比例声明的<type>numeric</type>列将把输入值转化为该比例（<acronym>SQL</acronym>标准要求缺省的比例是 0，即转化成整数精度。我们觉得这样做有点没用。如果你关心移植性，那你最好总是显式声明精度和比例）。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The maximum allowed precision when explicitly specified in the
      type declaration is 1000; <type>NUMERIC</type> without a specified
      precision is subject to the limits described in <xref
      linkend="datatype-numeric-table"/>.
     </para>
____________________________________________________________________________-->
     <para>
      显式指定类型精度时的最大允许精度为 1000，没有指定精度的<type>NUMERIC</type>受到<xref linkend="datatype-numeric-table"/>中描述的限制所控制。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     If the scale of a value to be stored is greater than the declared
     scale of the column, the system will round the value to the specified
     number of fractional digits.  Then, if the number of digits to the
     left of the decimal point exceeds the declared precision minus the
     declared scale, an error is raised.
    </para>
____________________________________________________________________________-->
    <para>
     如果一个要存储的值的比例比列声明的比例高，那么系统将尝试圆整（四舍五入）该值到指定的分数位数。 然后，如果小数点左边的位数超过了声明的精度减去声明的比例，那么抛出一个错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     Numeric values are physically stored without any extra leading or
     trailing zeroes.  Thus, the declared precision and scale of a column
     are maximums, not fixed allocations.  (In this sense the <type>numeric</type>
     type is more akin to <type>varchar(<replaceable>n</replaceable>)</type>
     than to <type>char(<replaceable>n</replaceable>)</type>.)  The actual storage
     requirement is two bytes for each group of four decimal digits,
     plus three to eight bytes overhead.
    </para>
____________________________________________________________________________-->
    <para>
     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和比例都是最大值，而不是固定分配的 （在这个方面，<type>numeric</type>类型更类似于<type>varchar(<replaceable>n</replaceable>)</type>， 而不像<type>char(<replaceable>n</replaceable>)</type>）。 实际存储要求是每四个十进制位组用两个字节，
     plus three to eight bytes overhead.
    </para>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
   </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>NaN</primary>
     <see>不是一个数字</see>
   </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>not a number</primary>
     <secondary>numeric (data type)</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>不是一个数字</primary>
     <secondary>数字（数据类型）</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     In addition to ordinary numeric values, the <type>numeric</type>
     type allows the special value <literal>NaN</literal>, meaning
     <quote>not-a-number</quote>.  Any operation on <literal>NaN</literal>
     yields another <literal>NaN</literal>.  When writing this value
     as a constant in an SQL command, you must put quotes around it,
     for example <literal>UPDATE table SET x = 'NaN'</literal>.  On input,
     the string <literal>NaN</literal> is recognized in a case-insensitive manner.
    </para>
____________________________________________________________________________-->
    <para>
     除了普通的数字值之外，<type>numeric</type>类型允许特殊值<literal>NaN</literal>， 表示<quote>不是一个数字</quote>。任何在 <literal>NaN</literal>上面的操作都生成另外一个<literal>NaN</literal>。 如果在 SQL 命令里把这些值当作一个常量写，你必须在其周围放上单引号，例如<literal>UPDATE table SET x = 'NaN'</literal>。在输入时，字串<literal>NaN</literal>被识别为大小写无关。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      In most implementations of the <quote>not-a-number</quote> concept,
      <literal>NaN</literal> is not considered equal to any other numeric
      value (including <literal>NaN</literal>).  In order to allow
      <type>numeric</type> values to be sorted and used in tree-based
      indexes, <productname>PostgreSQL</productname> treats <literal>NaN</literal>
      values as equal, and greater than all non-<literal>NaN</literal>
      values.
     </para>
____________________________________________________________________________-->
     <para>
      在<quote>不是一个数字</quote>概念的大部分实现中，<literal>NaN</literal>被认为不等于任何其他数字值（包括<literal>NaN</literal>）。为了允许<type>numeric</type>值可以被排序和使用基于树的索引，<productname>PostgreSQL</productname>把<literal>NaN</literal>值视为相等，并且比所有非<literal>NaN</literal>值都要大。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     The types <type>decimal</type> and <type>numeric</type> are
     equivalent.  Both types are part of the <acronym>SQL</acronym>
     standard.
    </para>
____________________________________________________________________________-->
    <para>
     类型<type>decimal</type>和<type>numeric</type>是等效的。两种类型都是<acronym>SQL</acronym>标准的一部分。
    </para>
    
<!--==========================orignal english content==========================
    <para>
     When rounding values, the <type>numeric</type> type rounds ties away
     from zero, while (on most machines) the <type>real</type>
     and <type>double precision</type> types round ties to the nearest even
     number.  For example:

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在对值进行圆整时，<type>numeric</type>类型会圆到远离零的整数，而（在大部分机器上）<type>real</type>和<type>double precision</type>类型会圆到最近的偶数上。例如：

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</programlisting>
    </para>
   </sect2>


   <sect2 id="datatype-float">
<!--==========================orignal english content==========================
    <title>Floating-Point Types</title>
____________________________________________________________________________-->
    <title>浮点类型</title>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>双精度</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>float8</primary>
     <see>双精度</see>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-float">
     <primary>floating point</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>浮点</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The data types <type>real</type> and <type>double
     precision</type> are inexact, variable-precision numeric types.
     In practice, these types are usually implementations of
     <acronym>IEEE</acronym> Standard 754 for Binary Floating-Point
     Arithmetic (single and double precision, respectively), to the
     extent that the underlying processor, operating system, and
     compiler support it.
    </para>
____________________________________________________________________________-->
    <para>
     数据类型<type>real</type>和<type>double precision</type>是不准确的、变精度的数字类型。实际上，这些类型是<acronym>IEEE</acronym>标准 754 二进制浮点算术（分别对应单精度和双精度）的一般实现， 一直到下层处理器、操作系统和编译器对它的支持。
    </para>

<!--==========================orignal english content==========================
    <para>
     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and retrieving a value might show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed here, except for the
     following points:
     <itemizedlist>
      <listitem>
       <para>
        If you require exact storage and calculations (such as for
        monetary amounts), use the <type>numeric</type> type instead.
       </para>
      </listitem>

      <listitem>
       <para>
        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
       </para>
      </listitem>

      <listitem>
       <para>
        Comparing two floating-point values for equality might not
        always work as expected.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。 处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：
     <itemizedlist>
      <listitem>
       <para>
        如果你要求准确的存储和计算（例如计算货币金额），应使用<type>numeric</type>类型。
       </para>
      </listitem>

      <listitem>
       <para>
        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。
       </para>
      </listitem>

      <listitem>
       <para>
        用两个浮点数值进行等值比较不可能总是按照期望地进行。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     On most platforms, the <type>real</type> type has a range of at least
     1E-37 to 1E+37 with a precision of at least 6 decimal digits.  The
     <type>double precision</type> type typically has a range of around
     1E-307 to 1E+308 with a precision of at least 15 digits.  Values that
     are too large or too small will cause an error.  Rounding might
     take place if the precision of an input number is too high.
     Numbers too close to zero that are not representable as distinct
     from zero will cause an underflow error.
    </para>
____________________________________________________________________________-->
    <para>
     在大部分平台上，<type>real</type>类型的范围是至少 -1E+37 到 +1E+37，精度至少是 6 位小数。<type>double precision</type>类型通常有 -1E+308 到 +1E+308 的范围，精度是至少 15 位数字。太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生园整。太接近零的数字，如果无法与零值的表现形式相区分就会产生下溢错误。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The <xref linkend="guc-extra-float-digits"/> setting controls the
      number of extra significant digits included when a floating point
      value is converted to text for output.  With the default value of
      <literal>0</literal>, the output is the same on every platform
      supported by PostgreSQL.  Increasing it will produce output that
      more accurately represents the stored value, but may be unportable.
     </para>
____________________________________________________________________________-->
     <para>
      <xref linkend="guc-extra-float-digits"/>设置控制当一个浮点值被转换为文本输出时要包括的额外有效数字的数目。其默认值为<literal>0</literal>，在每一个PostgreSQL支持的平台上输出都相同。增加该设置将产生能更精确表示存储值的输出，但是可能无法移植。
     </para>
    </note>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>not a number</primary>
     <secondary>double precision</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>不是一个数字</primary>
     <secondary>双精度</secondary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     In addition to ordinary numeric values, the floating-point types
     have several special values:
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     These represent the IEEE 754 special values
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively.  (On a machine whose
     floating-point arithmetic does not follow IEEE 754, these values
     will probably not work as expected.)  When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = '-Infinity'</literal>.  On input,
     these strings are recognized in a case-insensitive manner.
    </para>
____________________________________________________________________________-->
    <para>
     除了普通的数字值之外，浮点类型还有几个特殊值：
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     这些值分别表示 IEEE 754 特殊值<quote>正无穷大</quote>、<quote>负无穷大</quote>以及<quote>不是一个数字</quote>（在不遵循 IEEE 754 浮点算术的机器上，这些值的含义可能不是预期的）。如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如<literal>UPDATE table SET x = '-Infinity'</literal>。 在输入时，这些串是以大小写无关的方式识别的。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      IEEE754 specifies that <literal>NaN</literal> should not compare equal
      to any other floating-point value (including <literal>NaN</literal>).
      In order to allow floating-point values to be sorted and used
      in tree-based indexes, <productname>PostgreSQL</productname> treats
      <literal>NaN</literal> values as equal, and greater than all
      non-<literal>NaN</literal> values.
     </para>
____________________________________________________________________________-->
     <para>
      IEEE754指定<literal>NaN</literal>不应该与任何其他浮点值（包括<literal>NaN</literal>）相等。为了允许浮点值被排序或者在基于树的索引中使用，<productname>PostgreSQL</productname>将<literal>NaN</literal>值视为相等，并且比所有非<literal>NaN</literal>值要更大。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> also supports the SQL-standard
     notations <type>float</type> and
     <type>float(<replaceable>p</replaceable>)</type> for specifying
     inexact numeric types.  Here, <replaceable>p</replaceable> specifies
     the minimum acceptable precision in <emphasis>binary</emphasis> digits.
     <productname>PostgreSQL</productname> accepts
     <type>float(1)</type> to <type>float(24)</type> as selecting the
     <type>real</type> type, while
     <type>float(25)</type> to <type>float(53)</type> select
     <type>double precision</type>.  Values of <replaceable>p</replaceable>
     outside the allowed range draw an error.
     <type>float</type> with no precision specified is taken to mean
     <type>double precision</type>.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>还支持 SQL 标准表示法<type>float</type>和<type>float(<replaceable>p</replaceable>)</type>用于声明非精确的数字类型。在这里，<replaceable>p</replaceable>指定以<emphasis>二进制</emphasis>位表示的最低可接受精度。 在选取<type>real</type>类型的时候，<productname>PostgreSQL</productname>接受<type>float(1)</type>到<type>float(24)</type>，在选取<type>double precision</type>的时候，接受<type>float(25)</type>到<type>float(53)</type>。在允许范围之外的<replaceable>p</replaceable>值将导致一个错误。没有指定精度的<type>float</type>将被当作是<type>double precision</type>。
    </para>

    <note>
<!--==========================orignal english content==========================
     <para>
      The assumption that <type>real</type> and
      <type>double precision</type> have exactly 24 and 53 bits in the
      mantissa respectively is correct for IEEE-standard floating point
      implementations.  On non-IEEE platforms it might be off a little, but
      for simplicity the same ranges of <replaceable>p</replaceable> are used
      on all platforms.
     </para>
____________________________________________________________________________-->
     <para>
      认为<type>real</type>和<type>double precision</type>分别有 24 和 53 个二进制位的假设对 IEEE 标准的浮点实现来说是正确的。在非 IEEE 平台上，这个数值可能略有偏差，但是为了简化，我们在所有平台上都用了同样的<replaceable>p</replaceable>值范围。
     </para>
    </note>

   </sect2>

   <sect2 id="datatype-serial">
<!--==========================orignal english content==========================
    <title>Serial Types</title>
____________________________________________________________________________-->
    <title>序数类型</title>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>

    <note>
<!--==========================orignal english content==========================
     <para>
      This section describes a PostgreSQL-specific way to create an
      autoincrementing column.  Another way is to use the SQL-standard
      identity column feature, described at <xref linkend="sql-createtable"/>.
     </para>
____________________________________________________________________________-->
     <para>
      这一节描述了PostgreSQL特有的创建一个自增列的方法。另一种方法是使用SQL标准的标识列特性，它在<xref linkend="sql-createtable"/>中描述。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     The data types <type>smallserial</type>, <type>serial</type> and
     <type>bigserial</type> are not true types, but merely
     a notational convenience for creating unique identifier columns
     (similar to the <literal>AUTO_INCREMENT</literal> property
     supported by some other databases). In the current
     implementation, specifying:

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     is equivalent to specifying:

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <literal>NOT NULL</literal>
     constraint is applied to ensure that a null value cannot be
     inserted.  (In most cases you would also want to attach a
     <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.)  Lastly, the sequence is marked as <quote>owned by</quote>
     the column, so that it will be dropped if the column or table is dropped.
    </para>
____________________________________________________________________________-->
    <para>
     <type>smallserial</type>、<type>serial</type>和<type>bigserial</type>类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的<literal>AUTO_INCREMENT</literal>属性）。 在目前的实现中，下面一个语句：

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     等价于以下语句：

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个<literal>NOT NULL</literal>约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个<literal>UNIQUE</literal>或者<literal>PRIMARY KEY</literal>约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为<quote>属于</quote>该列，这样当列或表被删除时该序列也会被删除。
    </para>

    <note>
<!--==========================orignal english content==========================
      <para>
        Because <type>smallserial</type>, <type>serial</type> and
        <type>bigserial</type> are implemented using sequences, there may
        be "holes" or gaps in the sequence of values which appears in the
        column, even if no rows are ever deleted.  A value allocated
        from the sequence is still "used up" even if a row containing that
        value is never successfully inserted into the table column.  This
        may happen, for example, if the inserting transaction rolls back.
        See <literal>nextval()</literal> in <xref linkend="functions-sequence"/>
        for details.
      </para>
____________________________________________________________________________-->
      <para>
        因为<type>smallserial</type>、<type>serial</type>和<type>bigserial</type>是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见<xref linkend="functions-sequence"/>中的<literal>nextval()</literal>。
      </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     To insert the next value of the sequence into the <type>serial</type>
     column, specify that the <type>serial</type>
     column should be assigned its default value. This can be done
     either by excluding the column from the list of columns in
     the <command>INSERT</command> statement, or through the use of
     the <literal>DEFAULT</literal> key word.
    </para>
____________________________________________________________________________-->
    <para>
     要使用<type>serial</type>列插入序列的下一个数值到表中， 请指定<type>serial</type>列应该被赋予其缺省值。我们可以通过在<command>INSERT</command>语句中把该列排除在列列表之外来实现，也可以通过使用<literal>DEFAULT</literal>关键字来实现。
    </para>

<!--==========================orignal english content==========================
    <para>
     The type names <type>serial</type> and <type>serial4</type> are
     equivalent: both create <type>integer</type> columns.  The type
     names <type>bigserial</type> and <type>serial8</type> work
     the same way, except that they create a <type>bigint</type>
     column.  <type>bigserial</type> should be used if you anticipate
     the use of more than 2<superscript>31</superscript> identifiers over the
     lifetime of the table. The type names <type>smallserial</type> and
     <type>serial2</type> also work the same way, except that they
     create a <type>smallint</type> column.
    </para>
____________________________________________________________________________-->
    <para>
     类型名<type>serial</type>和<type>serial4</type>是等效的： 两个都创建<type>integer</type>列。类型名<type>bigserial</type>和<type>serial8</type>也一样，只不过它们创建一个 <type>bigint</type>列。如果你预计在表的生存期中使用的标识符数目超过 2<superscript>31</superscript> 个，那么你应该使用<type>bigserial</type>。类型名<type>smallserial</type>和<type>serial2</type>也以相同方式工作，只不过它们创建一个<type>smallint</type>列。
    </para>

<!--==========================orignal english content==========================
    <para>
     The sequence created for a <type>serial</type> column is
     automatically dropped when the owning column is dropped.
     You can drop the sequence without dropping the column, but this
     will force removal of the column default expression.
    </para>
____________________________________________________________________________-->
    <para>
     为一个<type>serial</type>列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。
    </para>
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
<!--==========================orignal english content==========================
   <title>Monetary Types</title>
____________________________________________________________________________-->
   <title>货币类型</title>

<!--==========================orignal english content==========================
   <para>
    The <type>money</type> type stores a currency amount with a fixed
    fractional precision; see <xref
    linkend="datatype-money-table"/>.  The fractional precision is
    determined by the database's <xref linkend="guc-lc-monetary"/> setting.
    The range shown in the table assumes there are two fractional digits.
    Input is accepted in a variety of formats, including integer and
    floating-point literals, as well as typical
    currency formatting, such as <literal>'$1,000.00'</literal>.
    Output is generally in the latter form but depends on the locale.
   </para>
____________________________________________________________________________-->
   <para>
    <type>money</type>类型存储固定小数精度的货币数字，参阅<xref linkend="datatype-money-table"/>。小数的精度由数据库的<xref linkend="guc-lc-monetary"/>设置决定。表中展示的范围假设有两个小数位。可接受的输入格式很多，包括整数和浮点数文字，以及常用的货币格式，如<literal>'$1,000.00'</literal>。 输出通常是最后一种形式，但和区域相关。
   </para>

    <table id="datatype-money-table">
<!--==========================orignal english content==========================
     <title>Monetary Types</title>
____________________________________________________________________________-->
     <title>货币类型</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>money</type></entry>
        <entry>8 bytes</entry>
        <entry>currency amount</entry>
        <entry>-92233720368547758.08 to +92233720368547758.07</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>money</type></entry>
        <entry>8 bytes</entry>
        <entry>货币额</entry>
        <entry>-92233720368547758.08到+92233720368547758.07</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Since the output of this data type is locale-sensitive, it might not
    work to load <type>money</type> data into a database that has a different
    setting of <varname>lc_monetary</varname>.  To avoid problems, before
    restoring a dump into a new database make sure <varname>lc_monetary</varname> has
    the same or equivalent value as in the database that was dumped.
   </para>
____________________________________________________________________________-->
   <para>
    由于这种数据类型的输出是区域敏感的，因此将<type>money</type>数据装入到一个具有不同<varname>lc_monetary</varname>设置的数据库是不起作用的。为了避免这种问题，在恢复一个转储到一个新数据库中之前，应确保新数据库的<varname>lc_monetary</varname>设置和被转储数据库的相同或者具有等效值。
   </para>

<!--==========================orignal english content==========================
   <para>
    Values of the <type>numeric</type>, <type>int</type>, and
    <type>bigint</type> data types can be cast to <type>money</type>.
    Conversion from the <type>real</type> and <type>double precision</type>
    data types can be done by casting to <type>numeric</type> first, for
    example:
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
    However, this is not recommended.  Floating point numbers should not be
    used to handle money due to the potential for rounding errors.
   </para>
____________________________________________________________________________-->
   <para>
    数据类型<type>numeric</type>、<type>int</type>和<type>bigint</type>的值可以被造型成<type>money</type>。从数据类型<type>real</type>和<type>double precision</type>的转换可以通过先造型成<type>numeric</type>来实现，例如：
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
    但是，我们不推荐这样做。浮点数不应该被用来处理货币，因为浮点数可能会有圆整错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    A <type>money</type> value can be cast to <type>numeric</type> without
    loss of precision. Conversion to other types could potentially lose
    precision, and must also be done in two stages:
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个<type>money</type>值可以在不损失精度的情况下被造型成<type>numeric</type>。转换到其他类型可能会丢失精度，并且必须采用两个阶段完成：
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Division of a <type>money</type> value by an integer value is performed
    with truncation of the fractional part towards zero.  To get a rounded
    result, divide by a floating-point value, or cast the <type>money</type>
    value to <type>numeric</type> before dividing and back to <type>money</type>
    afterwards.  (The latter is preferable to avoid risking precision loss.)
    When a <type>money</type> value is divided by another <type>money</type>
    value, the result is <type>double precision</type> (i.e., a pure number,
    not money); the currency units cancel each other out in the division.
   </para>
____________________________________________________________________________-->
   <para>
    一个<type>money</type>值被一个整数值除的除法结果会被截去分数部分。要得到圆整的结果，可以除以一个浮点值，或者在除法之前把<type>money</type>转换成<type>numeric</type>然后在除法之后转回<type>money</type>（如果要避免精度丢失的风险则后者更好）。当一个<type>money</type>值被另一个<type>money</type>值除时，结果是<type>double precision</type>（即一个纯数字，而不是金额），在除法中货币单位被约掉了。
   </para>
  </sect1>


  <sect1 id="datatype-character">
<!--==========================orignal english content==========================
   <title>Character Types</title>
____________________________________________________________________________-->
   <title>字符类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>character string</primary>
    <secondary>data types</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>字符串</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>string</primary>
    <see>character string</see>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>string</primary>
    <see>字符串</see>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>字符</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>

    <table id="datatype-character-table">
<!--==========================orignal english content==========================
     <title>Character Types</title>
____________________________________________________________________________-->
     <title>字符类型</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>variable-length with limit</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>有限制的变长</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>fixed-length, blank padded</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>定长，空格填充</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>text</type></entry>
        <entry>variable unlimited length</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>text</type></entry>
        <entry>无限变长</entry>
       </row>
     </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datatype-character-table"/> shows the
    general-purpose character types available in
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datatype-character-table"/>显示了在<productname>PostgreSQL</productname>里可用的一般用途的字符类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    <acronym>SQL</acronym> defines two primary character types:
    <type>character varying(<replaceable>n</replaceable>)</type> and
    <type>character(<replaceable>n</replaceable>)</type>, where <replaceable>n</replaceable>
    is a positive integer.  Both of these types can store strings up to
    <replaceable>n</replaceable> characters (not bytes) in length.  An attempt to store a
    longer string into a column of these types will result in an
    error, unless the excess characters are all spaces, in which case
    the string will be truncated to the maximum length. (This somewhat
    bizarre exception is required by the <acronym>SQL</acronym>
    standard.) If the string to be stored is shorter than the declared
    length, values of type <type>character</type> will be space-padded;
    values of type <type>character varying</type> will simply store the
    shorter
    string.
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了两种基本的字符类型： <type>character varying(<replaceable>n</replaceable>)</type>和<type>character(<replaceable>n</replaceable>)</type>， 其中<replaceable>n</replaceable>是一个正整数。两种类型都可以存储最多<replaceable>n</replaceable>个字符长的串。试图存储更长的串到这些类型的列里会产生一个错误， 除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度（这个看上去有点怪异的例外是<acronym>SQL</acronym>标准要求的）。 如果要存储的串比声明的长度短，类型为<type>character</type>的值将会用空白填满；而类型为<type>character varying</type>的值将只是存储短些的串。
   </para>

<!--==========================orignal english content==========================
   <para>
    If one explicitly casts a value to <type>character
    varying(<replaceable>n</replaceable>)</type> or
    <type>character(<replaceable>n</replaceable>)</type>, then an over-length
    value will be truncated to <replaceable>n</replaceable> characters without
    raising an error. (This too is required by the
    <acronym>SQL</acronym> standard.)
   </para>
____________________________________________________________________________-->
   <para>
    如果我们明确地把一个值造型成<type>character varying(<replaceable>n</replaceable>)</type>或者<type>character(<replaceable>n</replaceable>)</type>， 那么超长的值将被截断成<replaceable>n</replaceable>个字符，而不会抛出错误（这也是<acronym>SQL</acronym>标准的要求）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The notations <type>varchar(<replaceable>n</replaceable>)</type> and
    <type>char(<replaceable>n</replaceable>)</type> are aliases for <type>character
    varying(<replaceable>n</replaceable>)</type> and
    <type>character(<replaceable>n</replaceable>)</type>, respectively.
    <type>character</type> without length specifier is equivalent to
    <type>character(1)</type>. If <type>character varying</type> is used
    without length specifier, the type accepts strings of any size. The
    latter is a <productname>PostgreSQL</productname> extension.
   </para>
____________________________________________________________________________-->
   <para>
    <type>varchar(<replaceable>n</replaceable>)</type>和<type>char(<replaceable>n</replaceable>)</type>的概念分别是<type>character varying(<replaceable>n</replaceable>)</type>和<type>character(<replaceable>n</replaceable>)</type>的别名。没有长度声明词的<type>character</type>等效于<type>character(1)</type>。如果不带长度说明词使用<type>character varying</type>，那么该类型接受任何长度的串。后者是一个<productname>PostgreSQL</productname>的扩展。
   </para>

<!--==========================orignal english content==========================
   <para>
    In addition, <productname>PostgreSQL</productname> provides the
    <type>text</type> type, which stores strings of any length.
    Although the type <type>text</type> is not in the
    <acronym>SQL</acronym> standard, several other SQL database
    management systems have it as well.
   </para>
____________________________________________________________________________-->
   <para>
    另外，<productname>PostgreSQL</productname>提供<type>text</type>类型，它可以存储任何长度的串。尽管类型<type>text</type>不是<acronym>SQL</acronym>标准，但是许多其它 SQL 数据库系统也有它。
   </para>

<!--==========================orignal english content==========================
   <para>
    Values of type <type>character</type> are physically padded
    with spaces to the specified width <replaceable>n</replaceable>, and are
    stored and displayed that way.  However, trailing spaces are treated as
    semantically insignificant and disregarded when comparing two values
    of type <type>character</type>.  In collations where whitespace
    is significant, this behavior can produce unexpected results;
    for example <command>SELECT 'a '::CHAR(2) collate "C" &lt;
    E'a\n'::CHAR(2)</command> returns true, even though <literal>C</literal>
    locale would consider a space to be greater than a newline.
    Trailing spaces are removed when converting a <type>character</type> value
    to one of the other string types.  Note that trailing spaces
    <emphasis>are</emphasis> semantically significant in
    <type>character varying</type> and <type>text</type> values, and
    when using pattern matching, that is <literal>LIKE</literal> and
    regular expressions.
   </para>
____________________________________________________________________________-->
   <para>
    类型<type>character</type>的值物理上都用空白填充到指定的长度<replaceable>n</replaceable>， 并且以这种方式存储和显示。不过，拖尾的空白被当作是没有意义的，并且在比较两个
    <type>character</type>类型值时不会考虑它们。在空白有意义的排序规则中，这种行为可能会
    产生意料之外的结果，例如<command>SELECT 'a '::CHAR(2) collate "C" &lt;
    E'a\n'::CHAR(2)</command>会返回真（即便<literal>C</literal>区域会认为一个空格比新行更大）。当把一个<type>character</type>值转换成其他
    字符串类型之一时，拖尾的空白会被移除。请注意，在<type>character varying</type>和<type>text</type>值里， 结尾的空白语意上<emphasis>是</emphasis>有含义的，并且在使用模式匹配（如<literal>LIKE</literal>和正则表达式）时也会被考虑。
   </para>

<!--==========================orignal english content==========================
   <para>
    The storage requirement for a short string (up to 126 bytes) is 1 byte
    plus the actual string, which includes the space padding in the case of
    <type>character</type>.  Longer strings have 4 bytes of overhead instead
    of 1.  Long strings are compressed by the system automatically, so
    the physical requirement on disk might be less. Very long values are also
    stored in background tables so that they do not interfere with rapid
    access to shorter column values. In any case, the longest
    possible character string that can be stored is about 1 GB. (The
    maximum value that will be allowed for <replaceable>n</replaceable> in the data
    type declaration is less than that. It wouldn't be useful to
    change this because with multibyte character encodings the number of
    characters and bytes can be quite different. If you desire to
    store long strings with no specific upper limit, use
    <type>text</type> or <type>character varying</type> without a length
    specifier, rather than making up an arbitrary length limit.)
   </para>
____________________________________________________________________________-->
   <para>
    这些类型的存储需求是 4 字节加上实际的字串，如果是 character 的话再加上填充的字节。长的字串将会自动被系统压缩， 因此在磁盘上的物理需求可能会更少些。长的数值也会存储在后台表里面，这样它们就不会干扰对短字段值的快速访问。 不管怎样，允许存储的最长字串大概是 1 GB。 （允许在数据类型声明中出现的的 n 的最大值比这还小。 修改这个行为没有甚么意义，因为在多字节编码下字符和字节的数目可能差别很大。 如果你想存储没有特定上限的长字串，那么使用 text 或者没有长度声明词的 character varying， 而不要选择一个任意长度限制。）
    一个短串（最长126字节）的存储要求是1个字节外加实际的串，该串在<type>character</type>情况下包含填充的空白。长一些的串在前面需要4个字节而不是1个字节。长串会被系统自动压缩，这样在磁盘上的物理需求可能会更少。非常长的值也会被存储在背景表中，这样它们不会干扰对较短的列值的快速访问。在任何情况下，能被存储的最长的字符串是1GB（数据类型定义中<replaceable>n</replaceable>能允许的最大值比这个值要小。修改它没有用处，因为对于多字节字符编码来说，字符的数量和字节数可能完全不同。如果你想要存储没有指定上限的长串，使用<type>text</type>或没有长度声明的<type>character varying</type>，而不是给出一个任意长度限制）。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     There is no performance difference among these three types,
     apart from increased storage space when using the blank-padded
     type, and a few extra CPU cycles to check the length when storing into
     a length-constrained column.  While
     <type>character(<replaceable>n</replaceable>)</type> has performance
     advantages in some other database systems, there is no such advantage in
     <productname>PostgreSQL</productname>; in fact
     <type>character(<replaceable>n</replaceable>)</type> is usually the slowest of
     the three because of its additional storage costs.  In most situations
     <type>text</type> or <type>character varying</type> should be used
     instead.
    </para>
____________________________________________________________________________-->
    <para>
     这三种类型之间没有性能差别，只不过是在使用填充空白的类型的时候需要更多存储尺寸，以及在存储到一个有长度约束的列时需要少量额外CPU周期来检查长度。虽然在某些其它的数据库系统里，<type>character(<replaceable>n</replaceable>)</type>有一定的性能优势，但在<productname>PostgreSQL</productname>里没有。事实上，<type>character(<replaceable>n</replaceable>)</type>通常是这三种类型之中最慢的一个，因为它需要额外的存储开销。在大多数情况下，应该使用<type>text</type>或者<type>character varying</type>。
    </para>
   </tip>

<!--==========================orignal english content==========================
   <para>
    Refer to <xref linkend="sql-syntax-strings"/> for information about
    the syntax of string literals, and to <xref linkend="functions"/>
    for information about available operators and functions. The
    database character set determines the character set used to store
    textual values; for more information on character set support,
    refer to <xref linkend="multibyte"/>.
   </para>
____________________________________________________________________________-->
   <para>
    请参考<xref linkend="sql-syntax-strings"/>获取关于串文本的语法的信息，以及参阅<xref linkend="functions"/>获取关于可用操作符和函数的信息。 数据库的字符集决定用于存储文本值的字符集；有关字符集支持的更多信息，请参考<xref linkend="multibyte"/>。
   </para>

   <example>
<!--==========================orignal english content==========================
    <title>Using the Character Types</title>
____________________________________________________________________________-->
    <title>使用字符类型</title>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -&minus; <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -&minus; explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
    <calloutlist>
     <callout arearefs="co.datatype-char">
<!--==========================orignal english content==========================
      <para>
       The <function>char_length</function> function is discussed in
       <xref linkend="functions-string"/>.
      </para>
____________________________________________________________________________-->
      <para>
       函数<function>char_length</function>在<xref linkend="functions-string"/>中讨论。
      </para>
     </callout>
    </calloutlist>
   </example>

<!--==========================orignal english content==========================
   <para>
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref
    linkend="datatype-character-special-table"/>. The <type>name</type>
    type exists <emphasis>only</emphasis> for the storage of identifiers
    in the internal system catalogs and is not intended for use by the general user. Its
    length is currently defined as 64 bytes (63 usable characters plus
    terminator) but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code.
    The length is set at compile time (and
    is therefore adjustable for special uses); the default maximum
    length might change in a future release. The type <type>"char"</type>
    (note the quotes) is different from <type>char(1)</type> in that it
    only uses one byte of storage. It is internally used in the system
    catalogs as a simplistic enumeration type.
   </para>
____________________________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>里另外还有两种定长字符类型，在<xref linkend="datatype-character-special-table"/>里显示。 <type>name</type>类型<emphasis>只</emphasis>用于在内部系统目录中存储标识符并且不是给一般用户使用的。该类型长度当前定为 64 字节（63 可用字符加结束符）但在<literal>C</literal>源代码应该使用常量 <symbol>NAMEDATALEN</symbol>引用。这个长度是在编译的时候设置的（因而可以为特殊用途调整），缺省的最大长度在以后的版本可能会改变。类型<type>"char"</type>（注意引号）和 <type>char(1)</type>是不一样的，它只用了一个字节的存储空间。它在系统内部用于系统目录当做简化的枚举类型用。
   </para>

    <table id="datatype-character-special-table">
<!--==========================orignal english content==========================
     <title>Special Character Types</title>
____________________________________________________________________________-->
     <title>特殊字符类型</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 byte</entry>
        <entry>single-byte internal type</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>"char"</type></entry>
        <entry>1字节</entry>
        <entry>单字节内部类型</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>name</type></entry>
        <entry>64 bytes</entry>
        <entry>internal type for object names</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>name</type></entry>
        <entry>64字节</entry>
        <entry>用于对象名的内部类型</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
<!--==========================orignal english content==========================
  <title>Binary Data Types</title>
____________________________________________________________________________-->
  <title>二进制数据类型</title>

<!--==========================orignal english content==========================
  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datatype-binary">
   <primary>二进制数据</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <type>bytea</type> data type allows storage of binary strings;
    see <xref linkend="datatype-binary-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <type>bytea</type>数据类型允许存储二进制串，参见<xref linkend="datatype-binary-table"/>。
   </para>

   <table id="datatype-binary-table">
<!--==========================orignal english content==========================
    <title>Binary Data Types</title>
____________________________________________________________________________-->
    <title>二进制数据类型</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>存储尺寸</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><type>bytea</type></entry>
       <entry>1 or 4 bytes plus the actual binary string</entry>
       <entry>variable-length binary string</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry>1或4字节外加真正的二进制串</entry>
       <entry>变长二进制串</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    A binary string is a sequence of octets (or bytes).  Binary
    strings are distinguished from character strings in two
    ways.  First, binary strings specifically allow storing
    octets of value zero and other <quote>non-printable</quote>
    octets (usually, octets outside the decimal range 32 to 126).
    Character strings disallow zero octets, and also disallow any
    other octet values and sequences of octet values that are invalid
    according to the database's selected character set encoding.
    Second, operations on binary strings process the actual bytes,
    whereas the processing of character strings depends on locale settings.
    In short, binary strings are appropriate for storing data that the
    programmer thinks of as <quote>raw bytes</quote>, whereas character
    strings are appropriate for storing text.
   </para>
____________________________________________________________________________-->
   <para>
    二进制串是一个八位位组（或字节）的序列。 二进制串和字符串的区别有两个： 首先，二进制串明确允许存储零值的字节以及其它<quote>不可打印的</quote>字节（通常是位于十进制范围32到126之外的字节）。 字符串不允许零字节，并且也不允许那些对于数据库的选定字符集编码是非法的任何其它字节值或者字节值序列。 第二，对二进制串的操作会处理实际上的字节，而字符串的处理和取决于区域设置。 简单说，二进制字串适用于存储那些程序员认为是<quote>裸字节</quote>的数据，而字符串适合存储文本。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>bytea</type> type supports two
    formats for input and output: <quote>hex</quote> format
    and <productname>PostgreSQL</productname>'s historical
    <quote>escape</quote> format.  Both
    of these are always accepted on input.  The output format depends
    on the configuration parameter <xref linkend="guc-bytea-output"/>;
    the default is hex.  (Note that the hex format was introduced in
    <productname>PostgreSQL</productname> 9.0; earlier versions and some
    tools don't understand it.)
   </para>
____________________________________________________________________________-->
   <para>
    <type>bytea</type>类型支持两种用于输入和输出的格式：<quote>十六进制</quote>格式和<productname>PostgreSQL</productname>的历史的<quote>转义</quote>格式。在输入时这两种格式总是会被接受。输出格式则取决于配置参数<xref linkend="guc-bytea-output"/>，其默认值为十六进制（注意十六进制格式是在<productname>PostgreSQL</productname> 9.0中被引入的，早期的版本和某些工具无法理解它）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <acronym>SQL</acronym> standard defines a different binary
    string type, called <type>BLOB</type> or <type>BINARY LARGE
    OBJECT</type>.  The input format is different from
    <type>bytea</type>, but the provided functions and operators are
    mostly the same.
   </para>
____________________________________________________________________________-->
   <para>
    <acronym>SQL</acronym>标准定义了一种不同的二进制串类型， 叫做<type>BLOB</type>或者<type>BINARY LARGE OBJECT</type>。其输入格式和<type>bytea</type>不同，但是提供的函数和操作符大多一样。
   </para>

  <sect2>
<!--==========================orignal english content==========================
   <title><type>bytea</type> Hex Format</title>
____________________________________________________________________________-->
   <title><type>bytea</type>的十六进制格式</title>

<!--==========================orignal english content==========================
   <para>
    The <quote>hex</quote> format encodes binary data as 2 hexadecimal digits
    per byte, most significant nibble first.  The entire string is
    preceded by the sequence <literal>\x</literal> (to distinguish it
    from the escape format).  In some contexts, the initial backslash may
    need to be escaped by doubling it
    (see <xref linkend="sql-syntax-strings"/>).
    For input, the hexadecimal digits can
    be either upper or lower case, and whitespace is permitted between
    digit pairs (but not within a digit pair nor in the starting
    <literal>\x</literal> sequence).
    The hex format is compatible with a wide
    range of external applications and protocols, and it tends to be
    faster to convert than the escape format, so its use is preferred.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>十六进制</quote>格式将二进制数据编码为每个字节2个十六进制位，最高有效位在前。整个串以序列<literal>\x</literal>开头（用以和转义格式区分）。在某些情景中，开头的反斜线可能需要通过双写来转义，详见(see <xref linkend="sql-syntax-strings"/>)。 作为输入，十六进制位可以是大写也可以是小写，在位对之间可以有空白（但是在位对内部以及开头的<literal>\x</literal>序列中不能有空白）。十六进制格式和很多外部应用及协议相兼容，并且其转换速度要比转义格式更快，因此人们更愿意用它。
   </para>

<!--==========================orignal english content==========================
   <para>
    Example:
<programlisting>
SELECT '\xDEADBEEF';
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例子：
<programlisting>
SELECT '\xDEADBEEF';
</programlisting>
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title><type>bytea</type> Escape Format</title>
____________________________________________________________________________-->
   <title><type>bytea</type>的转义格式</title>

<!--==========================orignal english content==========================
   <para>
    The <quote>escape</quote> format is the traditional
    <productname>PostgreSQL</productname> format for the <type>bytea</type>
    type.  It
    takes the approach of representing a binary string as a sequence
    of ASCII characters, while converting those bytes that cannot be
    represented as an ASCII character into special escape sequences.
    If, from the point of view of the application, representing bytes
    as characters makes sense, then this representation can be
    convenient.  But in practice it is usually confusing because it
    fuzzes up the distinction between binary strings and character
    strings, and also the particular escape mechanism that was chosen is
    somewhat unwieldy.  Therefore, this format should probably be avoided
    for most new applications.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>转义</quote>格式是<type>bytea</type>类型的传统<productname>PostgreSQL</productname>格式。它采用将二进制串表示成ASCII字符序列的方法，而将那些无法用ASCII字符表示的字节转换成特殊的转义语句。从应用的角度来看，如果将字节表示为字符有意义，那么这种表示将很方便。但是在实际中，这常常是令人困扰的，因为它使二进制串和字符串之间的区别变得模糊，并且这种特别的转义机制也有点难于处理。因此这种格式可能会在大部分新应用中避免使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    When entering <type>bytea</type> values in escape format,
    octets of certain
    values <emphasis>must</emphasis> be escaped, while all octet
    values <emphasis>can</emphasis> be escaped.  In
    general, to escape an octet, convert it into its three-digit
    octal value and precede it by a backslash.
    Backslash itself (octet decimal value 92) can alternatively be represented by
    double backslashes.
    <xref linkend="datatype-binary-sqlesc"/>
    shows the characters that must be escaped, and gives the alternative
    escape sequences where applicable.
   </para>
____________________________________________________________________________-->
   <para>
    在转义模式下输入<type>bytea</type>值时，某些值的字节<emphasis>必须</emphasis>被转义，而所有的字节值都<emphasis>可以</emphasis>被转义。通常，要转义一个字节，需要把它转换成与它的三位八进制值， 并且前导一个反斜线。反斜线本身（十进制字节值92）也可以用双写的反斜线表示。<xref linkend="datatype-binary-sqlesc"/>显示了必须被转义的字符，并给出了可以使用的替代转义序列。
   </para>

   <table id="datatype-binary-sqlesc">
<!--==========================orignal english content==========================
    <title><type>bytea</type> Literal Escaped Octets</title>
____________________________________________________________________________-->
    <title><type>bytea</type>文字转义字节</title>
    <tgroup cols="5">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Input Representation</entry>
       <entry>Example</entry>
       <entry>Hex Representation</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>转义输入表示</entry>
       <entry>例子</entry>
       <entry>十六进制表示</entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry>0</entry>
       <entry>zero octet</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>SELECT '\000'::bytea;</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>0</entry>
       <entry>0字节</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>SELECT '\000'::bytea;</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>39</entry>
       <entry>single quote</entry>
       <entry><literal>''''</literal> or <literal>'\047'</literal></entry>
       <entry><literal>SELECT ''''::bytea;</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>39</entry>
       <entry>单引号</entry>
       <entry><literal>''''</literal>或<literal>'\047'</literal></entry>
       <entry><literal>SELECT ''''::bytea;</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>'\\'</literal> or <literal>'\134'</literal></entry>
       <entry><literal>SELECT '\\'::bytea;</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>'\\'</literal>或<literal>'\134'</literal></entry>
       <entry><literal>SELECT '\\'::bytea;</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>'\<replaceable>xxx'</replaceable></literal> (octal value)</entry>
       <entry><literal>SELECT '\001'::bytea;</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>'\<replaceable>xxx'</replaceable></literal>（八进制值）</entry>
       <entry><literal>SELECT '\001'::bytea;</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    The requirement to escape <emphasis>non-printable</emphasis> octets
    varies depending on locale settings. In some instances you can get away
    with leaving them unescaped.
   </para>
____________________________________________________________________________-->
   <para>
    转义<quote>不可打印的</quote>字节的要求取决于区域设置。在某些实例中，你可以不理睬它们，让它们保持未转义的状态。
   </para>

<!--==========================orignal english content==========================
   <para>
    The reason that single quotes must be doubled, as shown
    in <xref linkend="datatype-binary-sqlesc"/>, is that this
    is true for any string literal in a SQL command.  The generic
    string-literal parser consumes the outermost single quotes
    and reduces any pair of single quotes to one data character.
    What the <type>bytea</type> input function sees is just one
    single quote, which it treats as a plain data character.
    However, the <type>bytea</type> input function treats
    backslashes as special, and the other behaviors shown in
    <xref linkend="datatype-binary-sqlesc"/> are implemented by
    that function.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="datatype-binary-sqlesc"/>中所示，要求单引号必须写两次的原因对任何SQL命令中的字符串常量都是一样的。
   文字解析器消耗最外层的单引号，并缩减成对的单引号为一个普通数据字符。
   <type>bytea</type>输入函数看到的只是一个单引号，它将其视为普通数据字符。
   但是，<type>bytea</type>输入函数将反斜杠视为特殊字符，<xref linkend ="datatype-binary-sqlesc"/>中显示的其他行为由该函数实现。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    In some contexts, backslashes must be doubled compared to what is
    shown above, because the generic string-literal parser will also
    reduce pairs of backslashes to one data character;
    see <xref linkend="sql-syntax-strings"/>.
   </para>
____________________________________________________________________________-->
   <para>
    在某些情况下，反斜杠必须加倍，如上所示，因为通用的字符串文字解析器也会
    将一对反斜杠减少为一个数据字符;请参阅<xref linkend ="sql-syntax-strings"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    <type>Bytea</type> octets are output in <literal>hex</literal>
    format by default.  If you change <xref linkend="guc-bytea-output"/>
    to <literal>escape</literal>,
    <quote>non-printable</quote> octets are converted to their
    equivalent three-digit octal value and preceded by one backslash.
    Most <quote>printable</quote> octets are output by their standard
    representation in the client character set, e.g.:

<programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 abc klm *\251T
</programlisting>

    The octet with decimal value 92 (backslash) is doubled in the output.
    Details are in <xref linkend="datatype-binary-resesc"/>.
   </para>
____________________________________________________________________________-->
   <para>
    <type>Bytea</type>字节默认被输出为<literal>hex</literal>格式。如果你把<xref linkend="guc-bytea-output"/>改为<literal>escape</literal>，<quote>不可打印的</quote>字节会被转换成与之等效的三位八进制值并且前置一个反斜线。大部分<quote>可打印的</quote>字节被输出为它们在客户端字符集中的标准表示形式，例如：

<programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
----------------
 abc klm *\251T
</programlisting>

    十进制值为92（反斜线）的字节在输出时被双写。详情请见<xref linkend="datatype-binary-resesc"/>。
   </para>

   <table id="datatype-binary-resesc">
<!--==========================orignal english content==========================
    <title><type>bytea</type> Output Escaped Octets</title>
____________________________________________________________________________-->
    <title><type>bytea</type>输出转义字节</title>
    <tgroup cols="5">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Output Representation</entry>
       <entry>Example</entry>
       <entry>Output Result</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>转义的输出表示</entry>
       <entry>例子</entry>
       <entry>输出结果</entry>
      </row>
     </thead>

     <tbody>

<!--==========================orignal english content==========================
      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT '\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>SELECT '\134'::bytea;</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal> (octal value)</entry>
       <entry><literal>SELECT '\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal>（八进制值）</entry>
       <entry><literal>SELECT '\001'::bytea;</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry>32 to 126</entry>
       <entry><quote>printable</quote> octets</entry>
       <entry>client character set representation</entry>
       <entry><literal>SELECT '\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>32到126</entry>
       <entry><quote>可打印的</quote>字节</entry>
       <entry>客户端字符集表示</entry>
       <entry><literal>SELECT '\176'::bytea;</literal></entry>
       <entry><literal>~</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Depending on the front end to <productname>PostgreSQL</productname> you use,
    you might have additional work to do in terms of escaping and
    unescaping <type>bytea</type> strings. For example, you might also
    have to escape line feeds and carriage returns if your interface
    automatically translates these.
   </para>
____________________________________________________________________________-->
   <para>
    根据你使用的<productname>PostgreSQL</productname>前端，你在转义和未转义<type>bytea</type>串方面可能需要做额外的工作。例如，如果你的接口自动翻译换行和回车，你可能也不得不转义它们。
   </para>
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
<!--==========================orignal english content==========================
   <title>Date/Time Types</title>
____________________________________________________________________________-->
   <title>日期/时间类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>time without time zone</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>time with time zone</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>timestamp with time zone</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间戳</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>timestamp without time zone</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间戳</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>interval</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>间隔</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm zone="datatype-datetime">
    <primary>time span</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>时间跨度</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> supports the full set of
    <acronym>SQL</acronym> date and time types, shown in <xref
    linkend="datatype-datetime-table"/>.  The operations available
    on these data types are described in
    <xref linkend="functions-datetime"/>.
    Dates are counted according to the Gregorian calendar, even in
    years before that calendar was introduced (see <xref
    linkend="datetime-units-history"/> for more information).
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持<acronym>SQL</acronym>中所有的日期和时间类型，如<xref linkend="datatype-datetime-table"/>所示。这些数据类型上可用的操作如<xref linkend="functions-datetime"/>所述。日期根据公历来计算，即使对于该历法被引入之前的年份也一样（见<xref linkend="datetime-units-history"/>）。
   </para>

    <table id="datatype-datetime-table">
<!--==========================orignal english content==========================
     <title>Date/Time Types</title>
____________________________________________________________________________-->
     <title>日期/时间类型</title>
     <tgroup cols="6">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Low Value</entry>
        <entry>High Value</entry>
        <entry>Resolution</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>最小值</entry>
        <entry>最大值</entry>
        <entry>解析度</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 bytes</entry>
        <entry>both date and time (no time zone)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间（无时区）</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1微秒</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 bytes</entry>
        <entry>both date and time, with time zone</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间，有时区</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1微秒</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>date</type></entry>
        <entry>4 bytes</entry>
        <entry>date (no time of day)</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1 day</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>date</type></entry>
        <entry>4字节</entry>
        <entry>日期（没有一天中的时间）</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1日</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 bytes</entry>
        <entry>time of day (no date)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 microsecond</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>一天中的时间（无日期）</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1微秒</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 bytes</entry>
        <entry>time of day (no date), with time zone</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 microsecond</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12字节</entry>
        <entry>仅仅是一天中的时间（没有日期），带有时区</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1微秒</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16 bytes</entry>
        <entry>time interval</entry>
        <entry>-178000000 years</entry>
        <entry>178000000 years</entry>
        <entry>1 microsecond</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16字节</entry>
        <entry>时间间隔</entry>
        <entry>-178000000年</entry>
        <entry>178000000年</entry>
        <entry>1微秒</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     The SQL standard requires that writing just <type>timestamp</type>
     be equivalent to <type>timestamp without time
     zone</type>, and <productname>PostgreSQL</productname> honors that
     behavior.  <type>timestamptz</type> is accepted as an
     abbreviation for <type>timestamp with time zone</type>; this is a
     <productname>PostgreSQL</productname> extension.
    </para>
____________________________________________________________________________-->
    <para>
     SQL要求只写<type>timestamp</type>等效于<type>timestamp without time zone</type>，并且<productname>PostgreSQL</productname>鼓励这种行为。<type>timestamptz</type>被接受为<type>timestamp with time zone</type>的一种简写，这是一种<productname>PostgreSQL</productname>的扩展。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type> accept an optional precision value
    <replaceable>p</replaceable> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <replaceable>p</replaceable> is from 0 to 6.
   </para>
____________________________________________________________________________-->
   <para>
    <type>time</type>、<type>timestamp</type>和<type>interval</type>接受一个可选的精度值 <replaceable>p</replaceable>，这个精度值声明在秒域中小数点之后保留的位数。缺省情况下，在精度上没有明确的边界。<replaceable>p</replaceable>允许的范围是从 0 到 6。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>interval</type> type has an additional option, which is
    to restrict the set of stored fields by writing one of these phrases:
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
    Note that if both <replaceable>fields</replaceable> and
    <replaceable>p</replaceable> are specified, the
    <replaceable>fields</replaceable> must include <literal>SECOND</literal>,
    since the precision applies only to the seconds.
   </para>
____________________________________________________________________________-->
   <para>
    <type>interval</type>类型有一个附加选项，它可以通过写下面之一的短语来限制存储的fields的集合：
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
    注意如果<replaceable>fields</replaceable>和<replaceable>p</replaceable>被指定，<replaceable>fields</replaceable>必须包括<literal>SECOND</literal>，因为精度只应用于秒。
   </para>

<!--==========================orignal english content==========================
   <para>
    The type <type>time with time zone</type> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type>, and <type>timestamp with time zone</type> should
    provide a complete range of date/time functionality required by
    any application.
   </para>
____________________________________________________________________________-->
   <para>
    类型<type>time with time zone</type>是 SQL 标准定义的，但是该定义显示出了一些会影响可用性的性质。在大多数情况下， <type>date</type>、<type>time</type>、<type>timestamp without time zone</type>和<type>timestamp with time zone</type>的组合就应该能提供任何应用所需的全范围的日期/时间功能。
   </para>

<!--==========================orignal english content==========================
   <para>
    The types <type>abstime</type>
    and <type>reltime</type> are lower precision types which are used internally.
    You are discouraged from using these types in
    applications;  these internal types
    might disappear in a future release.
   </para>
____________________________________________________________________________-->
   <para>
    类型<type>abstime</type>和<type>reltime</type>是低精度类型，它们被用于系统内部。 我们不鼓励你在应用里面使用这些类型，这些内部类型可能会在未来的版本里消失。
   </para>

   <sect2 id="datatype-datetime-input">
<!--==========================orignal english content==========================
    <title>Date/Time Input</title>
____________________________________________________________________________-->
    <title> 日期/时间输入</title>

<!--==========================orignal english content==========================
    <para>
     Date and time input is accepted in almost any reasonable format, including
     ISO 8601, <acronym>SQL</acronym>-compatible,
     traditional <productname>POSTGRES</productname>, and others.
     For some formats, ordering of day, month, and year in date input is
     ambiguous and there is support for specifying the expected
     ordering of these fields.  Set the <xref linkend="guc-datestyle"/> parameter
     to <literal>MDY</literal> to select month-day-year interpretation,
     <literal>DMY</literal> to select day-month-year interpretation, or
     <literal>YMD</literal> to select year-month-day interpretation.
    </para>
____________________________________________________________________________-->
    <para>
     日期和时间的输入可以接受几乎任何合理的格式，包括 ISO 8601、<acronym>SQL</acronym>-兼容的、传统<productname>POSTGRES</productname>的和其他的形式。 对于一些格式，日期输入里的日、月和年的顺序会让人混淆， 并且支持指定所预期的这些域的顺序。把<xref linkend="guc-datestyle"/>参数设置为<literal>MDY</literal>，就是选择“月－日－年”的解释，设置为<literal>DMY</literal>就是 “日－月－年”，而<literal>YMD</literal>是 “年－月－日”。
    </para>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> is more flexible in
     handling date/time input than the
     <acronym>SQL</acronym> standard requires.
     See <xref linkend="datetime-appendix"/>
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>在处理日期/时间输入上比<acronym>SQL</acronym>标准要求的更灵活。 参阅<xref linkend="datetime-appendix"/>获取关于日期/时间输入的准确的分析规则和可识别文本域，包括月份、星期几和时区。
    </para>

<!--==========================orignal english content==========================
    <para>
     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to
     <xref linkend="sql-syntax-constants-generic"/> for more
     information.
     <acronym>SQL</acronym> requires the following syntax
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     where <replaceable>p</replaceable> is an optional precision
     specification giving the number of
     fractional digits in the seconds field. Precision can be
     specified for <type>time</type>, <type>timestamp</type>, and
     <type>interval</type> types, and can range from 0 to 6.
     If no precision is specified in a constant specification,
     it defaults to the precision of the literal value (but not
     more than 6 digits).
    </para>
____________________________________________________________________________-->
    <para>
     请记住任何日期或者时间的文字输入需要由单引号包围，就象一个文本字符串一样。参考<xref linkend="sql-syntax-constants-generic"/>获取更多信息。<acronym>SQL</acronym>要求下面的语法
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     其中<replaceable>p</replaceable>是一个可选的精度声明，它给出了在秒域中的小数位数目。精度可以被指定给<type>time</type>、<type>timestamp</type>和<type>interval</type>类型，并且可以取从0到6的值。这允许前文所述的值。如果在一个常数声明中没有指定任何精度，它将默认取文字值的精度（但不能超过6位）。
    </para>

    <sect3>
<!--==========================orignal english content==========================
    <title>Dates</title>
____________________________________________________________________________-->
    <title>日期</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>date</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>date</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="datatype-datetime-date-table"/> shows some possible
     inputs for the <type>date</type> type.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="datatype-datetime-date-table"/>显示了<type>date</type>类型可能的输入方式。
    </para>

     <table id="datatype-datetime-date-table">
<!--==========================orignal english content==========================
      <title>Date Input</title>
____________________________________________________________________________-->
      <title>日期输入</title>
      <tgroup cols="2">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Example</entry>
         <entry>Description</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; January 8 in any mode
         (recommended format)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; 任何模式下的1月8日
         （推荐格式）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>January 8, 1999</entry>
         <entry>unambiguous in any <varname>datestyle</varname> input mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>January 8, 1999</entry>
         <entry>在任何<varname>datestyle</varname>输入模式下都无歧义</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>1/8/1999</entry>
         <entry>January 8 in <literal>MDY</literal> mode;
          August 1 in <literal>DMY</literal> mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1/8/1999</entry>
         <entry><literal>MDY</literal>模式中的1月8日；<literal>DMY</literal>模式中的8月1日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>1/18/1999</entry>
         <entry>January 18 in <literal>MDY</literal> mode;
          rejected in other modes</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1/18/1999</entry>
         <entry><literal>MDY</literal>模式中的1月18日；在其他模式中被拒绝</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>01/02/03</entry>
         <entry>January 2, 2003 in <literal>MDY</literal> mode;
          February 1, 2003 in <literal>DMY</literal> mode;
          February 3, 2001 in <literal>YMD</literal> mode
         </entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>01/02/03</entry>
         <entry><literal>MDY</literal>模式中的2003年1月2日；
          <literal>DMY</literal>模式中的2003年2月1日；
          <literal>YMD</literal>模式中的2001年2月3日
         </entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>1999-Jan-08</entry>
         <entry>January 8 in any mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1999-Jan-08</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Jan-08-1999</entry>
         <entry>January 8 in any mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>Jan-08-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>08-Jan-1999</entry>
         <entry>January 8 in any mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>08-Jan-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>99-Jan-08</entry>
         <entry>January 8 in <literal>YMD</literal> mode, else error</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>99-Jan-08</entry>
         <entry><literal>YMD</literal>模式中的1月8日，否则错误</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>08-Jan-99</entry>
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>08-Jan-99</entry>
         <entry>1月8日，除了在<literal>YMD</literal>模式中错误</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>Jan-08-99</entry>
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>Jan-08-99</entry>
         <entry>1月8日，除了在<literal>YMD</literal>模式中错误</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>1999.008</entry>
         <entry>year and day of year</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1999.008</entry>
         <entry>年和一年中的日子</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>J2451187</entry>
         <entry>Julian date</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>J2451187</entry>
         <entry>儒略日期</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>year 99 BC</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>公元前99年</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Times</title>
____________________________________________________________________________-->
     <title>时间</title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>time</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>time</primary>
     </indexterm>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The time-of-day types are <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> and
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>.  <type>time</type> alone is equivalent to
      <type>time without time zone</type>.
     </para>
____________________________________________________________________________-->
     <para>
      当日时间类型是<type>time [ (<replaceable>p</replaceable>) ] without time zone</type>和<type>time [ (<replaceable>p</replaceable>) ] with time zone</type>。 只写<type>time</type>等效于<type>time without time zone</type>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Valid input for these types consists of a time of day followed
      by an optional time zone. (See <xref
      linkend="datatype-datetime-time-table"/>
      and <xref linkend="datatype-timezone-table"/>.)  If a time zone is
      specified in the input for <type>time without time zone</type>,
      it is silently ignored. You can also specify a date but it will
      be ignored, except when you use a time zone name that involves a
      daylight-savings rule, such as
      <literal>America/New_York</literal>. In this case specifying the date
      is required in order to determine whether standard or daylight-savings
      time applies.  The appropriate time zone offset is recorded in the
      <type>time with time zone</type> value.
     </para>
____________________________________________________________________________-->
     <para>
      这些类型的有效输入由当日时间后面跟着可选的时区组成（参阅<xref linkend="datatype-datetime-time-table"/>和<xref linkend="datatype-timezone-table"/>）。 如果在<type>time without time zone</type>的输入中指定了时区，那么它会被无声地忽略。你也可以指定一个日期但是它会被忽略，除非你使用了一个涉及到夏令时规则的时区，例如<literal>America/New_York</literal>。在这种情况下，为了判断是应用了标准时间还是夏令时时间，要求指定该日期。适当的时区偏移被记录在<type>time with time zone</type>值中。
     </para>

      <table id="datatype-datetime-time-table">
<!--==========================orignal english content==========================
       <title>Time Input</title>
____________________________________________________________________________-->
       <title>时间输入</title>
       <tgroup cols="2">
        <thead>
<!--==========================orignal english content==========================
         <row>
          <entry>Example</entry>
          <entry>Description</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>same as 04:05; AM does not affect value</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>和04:05一样，AM并不影响值</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>same as 16:05; input hour must be &lt;= 12</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>和16:05一样，输入的小时必须为 &lt;= 12</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>time zone specified by abbreviation</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>缩写指定的时区</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>time zone specified by full name</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>全名指定的时区</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
<!--==========================orignal english content==========================
       <title>Time Zone Input</title>
____________________________________________________________________________-->
       <title>时区输入</title>
       <tgroup cols="2">
        <thead>
<!--==========================orignal english content==========================
         <row>
          <entry>Example</entry>
          <entry>Description</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>PST</literal></entry>
          <entry>Abbreviation (for Pacific Standard Time)</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>PST</literal></entry>
          <entry>缩写（太平洋标准时间）</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>Full time zone name</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>完整时区名</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>POSIX-style time zone specification</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>POSIX风格的时区声明</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>ISO-8601 offset for PST</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>-800</literal></entry>
          <entry>ISO-8601 offset for PST</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>-800</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>-8</literal></entry>
          <entry>ISO-8601 offset for PST</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>-8</literal></entry>
          <entry>PST的ISO-8601偏移</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Military abbreviation for UTC</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>UTC的军方缩写</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>z</literal></entry>
          <entry>Short form of <literal>zulu</literal></entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>z</literal></entry>
          <entry><literal>zulu</literal>的短形式</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

<!--==========================orignal english content==========================
     <para>
     Refer to <xref linkend="datatype-timezones"/> for more information on how
     to specify time zones.
    </para>
____________________________________________________________________________-->
     <para>
     参考<xref linkend="datatype-timezones"/>可以了解如何指定时区。
    </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
    <title>Time Stamps</title>
____________________________________________________________________________-->
    <title>时间戳</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>timestamp</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>timestamp</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>

<!--==========================orignal english content==========================
     <para>
      Valid input for the time stamp types consists of the concatenation
      of a date and a time, followed by an optional time zone,
      followed by an optional <literal>AD</literal> or <literal>BC</literal>.
      (Alternatively, <literal>AD</literal>/<literal>BC</literal> can appear
      before the time zone, but this is not the preferred ordering.)
      Thus:

<programlisting>
1999-01-08 04:05:06
</programlisting>
      and:
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      are valid values, which follow the <acronym>ISO</acronym> 8601
      standard.  In addition, the common format:
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      is supported.
     </para>
____________________________________________________________________________-->
     <para>
      时间戳类型的有效输入由一个日期和时间的串接组成，后面跟着一个可选的时区，一个可选的<literal>AD</literal>或者<literal>BC</literal>（另外，<literal>AD</literal>/<literal>BC</literal>可以出现在时区前面，但这个顺序并非最佳）。 因此：

<programlisting>
1999-01-08 04:05:06
</programlisting>
      和：
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      都是有效的值，它遵循<acronym>ISO</acronym> 8601 标准。另外，使用广泛的格式：
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      也被支持。
     </para>

<!--==========================orignal english content==========================
     <para>
      The <acronym>SQL</acronym> standard differentiates
      <type>timestamp without time zone</type>
      and <type>timestamp with time zone</type> literals by the presence of a
      <quote>+</quote> or <quote>-</quote> symbol and time zone offset after
      the time.  Hence, according to the standard,

      <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>

      is a <type>timestamp without time zone</type>, while

      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>

      is a <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> never examines the content of a
      literal string before determining its type, and therefore will treat
      both of the above as <type>timestamp without time zone</type>.  To
      ensure that a literal is treated as <type>timestamp with time
      zone</type>, give it the correct explicit type:

      <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>

      In a literal that has been determined to be <type>timestamp without time
      zone</type>, <productname>PostgreSQL</productname> will silently ignore
      any time zone indication.
      That is, the resulting value is derived from the date/time
      fields in the input value, and is not adjusted for time zone.
     </para>
____________________________________________________________________________-->
     <para>
      <acronym>SQL</acronym>标准通过<quote>+</quote>或者<quote>-</quote>符号的存在以及时间后面的时区偏移来区分<type>timestamp without time zone</type>和<type>timestamp with time zone</type>文字。因此，根据标准，

      <programlisting>TIMESTAMP '2004-10-19 10:23:54'</programlisting>

      是一个<type>timestamp without time zone</type>， 而

      <programlisting>TIMESTAMP '2004-10-19 10:23:54+02'</programlisting>

      是一个<type>timestamp with time zone</type>。<productname>PostgreSQL</productname>从来不会在确定文字串的类型之前检查其内容，因此会把上面两个都看做是 <type>timestamp without time zone</type>。因此要保证把上面的文字当作<type>timestamp with time zone</type>看待， 就要给它正确的显式类型：

      <programlisting>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</programlisting>

      如果一个文字已被确定是<type>timestamp without time zone</type>，<productname>PostgreSQL</productname>将不声不响忽略任何其中指出的时区。 即，结果值是从输入值的日期/时间域衍生出来的，并且没有就时区进行调整。
     </para>

<!--==========================orignal english content==========================
     <para>
      For <type>timestamp with time zone</type>, the internally stored
      value is always in UTC (Universal
      Coordinated Time, traditionally known as Greenwich Mean Time,
      <acronym>GMT</acronym>).  An input value that has an explicit
      time zone specified is converted to UTC using the appropriate offset
      for that time zone.  If no time zone is stated in the input string,
      then it is assumed to be in the time zone indicated by the system's
      <xref linkend="guc-timezone"/> parameter, and is converted to UTC using the
      offset for the <varname>timezone</varname> zone.
     </para>
____________________________________________________________________________-->
     <para>
      对于<type>timestamp with time zone</type>，内部存储的值总是 UTC （全球统一时间，以前也叫格林威治时间<acronym>GMT</acronym>）。如果一个输入值有明确的时区声明， 那么它将用该时区合适的偏移量转换成 UTC。如果在输入串里没有时区声明， 那么它就被假设是在系统的<xref linkend="guc-timezone"/>参数里的那个时区，然后使用这个 <varname>timezone</varname>时区的偏移转换成 UTC。
     </para>

<!--==========================orignal english content==========================
     <para>
      When a <type>timestamp with time
      zone</type> value is output, it is always converted from UTC to the
      current <varname>timezone</varname> zone, and displayed as local time in that
      zone.  To see the time in another time zone, either change
      <varname>timezone</varname> or use the <literal>AT TIME ZONE</literal> construct
      (see <xref linkend="functions-datetime-zoneconvert"/>).
     </para>
____________________________________________________________________________-->
     <para>
      如果一个<type>timestamp with time zone</type>值被输出，那么它总是从 UTC 转换成当前的<varname>timezone</varname>时区，并且显示为该时区的本地时间。要看其它时区的时间，要么修改<varname>timezone</varname>，要么使用<literal>AT TIME ZONE</literal>构造（参阅<xref linkend="functions-datetime-zoneconvert"/>）。
     </para>

<!--==========================orignal english content==========================
     <para>
      Conversions between <type>timestamp without time zone</type> and
      <type>timestamp with time zone</type> normally assume that the
      <type>timestamp without time zone</type> value should be taken or given
      as <varname>timezone</varname> local time.  A different time zone can
      be specified for the conversion using <literal>AT TIME ZONE</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      在<type>timestamp without time zone</type>和<type>timestamp with time zone</type>之间的转换通常假设<type>timestamp without time zone</type>值应该以<varname>timezone</varname>本地时间的形式接受或者写出。为该转换指定一个不同的可以用<literal>AT TIME ZONE</literal>。
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Special Values</title>
____________________________________________________________________________-->
     <title>特殊值</title>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>

<!--==========================orignal english content==========================
     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      <productname>PostgreSQL</productname> supports several
      special date/time input values for convenience, as shown in <xref
      linkend="datatype-datetime-special-table"/>.  The values
      <literal>infinity</literal> and <literal>-infinity</literal>
      are specially represented inside the system and will be displayed
      unchanged; but the others are simply notational shorthands
      that will be converted to ordinary date/time values when read.
      (In particular, <literal>now</literal> and related strings are converted
      to a specific time value as soon as they are read.)
      All of these values need to be enclosed in single quotes when used
      as constants in SQL commands.
     </para>
____________________________________________________________________________-->
     <para>
      为了方便，<productname>PostgreSQL</productname>支持一些特殊日期/时间输入值，如<xref linkend="datatype-datetime-special-table"/>所示。这些值中<literal>infinity</literal>和<literal>-infinity</literal>被在系统内部以特殊方式表示并且将被原封不动地显示。但是其他的仅仅只是概念上的速写，当被读到的时候会被转换为正常的日期/时间值（特殊地，<literal>now</literal>及相关串在被读到时立刻被转换到一个指定的时间值）。在作为常量在SQL命令中使用时，所有这些值需要被包括在单引号内。
     </para>

      <table id="datatype-datetime-special-table">
<!--==========================orignal english content==========================
       <title>Special Date/Time Inputs</title>
____________________________________________________________________________-->
       <title>特殊日期/时间输入</title>
       <tgroup cols="3">
        <thead>
<!--==========================orignal english content==========================
         <row>
          <entry>Input String</entry>
          <entry>Valid Types</entry>
          <entry>Description</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry>输入串</entry>
          <entry>合法类型</entry>
          <entry>描述</entry>
         </row>
        </thead>
        <tbody>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00 (Unix system time zero)</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00（Unix系统时间0）</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>later than all other time stamps</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都晚</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>earlier than all other time stamps</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都早</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>current transaction's start time</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>当前事务的开始时间</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight today</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>当日午夜</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight tomorrow</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>明日午夜</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight yesterday</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>昨日午夜</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

<!--==========================orignal english content==========================
     <para>
      The following <acronym>SQL</acronym>-compatible functions can also
      be used to obtain the current time value for the corresponding data
      type:
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
      <literal>LOCALTIMESTAMP</literal>.  The latter four accept an
      optional subsecond precision specification.  (See <xref
      linkend="functions-datetime-current"/>.)  Note that these are
      SQL functions and are <emphasis>not</emphasis> recognized in data input strings.
     </para>
____________________________________________________________________________-->
     <para>
      下列<acronym>SQL</acronym>-兼容的函数可以被用来为相应的数据类型获得当前时间值：
      <literal>CURRENT_DATE</literal>、<literal>CURRENT_TIME</literal>、
      <literal>CURRENT_TIMESTAMP</literal>、<literal>LOCALTIME</literal>、
      <literal>LOCALTIMESTAMP</literal>。后四种接受一个可选的亚秒精度声明（参见<xref
      linkend="functions-datetime-current"/>）。注意这些是SQL函数并且在数据输入串中<emphasis>不</emphasis>被识别。
     </para>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
<!--==========================orignal english content==========================
    <title>Date/Time Output</title>
____________________________________________________________________________-->
    <title>日期/时间输出</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>date</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>date</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>time</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>time</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The output format of the date/time types can be set to one of the four
     styles ISO 8601,
     <acronym>SQL</acronym> (Ingres), traditional <productname>POSTGRES</productname>
     (Unix <application>date</application> format), or
     German.  The default
     is the <acronym>ISO</acronym> format.  (The
     <acronym>SQL</acronym> standard requires the use of the ISO 8601
     format.  The name of the <quote>SQL</quote> output format is a
     historical accident.)  <xref
     linkend="datatype-datetime-output-table"/> shows examples of each
     output style.  The output of the <type>date</type> and
     <type>time</type> types is generally only the date or time part
     in accordance with the given examples.  However, the
     <productname>POSTGRES</productname> style outputs date-only values in
     <acronym>ISO</acronym> format.
    </para>
____________________________________________________________________________-->
    <para>
     时间/日期类型的输出格式可以设成四种风格之一： ISO 8601、<acronym>SQL</acronym>（Ingres）、传统的<productname>POSTGRES</productname>（Unix的<application>date</application>格式）或 German 。缺省是<acronym>ISO</acronym>格式（<acronym>ISO</acronym>标准要求使用 ISO 8601 格式。<acronym>ISO</acronym>输出格式的名字是历史偶然）。<xref linkend="datatype-datetime-output-table"/>显示了每种输出风格的例子。<type>date</type>和<type>time</type>类型的 输出通常只有日期或时间部分和例子中一致。不过，<productname>POSTGRES</productname>风格输出的是<acronym>ISO</acronym>格式的只有日期的值。
    </para>

     <table id="datatype-datetime-output-table">
<!--==========================orignal english content==========================
      <title>Date/Time Output Styles</title>
____________________________________________________________________________-->
      <title>日期/时间输出风格</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Style Specification</entry>
         <entry>Description</entry>
         <entry>Example</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>风格声明</entry>
         <entry>描述</entry>
         <entry>例子</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, SQL standard</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, SQL标准</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>traditional style</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>传统风格</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>original style</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>原始风格</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>German</literal></entry>
         <entry>regional style</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>German</literal></entry>
         <entry>地区风格</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note>
<!--==========================orignal english content==========================
     <para>
      ISO 8601 specifies the use of uppercase letter <literal>T</literal> to separate
      the date and time.  <productname>PostgreSQL</productname> accepts that format on
      input, but on output it uses a space rather than <literal>T</literal>, as shown
      above.  This is for readability and for consistency with RFC 3339 as
      well as some other database systems.
     </para>
____________________________________________________________________________-->
     <para>
      ISO 8601指定使用大写字母<literal>T</literal>来分隔日期和时间。<productname>PostgreSQL</productname>在输入上接受这种格式，但是在输出时它采用一个空格而不是<literal>T</literal>，如上所示。和一些其他数据库系统一样，这是为了可读性以及与RFC 3339的一致性。
     </para>
    </note>

<!--==========================orignal english content==========================
    <para>
     In the <acronym>SQL</acronym> and POSTGRES styles, day appears before
     month if DMY field ordering has been specified, otherwise month appears
     before day.
     (See <xref linkend="datatype-datetime-input"/>
     for how this setting also affects interpretation of input values.)
     <xref linkend="datatype-datetime-output2-table"/> shows examples.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>和POSTGRES风格中，如果DMY域顺序被指定，“日”将出现在“月”之前，否则“月”出现在“日”之前（有关该设置如何影响输入值的解释，请参考<xref linkend="datatype-datetime-input"/>）。<xref linkend="datatype-datetime-output2-table"/>给出了例子。
    </para>

     <table id="datatype-datetime-output2-table">
<!--==========================orignal english content==========================
      <title>Date Order Conventions</title>
____________________________________________________________________________-->
      <title>日期顺序习惯</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry><varname>datestyle</varname> Setting</entry>
         <entry>Input Ordering</entry>
         <entry>Example Output</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><varname>datestyle</varname>设置</entry>
         <entry>输入顺序</entry>
         <entry>例子输出</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>month</replaceable>/<replaceable>day</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>月</replaceable>/<replaceable>日</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
    <para>
     The date/time style can be selected by the user using the
     <command>SET datestyle</command> command, the <xref
     linkend="guc-datestyle"/> parameter in the
     <filename>postgresql.conf</filename> configuration file, or the
     <envar>PGDATESTYLE</envar> environment variable on the server or
     client.
    </para>
____________________________________________________________________________-->
    <para>
     日期/时间风格可以由用户使用<command>SET datestyle</command>命令选取，在<filename>postgresql.conf</filename>配置文件里的参数<xref linkend="guc-datestyle"/>设置或者在服务器或客户端的<envar>PGDATESTYLE</envar>环境变量里设置。
    </para>

<!--==========================orignal english content==========================
    <para>
     The formatting function <function>to_char</function>
     (see <xref linkend="functions-formatting"/>) is also available as
     a more flexible way to format date/time output.
    </para>
____________________________________________________________________________-->
    <para>
     格式化函数<function>to_char</function>（见<xref linkend="functions-formatting"/>）也可以作为一个更灵活的方式来格式化日期/时间输出。
    </para>
   </sect2>

   <sect2 id="datatype-timezones">
<!--==========================orignal english content==========================
    <title>Time Zones</title>
____________________________________________________________________________-->
    <title> 时区</title>

<!--==========================orignal english content==========================
    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>

<!--==========================orignal english content==========================
   <para>
    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900s,
    but continue to be prone to arbitrary changes, particularly with
    respect to daylight-savings rules.
    <productname>PostgreSQL</productname> uses the widely-used
    IANA (Olson) time zone database for information about
    historical time zone rules.  For times in the future, the assumption
    is that the latest known rules for a given time zone will
    continue to be observed indefinitely far into the future.
   </para>
____________________________________________________________________________-->
   <para>
    时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。 到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，部分是因为夏时制规
    则。<productname>PostgreSQL</productname>使用广泛使用的 IANA (Olson) 时区数据库来得到有关历史时区规则的信息。对于未来的时间，我们假设关于一个给定时区的最新已知
    规则将会一直持续到无穷远的未来。
   </para>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> endeavors to be compatible with
     the <acronym>SQL</acronym> standard definitions for typical usage.
     However, the <acronym>SQL</acronym> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:

     <itemizedlist>
      <listitem>
       <para>
        Although the <type>date</type> type
        cannot have an associated time zone, the
        <type>time</type> type can.
        Time zones in the real world have little meaning unless
        associated with a date as well as a time,
        since the offset can vary through the year with daylight-saving
        time boundaries.
       </para>
      </listitem>

      <listitem>
       <para>
        The default time zone is specified as a constant numeric offset
        from <acronym>UTC</acronym>. It is therefore impossible to adapt to
        daylight-saving time when doing date/time arithmetic across
        <acronym>DST</acronym> boundaries.
       </para>
      </listitem>

     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>努力在典型使用中与<acronym>SQL</acronym>标准的定义相兼容。但<acronym>SQL</acronym>标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：

     <itemizedlist>
      <listitem>
       <para>
        尽管<type>date</type>类型与时区没有联系，而<type>time</type>类型却可以有。 然而，现实世界的时区只有在与时间和日期都关联时才有意义， 因为偏移（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。
       </para>
      </listitem>

      <listitem>
       <para>
        缺省的时区会指定一个到<acronym>UTC</acronym>的数字常量偏移（时差）。因此，当跨<acronym>DST</acronym>边界做日期/时间算术时， 我们根本不可能适应于夏时制时间。
       </para>
      </listitem>

     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     do <emphasis>not</emphasis> recommend using the type <type>time with
     time zone</type> (though it is supported by
     <productname>PostgreSQL</productname> for legacy applications and
     for compliance with the <acronym>SQL</acronym> standard).
     <productname>PostgreSQL</productname> assumes
     your local time zone for any type containing only date or time.
    </para>
____________________________________________________________________________-->
    <para>
     为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。我们<emphasis>不</emphasis>建议使用类型 <type>time with time zone</type> （尽管<productname>PostgreSQL</productname>出于遗留应用以及与<acronym>SQL</acronym>标准兼容性的考虑支持这个类型）。 <productname>PostgreSQL</productname>假设你用于任何类型的本地时区都只包含日期或时间。
    </para>

<!--==========================orignal english content==========================
    <para>
     All timezone-aware dates and times are stored internally in
     <acronym>UTC</acronym>.  They are converted to local time
     in the zone specified by the <xref linkend="guc-timezone"/> configuration
     parameter before being displayed to the client.
    </para>
____________________________________________________________________________-->
    <para>
     在系统内部，所有时区相关的日期和时间都用<acronym>UTC</acronym>存储。它们在被显示给客户端之前会被转换成由<xref linkend="guc-timezone"/>配置参数指定的本地时间。
    </para>

<!--==========================orignal english content==========================
    <para>
     <productname>PostgreSQL</productname> allows you to specify time zones in
     three different forms:
     <itemizedlist>
      <listitem>
       <para>
        A full time zone name, for example <literal>America/New_York</literal>.
        The recognized time zone names are listed in the
        <literal>pg_timezone_names</literal> view (see <xref
        linkend="view-pg-timezone-names"/>).
        <productname>PostgreSQL</productname> uses the widely-used IANA
        time zone data for this purpose, so the same time zone
        names are also recognized by other software.
       </para>
      </listitem>
      <listitem>
       <para>
        A time zone abbreviation, for example <literal>PST</literal>.  Such a
        specification merely defines a particular offset from UTC, in
        contrast to full time zone names which can imply a set of daylight
        savings transition-date rules as well.  The recognized abbreviations
        are listed in the <literal>pg_timezone_abbrevs</literal> view (see <xref
        linkend="view-pg-timezone-abbrevs"/>).  You cannot set the
        configuration parameters <xref linkend="guc-timezone"/> or
        <xref linkend="guc-log-timezone"/> to a time
        zone abbreviation, but you can use abbreviations in
        date/time input values and with the <literal>AT TIME ZONE</literal>
        operator.
       </para>
      </listitem>
      <listitem>
       <para>
        In addition to the timezone names and abbreviations,
        <productname>PostgreSQL</productname> will accept POSIX-style time zone
        specifications of the form <replaceable>STD</replaceable><replaceable>offset</replaceable> or
        <replaceable>STD</replaceable><replaceable>offset</replaceable><replaceable>DST</replaceable>, where
        <replaceable>STD</replaceable> is a zone abbreviation, <replaceable>offset</replaceable> is a
        numeric offset in hours west from UTC, and <replaceable>DST</replaceable> is an
        optional daylight-savings zone abbreviation, assumed to stand for one
        hour ahead of the given offset. For example, if <literal>EST5EDT</literal>
        were not already a recognized zone name, it would be accepted and would
        be functionally equivalent to United States East Coast time.  In this
        syntax, a zone abbreviation can be a string of letters, or an
        arbitrary string surrounded by angle brackets (<literal>&lt;&gt;</literal>).
        When a daylight-savings zone abbreviation is present,
        it is assumed to be used
        according to the same daylight-savings transition rules used in the
        IANA time zone database's <filename>posixrules</filename> entry.
        In a standard <productname>PostgreSQL</productname> installation,
        <filename>posixrules</filename> is the same as <literal>US/Eastern</literal>, so
        that POSIX-style time zone specifications follow USA daylight-savings
        rules.  If needed, you can adjust this behavior by replacing the
        <filename>posixrules</filename> file.
       </para>
      </listitem>
     </itemizedlist>

     In short, this is the difference between abbreviations
     and full names: abbreviations represent a specific offset from UTC,
     whereas many of the full names imply a local daylight-savings time
     rule, and so have two possible UTC offsets.  As an example,
     <literal>2014-06-04 12:00 America/New_York</literal> represents noon local
     time in New York, which for this particular date was Eastern Daylight
     Time (UTC-4).  So <literal>2014-06-04 12:00 EDT</literal> specifies that
     same time instant.  But <literal>2014-06-04 12:00 EST</literal> specifies
     noon Eastern Standard Time (UTC-5), regardless of whether daylight
     savings was nominally in effect on that date.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>允许你使用三种不同形式指定时区：
     <itemizedlist>
      <listitem>
       <para>
        一个完整的时区名字，例如<literal>America/New_York</literal>。能被识别的时区名字被列在<literal>pg_timezone_names</literal>视图中（参见<xref linkend="view-pg-timezone-names"/>）。<productname>PostgreSQL</productname>用广泛使用的 IANA 时区数据来实现该目的，因此相同的时区名字也可以在其他软件中被识别。
       </para>
      </listitem>
      <listitem>
       <para>
        一个时区缩写，例如<literal>PST</literal>。这样一种声明仅仅定义了到UTC的一个特定偏移，而不像完整时区名那样指出整套夏令时转换日期规则。能被识别的缩写被列在<literal>pg_timezone_abbrevs</literal>视图中（参见<xref linkend="view-pg-timezone-abbrevs"/>）。你不能将配置参数<xref linkend="guc-timezone"/>或<xref linkend="guc-log-timezone"/>设置成一个时区缩写，但是你可以在日期/时间输入值和<literal>AT TIME ZONE</literal>操作符中使用时区缩写。
       </para>
      </listitem>
      <listitem>
       <para>
        除了时区名和缩写，<productname>PostgreSQL</productname>将接受POSIX-风格的
        时区声明，形式为<replaceable>STD</replaceable><replaceable>offset</replaceable>或
        <replaceable>STD</replaceable><replaceable>offset</replaceable><replaceable>DST</replaceable>，
        其中<replaceable>STD</replaceable>是一个区域缩写、<replaceable>offset</replaceable>是从UTC西
        起的以小时计的数字偏移量、<replaceable>DST</replaceable>是一个可选的夏令时区域缩
        写（被假定为给定偏移量提前一小时）。例如，如果<literal>EST5EDT</literal>还不是一
        个被识别的区域名，它可以被接受并且可能和美国东海岸时间的功效相同。在这种语法中，
        一个时区缩写可以是一个字母的字符串或者由尖括号（<literal>&lt;&gt;</literal>）包围
        的任意字符串。当一个夏令时区域缩写出现时，会假定根据 IANA 时区数据库的
        <filename>posixrules</filename>条目中使用的同一个夏令时转换规则使用它。
        在一个标准的<productname>PostgreSQL</productname>安装中，
        <filename>posixrules</filename>和<literal>US/Eastern</literal>相同，
        因此POSIX-风格的时区声明遵循美国的夏令时规则。如果需要，你可以通过替换
        <filename>posixrules</filename>文件来调整这种行为。
       </para>
      </listitem>
     </itemizedlist>

     简而言之，在缩写和全称之间是有不同的：缩写表示从UTC开始的一个特定偏移量，
     而很多全称表示一个本地夏令时规则并且因此具有两种可能的UTC偏移量。例如，
     <literal>2014-06-04 12:00 America/New_York</literal>表示纽约本地时间的中午，
     这个特殊的日期是东部夏令时间（UTC-4）。因此<literal>2014-06-04 12:00 EDT</literal>
     指定的是同一个时间点。但是<literal>2014-06-04 12:00 EST</literal>指定东部标准时间的
     中午（UTC-5），不管在那个日期夏令时是否生效。
    </para>

<!--==========================orignal english content==========================
    <para>
     To complicate matters, some jurisdictions have used the same timezone
     abbreviation to mean different UTC offsets at different times; for
     example, in Moscow <literal>MSK</literal> has meant UTC+3 in some years and
     UTC+4 in others.  <application>PostgreSQL</application> interprets such
     abbreviations according to whatever they meant (or had most recently
     meant) on the specified date; but, as with the <literal>EST</literal> example
     above, this is not necessarily the same as local civil time on that date.
    </para>
____________________________________________________________________________-->
    <para>
     更要命的是，某些行政区已经使用相同的时区缩写在不同的时间表示不同的 UTC 偏移量。例如，
     在莫斯科<literal>MSK</literal>在某些年份表示 UTC+3 而在另一些年份表示 UTC+4。 <application>PostgreSQL</application> 会根据在指定的日期它们到底表示什么（或者最近表示什么）
     来解释这种缩写。但是，正如上面的<literal>EST</literal>例子所示，这并不是必须和那一天的本地
     标准时间相同。
    </para>

<!--==========================orignal english content==========================
    <para>
     One should be wary that the POSIX-style time zone feature can
     lead to silently accepting bogus input, since there is no check on the
     reasonableness of the zone abbreviations.  For example, <literal>SET
     TIMEZONE TO FOOBAR0</literal> will work, leaving the system effectively using
     a rather peculiar abbreviation for UTC.
     Another issue to keep in mind is that in POSIX time zone names,
     positive offsets are used for locations <emphasis>west</emphasis> of Greenwich.
     Everywhere else, <productname>PostgreSQL</productname> follows the
     ISO-8601 convention that positive timezone offsets are <emphasis>east</emphasis>
     of Greenwich.
    </para>
____________________________________________________________________________-->
    <para>
     你应该注意到POSIX-风格的时区特性可能导致伪造的输入被接受，因为它没有对区域缩写合理性的检查。例如<literal>SET TIMEZONE TO FOOBAR0</literal>将会正常工作，让系统实际使用一个相当奇怪的UTC缩写。另一个需要记住的问题是在POSIX时区名中，正值的偏移量被用于格林威治<emphasis>以西</emphasis>的位置。在其他情况下，<productname>PostgreSQL</productname>将遵循 ISO-8601 惯例，认为正值的时区偏移量是格林威治<emphasis>以东</emphasis>。
    </para>

<!--==========================orignal english content==========================
    <para>
     In all cases, timezone names and abbreviations are recognized
     case-insensitively.  (This is a change from <productname>PostgreSQL</productname>
     versions prior to 8.2, which were case-sensitive in some contexts but
     not others.)
    </para>
____________________________________________________________________________-->
    <para>
     在所有情况下，时区名及其缩写都是大小写不敏感的（这是对<productname>PostgreSQL</productname> 8.2之前版本的一个修改，在这些版本中某些环境下时区名是大小写敏感的而在另外一些环境中却是大小写不敏感的）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Neither timezone names nor abbreviations are hard-wired into the server;
     they are obtained from configuration files stored under
     <filename>.../share/timezone/</filename> and <filename>.../share/timezonesets/</filename>
     of the installation directory
     (see <xref linkend="datetime-config-files"/>).
    </para>
____________________________________________________________________________-->
    <para>
     时区名和缩写都不是硬写在服务器中的，它们是从存储在安装目录下的<filename>.../share/timezone/</filename>和<filename>.../share/timezonesets/</filename>子目录中获取的（参见<xref linkend="datetime-config-files"/>）。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <xref linkend="guc-timezone"/> configuration parameter can
     be set in the file <filename>postgresql.conf</filename>, or in any of the
     other standard ways described in <xref linkend="runtime-config"/>.
     There are also some special ways to set it:

     <itemizedlist>
      <listitem>
       <para>
        The <acronym>SQL</acronym> command <command>SET TIME ZONE</command>
        sets the time zone for the session.  This is an alternative spelling
        of <command>SET TIMEZONE TO</command> with a more SQL-spec-compatible syntax.
       </para>
      </listitem>

      <listitem>
       <para>
        The <envar>PGTZ</envar> environment variable is used by
        <application>libpq</application> clients
        to send a <command>SET TIME ZONE</command>
        command to the server upon connection.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="guc-timezone"/>配置参数可以在文件<filename>postgresql.conf</filename>中被设置，或者使用<xref linkend="runtime-config"/>中描述的任何一种标准方法设置。同时也有一些特殊的方法来设置它：

     <itemizedlist>
      <listitem>
       <para>
        <acronym>SQL</acronym>命令<command>SET TIME ZONE</command>为会话设置时区。它是<command>SET TIMEZONE TO</command>的另一种拼写，它更加符合SQL的语法。
       </para>
      </listitem>

      <listitem>
       <para>
        <application>libpq</application>客户端使用<envar>PGTZ</envar>环境变量来通过连接发送一个<command>SET TIME ZONE</command>命令给服务器。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect2>

   <sect2 id="datatype-interval-input">
<!--==========================orignal english content==========================
    <title>Interval Input</title>
____________________________________________________________________________-->
    <title>间隔输入</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>interval</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>interval</primary>
    </indexterm>

<!--==========================orignal english content==========================
     <para>
      <type>interval</type> values can be written using the following
      verbose syntax:

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

     where <replaceable>quantity</replaceable> is a number (possibly signed);
     <replaceable>unit</replaceable> is <literal>microsecond</literal>,
     <literal>millisecond</literal>, <literal>second</literal>,
     <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
     <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
     <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
     or abbreviations or plurals of these units;
     <replaceable>direction</replaceable> can be <literal>ago</literal> or
     empty.  The at sign (<literal>@</literal>) is optional noise.  The amounts
     of the different units are implicitly added with appropriate
     sign accounting.  <literal>ago</literal> negates all the fields.
     This syntax is also used for interval output, if
     <xref linkend="guc-intervalstyle"/> is set to
     <literal>postgres_verbose</literal>.
    </para>
____________________________________________________________________________-->
     <para>
      <type>interval</type>值可以使用下列语法书写：

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

     其中<replaceable>quantity</replaceable>是一个数字（很可能是有符号的）；
     <replaceable>unit</replaceable>是<literal>毫秒</literal>、
     <literal>millisecond</literal>、<literal>second</literal>、
     <literal>minute</literal>、<literal>hour</literal>、<literal>day</literal>、
     <literal>week</literal>、<literal>month</literal>、<literal>year</literal>、
     <literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>
     或者缩写或者这些单位的复数；
     <replaceable>direction</replaceable>可以是<literal>ago</literal>或者为空。At符号（<literal>@</literal>）是一个可选的噪声。不同单位的数量通过合适的符号计数被隐式地添加。<literal>ago</literal>对所有域求反。如果<xref linkend="guc-intervalstyle"/>被设置为<literal>postgres_verbose</literal>，该语法也被用于间隔输出。
    </para>

<!--==========================orignal english content==========================
    <para>
     Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <literal>'1 12:59:10'</literal> is read
     the same as <literal>'1 day 12 hours 59 min 10 sec'</literal>.  Also,
     a combination of years and months can be specified with a dash;
     for example <literal>'200-10'</literal> is read the same as <literal>'200 years
     10 months'</literal>.  (These shorter forms are in fact the only ones allowed
     by the <acronym>SQL</acronym> standard, and are used for output when
     <varname>IntervalStyle</varname> is set to <literal>sql_standard</literal>.)
    </para>
____________________________________________________________________________-->
    <para>
     日、小时、分钟和秒的数量可以不适用显式的单位标记指定。例如，<literal>'1 12:59:10'</literal>被读作<literal>'1 day 12 hours 59 min 10 sec'</literal>。同样，一个年和月的组合可以使用一个横线指定，例如<literal>'200-10'</literal>被读作<literal>'200年10个月'</literal>（这些较短的形式事实上是<acronym>SQL</acronym>标准唯一许可的形式，并且在<varname>IntervalStyle</varname>被设置为<literal>sql_standard</literal>时用于输出）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Interval values can also be written as ISO 8601 time intervals, using
     either the <quote>format with designators</quote> of the standard's section
     4.4.3.2 or the <quote>alternative format</quote> of section 4.4.3.3.  The
     format with designators looks like this:
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
      The string must start with a <literal>P</literal>, and may include a
      <literal>T</literal> that introduces the time-of-day units.  The
      available unit abbreviations are given in <xref
      linkend="datatype-interval-iso8601-units"/>.  Units may be
      omitted, and may be specified in any order, but units smaller than
      a day must appear after <literal>T</literal>.  In particular, the meaning of
      <literal>M</literal> depends on whether it is before or after
      <literal>T</literal>.
     </para>
____________________________________________________________________________-->
    <para>
     间隔值也可以被写成 ISO 8601 时间间隔，使用该标准4.4.3.2小节的<quote>带标志符的格式</quote>或者4.4.3.3小节的<quote>替代格式</quote>。带标志符的格式看起来像这样：
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
      该串必须以一个<literal>P</literal>开始，并且可以包括一个引入当日时间单位的<literal>T</literal>。可用的单位缩写在<xref linkend="datatype-interval-iso8601-units"/>中给出。单位可以被忽略，并且可以以任何顺序指定，但是小于一天的单位必须出现在<literal>T</literal>之后。特别地，<literal>M</literal>的含义取决于它出现在<literal>T</literal>之前还是之后。
     </para>

     <table id="datatype-interval-iso8601-units">
<!--==========================orignal english content==========================
      <title>ISO 8601 Interval Unit Abbreviations</title>
____________________________________________________________________________-->
      <title>ISO 8601 间隔单位缩写</title>
     <tgroup cols="2">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Abbreviation</entry>
         <entry>Meaning</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>缩写</entry>
         <entry>含义</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>Y</entry>
         <entry>Years</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>Y</entry>
         <entry>年</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>M</entry>
         <entry>Months (in the date part)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>M</entry>
         <entry>月（在日期部分中）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>W</entry>
         <entry>Weeks</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>W</entry>
         <entry>周</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>D</entry>
         <entry>Days</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>D</entry>
         <entry>日</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>H</entry>
         <entry>Hours</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>H</entry>
         <entry>小时</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>M</entry>
         <entry>Minutes (in the time part)</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>M</entry>
         <entry>分钟 (在时间部分中）</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>S</entry>
         <entry>Seconds</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>S</entry>
         <entry>秒</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
     <para>
      In the alternative format:
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
      the string must begin with <literal>P</literal>, and a
      <literal>T</literal> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates.
    </para>
____________________________________________________________________________-->
     <para>
      如果使用替代格式：
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
      串必须以<literal>P</literal>开始，并且一个<literal>T</literal>分隔间隔的日期和时间部分。其值按照类似于 ISO 8601日期的数字给出。
    </para>

<!--==========================orignal english content==========================
    <para>
     When writing an interval constant with a <replaceable>fields</replaceable>
     specification, or when assigning a string to an interval column that was
     defined with a <replaceable>fields</replaceable> specification, the interpretation of
     unmarked quantities depends on the <replaceable>fields</replaceable>.  For
     example <literal>INTERVAL '1' YEAR</literal> is read as 1 year, whereas
     <literal>INTERVAL '1'</literal> means 1 second.  Also, field values
     <quote>to the right</quote> of the least significant field allowed by the
     <replaceable>fields</replaceable> specification are silently discarded.  For
     example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>
     results in dropping the seconds field, but not the day field.
    </para>
____________________________________________________________________________-->
    <para>
     在用一个<replaceable>域</replaceable>声明书写一个间隔常量时，或者为一个用<replaceable>域</replaceable>声明定义的间隔列赋予一个串时，对于为标记的量的解释依赖于<replaceable>域</replaceable>。例如<literal>INTERVAL '1' YEAR</literal>被解读成1年，而<literal>INTERVAL '1'</literal>表示1秒。同样，<replaceable>域</replaceable>声明允许的最后一个有效域<quote>右边</quote>的域值会被无声地丢弃掉。例如书写<literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>将会导致丢弃秒域，而不是日域。
    </para>

<!--==========================orignal english content==========================
    <para>
     According to the <acronym>SQL</acronym> standard all fields of an interval
     value must have the same sign, so a leading negative sign applies to all
     fields; for example the negative sign in the interval literal
     <literal>'-1 2:03:04'</literal> applies to both the days and hour/minute/second
     parts.  <productname>PostgreSQL</productname> allows the fields to have different
     signs, and traditionally treats each field in the textual representation
     as independently signed, so that the hour/minute/second part is
     considered positive in this example.  If <varname>IntervalStyle</varname> is
     set to <literal>sql_standard</literal> then a leading sign is considered
     to apply to all fields (but only if no additional signs appear).
     Otherwise the traditional <productname>PostgreSQL</productname> interpretation is
     used.  To avoid ambiguity, it's recommended to attach an explicit sign
     to each field if any field is negative.
    </para>
____________________________________________________________________________-->
    <para>
     根据<acronym>SQL</acronym>标准，一个间隔值的所有域都必须由相同的符号，这样一个领头的负号将会应用到所有域；例如在间隔文字<literal>'-1 2:03:04'</literal>中的负号会被应用于日、小时、分钟和秒部分。<productname>PostgreSQL</productname>允许域具有不同的符号，并且在习惯上认为以文本表示的每个域具有独立的符号，因此在这个例子中小时、分钟和秒部分被认为是正值。如果<varname>IntervalStyle</varname>被设置为<literal>sql_standard</literal>，则一个领头的符号将被认为是应用于所有域（但是仅当没有额外符号出现）。否则将使用传统的<productname>PostgreSQL</productname>解释。为了避免混淆，我们推荐在任何域为负值时为每一个域都附加一个显式的符号。
    </para>

<!--==========================orignal english content==========================
    <para>
     In the verbose input format, and in some fields of the more compact
     input formats, field values can have fractional parts; for example
     <literal>'1.5 week'</literal> or <literal>'01:02:03.45'</literal>.  Such input is
     converted to the appropriate number of months, days, and seconds
     for storage.  When this would result in a fractional number of
     months or days, the fraction is added to the lower-order fields
     using the conversion factors 1 month = 30 days and 1 day = 24 hours.
     For example, <literal>'1.5 month'</literal> becomes 1 month and 15 days.
     Only seconds will ever be shown as fractional on output.
    </para>
____________________________________________________________________________-->
    <para>
     在冗长的输入格式中，以及在更紧凑输入格式的某些域中，域值可以有分数部分；例如<literal>'1.5 week'</literal>或<literal>'01:02:03.45'</literal>。这样的输入被转换为合适的月数、日数和秒数用于存储。当这样会导致月和日中的分数时，分数被加到低序域中，使用的转换因子是1月=30日和1日=24小时。例如，<literal>'1.5 month'</literal>会变成1月和15日。只有秒总是在输出时被显示为分数。
    </para>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="datatype-interval-input-examples"/> shows some examples
     of valid <type>interval</type> input.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="datatype-interval-input-examples"/>展示了一些有效<type>interval</type>输入的例子。
    </para>

     <table id="datatype-interval-input-examples">
<!--==========================orignal english content==========================
      <title>Interval Input</title>
____________________________________________________________________________-->
      <title>间隔输入</title>
      <tgroup cols="2">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry>Example</entry>
         <entry>Description</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>1-2</entry>
         <entry>SQL standard format: 1 year 2 months</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1-2</entry>
         <entry>SQL标准格式：1年2个月</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>3 4:05:06</entry>
         <entry>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>3 4:05:06</entry>
         <entry>SQL标准格式：3日4小时5分钟6秒</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry>ISO 8601 <quote>format with designators</quote>: same meaning as above</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry><quote>带标志符的</quote>ISO 8601 格式：含义同上</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry>ISO 8601 <quote>alternative format</quote>: same meaning as above</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry>ISO 8601 的<quote>替代格式</quote>：含义同上</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!--==========================orignal english content==========================
     <para>
     Internally <type>interval</type> values are stored as months, days,
     and seconds. This is done because the number of days in a month
     varies, and a day can have 23 or 25 hours if a daylight savings
     time adjustment is involved.  The months and days fields are integers
     while the seconds field can store fractions.  Because intervals are
     usually created from constant strings or <type>timestamp</type> subtraction,
     this storage method works well in most cases, but can cause unexpected
     results:

<programlisting>
SELECT EXTRACT(hours from '80 minutes'::interval);
 date_part
-&minus;-&minus;-&minus;-&minus;-&minus;-
         1

SELECT EXTRACT(days from '80 hours'::interval);
 date_part
-&minus;-&minus;-&minus;-&minus;-&minus;-
         0
</programlisting>

     Functions <function>justify_days</function> and
     <function>justify_hours</function> are available for adjusting days
     and hours that overflow their normal ranges.
    </para>
____________________________________________________________________________-->
     <para>
     在内部，<type>interval</type>值被存储为months、days以及seconds。之所以这样做是因为一个月中的天数是变化的，并且在涉及到夏令时调整时一天可以有23或者25个小时。months以及days域是整数，而seconds域可以存储分数。因为区间通常是从常量字符串或者<type>timestamp</type>减法创建而来，这种存储方法在大部分情况下都很好，但是也可能导致预料之外的结果：

<programlisting>
SELECT EXTRACT(hours from '80 minutes'::interval);
 date_part
-----------
         1

SELECT EXTRACT(days from '80 hours'::interval);
 date_part
-----------
         0
</programlisting>

     函数<function>justify_days</function>和<function>justify_hours</function>可以用来调整溢出其正常范围之外的days和hours。
    </para>

   </sect2>

   <sect2 id="datatype-interval-output">
<!--==========================orignal english content==========================
    <title>Interval Output</title>
____________________________________________________________________________-->
    <title>间隔输出</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>interval</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>interval</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The output format of the interval type can be set to one of the
     four styles <literal>sql_standard</literal>, <literal>postgres</literal>,
     <literal>postgres_verbose</literal>, or <literal>iso_8601</literal>,
     using the command <literal>SET intervalstyle</literal>.
     The default is the <literal>postgres</literal> format.
     <xref linkend="interval-style-output-table"/> shows examples of each
     output style.
    </para>
____________________________________________________________________________-->
    <para>
     间隔类型的输出格式可以被设置为四种风格之一：<literal>sql_standard</literal>、<literal>postgres</literal>、<literal>postgres_verbose</literal>或<literal>iso_8601</literal>，设置方法使用<literal>SET intervalstyle</literal>命令。默认值为<literal>postgres</literal>格式。<xref linkend="interval-style-output-table"/>展示了每种输出风格的例子。
    </para>

<!--==========================orignal english content==========================
    <para>
     The <literal>sql_standard</literal> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.
    </para>
____________________________________________________________________________-->
    <para>
     如果间隔值符合SQL标准的限制（仅年-月或仅日-时间，没有正负值部分的混合），<literal>sql_standard</literal>风格为间隔文字串产生符合SQL标准规范的输出。否则输出将看起来像一个标准的年-月文字串跟着一个日-时间文字串，并且带有显式添加的符号以区分混合符号的间隔。
    </para>

<!--==========================orignal english content==========================
    <para>
     The output of the <literal>postgres</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <xref linkend="guc-datestyle"/> parameter was set to <literal>ISO</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     当<xref linkend="guc-datestyle"/>参数被设置为<literal>ISO</literal>时，<literal>postgres</literal>风格的输出匹配<productname>PostgreSQL</productname> 8.4版本以前的输出。
    </para>

<!--==========================orignal english content==========================
    <para>
     The output of the <literal>postgres_verbose</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <varname>DateStyle</varname> parameter was set to non-<literal>ISO</literal> output.
    </para>
____________________________________________________________________________-->
    <para>
     当<varname>DateStyle</varname>参数被设置为非<literal>ISO</literal>输出时，<literal>postgres_verbose</literal>风格的输出匹配<productname>PostgreSQL</productname> 8.4版本以前的输出。
    </para>

<!--==========================orignal english content==========================
    <para>
     The output of the <literal>iso_8601</literal> style matches the <quote>format
     with designators</quote> described in section 4.4.3.2 of the
     ISO 8601 standard.
    </para>
____________________________________________________________________________-->
    <para>
     <literal>iso_8601</literal>风格的输出匹配在ISO 8601标准的4.4.3.2小节中描述的<quote>带标志符的格式</quote>。
    </para>

     <table id="interval-style-output-table">
<!--==========================orignal english content==========================
       <title>Interval Output Style Examples</title>
____________________________________________________________________________-->
       <title>间隔输出风格例子</title>
       <tgroup cols="4">
        <thead>
<!--==========================orignal english content==========================
         <row>
          <entry>Style Specification</entry>
          <entry>Year-Month Interval</entry>
          <entry>Day-Time Interval</entry>
          <entry>Mixed Interval</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry>风格声明</entry>
          <entry>年-月间隔</entry>
          <entry>日-时间间隔</entry>
          <entry>混合间隔</entry>
         </row>
        </thead>
        <tbody>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
<!--==========================orignal english content==========================
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
____________________________________________________________________________-->
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
<!--==========================orignal english content==========================
   <title>Boolean Type</title>
____________________________________________________________________________-->
   <title>布尔类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>data type</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides the
    standard <acronym>SQL</acronym> type <type>boolean</type>;
    see <xref linkend="datatype-boolean-table"/>.
    The <type>boolean</type> type can have several states:
    <quote>true</quote>, <quote>false</quote>, and a third state,
    <quote>unknown</quote>, which is represented by the
    <acronym>SQL</acronym> null value.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供标准的<acronym>SQL</acronym>类型<type>boolean</type>，参见<xref linkend="datatype-boolean-table"/>。<type>boolean</type>可以有多个状态：<quote>true（真）</quote>、<quote>false（假）</quote>和第三种状态<quote>unknown（未知）</quote>，未知状态由<acronym>SQL</acronym>空值表示。
   </para>

   <table id="datatype-boolean-table">
<!--==========================orignal english content==========================
    <title>Boolean Data Type</title>
____________________________________________________________________________-->
    <title>布尔数据类型</title>
    <tgroup cols="3">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>存储字节</entry>
       <entry>描述</entry>
      </row>
     </thead>
     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry><type>boolean</type></entry>
       <entry>1 byte</entry>
       <entry>state of true or false</entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry>1字节</entry>
       <entry>状态为真或假</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
   <para>
    Valid literal values for the <quote>true</quote> state are:
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'on'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    For the <quote>false</quote> state, the following values can be
    used:
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'off'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    Leading or trailing whitespace is ignored, and case does not matter.
    The key words
    <literal>TRUE</literal> and <literal>FALSE</literal> are the preferred
    (<acronym>SQL</acronym>-compliant) usage.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>真</quote>状态的有效文字值是：
    <simplelist>
     <member><literal>TRUE</literal></member>
     <member><literal>'t'</literal></member>
     <member><literal>'true'</literal></member>
     <member><literal>'y'</literal></member>
     <member><literal>'yes'</literal></member>
     <member><literal>'on'</literal></member>
     <member><literal>'1'</literal></member>
    </simplelist>
    而对于<quote>假</quote>状态，你可以使用下面这些值：
    <simplelist>
     <member><literal>FALSE</literal></member>
     <member><literal>'f'</literal></member>
     <member><literal>'false'</literal></member>
     <member><literal>'n'</literal></member>
     <member><literal>'no'</literal></member>
     <member><literal>'off'</literal></member>
     <member><literal>'0'</literal></member>
    </simplelist>
    前导或者末尾的空白将被忽略，并且大小写也无关紧要。使用<literal>TRUE</literal>和<literal>FALSE</literal>这样的关键词比较好（<acronym>SQL</acronym>兼容）。
   </para>

<!--==========================orignal english content==========================
   <para>
    <xref linkend="datatype-boolean-example"/> shows that
    <type>boolean</type> values are output using the letters
    <literal>t</literal> and <literal>f</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="datatype-boolean-example"/>显示了使用字母<literal>t</literal>和<literal>f</literal>输出<type>boolean</type>值的例子。
   </para>

   <example id="datatype-boolean-example">
<!--==========================orignal english content==========================
    <title>Using the <type>boolean</type> Type</title>
____________________________________________________________________________-->
    <title>使用<type>boolean</type>类型</title>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 t | sic est
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
   </example>
  </sect1>

  <sect1 id="datatype-enum">
<!--==========================orignal english content==========================
   <title>Enumerated Types</title>
____________________________________________________________________________-->
   <title>枚举类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-enum">
    <primary>data type</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-enum">
    <primary>数据类型</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Enumerated (enum) types are data types that
    comprise a static, ordered set of values.
    They are equivalent to the <type>enum</type>
    types supported in a number of programming languages. An example of an enum
    type might be the days of the week, or a set of status values for
    a piece of data.
   </para>
____________________________________________________________________________-->
   <para>
    枚举（enum）类型是由一个静态、值的有序集合构成的数据类型。它们等效于很多编程语言所支持的<type>enum</type>类型。枚举类型的一个例子可以是一周中的日期，或者一个数据的状态值集合。
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title>Declaration of Enumerated Types</title>
____________________________________________________________________________-->
    <title>枚举类型的声明</title>

<!--==========================orignal english content==========================
    <para>
     Enum types are created using the <xref
     linkend="sql-createtype"/> command,
     for example:

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     Once created, the enum type can be used in table and function
     definitions much like any other type:
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood 
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Moe  | happy
(1 row)
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     枚举类型可以使用<xref linkend="sql-createtype"/>命令创建，例如：

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     一旦被创建，枚举类型可以像很多其他类型一样在表和函数定义中使用：
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>
    </sect2>

    <sect2>
<!--==========================orignal english content==========================
     <title>Ordering</title>
____________________________________________________________________________-->
     <title>排序</title>

<!--==========================orignal english content==========================
     <para>
      The ordering of the values in an enum type is the
      order in which the values were listed when the type was created.
      All standard comparison operators and related
      aggregate functions are supported for enums.  For example:

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood 
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood 
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name  
-&minus;-&minus;-&minus;-
 Larry
(1 row)
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      一个枚举类型的值的排序是该类型被创建时所列出的值的顺序。枚举类型的所有标准的比较操作符以及相关聚集函数都被支持。例如：

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name
-------
 Larry
(1 row)
</programlisting>
     </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Type Safety</title>
____________________________________________________________________________-->
    <title>类型安全性</title>

<!--==========================orignal english content==========================
    <para>
     Each enumerated data type is separate and cannot
     be compared with other enumerated types.  See this example:

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     每一种枚举数据类型都是独立的并且不能和其他枚举类型相比较。看这样一个例子：

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     If you really need to do something like that, you can either
     write a custom operator or add explicit casts to your query:

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks 
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Moe  |         4
(1 row)

</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     如果你确实需要做这样的事情，你可以写一个自定义的操作符或者在查询中加上显式造型：

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks
------+-----------
 Moe  |         4
(1 row)

</programlisting>
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Implementation Details</title>
____________________________________________________________________________-->
    <title>实现细节</title>

<!--==========================orignal english content==========================
    <para>
     Enum labels are case sensitive, so
     <type>'happy'</type> is not the same as <type>'HAPPY'</type>.
     White space in the labels is significant too.
    </para>
____________________________________________________________________________-->
    <para>
     枚举标签是大小写敏感的，因此<type>'happy'</type>与<type>'HAPPY'</type>是不同的。标签中的空格也是有意义的。
    </para>

<!--==========================orignal english content==========================
    <para>
     Although enum types are primarily intended for static sets of values,
     there is support for adding new values to an existing enum type, and for
     renaming values (see <xref linkend="sql-altertype"/>).  Existing values
     cannot be removed from an enum type, nor can the sort ordering of such
     values be changed, short of dropping and re-creating the enum type.
    </para>
____________________________________________________________________________-->
    <para>
     尽管枚举类型的主要目的是用于值的静态集合，但也有方法在现有枚举类型中增加新值和重命名值（见<xref linkend="sql-altertype"/>）。不能从枚举类型中去除现有的值，也不能更改这些值的排序顺序，如果要那样做可以删除并且重建枚举类型。
    </para>

<!--==========================orignal english content==========================
    <para>
     An enum value occupies four bytes on disk.  The length of an enum
     value's textual label is limited by the <symbol>NAMEDATALEN</symbol>
     setting compiled into <productname>PostgreSQL</productname>; in standard
     builds this means at most 63 bytes.
    </para>
____________________________________________________________________________-->
    <para>
     一个枚举值在磁盘上占据4个字节。一个枚举值的文本标签的长度受限于<symbol>NAMEDATALEN</symbol>设置，该设置被编译在<productname>PostgreSQL</productname>中，在标准编译下它表示最多63字节。
    </para>

<!--==========================orignal english content==========================
    <para>
     The translations from internal enum values to textual labels are
     kept in the system catalog
     <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>.
     Querying this catalog directly can be useful.
    </para>
____________________________________________________________________________-->
    <para>
     从内部枚举值到文本标签的翻译被保存在系统目录<link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>中。可以直接查询该目录。
    </para>

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
<!--==========================orignal english content==========================
   <title>Geometric Types</title>
____________________________________________________________________________-->
   <title>几何类型</title>

<!--==========================orignal english content==========================
   <para>
    Geometric data types represent two-dimensional spatial
    objects. <xref linkend="datatype-geo-table"/> shows the geometric
    types available in <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    几何数据类型表示二维的空间物体。<xref linkend="datatype-geo-table"/>展示了<productname>PostgreSQL</productname>中可以用的几何类型。
   </para>

    <table id="datatype-geo-table">
<!--==========================orignal english content==========================
     <title>Geometric Types</title>
____________________________________________________________________________-->
     <title>几何类型</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Representation</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>表示</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>point</type></entry>
        <entry>16 bytes</entry>
        <entry>Point on a plane</entry>
        <entry>(x,y)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>point</type></entry>
        <entry>16字节</entry>
        <entry>平面上的点</entry>
        <entry>(x,y)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>line</type></entry>
        <entry>32 bytes</entry>
        <entry>Infinite line</entry>
        <entry>{A,B,C}</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>line</type></entry>
        <entry>32字节</entry>
        <entry>无限长的线</entry>
        <entry>{A,B,C}</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 bytes</entry>
        <entry>Finite line segment</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>lseg</type></entry>
        <entry>32字节</entry>
        <entry>有限线段</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>box</type></entry>
        <entry>32 bytes</entry>
        <entry>Rectangular box</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>box</type></entry>
        <entry>32字节</entry>
        <entry>矩形框</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n bytes</entry>
        <entry>Closed path (similar to polygon)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>封闭路径（类似于多边形）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n bytes</entry>
        <entry>Open path</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>开放路径</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n bytes</entry>
        <entry>Polygon (similar to closed path)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n字节</entry>
        <entry>多边形（类似于封闭路径）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
<!--==========================orignal english content==========================
       <row>
        <entry><type>circle</type></entry>
        <entry>24 bytes</entry>
        <entry>Circle</entry>
        <entry>&lt;(x,y),r&gt; (center point and radius)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>circle</type></entry>
        <entry>24字节</entry>
        <entry>圆</entry>
        <entry>&lt;(x,y),r&gt;（中心点和半径）</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    A rich set of functions and operators is available to perform various geometric
    operations such as scaling, translation, rotation, and determining
    intersections.  They are explained in <xref linkend="functions-geometry"/>.
   </para>
____________________________________________________________________________-->
   <para>
    我们有一系列丰富的函数和操作符可用来进行各种几何操作， 如缩放、平移、旋转和计算相交等 它们在<xref linkend="functions-geometry"/>中解释。
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title>Points</title>
____________________________________________________________________________-->
    <title>点</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>point</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>point</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Points are the fundamental two-dimensional building block for geometric
     types.  Values of type <type>point</type> are specified using either of
     the following syntaxes:

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     where <replaceable>x</replaceable> and <replaceable>y</replaceable> are the respective
     coordinates, as floating-point numbers.
    </para>
____________________________________________________________________________-->
    <para>
     点是几何类型的基本二维构造块。用下面的语法描述<type>point</type>类型的值：

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     其中<replaceable>x</replaceable>和<replaceable>y</replaceable>分别是坐标，都是浮点数。
    </para>

<!--==========================orignal english content==========================
    <para>
     Points are output using the first syntax.
    </para>
____________________________________________________________________________-->
    <para>
     点使用第一种语法输出。
    </para>
   </sect2>

   <sect2 id="datatype-line">
<!--==========================orignal english content==========================
    <title>Lines</title>
____________________________________________________________________________-->
    <title>线</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>line</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>line</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Lines are represented by the linear
     equation <replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0,
     where <replaceable>A</replaceable> and <replaceable>B</replaceable> are not both zero.  Values
     of type <type>line</type> are input and output in the following form:
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

     Alternatively, any of the following forms can be used for input:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are two different points on the line.
    </para>
____________________________________________________________________________-->
    <para>
     线由线性方程<replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0
     表示，其中<replaceable>A</replaceable>和<replaceable>B</replaceable>都不为零。类型<type>line</type>
     的值采用以下形式输入和输出：
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

     另外，还可以用下列任一形式输入：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线上不同的两点。
    </para>
   </sect2>

   <sect2 id="datatype-lseg">
<!--==========================orignal english content==========================
    <title>Line Segments</title>
____________________________________________________________________________-->
    <title>线段</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>lseg</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>lseg</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>line segment</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>线段</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Line segments are represented by pairs of points that are the endpoints
     of the segment.  Values of type <type>lseg</type> are specified using any
     of the following syntaxes:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are the end points of the line segment.
    </para>
____________________________________________________________________________-->
    <para>
     线段用一对线段的端点来表示。<type>lseg</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线段的端点。
    </para>

<!--==========================orignal english content==========================
    <para>
     Line segments are output using the first syntax.
    </para>
____________________________________________________________________________-->
    <para>
     线段使用第一种语法输出。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Boxes</title>
____________________________________________________________________________-->
    <title>方框</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>rectangle</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>rectangle</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Boxes are represented by pairs of points that are opposite
     corners of the box.
     Values of type <type>box</type> are specified using any of the following
     syntaxes:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are any two opposite corners of the box.
    </para>
____________________________________________________________________________-->
    <para>
     方框用其对角的点对表示。<type>box</type>类型的值使用下面的语法指定：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是方框的对角点。
    </para>

<!--==========================orignal english content==========================
    <para>
     Boxes are output using the second syntax.
    </para>
____________________________________________________________________________-->
    <para>
     方框使用第二种语法输出。
    </para>

<!--==========================orignal english content==========================
    <para>
     Any two opposite corners can be supplied on input, but the values
     will be reordered as needed to store the
     upper right and lower left corners, in that order.
    </para>
____________________________________________________________________________-->
    <para>
     在输入时可以提供任意两个对角，但是值将根据需要被按顺序记录为右上角和左下角。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Paths</title>
____________________________________________________________________________-->
    <title>路径</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Paths are represented by lists of connected points. Paths can be
     <firstterm>open</firstterm>, where
     the first and last points in the list are considered not connected, or
     <firstterm>closed</firstterm>,
     where the first and last points are considered connected.
    </para>
____________________________________________________________________________-->
    <para>
     路径由一系列连接的点组成。路径可能是<firstterm>开放</firstterm>的，也就是认为列表中第一个点和最后一个点没有被连接起来；也可能是<firstterm>封闭</firstterm>的，这时认为第一个和最后一个点被连接起来。
    </para>

<!--==========================orignal english content==========================
    <para>
     Values of type <type>path</type> are specified using any of the following
     syntaxes:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     where the points are the end points of the line segments
     comprising the path.  Square brackets (<literal>[]</literal>) indicate
     an open path, while parentheses (<literal>()</literal>) indicate a
     closed path.  When the outermost parentheses are omitted, as
     in the third through fifth syntaxes, a closed path is assumed.
    </para>
____________________________________________________________________________-->
    <para>
     <type>path</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成路径的线段的端点。方括弧（<literal>[]</literal>）表示一个开放的路径，圆括弧（<literal>()</literal>）表示一个封闭的路径。如第三种到第五种语法所示，当最外面的圆括号被忽略时，路径将被假定为封闭。
    </para>

<!--==========================orignal english content==========================
    <para>
     Paths are output using the first or second syntax, as appropriate.
    </para>
____________________________________________________________________________-->
    <para>
     路径的输出使用第一种或第二种语法。
    </para>
   </sect2>

   <sect2 id="datatype-polygon">
<!--==========================orignal english content==========================
    <title>Polygons</title>
____________________________________________________________________________-->
    <title>多边形</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>polygon</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>polygon</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Polygons are represented by lists of points (the vertexes of the
     polygon). Polygons are very similar to closed paths, but are
     stored differently and have their own set of support routines.
    </para>
____________________________________________________________________________-->
    <para>
     多边形由一系列点代表（多边形的顶点）。多边形和封闭路径很像，但是存储方式不一样而且有自己的一套支持例程。
    </para>

<!--==========================orignal english content==========================
    <para>
     Values of type <type>polygon</type> are specified using any of the
     following syntaxes:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     where the points are the end points of the line segments
     comprising the boundary of the polygon.
    </para>
____________________________________________________________________________-->
    <para>
     <type>polygon</type>类型的值用下列语法声明：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成多边形边界的线段的端点。
    </para>

<!--==========================orignal english content==========================
    <para>
     Polygons are output using the first syntax.
    </para>
____________________________________________________________________________-->
    <para>
     多边形的输出使用第一种语法。
    </para>
   </sect2>

   <sect2 id="datatype-circle">
<!--==========================orignal english content==========================
    <title>Circles</title>
____________________________________________________________________________-->
    <title>圆</title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>circle</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>circle</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     Circles are represented by a center point and radius.
     Values of type <type>circle</type> are specified using any of the
     following syntaxes:

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     is the center point and <replaceable>r</replaceable> is the radius of the
     circle.
    </para>
____________________________________________________________________________-->
    <para>
     圆由一个圆心和一个半径代表。<type>circle</type>类型的值用下面的语法指定：

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     其中<literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>是圆心，而<replaceable>r</replaceable>是圆的半径。
    </para>

<!--==========================orignal english content==========================
    <para>
     Circles are output using the first syntax.
    </para>
____________________________________________________________________________-->
    <para>
     圆的输出用第一种语法。
    </para>
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
<!--==========================orignal english content==========================
   <title>Network Address Types</title>
____________________________________________________________________________-->
   <title>网络地址类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>data types</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> offers data types to store IPv4, IPv6, and MAC
    addresses, as shown in <xref linkend="datatype-net-types-table"/>.  It
    is better to use these types instead of plain text types to store
    network addresses, because
    these types offer input error checking and specialized
    operators and functions (see <xref linkend="functions-net"/>).
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供用于存储 IPv4、IPv6 和 MAC 地址的数据类型，如<xref linkend="datatype-net-types-table"/>所示。 用这些数据类型存储网络地址比用纯文本类型好，因为这些类型提供输入错误检查以及特殊的操作符和函数（见<xref linkend="functions-net"/>）
   </para>

    <table tocentry="1" id="datatype-net-types-table">
<!--==========================orignal english content==========================
     <title>Network Address Types</title>
____________________________________________________________________________-->
     <title>网络地址类型</title>
     <tgroup cols="3">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
      </thead>
      <tbody>

<!--==========================orignal english content==========================
       <row>
        <entry><type>cidr</type></entry>
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 networks</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>cidr</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6网络</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>inet</type></entry>
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 hosts and networks</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>inet</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6主机以及网络</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 bytes</entry>
        <entry>MAC addresses</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>macaddr</type></entry>
        <entry>6字节</entry>
        <entry>MAC地址</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>macaddr8</type></entry>
        <entry>8 bytes</entry>
        <entry>MAC addresses (EUI-64 format)</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>macaddr8</type></entry>
        <entry>8 bytes</entry>
        <entry>MAC地址（EUI-64格式）</entry>
       </row>

      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    When sorting <type>inet</type> or <type>cidr</type> data types,
    IPv4 addresses will always sort before IPv6 addresses, including
    IPv4 addresses encapsulated or mapped to IPv6 addresses, such as
    ::10.2.3.4 or ::ffff:10.4.3.2.
   </para>
____________________________________________________________________________-->
   <para>
    在对<type>inet</type>或者<type>cidr</type>数据类型进行排序的时候， IPv4 地址将总是排在 IPv6 地址前面，包括那些封装或者是映射在 IPv6 地址里 的 IPv4 地址，例如 ::10.2.3.4 或者 ::ffff::10.4.3.2。
   </para>


   <sect2 id="datatype-inet">
<!--==========================orignal english content==========================
    <title><type>inet</type></title>
____________________________________________________________________________-->
    <title><type>inet</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>inet (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>inet（数据类型）</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The <type>inet</type> type holds an IPv4 or IPv6 host address, and
     optionally its subnet, all in one field.
     The subnet is represented by the number of network address bits
     present in the host address (the
     <quote>netmask</quote>).  If the netmask is 32 and the address is IPv4,
     then the value does not indicate a subnet, only a single host.
     In IPv6, the address length is 128 bits, so 128 bits specify a
     unique host address.  Note that if you
     want to accept only networks, you should use the
     <type>cidr</type> type rather than <type>inet</type>.
    </para>
____________________________________________________________________________-->
    <para>
     <type>inet</type>在一个数据域里保存一个 IPv4 或 IPv6 主机地址，以及一个可选的它的子网。 子网由主机地址中表示的网络地址位数表示（<quote>网络掩码</quote>）。 如果网络掩码为 32 并且地址是 IPv4 ，那么该值不表示任何子网，只是一台主机。在 IPv6 中地址长度是 128 位，因此 128 位指定一个唯一的主机地址。 请注意如果你想只接受网络地址，你应该使用<type>cidr</type>类型而不是<type>inet</type>。
    </para>

<!--==========================orignal english content==========================
    <para>
      The input format for this type is
      <replaceable class="parameter">address/y</replaceable>
      where
      <replaceable class="parameter">address</replaceable>
      is an IPv4 or IPv6 address and
      <replaceable class="parameter">y</replaceable>
      is the number of bits in the netmask.  If the
      <replaceable class="parameter">/y</replaceable>
      portion is missing, the
      netmask is 32 for IPv4 and 128 for IPv6, so the value represents
      just a single host.  On display, the
      <replaceable class="parameter">/y</replaceable>
      portion is suppressed if the netmask specifies a single host.
    </para>
____________________________________________________________________________-->
    <para>
      该类型的输入格式是<replaceable class="parameter">地址/y</replaceable>，其中<replaceable class="parameter">地址</replaceable>是一个 IPv4 或者 IPv6 地址，<replaceable class="parameter">y</replaceable>是网络掩码的位数。如果<replaceable class="parameter">/y</replaceable>部分缺失， 则网络掩码对 IPv4 而言是 32，对 IPv6 而言是 128，所以该值表示只有一台主机。在显示时，如果<replaceable class="parameter">/y</replaceable>部分指定一个单台主机，它将不会被显示出来。
    </para>
   </sect2>

   <sect2 id="datatype-cidr">
<!--==========================orignal english content==========================
    <title><type>cidr</type></title>
____________________________________________________________________________-->
    <title><type>cidr</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>cidr</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>cidr</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The <type>cidr</type> type holds an IPv4 or IPv6 network specification.
     Input and output formats follow Classless Internet Domain Routing
     conventions.
     The format for specifying networks is <replaceable
     class="parameter">address/y</replaceable> where <replaceable
     class="parameter">address</replaceable> is the network represented as an
     IPv4 or IPv6 address, and <replaceable
     class="parameter">y</replaceable> is the number of bits in the netmask.  If
     <replaceable class="parameter">y</replaceable> is omitted, it is calculated
     using assumptions from the older classful network numbering system, except
     it will be at least large enough to include all of the octets
     written in the input.  It is an error to specify a network address
     that has bits set to the right of the specified netmask.
    </para>
____________________________________________________________________________-->
    <para>
     <type>cidr</type>类型保存一个 IPv4 或 IPv6 网络地址声明。其输入和输出遵循无类的互联网域路由（Classless Internet Domain Routing）习惯。声明一个网络的格式是<replaceable class="parameter">地址/y</replaceable>，其中<replaceable class="parameter">address</replaceable>是 IPv4 或 IPv6 网络地址而<replaceable class="parameter">y</replaceable>是网络掩码的位数。如果省略<replaceable class="parameter">y</replaceable>， 那么掩码部分用旧的有类的网络编号系统进行计算，否则它将至少大到足以包括写在输入中的所有字节。声明一个在其指定的掩码右边置了位的网络地址会导致错误。
    </para>

<!--==========================orignal english content==========================
    <para>
     <xref linkend="datatype-net-cidr-table"/> shows some examples.
    </para>
____________________________________________________________________________-->
    <para>
     <xref linkend="datatype-net-cidr-table"/>展示了一些例子。
    </para>

     <table id="datatype-net-cidr-table">
<!--==========================orignal english content==========================
      <title><type>cidr</type> Type Input Examples</title>
____________________________________________________________________________-->
      <title><type>cidr</type>类型输入例子</title>
      <tgroup cols="3">
       <thead>
<!--==========================orignal english content==========================
        <row>
         <entry><type>cidr</type> Input</entry>
         <entry><type>cidr</type> Output</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry><type>cidr</type>输入</entry>
         <entry><type>cidr</type>输出</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
       </thead>
       <tbody>
<!--==========================orignal english content==========================
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:2e0:81ff:fe22:d1f1</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
<!--==========================orignal english content==========================
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
____________________________________________________________________________-->
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
<!--==========================orignal english content==========================
    <title><type>inet</type> vs. <type>cidr</type></title>
____________________________________________________________________________-->
    <title><type>inet</type> vs. <type>cidr</type></title>

<!--==========================orignal english content==========================
    <para>
    The essential difference between <type>inet</type> and <type>cidr</type>
    data types is that <type>inet</type> accepts values with nonzero bits to
    the right of the netmask, whereas <type>cidr</type> does not.  For
    example, <literal>192.168.0.1/24</literal> is valid for <type>inet</type>
    but not for <type>cidr</type>.
    </para>
____________________________________________________________________________-->
    <para>
    <type>inet</type>和<type>cidr</type>类型之间的本质区别是<type>inet</type>接受右边有非零位的网络掩码， 而<type>cidr</type>不接受。例如，<literal>192.168.0.1/24</literal>对<type>inet</type>是有效的，但对<type>cidr</type>是无效的。
    </para>

      <tip>
<!--==========================orignal english content==========================
        <para>
        If you do not like the output format for <type>inet</type> or
        <type>cidr</type> values, try the functions <function>host</function>,
        <function>text</function>, and <function>abbrev</function>.
        </para>
____________________________________________________________________________-->
        <para>
        如果你不喜欢<type>inet</type>或<type>cidr</type>值的输出格式，可以尝试函数<function>host</function>、<function>text</function>和<function>abbrev</function>。
        </para>
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
<!--==========================orignal english content==========================
    <title><type>macaddr</type></title>
____________________________________________________________________________-->
    <title><type>macaddr</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>macaddr (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>macaddr（数据类型）</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>MAC address</primary>
     <see>macaddr</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>MAC地址</primary>
     <see>macaddr</see>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The <type>macaddr</type> type stores MAC addresses, known for example
     from Ethernet card hardware addresses (although MAC addresses are
     used for other purposes as well).  Input is accepted in the
     following formats:

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

     These examples would all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.
    </para>
____________________________________________________________________________-->
    <para>
     <type>macaddr</type>类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

     这些例子指定的都是同一个地址。对于位<literal>a</literal>到<literal>f</literal>，大小写都可以接受。输出总是使用展示的第一种形式。    </para>

<!--==========================orignal english content==========================
    <para>
     IEEE Std 802-2001 specifies the second shown form (with hyphens)
     as the canonical form for MAC addresses, and specifies the first
     form (with colons) as the bit-reversed notation, so that
     08-00-2b-01-02-03 = 01:00:4D:08:04:0C.  This convention is widely
     ignored nowadays, and it is relevant only for obsolete network
     protocols (such as Token Ring).  PostgreSQL makes no provisions
     for bit reversal, and all accepted formats use the canonical LSB
     order.
    </para>
____________________________________________________________________________-->
    <para>
     IEEE Std 802-2001 指定第二种展示的形式（带有连字符）作为MAC地址的标准形式，并且指定第一种形式（带有分号）作为位翻转的记号，因此 08-00-2b-01-02-03 = 01:00:4D:08:04:0C。这种习惯目前已经被广泛地忽略，并且它只与废弃的网络协议（如令牌环）相关。PostgreSQL 没有对位翻转做任何规定，并且所有可接受的格式都使用标准的LSB顺序。
    </para>

<!--==========================orignal english content==========================
    <para>
     The remaining five input formats are not part of any standard.
    </para>
____________________________________________________________________________-->
    <para>
     剩下的五种输入格式不属于任何标准。
    </para>
   </sect2>

   <sect2 id="datatype-macaddr8">
<!--==========================orignal english content==========================
    <title><type>macaddr8</type></title>
____________________________________________________________________________-->
    <title><type>macaddr8</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>macaddr8 (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>macaddr8 (data type)</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>MAC address (EUI-64 format)</primary>
     <see>macaddr</see>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>MAC address (EUI-64 format)</primary>
     <see>macaddr</see>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     The <type>macaddr8</type> type stores MAC addresses in EUI-64
     format, known for example from Ethernet card hardware addresses
     (although MAC addresses are used for other purposes as well).
     This type can accept both 6 and 8 byte length MAC addresses
     and stores them in 8 byte length format.  MAC addresses given
     in 6 byte format will be stored in 8 byte length format with the
     4th and 5th bytes set to FF and FE, respectively.

     Note that IPv6 uses a modified EUI-64 format where the 7th bit
     should be set to one after the conversion from EUI-48.  The
     function <function>macaddr8_set7bit</function> is provided to make this
     change.

     Generally speaking, any input which is comprised of pairs of hex
     digits (on byte boundaries), optionally separated consistently by
     one of <literal>':'</literal>, <literal>'-'</literal> or <literal>'.'</literal>, is
     accepted.  The number of hex digits must be either 16 (8 bytes) or
     12 (6 bytes).  Leading and trailing whitespace is ignored.

     The following are examples of input formats that are accepted:

     <simplelist>
      <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
      <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
      <member><literal>'08002b:0102030405'</literal></member>
      <member><literal>'08002b-0102030405'</literal></member>
      <member><literal>'0800.2b01.0203.0405'</literal></member>
      <member><literal>'0800-2b01-0203-0405'</literal></member>
      <member><literal>'08002b01:02030405'</literal></member>
      <member><literal>'08002b0102030405'</literal></member>
     </simplelist>

     These examples would all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.

     The last six input formats that are mentioned above are not part
     of any standard.

     To convert a traditional 48 bit MAC address in EUI-48 format to
     modified EUI-64 format to be included as the host portion of an
     IPv6 address, use <function>macaddr8_set7bit</function> as shown:

<programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit     
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
</programlisting>

    </para>
____________________________________________________________________________-->
    <para>
     <type>macaddr8</type>类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。以6字节格式给出的MAC地址被存储为8字节长度格式的方式是吧第4和第5字节分别设置为FF和FE。

     注意IPv6使用一种修改过的EUI-64格式，其中从EUI-48转换过来后的第7位应该被设置为一。函数<function>macaddr8_set7bit</function>被用来做这种修改。

     一般而言，任何由16进制数（字节边界上）对构成的输入（可以由<literal>':'</literal>、<literal>'-'</literal>或者<literal>'.'</literal>统一地分隔）都会被接受。16进制数的数量必须是16（8字节）或者12（6字节）。前导和拖尾的空格会被忽略。

     下面是可以被接受的输入格式的例子：

     <simplelist>
      <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
      <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
      <member><literal>'08002b:0102030405'</literal></member>
      <member><literal>'08002b-0102030405'</literal></member>
      <member><literal>'0800.2b01.0203.0405'</literal></member>
      <member><literal>'0800-2b01-0203-0405'</literal></member>
      <member><literal>'08002b01:02030405'</literal></member>
      <member><literal>'08002b0102030405'</literal></member>
     </simplelist>

     这些例子都指定相同的地址。数字<literal>a</literal>到<literal>f</literal>的大小写形式都被接受。输出总是以上面显示的第一种形式。

     上述的后六种输入格式不属于任何标准。

     要把EUI-48格式的传统48位MAC地址转换成修改版EUI-64格式（包括在IPv6地址中作为主机部分），可以使用下面的<function>macaddr8_set7bit</function>：

<programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit     
-------------------------
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
</programlisting>

    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
<!--==========================orignal english content==========================
   <title>Bit String Types</title>
____________________________________________________________________________-->
   <title>位串类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-bit">
    <primary>bit string</primary>
    <secondary>data type</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-bit">
    <primary>位串</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Bit strings are strings of 1's and 0's.  They can be used to store
    or visualize bit masks.  There are two SQL bit types:
    <type>bit(<replaceable>n</replaceable>)</type> and <type>bit
    varying(<replaceable>n</replaceable>)</type>, where
    <replaceable>n</replaceable> is a positive integer.
   </para>
____________________________________________________________________________-->
   <para>
    位串就是一串 1 和 0 的串。它们可以用于存储和可视化位掩码。我们有两种类型的 SQL 位类型：<type>bit(<replaceable>n</replaceable>)</type>和<type>bit varying(<replaceable>n</replaceable>)</type>，其中 <replaceable>n</replaceable>是一个正整数。
   </para>

<!--==========================orignal english content==========================
   <para>
    <type>bit</type> type data must match the length
    <replaceable>n</replaceable> exactly; it is an error to attempt to
    store shorter or longer bit strings.  <type>bit varying</type> data is
    of variable length up to the maximum length
    <replaceable>n</replaceable>; longer strings will be rejected.
    Writing <type>bit</type> without a length is equivalent to
    <literal>bit(1)</literal>, while <type>bit varying</type> without a length
    specification means unlimited length.
   </para>
____________________________________________________________________________-->
   <para>
    <type>bit</type>类型的数据必须准确匹配长度<replaceable>n</replaceable>; 试图存储短些或者长一些的位串都是错误的。<type>bit varying</type>数据是最长<replaceable>n</replaceable>的变长类型，更长的串会被拒绝。写一个没有长度的<type>bit</type>等效于 <literal>bit(1)</literal>，没有长度的<type>bit varying</type>意味着没有长度限制。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     If one explicitly casts a bit-string value to
     <type>bit(<replaceable>n</replaceable>)</type>, it will be truncated or
     zero-padded on the right to be exactly <replaceable>n</replaceable> bits,
     without raising an error.  Similarly,
     if one explicitly casts a bit-string value to
     <type>bit varying(<replaceable>n</replaceable>)</type>, it will be truncated
     on the right if it is more than <replaceable>n</replaceable> bits.
    </para>
____________________________________________________________________________-->
    <para>
     如果我们显式地把一个位串值转换成<type>bit(<replaceable>n</replaceable>)</type>， 那么它的右边将被截断或者在右边补齐零，直到刚好<replaceable>n</replaceable>位， 而且不会抛出任何错误。类似地，如果我们显式地把一个位串数值转换成<type>bit varying(<replaceable>n</replaceable>)</type>，如果它超过了<replaceable>n</replaceable>位， 那么它的右边将被截断。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Refer to <xref
    linkend="sql-syntax-bit-strings"/> for information about the syntax
    of bit string constants.  Bit-logical operators and string
    manipulation functions are available; see <xref
    linkend="functions-bitstring"/>.
   </para>
____________________________________________________________________________-->
   <para>
    请参考<xref linkend="sql-syntax-bit-strings"/>获取有关位串常量的语法的信息。还有一些位逻辑操作符和串操作函数可用，请见<xref linkend="functions-bitstring"/>。
   </para>

   <example>
<!--==========================orignal english content==========================
    <title>Using the Bit String Types</title>
____________________________________________________________________________-->
    <title>使用位串类型</title>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-&minus;-&minus;-+-&minus;-&minus;-
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
   </example>

<!--==========================orignal english content==========================
   <para>
    A bit string value requires 1 byte for each group of 8 bits, plus
    5 or 8 bytes overhead depending on the length of the string
    (but long values may be compressed or moved out-of-line, as explained
    in <xref linkend="datatype-character"/> for character strings).
   </para>
____________________________________________________________________________-->
   <para>
    一个位串值对于每8位的组需要一个字节，外加总共5个或8个字节，这取决于串的长度（但是长值可能被压缩或者移到线外，如<xref linkend="datatype-character"/>中对字符串的解释一样）。
   </para>
  </sect1>

  <sect1 id="datatype-textsearch">
<!--==========================orignal english content==========================
   <title>Text Search Types</title>
____________________________________________________________________________-->
   <title>文本搜索类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>data types</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>data types</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides two data types that
    are designed to support full text search, which is the activity of
    searching through a collection of natural-language <firstterm>documents</firstterm>
    to locate those that best match a <firstterm>query</firstterm>.
    The <type>tsvector</type> type represents a document in a form optimized
    for text search; the <type>tsquery</type> type similarly represents
    a text query.
    <xref linkend="textsearch"/> provides a detailed explanation of this
    facility, and <xref linkend="functions-textsearch"/> summarizes the
    related functions and operators.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供两种数据类型，它们被设计用来支持全文搜索，全文搜索是一种在自然语言的<firstterm>文档</firstterm>集合中搜索以定位那些最匹配一个<firstterm>查询</firstterm>的文档的活动。<type>tsvector</type>类型表示一个为文本搜索优化的形式下的文档，<type>tsquery</type>类型表示一个文本查询。<xref linkend="textsearch"/>提供了对于这种功能的详细解释，并且<xref linkend="functions-textsearch"/>总结了相关的函数和操作符。
   </para>

   <sect2 id="datatype-tsvector">
<!--==========================orignal english content==========================
    <title><type>tsvector</type></title>
____________________________________________________________________________-->
    <title><type>tsvector</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>tsvector (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>tsvector（数据类型）</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     A <type>tsvector</type> value is a sorted list of distinct
     <firstterm>lexemes</firstterm>, which are words that have been
     <firstterm>normalized</firstterm> to merge different variants of the same word
     (see <xref linkend="textsearch"/> for details).  Sorting and
     duplicate-elimination are done automatically during input, as shown in
     this example:

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

     To represent
     lexemes containing whitespace or punctuation, surround them with quotes:

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector                  
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

     (We use dollar-quoted string literals in this example and the next one
     to avoid the confusion of having to double quote marks within the
     literals.)  Embedded quotes and backslashes must be doubled:

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector                    
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     Optionally, integer <firstterm>positions</firstterm>
     can be attached to lexemes:

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     A position normally indicates the source word's location in the
     document.  Positional information can be used for
     <firstterm>proximity ranking</firstterm>.  Position values can
     range from 1 to 16383; larger numbers are silently set to 16383.
     Duplicate positions for the same lexeme are discarded.
    </para>
____________________________________________________________________________-->
    <para>
     一个<type>tsvector</type>值是一个排序的可区分<firstterm>词位</firstterm>的列表，<firstterm>词位</firstterm>是被<firstterm>正规化</firstterm>合并了同一个词的不同变种的词（详见<xref linkend="textsearch"/>）。排序和去重是在输入期间自动完成的，如下例所示：

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

     要表示包含空白或标点的词位，将它们用引号包围：

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

     （我们在这个例子中使用美元符号包围的串文字并且下一个用来避免在文字中包含双引号记号产生的混淆）。嵌入的引号和反斜线必须被双写：

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     可选的，整数<firstterm>位置</firstterm>可以被附加给词位：

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     一个位置通常表示源词在文档中的定位。位置信息可以被用于<firstterm>邻近排名</firstterm>。位置值可以从 1 到 16383，更大的数字会被 16383。对于相同的词位出现的重复位置将被丢弃。
    </para>

<!--==========================orignal english content==========================
    <para>
     Lexemes that have positions can further be labeled with a
     <firstterm>weight</firstterm>, which can be <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, or <literal>D</literal>.
     <literal>D</literal> is the default and hence is not shown on output:

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector          
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     Weights are typically used to reflect document structure, for example
     by marking title words differently from body words.  Text search
     ranking functions can assign different priorities to the different
     weight markers.
    </para>
____________________________________________________________________________-->
    <para>
     具有位置的词位可以进一步地被标注一个<firstterm>权重</firstterm>，它可以是<literal>A</literal>、
     <literal>B</literal>、<literal>C</literal>或<literal>D</literal>。
     <literal>D</literal>是默认值并且因此在输出中不会显示：

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     权重通常被用来反映文档结构，例如将主题词标记成与正文词不同。文本搜索排名函数可以为不同的权重标记器分配不同的优先级。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is important to understand that the
     <type>tsvector</type> type itself does not perform any word
     normalization; it assumes the words it is given are normalized
     appropriately for the application.  For example,

<programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector      
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'Fat' 'Rats' 'The'
</programlisting>

     For most English-text-searching applications the above words would
     be considered non-normalized, but <type>tsvector</type> doesn't care.
     Raw document text should usually be passed through
     <function>to_tsvector</function> to normalize the words appropriately
     for searching:

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector   
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat':2 'rat':3
</programlisting>

     Again, see <xref linkend="textsearch"/> for more detail.
    </para>
____________________________________________________________________________-->
    <para>
     了解<type>tsvector</type>类型本身并不执行任何词正规化这一点很重要，它假定给它的词已经被恰当地为应用正规化过。例如，

<programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'
</programlisting>

     对于大部分英语文本搜索应用，上面的词将会被认为是非正规化的，但是<type>tsvector</type>并不在乎这一点。原始文档文本通常应该经过<function>to_tsvector</function>以恰当地为搜索正规化其中的词：

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3
</programlisting>

     再次地，详情请参阅<xref linkend="textsearch"/>。
    </para>

   </sect2>

   <sect2 id="datatype-tsquery">
<!--==========================orignal english content==========================
    <title><type>tsquery</type></title>
____________________________________________________________________________-->
    <title><type>tsquery</type></title>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>tsquery (data type)</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>tsquery（数据类型）</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <para>
     A <type>tsquery</type> value stores lexemes that are to be
     searched for, and can combine them using the Boolean operators
     <literal>&amp;</literal> (AND), <literal>|</literal> (OR), and
     <literal>!</literal> (NOT), as well as the phrase search operator
     <literal>&lt;-&gt;</literal> (FOLLOWED BY).  There is also a variant
     <literal>&lt;<replaceable>N</replaceable>&gt;</literal> of the FOLLOWED BY
     operator, where <replaceable>N</replaceable> is an integer constant that
     specifies the distance between the two lexemes being searched
     for.  <literal>&lt;-&gt;</literal> is equivalent to <literal>&lt;1&gt;</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     一个<type>tsquery</type>值存储要用于搜索的词位，并且使用布尔操作符<literal>&amp;</literal>（AND）、<literal>|</literal>（OR）和<literal>!</literal>（NOT）来组合它们，还有短语搜索操作符<literal>&lt;-&gt;</literal>（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体<literal>&lt;<replaceable>N</replaceable>&gt;</literal>，其中<replaceable>N</replaceable>是一个整数常量，它指定要搜索的两个词位之间的距离。<literal>&lt;-&gt;</literal>等效于<literal>&lt;1&gt;</literal>。
    </para>

<!--==========================orignal english content==========================
    <para>
     Parentheses can be used to enforce grouping of these operators.
     In the absence of parentheses, <literal>!</literal> (NOT) binds most tightly,
     <literal>&lt;-&gt;</literal> (FOLLOWED BY) next most tightly, then
     <literal>&amp;</literal> (AND), with <literal>|</literal> (OR) binding
     the least tightly.
    </para>
____________________________________________________________________________-->
    <para>   
     圆括号可以被用来强制对操作符分组。如果没有圆括号，<literal>!</literal>（NOT）的优先级最高，其次是<literal>&lt;-&gt;</literal>（FOLLOWED BY），然后是<literal>&amp;</literal>（AND），最后是<literal>|</literal>（OR）。
    </para>

<!--==========================orignal english content==========================
    <para>
     Here are some examples:

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery    
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     这里有一些例子：

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery    
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery          
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery         
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Optionally, lexemes in a <type>tsquery</type> can be labeled with
     one or more weight letters, which restricts them to match only
     <type>tsvector</type> lexemes with one of those weights:

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat':AB &amp; 'cat'
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     可选地，一个<type>tsquery</type>中的词位可以被标注一个或多个权重字母，这将限制它们只能和具有那些权重之一的<type>tsvector</type>词位相匹配：

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</literal>
     to specify prefix matching:
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery  
-&minus;-&minus;-&minus;-&minus;-&minus;-
 'super':*
</programlisting>
     This query will match any word in a <type>tsvector</type> that begins
     with <quote>super</quote>.
    </para>
____________________________________________________________________________-->
    <para>
     此外，一个<type>tsquery</type>中的词位可以被标注为<literal>*</literal>来指定前缀匹配：
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*
</programlisting>
     这个查询将匹配一个<type>tsvector</type>中以<quote>super</quote>开头的任意词。
    </para>

<!--==========================orignal english content==========================
    <para>
     Quoting rules for lexemes are the same as described previously for
     lexemes in <type>tsvector</type>; and, as with <type>tsvector</type>,
     any required normalization of words must be done before converting
     to the <type>tsquery</type> type.  The <function>to_tsquery</function>
     function is convenient for performing such normalization:

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery    
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat':AB &amp; 'cat'
</programlisting>

     Note that <function>to_tsquery</function> will process prefixes in the same way
     as other words, which means this comparison returns true:

<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;
 t
</programlisting>
     because <literal>postgres</literal> gets stemmed to <literal>postgr</literal>:
<programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'postgradu':1 | 'postgr':*
</programlisting>
     which will match the stemmed form of <literal>postgraduate</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     词位的引号规则和之前描述的<type>tsvector</type>中的词位相同；并且，正如<type>tsvector</type>，任何请求的词正规化必须在转换到<type>tsquery</type>类型之前完成。<function>to_tsquery</function>函数可以方便地执行这种正规化：

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>

     注意<function>to_tsquery</function>将会以和其他词同样的方式处理前缀，这也意味着下面的比较会返回真：

<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t
</programlisting>
     因为<literal>postgres</literal>会被处理成<literal>postgr</literal>：
<programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*
</programlisting>
     这会匹配<literal>postgraduate</literal>被处理后的形式。
    </para>

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
<!--==========================orignal english content==========================
   <title><acronym>UUID</acronym> Type</title>
____________________________________________________________________________-->
   <title><acronym>UUID</acronym>类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The data type <type>uuid</type> stores Universally Unique Identifiers
    (UUID) as defined by RFC 4122, ISO/IEC 9834-8:2005, and related standards.
    (Some systems refer to this data type as a globally unique identifier, or
    GUID,<indexterm><primary>GUID</primary></indexterm> instead.)  This
    identifier is a 128-bit quantity that is generated by an algorithm chosen
    to make it very unlikely that the same identifier will be generated by
    anyone else in the known universe using the same algorithm.  Therefore,
    for distributed systems, these identifiers provide a better uniqueness
    guarantee than sequence generators, which
    are only unique within a single database.
   </para>
____________________________________________________________________________-->
   <para>
    数据类型<type>uuid</type>存储由RFC 4122、ISO/IEC 9834-8:2005以及相关标准定义的通用唯一标识符（UUID）（某些系统将这种数据类型引用为全局唯一标识符GUID<indexterm><primary>GUID</primary></indexterm>）。这种标识符是一个128位的量，它由一个精心选择的算法产生，该算法能保证在已知空间中任何其他使用相同算法的人能够产生同一个标识符的可能性非常非常小。因此，对于分布式系统，这些标识符相比序列生成器而言提供了一种很好的唯一性保障，序列生成器只能在一个数据库中保证唯一。
   </para>

<!--==========================orignal english content==========================
   <para>
    A UUID is written as a sequence of lower-case hexadecimal digits,
    in several groups separated by hyphens, specifically a group of 8
    digits followed by three groups of 4 digits followed by a group of
    12 digits, for a total of 32 digits representing the 128 bits.  An
    example of a UUID in this standard form is:
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname> also accepts the following
    alternative forms for input:
    use of upper-case digits, the standard format surrounded by
    braces, omitting some or all hyphens, adding a hyphen after any
    group of four digits.  Examples are:
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
    Output is always in the standard form.
   </para>
____________________________________________________________________________-->
   <para>
    一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname>也接受另一种输入形式：
    使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
    输出总是采用标准形式。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> provides storage and comparison
    functions for UUIDs, but the core database does not include any
    function for generating UUIDs, because no single algorithm is well
    suited for every application.  The <xref
    linkend="uuid-ossp"/> module
    provides functions that implement several standard algorithms.
    The <xref linkend="pgcrypto"/> module also provides a generation
    function for random UUIDs.
    Alternatively, UUIDs could be generated by client applications or
    other libraries invoked through a server-side function.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>为UUID提供了存储和比较函数，但是核心数据库不包含任何用于产生UUID的函数，因为没有一个单一算法能够很好地适应每一个应用。<xref linkend="uuid-ossp"/>模块提供了实现一些标准算法的函数。
    <xref linkend="pgcrypto"/>模块也为随机 UUID 提供了一个生成函数。
    此外，UUID可以由客户端应用产生，或者由通过服务器端函数调用的其他库生成。
   </para>
  </sect1>

  <sect1 id="datatype-xml">
<!--==========================orignal english content==========================
   <title><acronym>XML</acronym> Type</title>
____________________________________________________________________________-->
   <title><acronym>XML</acronym>类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <type>xml</type> data type can be used to store XML data.  Its
    advantage over storing XML data in a <type>text</type> field is that it
    checks the input values for well-formedness, and there are support
    functions to perform type-safe operations on it; see <xref
    linkend="functions-xml"/>.  Use of this data type requires the
    installation to have been built with <command>configure
    -&minus;with-libxml</command>.
   </para>
____________________________________________________________________________-->
   <para>
    <type>xml</type>数据类型可以被用来存储XML数据。它比直接在一个<type>text</type>域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作，参见<xref linkend="functions-xml"/>。使用这种数据类型要求在安装时用<command>configure --with-libxml</command>选项编译。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>xml</type> type can store well-formed
    <quote>documents</quote>, as defined by the XML standard, as well
    as <quote>content</quote> fragments, which are defined by the
    production <literal>XMLDecl? content</literal> in the XML
    standard.  Roughly, this means that content fragments can have
    more than one top-level element or character node.  The expression
    <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
    can be used to evaluate whether a particular <type>xml</type>
    value is a full document or only a content fragment.
   </para>
____________________________________________________________________________-->
   <para>
    <type>xml</type>类型可以存储结构良好（如XML标准所定义）的<quote>文档</quote>，以及<quote>内容</quote>片段，它们由XML标准中的<literal>XMLDecl? content</literal>产品所定义。粗略地看，这意味着内容片段中可以有多于一个的顶层元素或字符节点。表达式<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>可以被用来评估一个特定的<type>xml</type>值是一个完整文档或者仅仅是一个文档片段。
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title>Creating XML Values</title>
____________________________________________________________________________-->
    <title>创建XML值</title>
<!--==========================orignal english content==========================
   <para>
    To produce a value of type <type>xml</type> from character data,
    use the function
    <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    Examples:
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    While this is the only way to convert character strings into XML
    values according to the SQL standard, the PostgreSQL-specific
    syntaxes:
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    can also be used.
   </para>
____________________________________________________________________________-->
   <para>
    要从字符数据中生成一个<type>xml</type>类型的值，可以使用函数<function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    例子：
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    然而根据SQL标准这是唯一将字符串转换为XML值的方法，PostgreSQL特有的语法：
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    也可以被使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>xml</type> type does not validate input values
    against a document type declaration
    (DTD),<indexterm><primary>DTD</primary></indexterm>
    even when the input value specifies a DTD.
    There is also currently no built-in support for validating against
    other XML schema languages such as XML Schema.
   </para>
____________________________________________________________________________-->
   <para>
    即便输入值指定了一个文档类型声明（DTD），<type>xml</type>类型也不根据DTD来验证输入值<indexterm><primary>DTD</primary></indexterm>。目前也没有内建的支持用于根据其他XML模式语言（如XML模式）来进行验证。
   </para>

<!--==========================orignal english content==========================
   <para>
    The inverse operation, producing a character string value from
    <type>xml</type>, uses the function
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
    <replaceable>type</replaceable> can be
    <type>character</type>, <type>character varying</type>, or
    <type>text</type> (or an alias for one of those).  Again, according
    to the SQL standard, this is the only way to convert between type
    <type>xml</type> and character types, but PostgreSQL also allows
    you to simply cast the value.
   </para>
____________________________________________________________________________-->
   <para>
    作为一个逆操作，从<type>xml</type>产生一个字符串可以使用函数<function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
    <replaceable>type</replaceable>可以是
    <type>character</type>、<type>character varying</type>或
    <type>text</type>（或者其中之一的一个别名）。再次地，根据SQL标准，这也是在<type>xml</type>类型和字符类型间做转换的唯一方法，但是PostgreSQL也允许你简单地造型这些值。
   </para>

<!--==========================orignal english content==========================
   <para>
    When a character string value is cast to or from type
    <type>xml</type> without going through <type>XMLPARSE</type> or
    <type>XMLSERIALIZE</type>, respectively, the choice of
    <literal>DOCUMENT</literal> versus <literal>CONTENT</literal> is
    determined by the <quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>
    session configuration parameter, which can be set using the
    standard command:
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    or the more PostgreSQL-like syntax
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    The default is <literal>CONTENT</literal>, so all forms of XML
    data are allowed.
   </para>
____________________________________________________________________________-->
   <para>
    当一个字符串不是使用<type>XMLPARSE</type>造型成<type>xml</type>或者不是使用<type>XMLSERIALIZE</type>从<type>xml</type>造型得到，对于<literal>DOCUMENT</literal>和<literal>CONTENT</literal>两者的选择是根据<quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>会话配置参数决定的，它可以使用标准命令来设置：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    或者是更具有PostgreSQL风格的语法
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    默认值是<literal>CONTENT</literal>，因此所有形式的XML数据都被允许。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     With the default XML option setting, you cannot directly cast
     character strings to type <type>xml</type> if they contain a
     document type declaration, because the definition of XML content
     fragment does not accept them.  If you need to do that, either
     use <literal>XMLPARSE</literal> or change the XML option.
    </para>
____________________________________________________________________________-->
    <para>
     在使用默认XML option设置时，如果字符串包含一个文档类型声明，你就不能直接将字符串造型成类型<type>xml</type>，因为XML内容片断的定义不接受它们。如果你需要这样做，要么使用<literal>XMLPARSE</literal>，要么修改XML option。
    </para>
   </note>

   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Encoding Handling</title>
____________________________________________________________________________-->
    <title>编码处理</title>
<!--==========================orignal english content==========================
   <para>
    Care must be taken when dealing with multiple character encodings
    on the client, server, and in the XML data passed through them.
    When using the text mode to pass queries to the server and query
    results to the client (which is the normal mode), PostgreSQL
    converts all character data passed between the client and the
    server and vice versa to the character encoding of the respective
    end; see <xref linkend="multibyte"/>.  This includes string
    representations of XML values, such as in the above examples.
    This would ordinarily mean that encoding declarations contained in
    XML data can become invalid as the character data is converted
    to other encodings while traveling between client and server,
    because the embedded encoding declaration is not changed.  To cope
    with this behavior, encoding declarations contained in
    character strings presented for input to the <type>xml</type> type
    are <emphasis>ignored</emphasis>, and content is assumed
    to be in the current server encoding.  Consequently, for correct
    processing, character strings of XML data must be sent
    from the client in the current client encoding.  It is the
    responsibility of the client to either convert documents to the
    current client encoding before sending them to the server, or to
    adjust the client encoding appropriately.  On output, values of
    type <type>xml</type> will not have an encoding declaration, and
    clients should assume all data is in the current client
    encoding.
   </para>
____________________________________________________________________________-->
   <para>
    在客户端、服务器以及其中流过的XML数据上处理多字符编码时必须要注意。在使用文本模式向服务器传递查询以及向客户端传递查询结果（在普通模式）时，PostgreSQL将所有在客户端和服务器之间传递的字符数据转换为目标端的字符编码，参见<xref linkend="multibyte"/>。这也包括了表示XML值的串，正如上面的例子所述。这也通常意味着由于字符数据会在客户端和服务器之间传递时被转换成其他编码，包含在XML数据中的编码声明可能是无效的，因为内嵌的编码声明没有被改变。为了处理这种行为，包含在表示<type>xml</type>类型输入的字符串中包含的编码声明会被<emphasis>忽略</emphasis>，并且其内容被假定为当前服务器的编码。接着，为了正确处理，XML数据的字符串必须以当前客户端编码从客户端发出。客户端负责在把文档发送给服务器之前将它们转换为当前客户端编码，或者适当地调整客户端编码。在输出时，<type>xml</type>类型的值将不会有一个编码声明，并且客户端将会假设所有数据都是当前客户端编码。
   </para>

<!--==========================orignal english content==========================
   <para>
    When using binary mode to pass query parameters to the server
    and query results back to the client, no encoding conversion
    is performed, so the situation is different.  In this case, an
    encoding declaration in the XML data will be observed, and if it
    is absent, the data will be assumed to be in UTF-8 (as required by
    the XML standard; note that PostgreSQL does not support UTF-16).
    On output, data will have an encoding declaration
    specifying the client encoding, unless the client encoding is
    UTF-8, in which case it will be omitted.
   </para>
____________________________________________________________________________-->
   <para>
    在使用二进制模式传送查询参数给服务器以及传回查询结果给客户端时，不会执行编码转换，因此情况就有所不同。在这种情况下，XML数据中的编码声明将被注意到，并且如果缺少编码声明时该数据会被假定为UTF-8（由于XML标准的要求，注意PostgreSQL不支持UTF-16）。在输出时，数据将会有一个编码声明来指定客户端编码，除非客户端编码为UTF-8（这种情况下编码声明会被忽略）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Needless to say, processing XML data with PostgreSQL will be less
    error-prone and more efficient if the XML data encoding, client encoding,
    and server encoding are the same.  Since XML data is internally
    processed in UTF-8, computations will be most efficient if the
    server encoding is also UTF-8.
   </para>
____________________________________________________________________________-->
   <para>
    不用说，在PostgreSQL中处理XML数据产生错误的可能性更小，并且在XML数据编码、客户端编码和服务器编码三者相同时效率更高。因为XML数据在内部是以UTF-8处理的，如果服务器编码也是UTF-8时，计算效率将会最高。
   </para>

   <caution>
<!--==========================orignal english content==========================
    <para>
     Some XML-related functions may not work at all on non-ASCII data
     when the server encoding is not UTF-8.  This is known to be an
     issue for <function>xmltable()</function> and <function>xpath()</function> in particular.
    </para>
____________________________________________________________________________-->
    <para>
     当服务器编码不是UTF-8时，某些XML相关的函数可能在非ASCII数据上完全无法工作。尤其在<function>xmltable()</function>和<function>xpath()</function>上，这是一个已知的问题。
    </para>
   </caution>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
   <title>Accessing XML Values</title>
____________________________________________________________________________-->
   <title>访问XML值</title>

<!--==========================orignal english content==========================
   <para>
    The <type>xml</type> data type is unusual in that it does not
    provide any comparison operators.  This is because there is no
    well-defined and universally useful comparison algorithm for XML
    data.  One consequence of this is that you cannot retrieve rows by
    comparing an <type>xml</type> column against a search value.  XML
    values should therefore typically be accompanied by a separate key
    field such as an ID.  An alternative solution for comparing XML
    values is to convert them to character strings first, but note
    that character string comparison has little to do with a useful
    XML comparison method.
   </para>
____________________________________________________________________________-->
   <para>
    <type>xml</type>数据类型有些不同寻常，因为它不提供任何比较操作符。这是因为对于XML数据不存在良定义的和通用的比较算法。这种状况造成的后果就是，你无法通过比较一个<type>xml</type>和一个搜索值来检索行。XML值因此通常应该伴随着一个独立键值域，如一个ID。另一种比较XML值的方案是将它们先转换为字符串，但注意字符串比较对于XML比较方法没有什么帮助。
   </para>

<!--==========================orignal english content==========================
   <para>
    Since there are no comparison operators for the <type>xml</type>
    data type, it is not possible to create an index directly on a
    column of this type.  If speedy searches in XML data are desired,
    possible workarounds include casting the expression to a
    character string type and indexing that, or indexing an XPath
    expression.  Of course, the actual query would have to be adjusted
    to search by the indexed expression.
   </para>
____________________________________________________________________________-->
   <para>
    由于没有可以用于<type>xml</type>数据类型的比较操作符，因此无法直接在这种类型上创建索引。如果需要在XML中快速的搜索，可能的解决方案包括将表达式造型为一个字符串类型然后索引之，或者在一个XPath表达式上索引。当然，实际的查询必须被调整为使用被索引的表达式。
   </para>

<!--==========================orignal english content==========================
   <para>
    The text-search functionality in PostgreSQL can also be used to speed
    up full-document searches of XML data.  The necessary
    preprocessing support is, however, not yet available in the PostgreSQL
    distribution.
   </para>
____________________________________________________________________________-->
   <para>
    PostgreSQL中的文本搜索功能也可以被用来加速XML数据的全文搜索。但是，所需的预处理支持目前在PostgreSQL发布中还不可用。
   </para>
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="domains">
<!--==========================orignal english content==========================
   <title>Domain Types</title>
____________________________________________________________________________-->
   <title>域类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="domains">
    <primary>domain</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="domains">
    <primary>domain</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="domains">
    <primary>data type</primary>
    <secondary>domain</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="domains">
    <primary>data type</primary>
    <secondary>domain</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A <firstterm>domain</firstterm> is a user-defined data type that is
    based on another <firstterm>underlying type</firstterm>.  Optionally,
    it can have constraints that restrict its valid values to a subset of
    what the underlying type would allow.  Otherwise it behaves like the
    underlying type &mdash; for example, any operator or function that
    can be applied to the underlying type will work on the domain type.
    The underlying type can be any built-in or user-defined base type,
    enum type, array type, composite type, range type, or another domain.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>域</firstterm>是一种用户定义的数据类型，它基于另一种<firstterm>底层类型</firstterm>。根据需要，它可以有约束来限制其有效值为底层类型所允许值的一个子集。如果没有约束，它的行为就和底层类型一样 &mdash; 例如，任何适用于底层类型的操作符或函数都对该域类型有效。底层类型可以是任何内建或者用户定义的基础类型、枚举类型、数组类型、组合类型、范围类型或者另一个域。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, we could create a domain over integers that accepts only
    positive integers:
<programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -&minus; works
INSERT INTO mytable VALUES(-1);  -&minus; fails
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，我们可以在整数之上创建一个域，它只接受正整数：
<programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -- works
INSERT INTO mytable VALUES(-1);  -- fails
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    When an operator or function of the underlying type is applied to a
    domain value, the domain is automatically down-cast to the underlying
    type.  Thus, for example, the result of <literal>mytable.id - 1</literal>
    is considered to be of type <type>integer</type> not <type>posint</type>.
    We could write <literal>(mytable.id - 1)::posint</literal> to cast the
    result back to <type>posint</type>, causing the domain's constraints
    to be rechecked.  In this case, that would result in an error if the
    expression had been applied to an <structfield>id</structfield> value of
    1.  Assigning a value of the underlying type to a field or variable of
    the domain type is allowed without writing an explicit cast, but the
    domain's constraints will be checked.
   </para>
____________________________________________________________________________-->
   <para>
    当底层类型的一个操作符或函数适用于一个域值时，域会被自动向下造型为底层类型。因此，<literal>mytable.id - 1</literal>的结果会被认为是类型<type>integer</type>而不是<type>posint</type>。我们可以写成<literal>(mytable.id - 1)::posint</literal>来把结果转换回<type>posint</type>，这会导致域的约束被重新检查。在这种情况下，如果该表达式被应用于一个值为1的<structfield>id</structfield>就会错误。把底层类型的值赋给域类型的一个字段或者变量不需要写显式的造型，但是域的约束将会被检查。
   </para>

<!--==========================orignal english content==========================
   <para>
    For additional information see <xref linkend="sql-createdomain"/>.
   </para>
____________________________________________________________________________-->
   <para>
    更多信息请参考<xref linkend="sql-createdomain"/>。
   </para>
  </sect1>

  <sect1 id="datatype-oid">
<!--==========================orignal english content==========================
   <title>Object Identifier Types</title>
____________________________________________________________________________-->
   <title>对象标识符类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>object identifier</primary>
    <secondary>data type</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>对象标识符</primary>
    <secondary>数据类型</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various
    system tables.  OIDs are not added to user-created tables, unless
    <literal>WITH OIDS</literal> is specified when the table is
    created, or the <xref linkend="guc-default-with-oids"/>
    configuration variable is enabled.  Type <type>oid</type> represents
    an object identifier.  There are also several alias types for
    <type>oid</type>: <type>regproc</type>, <type>regprocedure</type>,
    <type>regoper</type>, <type>regoperator</type>, <type>regclass</type>,
    <type>regtype</type>, <type>regrole</type>, <type>regnamespace</type>,
    <type>regconfig</type>, and <type>regdictionary</type>.
    <xref linkend="datatype-oid-table"/> shows an overview.
   </para>
____________________________________________________________________________-->
   <para>
    对象标识符（OID）被<productname>PostgreSQL</productname>用来在内部作为多个系统表的主键。OID不会被添加到用户创建的表中，除非在创建表时指定了<literal>WITH OIDS</literal>或者<xref linkend="guc-default-with-oids"/>配置变量被启用。类型<type>oid</type>表示一个对象标识符。也有多个<type>oid</type>的别名类型：<type>regproc</type>、<type>regprocedure</type>、<type>regoper</type>、<type>regoperator</type>、<type>regclass</type>、<type>regtype</type>、<type>regrole</type>、<type>regnamespace</type>、<type>regconfig</type>和<type>regdictionary</type>。<xref linkend="datatype-oid-table"/>显示了一个概览。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>oid</type> type is currently implemented as an unsigned
    four-byte integer.  Therefore, it is not large enough to provide
    database-wide uniqueness in large databases, or even in large
    individual tables.  So, using a user-created table's OID column as
    a primary key is discouraged.  OIDs are best used only for
    references to system tables.
   </para>
____________________________________________________________________________-->
   <para>
    <type>oid</type>类型目前被实现为一个无符号4字节整数。因此，在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。于是，我们不鼓励使用一个用户定义表的OID列作为主键。OID最好只被用于引用系统表。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>oid</type> type itself has few operations beyond comparison.
    It can be cast to integer, however, and then manipulated using the
    standard integer operators.  (Beware of possible
    signed-versus-unsigned confusion if you do this.)
   </para>
____________________________________________________________________________-->
   <para>
    <type>oid</type>类型本身除了比较之外只有很少的操作。不过，它可以被造型成整数，并且接着可以使用标准的整数操作符进行操纵（这样做时要注意有符号和无符号之间可能出现的混乱）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The OID alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</type> would use.  The alias
    types allow simplified lookup of OID values for objects.  For example,
    to examine the <structname>pg_attribute</structname> rows related to a table
    <literal>mytable</literal>, one could write:
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    rather than:
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</literal> in different schemas.
    The <type>regclass</type> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</quote>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</type> is handy for symbolic display of a numeric OID.
   </para>
____________________________________________________________________________-->
   <para>
    OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<type>oid</type>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<literal>mytable</literal>有关的<structname>pg_attribute</structname>行，你可以写：
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    而不是：
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    虽然从它本身看起来并没有那么糟，它仍然被过度简化了。如果有多个名为<literal>mytable</literal>的表存在于不同的模式中，就可能需要一个更复杂的子选择来选择右边的OID。<type>regclass</type>输入转换器会根据模式路径设置处理表查找，并且因此它会自动地完成这种<quote>右边的事情</quote>。类似地，对于一个数字OID的符号化显示可以很方便地通过将表OID造型成<type>regclass</type>来实现。
   </para>

    <table id="datatype-oid-table">
<!--==========================orignal english content==========================
     <title>Object Identifier Types</title>
____________________________________________________________________________-->
     <title>对象标识符类型</title>
     <tgroup cols="4">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>References</entry>
        <entry>Description</entry>
        <entry>Value Example</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>引用</entry>
        <entry>描述</entry>
        <entry>值示例</entry>
       </row>
      </thead>

      <tbody>

<!--==========================orignal english content==========================
       <row>
        <entry><type>oid</type></entry>
        <entry>any</entry>
        <entry>numeric object identifier</entry>
        <entry><literal>564182</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>oid</type></entry>
        <entry>任意</entry>
        <entry>数字形式的对象标识符</entry>
        <entry><literal>564182</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>function name</entry>
        <entry><literal>sum</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>函数名字</entry>
        <entry><literal>sum</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>function with argument types</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>带参数类型的函数</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>operator name</entry>
        <entry><literal>+</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>操作符名字</entry>
        <entry><literal>+</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>operator with argument types</entry>
        <entry><literal>*(integer,integer)</literal> or <literal>-(NONE,integer)</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>带参数类型的操作符</entry>
        <entry><literal>*(integer,integer)</literal> or <literal>-(NONE,integer)</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>relation name</entry>
        <entry><literal>pg_type</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>关系名字</entry>
        <entry><literal>pg_type</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>data type name</entry>
        <entry><literal>integer</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>数据类型名字</entry>
        <entry><literal>integer</literal></entry>
       </row>
       
<!--==========================orignal english content==========================
       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>role name</entry>
        <entry><literal>smithee</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>角色名</entry>
        <entry><literal>smithee</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>namespace name</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>名字空间名称</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>text search configuration</entry>
        <entry><literal>english</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>文本搜索配置</entry>
        <entry><literal>english</literal></entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>text search dictionary</entry>
        <entry><literal>simple</literal></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>文本搜索字典</entry>
        <entry><literal>simple</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    All of the OID alias types for objects grouped by namespace accept
    schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    The <type>regproc</type> and <type>regoper</type> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</type> or
    <type>regoperator</type> are more appropriate.  For <type>regoperator</type>,
    unary operators are identified by writing <literal>NONE</literal> for the unused
    operand.
   </para>
____________________________________________________________________________-->
   <para>
    所有用于由名字空间组织的对象的 OID 别名类型都接受模式限定的名字，如果没有被限定的对象在当前搜索路径中无法找到时，将会在输出时显示模式限定的名字。<type>regproc</type>和<type>regoper</type>别名类型将只接受唯一的（非重载的）输入名字，因此它们的使用是受限的；对于大多数使用，<type>regprocedure</type>或<type>regoperator</type>更合适。对于<type>regoperator</type>，通过使用<literal>NONE</literal>来替代未使用的操作数可以标识一元操作符。
   </para>

<!--==========================orignal english content==========================
   <para>
    An additional property of most of the OID alias types is the creation of
    dependencies.  If a
    constant of one of these types appears in a stored expression
    (such as a column default expression or view), it creates a dependency
    on the referenced object.  For example, if a column has a default
    expression <literal>nextval('my_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname>
    understands that the default expression depends on the sequence
    <literal>my_seq</literal>; the system will not let the sequence be dropped
    without first removing the default expression.
    <type>regrole</type> is the only exception for the property. Constants of this
    type are not allowed in such expressions.
   </para>
____________________________________________________________________________-->
   <para>
    大部分 OID 别名类型的一个附加性质是依赖性的创建。如果这些类型之一的一个常量出现在一个存储的表达式（如一个列默认值表达式或视图）中，它会在被引用的对象上创建一个依赖。例如，如果一个列有一个默认值表达式<literal>nextval('my_seq'::regclass)</literal>，<productname>PostgreSQL</productname>会理解该默认值表达式是依赖于序列<literal>my_seq</literal>的，在删除该默认值表达式之前系统将不允许删除该序列。<type>regrole</type>是这个性质的唯一例外。这种类型的常量不允许出现在这类表达式中。
   </para>
   
   <note>
<!--==========================orignal english content==========================
   <para>
    The OID alias types do not completely follow transaction isolation
    rules. The planner also treats them as simple constants, which may
    result in sub-optimal planning.
   </para>
____________________________________________________________________________-->
   <para>
    OID 别名类型不完全遵循事务隔离规则。规划器也把它们当做简单常量，
    这可能会导致次优的规划。
   </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    Another identifier type used by the system is <type>xid</type>, or transaction
    (abbreviated <abbrev>xact</abbrev>) identifier.  This is the data type of the system columns
    <structfield>xmin</structfield> and <structfield>xmax</structfield>.  Transaction identifiers are 32-bit quantities.
   </para>
____________________________________________________________________________-->
   <para>
    另一种系统中使用的标识符类型是<type>xid</type>，或者称为事务（简写为<abbrev>xact</abbrev>）标识符。这是系统列<structfield>xmin</structfield>和<structfield>xmax</structfield>使用的数据类型。事务标识符是32位量。
   </para>

<!--==========================orignal english content==========================
   <para>
    A third identifier type used by the system is <type>cid</type>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</structfield> and <structfield>cmax</structfield>. Command identifiers are also 32-bit quantities.
   </para>
____________________________________________________________________________-->
   <para>
    系统使用的第三种标识符类型是<type>cid</type>，或者称为命令标识符。这是系统列<structfield>cmin</structfield>和<structfield>cmax</structfield>使用的数据类型。命令标识符也是32位量。
   </para>

<!--==========================orignal english content==========================
   <para>
    A final identifier type used by the system is <type>tid</type>, or tuple
    identifier (row identifier).  This is the data type of the system column
    <structfield>ctid</structfield>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the row within its table.
   </para>
____________________________________________________________________________-->
   <para>
    系统使用的最后一种标识符类型是<type>tid</type>，或者称为元组标识符（行标识符）。这是系统列<structfield>ctid</structfield>使用的数据类型。一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。
   </para>

<!--==========================orignal english content==========================
   <para>
    (The system columns are further explained in <xref
    linkend="ddl-system-columns"/>.)
   </para>
____________________________________________________________________________-->
   <para>
    （这些系统列在<xref linkend="ddl-system-columns"/>中有进一步的解释）。
   </para>
  </sect1>

  <sect1 id="datatype-pg-lsn">
<!--==========================orignal english content==========================
   <title><acronym>pg_lsn Type</acronym></title>
____________________________________________________________________________-->
   <title><acronym>pg_lsn 类型</acronym></title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence
    Number) data which is a pointer to a location in the WAL. This type is a
    representation of <type>XLogRecPtr</type> and an internal system type of
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    <type>pg_lsn</type>数据类型可以被用来存储 LSN（日志序列号）数据，LSN 是一个指向WAL中的位置的指针。这个类型是<type>XLogRecPtr</type>的一种表达并且是
    <productname>PostgreSQL</productname>的一种内部系统类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    Internally, an LSN is a 64-bit integer, representing a byte position in
    the write-ahead log stream.  It is printed as two hexadecimal numbers of
    up to 8 digits each, separated by a slash; for example,
    <literal>16/B374D848</literal>.  The <type>pg_lsn</type> type supports the
    standard comparison operators, like <literal>=</literal> and
    <literal>&gt;</literal>.  Two LSNs can be subtracted using the
    <literal>-</literal> operator; the result is the number of bytes separating
    those write-ahead log locations.
   </para>
____________________________________________________________________________-->
   <para>
    在内部，一个 LSN 是一个 64 位整数，表示在预写式日志流中的一个字节位置。它被打印成
    两个最高 8 位的十六进制数，中间用斜线分隔，例如<literal>16/B374D848</literal>。
    <type>pg_lsn</type>类型支持标准的比较操作符，如<literal>=</literal>和
    <literal>&gt;</literal>。两个 LSN 可以用<literal>-</literal>操作符做减法，
    结果将是分隔两个预写式日志位置的字节数。
   </para>
  </sect1>

  <sect1 id="datatype-pseudo">
<!--==========================orignal english content==========================
   <title>Pseudo-Types</title>
____________________________________________________________________________-->
   <title>伪类型</title>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>
   
<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>opaque</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The <productname>PostgreSQL</productname> type system contains a
    number of special-purpose entries that are collectively called
    <firstterm>pseudo-types</firstterm>.  A pseudo-type cannot be used as a
    column data type, but it can be used to declare a function's
    argument or result type.  Each of the available pseudo-types is
    useful in situations where a function's behavior does not
    correspond to simply taking or returning a value of a specific
    <acronym>SQL</acronym> data type.  <xref
    linkend="datatype-pseudotypes-table"/> lists the existing
    pseudo-types.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>类型系统包含了一些特殊目的的项，它们被统称为<firstterm>伪类型</firstterm>。一个伪类型不能被用作一个列的数据类型，但是它可以被用来定义一个函数的参数或者结果类型。每一种可用的伪类型都有其可以发挥作用的情况，这些情况的特点是一个函数的行为并不能符合于简单使用或者返回一种特定<acronym>SQL</acronym>数据类型的值。<xref linkend="datatype-pseudotypes-table"/>列出了现有的伪类型。
   </para>

    <table id="datatype-pseudotypes-table">
<!--==========================orignal english content==========================
     <title>Pseudo-Types</title>
____________________________________________________________________________-->
     <title>伪类型</title>
     <tgroup cols="2">
      <thead>
<!--==========================orignal english content==========================
       <row>
        <entry>Name</entry>
        <entry>Description</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
      </thead>

      <tbody>
<!--==========================orignal english content==========================
       <row>
        <entry><type>any</type></entry>
        <entry>Indicates that a function accepts any input data type.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>any</type></entry>
        <entry>表示一个函数可以接受任意输入数据类型。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indicates that a function accepts any data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>anyelement</type></entry>
        <entry>表示一个函数可以接受任意数据类型（参见<xref linkend="extend-types-polymorphic"/>）。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>anyarray</type></entry>
        <entry>Indicates that a function accepts any array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>anyarray</type></entry>
        <entry>表示一个函数可以接受任意数组数据类型（参见<xref linkend="extend-types-polymorphic"/>）</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Indicates that a function accepts any non-array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>表示一个函数可以接受任意非数组数据类型（参见<xref linkend="extend-types-polymorphic"/>）。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>anyenum</type></entry>
        <entry>Indicates that a function accepts any enum data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="datatype-enum"/>).</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>anyenum</type></entry>
        <entry>表示一个函数可以接受任意枚举数据类型（参见<xref linkend="extend-types-polymorphic"/>和<xref linkend="datatype-enum"/>）。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>anyrange</type></entry>
        <entry>Indicates that a function accepts any range data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>anyrange</type></entry>
        <entry>表示一个函数可以接受任意范围数据类型（参见<xref linkend="extend-types-polymorphic"/>和<xref linkend="rangetypes"/>）。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>cstring</type></entry>
        <entry>Indicates that a function accepts or returns a null-terminated C string.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>cstring</type></entry>
        <entry>表示一个函数接受或者返回一个非空结尾的C字符串。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>internal</type></entry>
        <entry>Indicates that a function accepts or returns a server-internal
        data type.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>internal</type></entry>
        <entry>表示一个函数接受或返回一个服务器内部数据类型。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>language_handler</type></entry>
        <entry>A procedural language call handler is declared to return <type>language_handler</type>.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>language_handler</type></entry>
        <entry>一个被声明为返回<type>language_handler</type>的过程语言调用处理器。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>A foreign-data wrapper handler is declared to return <type>fdw_handler</type>.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>一个被声明为返回<type>fdw_handler</type>的外部数据包装器处理器。</entry>
       </row>
       
<!--==========================orignal english content==========================
       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>An index access method handler is declared to return <type>index_am_handler</type>.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>一个被声明为返回<type>index_am_handler</type>索引访问方法处理器。</entry>
       </row>
       
<!--==========================orignal english content==========================
       <row>
        <entry><type>tsm_handler</type></entry>
        <entry>A tablesample method handler is declared to return <type>tsm_handler</type>.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>tsm_handler</type></entry>
        <entry> 一个被声明为返回<type>tsm_handler</type>的表采样方法处理器。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>record</type></entry>
        <entry>Identifies a function taking or returning an unspecified row type.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>record</type></entry>
        <entry>标识一个接收或者返回一个未指定的行类型的函数。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>trigger</type></entry>
        <entry>A trigger function is declared to return <type>trigger.</type></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>trigger</type></entry>
        <entry>一个被声明为返回<type>trigger</type>的触发器函数。</entry>
       </row>
       
<!--==========================orignal english content==========================
       <row>
        <entry><type>event_trigger</type></entry>
        <entry>An event trigger function is declared to return <type>event_trigger.</type></entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>event_trigger</type></entry>
        <entry>一个被声明为返回<type>event_trigger</type>的事件触发器函数。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>Identifies a representation of DDL commands that is available to event triggers.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>标识一种对事件触发器可用的 DDL 命令的表达。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>void</type></entry>
        <entry>Indicates that a function returns no value.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>void</type></entry>
        <entry>表示一个函数不返回值。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>unknown</type></entry>
        <entry>Identifies a not-yet-resolved type, e.g. of an undecorated
         string literal.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>unknown</type></entry>
        <entry>标识一种还未被解析的类型，例如一个未修饰的字符文本。</entry>
       </row>

<!--==========================orignal english content==========================
       <row>
        <entry><type>opaque</type></entry>
        <entry>An obsolete type name that formerly served many of the above
         purposes.</entry>
       </row>
____________________________________________________________________________-->
       <row>
        <entry><type>opaque</type></entry>
        <entry>一种已被废弃的类型名称，以前它用于实现以上的很多种目的。</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

<!--==========================orignal english content==========================
   <para>
    Functions coded in C (whether built-in or dynamically loaded) can be
    declared to accept or return any of these pseudo data types.  It is up to
    the function author to ensure that the function will behave safely
    when a pseudo-type is used as an argument type.
   </para>
____________________________________________________________________________-->
   <para>
    用C编写的函数（不管是内建的还是动态载入的）可以被声明为接受或返回这些为数据类型的任意一种。函数的作者应当保证当一个伪类型被用作一个参数类型时函数的行为是安全的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Functions coded in procedural languages can use pseudo-types only as
    allowed by their implementation languages.  At present most procedural
    languages forbid use of a pseudo-type as an argument type, and allow
    only <type>void</type> and <type>record</type> as a result type (plus
    <type>trigger</type> or <type>event_trigger</type> when the function is used
    as a trigger or event trigger).  Some also
    support polymorphic functions using the types <type>anyelement</type>,
    <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>, and
    <type>anyrange</type>.
   </para>
____________________________________________________________________________-->
   <para>
    用过程语言编写的函数只有在其实现语言允许的情况下才能使用伪类型。目前大部分过程语言都禁止使用伪类型作为一种参数类型，并且只允许使用<type>void</type>和<type>record</type>作为结果类型（如果函数被用于一个触发器或者事件触发器， <type>trigger</type>或者<type>event_trigger</type>也被允许作为结果类型）。某些过程语言也支持在多态函数中使用类型<type>anyelement</type>、<type>anyarray</type>、<type>anynonarray</type>、<type>anyenum</type>和<type>anyrange</type>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <type>internal</type> pseudo-type is used to declare functions
    that are meant only to be called internally by the database
    system, and not by direct invocation in an <acronym>SQL</acronym>
    query.  If a function has at least one <type>internal</type>-type
    argument then it cannot be called from <acronym>SQL</acronym>.  To
    preserve the type safety of this restriction it is important to
    follow this coding rule: do not create any function that is
    declared to return <type>internal</type> unless it has at least one
    <type>internal</type> argument.
   </para>
____________________________________________________________________________-->
   <para>
    <type>internal</type>伪类型用于定义只在数据库系统内部调用的函数，这些函数不会被<acronym>SQL</acronym>直接调用。如果一个函数拥有至少一个<type>internal</type>类型的参数，则它不能从<acronym>SQL</acronym>中被调用。为了保持这种限制的类型安全性，遵循以下编码规则非常重要：不要创建任何被声明要返回<type>internal</type>的函数，除非它有至少一个<type>internal</type>参数。
   </para>

  </sect1>

 </chapter>
