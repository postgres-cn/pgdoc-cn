<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
<!--==========================orignal english content==========================
 <title>Data Definition</title>
____________________________________________________________________________-->
 <title>数据定义</title>

<!--==========================orignal english content==========================
 <para>
  This chapter covers how one creates the database structures that
  will hold one's data.  In a relational database, the raw data is
  stored in tables, so the majority of this chapter is devoted to
  explaining how tables are created and modified and what features are
  available to control what data is stored in the tables.
  Subsequently, we discuss how tables can be organized into
  schemas, and how privileges can be assigned to tables.  Finally,
  we will briefly look at other features that affect the data storage,
  such as inheritance, table partitioning, views, functions, and
  triggers.
 </para>
____________________________________________________________________________-->
 <para>
  本章包含了如何创建用来保存数据的数据库结构。在一个关系型数据库中，原始数据被存储在表中，因此本章的主要工作就是解释如何创建和修改表，以及哪些特性可以控制何种数据会被存储在表中。接着，我们讨论表如何被组织成模式，以及如何将权限分配给表。最后，我们将将简短地介绍其他一些影响数据存储的特性，例如继承、表分区、视图、函数和触发器。
 </para>

 <sect1 id="ddl-basics">
<!--==========================orignal english content==========================
  <title>Table Basics</title>
____________________________________________________________________________-->
  <title>表基础</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>row</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>row</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>column</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>column</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A table in a relational database is much like a table on paper: It
   consists of rows and columns.  The number and order of the columns
   is fixed, and each column has a name.  The number of rows is
   variable &mdash; it reflects how much data is stored at a given moment.
   SQL does not make any guarantees about the order of the rows in a
   table.  When a table is read, the rows will appear in an unspecified order,
   unless sorting is explicitly requested.  This is covered in <xref
   linkend="queries"/>.  Furthermore, SQL does not assign unique
   identifiers to rows, so it is possible to have several completely
   identical rows in a table.  This is a consequence of the
   mathematical model that underlies SQL but is usually not desirable.
   Later in this chapter we will see how to deal with this issue.
  </para>
____________________________________________________________________________-->
  <para>
   关系型数据库中的一个表非常像纸上的一张表：它由行和列组成。列的数量和顺序是固定的，并且每一列拥有一个名字。行的数目是变化的，它反映了在一个给定时刻表中存储的数据量。SQL并不保证表中行的顺序。当一个表被读取时，表中的行将以非特定顺序出现，除非明确地指定需要排序。这些将在<xref linkend="queries"/>介绍。此外，SQL不会为行分配唯一的标识符，因此在一个表中可能会存在一些完全相同的行。这是SQL之下的数学模型导致的结果，但并不是所期望的。稍后在本章中我们将看到如何处理这种问题。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each column has a data type.  The data type constrains the set of
   possible values that can be assigned to a column and assigns
   semantics to the data stored in the column so that it can be used
   for computations.  For instance, a column declared to be of a
   numerical type will not accept arbitrary text strings, and the data
   stored in such a column can be used for mathematical computations.
   By contrast, a column declared to be of a character string type
   will accept almost any kind of data but it does not lend itself to
   mathematical calculations, although other operations such as string
   concatenation are available.
  </para>
____________________________________________________________________________-->
  <para>
   每一列都有一个数据类型。数据类型约束着一组可以分配给列的可能值，并且它为列中存储的数据赋予了语义，这样它可以用于计算。例如，一个被声明为数字类型的列将不会接受任何文本串，而存储在这样一列中的数据可以用来进行数学计算。反过来，一个被声明为字符串类型的列将接受几乎任何一种的数据，它可以进行如字符串连接的操作但不允许进行数学计算。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> includes a sizable set of
   built-in data types that fit many applications.  Users can also
   define their own data types.  Most built-in data types have obvious
   names and semantics, so we defer a detailed explanation to <xref
   linkend="datatype"/>.  Some of the frequently used data types are
   <type>integer</type> for whole numbers, <type>numeric</type> for
   possibly fractional numbers, <type>text</type> for character
   strings, <type>date</type> for dates, <type>time</type> for
   time-of-day values, and <type>timestamp</type> for values
   containing both date and time.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>包括了相当多的内建数据类型，可以适用于很多应用。用户也可以定义他们自己的数据类型。大部分内建数据类型有着显而易见的名称和语义，所以我们将它们的详细解释放在<xref linkend="datatype"/>中。一些常用的数据类型是：用于整数的<type>integer</type>；可以用于分数的<type>numeric</type>；用于字符串的<type>text</type>，用于日期的<type>date</type>，用于一天内时间的<type>time</type>以及可以同时包含日期和时间的<type>timestamp</type>。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   To create a table, you use the aptly named <xref
   linkend="sql-createtable"/> command.
   In this command you specify at least a name for the new table, the
   names of the columns and the data type of each column.  For
   example:
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   This creates a table named <literal>my_first_table</literal> with
   two columns.  The first column is named
   <literal>first_column</literal> and has a data type of
   <type>text</type>; the second column has the name
   <literal>second_column</literal> and the type <type>integer</type>.
   The table and column names follow the identifier syntax explained
   in <xref linkend="sql-syntax-identifiers"/>.  The type names are
   usually also identifiers, but there are some exceptions.  Note that the
   column list is comma-separated and surrounded by parentheses.
  </para>
____________________________________________________________________________-->
  <para>
   要创建一个表，我们要用到<xref linkend="sql-createtable"/>命令。在这个命令中 我们需要为新表至少指定一个名字、列的名字及数据类型。例如：
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   这将创建一个名为<literal>my_first_table</literal>的表，它拥有两个列。第一个列名为<literal>first_column</literal>且数据类型为<type>text</type>；第二个列名为<literal>second_column</literal>且数据类型为<type>integer</type>。表和列的名字遵循<xref linkend="sql-syntax-identifiers"/>中解释的标识符语法。类型名称通常也是标识符，但是也有些例外。注意列的列表由逗号分隔并被圆括号包围。
  </para>

<!--==========================orignal english content==========================
  <para>
   Of course, the previous example was heavily contrived.  Normally,
   you would give names to your tables and columns that convey what
   kind of data they store.  So let's look at a more realistic
   example:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   (The <type>numeric</type> type can store fractional components, as
   would be typical of monetary amounts.)
  </para>
____________________________________________________________________________-->
  <para>
   当然，前面的例子是非常不自然的。通常，我们为表和列赋予的名称都会表明它们存储着什么类别的数据。因此让我们再看一个更现实的例子：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   （<type>numeric</type>类型能够存储小数部分，典型的例子是金额。）
  </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    When you create many interrelated tables it is wise to choose a
    consistent naming pattern for the tables and columns.  For
    instance, there is a choice of using singular or plural nouns for
    table names, both of which are favored by some theorist or other.
   </para>
____________________________________________________________________________-->
   <para>
    当我们创建很多相关的表时，最好为表和列选择一致的命名模式。例如，一种选择是用单数或复数名词作为表名，每一种都受到一些理论家支持。
   </para>
  </tip>

<!--==========================orignal english content==========================
  <para>
   There is a limit on how many columns a table can contain.
   Depending on the column types, it is between 250 and 1600.
   However, defining a table with anywhere near this many columns is
   highly unusual and often a questionable design.
  </para>
____________________________________________________________________________-->
  <para>
   一个表能够拥有的列的数据是有限的，根据列的类型，这个限制介于250和1600之间。但是，极少会定义一个接近这个限制的表，即便有也是一个值的商榷的设计。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   If you no longer need a table, you can remove it using the <xref
   linkend="sql-droptable"/> command.
   For example:
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   Attempting to drop a table that does not exist is an error.
   Nevertheless, it is common in SQL script files to unconditionally
   try to drop each table before creating it, ignoring any error
   messages, so that the script works whether or not the table exists.
   (If you like, you can use the <literal>DROP TABLE IF EXISTS</literal> variant
   to avoid the error messages, but this is not standard SQL.)
  </para>
____________________________________________________________________________-->
  <para>
   如果我们不再需要一个表，我们可以通过使用<xref
   linkend="sql-droptable"/>命令来移除它。例如：
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   尝试移除一个不存在的表会引起错误。然而，在SQL脚本中在创建每个表之前无条件地尝试移除它的做法是很常见的，即使发生错误也会忽略之，因此这样的脚本可以在表存在和不存在时都工作得很好（如果你喜欢，可以使用<literal>DROP TABLE IF EXISTS</literal>变体来防止出现错误消息，但这并非标准SQL）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If you need to modify a table that already exists, see <xref
   linkend="ddl-alter"/> later in this chapter.
  </para>
____________________________________________________________________________-->
  <para>
   如果我们需要修改一个已经存在的表，请参考本章稍后的<xref
   linkend="ddl-alter"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   With the tools discussed so far you can create fully functional
   tables.  The remainder of this chapter is concerned with adding
   features to the table definition to ensure data integrity,
   security, or convenience.  If you are eager to fill your tables with
   data now you can skip ahead to <xref linkend="dml"/> and read the
   rest of this chapter later.
  </para>
____________________________________________________________________________-->
  <para>
   利用到目前为止所讨论的工具，我们可以创建一个全功能的表。本章的后续部分将集中于为表定义增加特性来保证数据完整性、安全性或方便。如果你希望现在就去填充你的表，你可以跳过这些直接去<xref linkend="dml"/>。
  </para>
 </sect1>

 <sect1 id="ddl-default">
<!--==========================orignal english content==========================
  <title>Default Values</title>
____________________________________________________________________________-->
  <title>默认值</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A column can be assigned a default value.  When a new row is
   created and no values are specified for some of the columns, those
   columns will be filled with their respective default values.  A
   data manipulation command can also request explicitly that a column
   be set to its default value, without having to know what that value is.
   (Details about data manipulation commands are in <xref linkend="dml"/>.)
  </para>
____________________________________________________________________________-->
  <para>
   一个列可以被分配一个默认值。当一个新行被创建且没有为某些列指定值时，这些列将会被它们相应的默认值填充。一个数据操纵命令也可以显式地要求一个列被置为它的默认值，而不需要知道这个值到底是什么（数据操纵命令详见<xref linkend="dml"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   If no default value is declared explicitly, the default value is the
   null value.  This usually makes sense because a null value can
   be considered to represent unknown data.
  </para>
____________________________________________________________________________-->
  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   如果没有显式指定默认值，则默认值是空值。这是合理的，因为空值表示未知数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   In a table definition, default values are listed after the column
   data type.  For example:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在一个表定义中，默认值被列在列的数据类型之后。例如：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   The default value can be an expression, which will be
   evaluated whenever the default value is inserted
   (<emphasis>not</emphasis> when the table is created).  A common example
   is for a <type>timestamp</type> column to have a default of <literal>CURRENT_TIMESTAMP</literal>,
   so that it gets set to the time of row insertion.  Another common
   example is generating a <quote>serial number</quote> for each row.
   In <productname>PostgreSQL</productname> this is typically done by
   something like:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   where the <literal>nextval()</literal> function supplies successive values
   from a <firstterm>sequence object</firstterm> (see <xref
   linkend="functions-sequence"/>). This arrangement is sufficiently common
   that there's a special shorthand for it:
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   The <literal>SERIAL</literal> shorthand is discussed further in <xref
   linkend="datatype-serial"/>.
  </para>
____________________________________________________________________________-->
  <para>
   默认值可以是一个表达式，它将在任何需要插入默认值的时候被实时计算（<emphasis>不</emphasis>是表创建时）。一个常见的例子是为一个<type>timestamp</type>列指定默认值为<literal>CURRENT_TIMESTAMP</literal>，这样它将得到行被插入时的时间。另一个常见的例子是为每一行生成一个<quote>序列号</quote> 。这在<productname>PostgreSQL</productname>可以按照如下方式实现：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   这里<literal>nextval()</literal>函数从一个<firstterm>序列对象</firstterm><xref linkend="functions-sequence"/>）。还有一种特别的速写：
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   <literal>SERIAL</literal>速写将在<xref
   linkend="datatype-serial"/>进一步讨论。
  </para>
 </sect1>

 <sect1 id="ddl-constraints">
<!--==========================orignal english content==========================
  <title>Constraints</title>
____________________________________________________________________________-->
  <title>约束</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Data types are a way to limit the kind of data that can be stored
   in a table.  For many applications, however, the constraint they
   provide is too coarse.  For example, a column containing a product
   price should probably only accept positive values.  But there is no
   standard data type that accepts only positive numbers.  Another issue is
   that you might want to constrain column data with respect to other
   columns or rows.  For example, in a table containing product
   information, there should be only one row for each product number.
  </para>
____________________________________________________________________________-->
  <para>
   数据类型是一种限制能够存储在表中数据类别的方法。但是对于很多应用来说，它们提供的约束太粗糙。例如，一个包含产品价格的列应该只接受正值。但是没有任何一种标准数据类型只接受正值。另一个问题是我们可能需要根据其他列或行来约束一个列中的数据。例如，在一个包含产品信息的表中，对于每个产品编号应该只有一行。
  </para>

<!--==========================orignal english content==========================
  <para>
   To that end, SQL allows you to define constraints on columns and
   tables.  Constraints give you as much control over the data in your
   tables as you wish.  If a user attempts to store data in a column
   that would violate a constraint, an error is raised.  This applies
   even if the value came from the default value definition.
  </para>
____________________________________________________________________________-->
  <para>
   到目前为止，SQL允许我们在列和表上定义约束。约束让我们能够根据我们的愿望来控制表中的数据。如果一个用户试图在一个列中保存违反一个约束的数据，一个错误会被抛出。即便是这个值来自于默认值定义，这个规则也同样适用。
  </para>

  <sect2 id="ddl-constraints-check-constraints">
<!--==========================orignal english content==========================
   <title>Check Constraints</title>
____________________________________________________________________________-->
   <title>检查约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>check constraint</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>check constraint</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A check constraint is the most generic constraint type.  It allows
    you to specify that the value in a certain column must satisfy a
    Boolean (truth-value) expression.  For instance, to require positive
    product prices, you could use:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个检查约束是最普通的约束类型。它允许我们指定一个特定列中的值必须要满足一个布尔表达式。例如，为了要求正值的产品价格，我们可以使用：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    As you see, the constraint definition comes after the data type,
    just like default value definitions.  Default values and
    constraints can be listed in any order.  A check constraint
    consists of the key word <literal>CHECK</literal> followed by an
    expression in parentheses.  The check constraint expression should
    involve the column thus constrained, otherwise the constraint
    would not make too much sense.
   </para>
____________________________________________________________________________-->
   <para>
    如你所见，约束定义就和默认值定义一样跟在数据类型之后。默认值和约束之间的顺序没有影响。一个检查约束有关键字<literal>CHECK</literal>以及其后的包围在圆括号中的表达式组成。检查约束表达式应该涉及到被约束的列，否则该约束也没什么实际意义。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    You can also give the constraint a separate name.  This clarifies
    error messages and allows you to refer to the constraint when you
    need to change it.  The syntax is:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    So, to specify a named constraint, use the key word
    <literal>CONSTRAINT</literal> followed by an identifier followed
    by the constraint definition.  (If you don't specify a constraint
    name in this way, the system chooses a name for you.)
   </para>
____________________________________________________________________________-->
   <para>
    我们也可以给与约束一个独立的名称。这会使得错误消息更为清晰，同时也允许我们在需要更改约束时能引用它。语法为：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    要指定一个命名的约束，请在约束名称标识符前使用关键词<literal>CONSTRAINT</literal>，然后把约束定义放在标识符之后（如果没有以这种方式指定一个约束名称，系统将会为我们选择一个）。
   </para>

<!--==========================orignal english content==========================
   <para>
    A check constraint can also refer to several columns.  Say you
    store a regular price and a discounted price, and you want to
    ensure that the discounted price is lower than the regular price:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个检查约束也可以引用多个列。例如我们存储一个普通价格和一个打折后的价格，而我们希望保证打折后的价格低于普通价格：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The first two constraints should look familiar.  The third one
    uses a new syntax.  It is not attached to a particular column,
    instead it appears as a separate item in the comma-separated
    column list.  Column definitions and these constraint
    definitions can be listed in mixed order.
   </para>
____________________________________________________________________________-->
   <para>
    前两个约束看起来很相似。第三个则使用了一种新语法。它并没有依附在一个特定的列，而是作为一个独立的项出现在逗号分隔的列列表中。列定义和这种约束定义可以以混合的顺序出现在列表中。
   </para>

<!--==========================orignal english content==========================
   <para>
    We say that the first two constraints are column constraints, whereas the
    third one is a table constraint because it is written separately
    from any one column definition.  Column constraints can also be
    written as table constraints, while the reverse is not necessarily
    possible, since a column constraint is supposed to refer to only the
    column it is attached to.  (<productname>PostgreSQL</productname> doesn't
    enforce that rule, but you should follow it if you want your table
    definitions to work with other database systems.)  The above example could
    also be written as:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    or even:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    It's a matter of taste.
   </para>
____________________________________________________________________________-->
   <para>
    我们将前两个约束称为列约束，而第三个约束为表约束，因为它独立于任何一个列定义。列约束也可以写成表约束，但反过来不行，因为一个列约束只能引用它所依附的那一个列（<productname>PostgreSQL</productname>并不强制要求这个规则，但是如果我们希望表定义能够在其他数据库系统中工作，那就应该遵循它）。上述例子也可以写成：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    甚至是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    这只是口味的问题。
   </para>

<!--==========================orignal english content==========================
   <para>
    Names can be assigned to table constraints in the same way as
    column constraints:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    表约束也可以用列约束相同的方法来指定名称：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    It should be noted that a check constraint is satisfied if the
    check expression evaluates to true or the null value.  Since most
    expressions will evaluate to the null value if any operand is null,
    they will not prevent null values in the constrained columns.  To
    ensure that a column does not contain null values, the not-null
    constraint described in the next section can be used.
   </para>
____________________________________________________________________________-->
   <para>
    需要注意的是，一个检查约束在其检查表达式值为真或空值时被满足。因为当任何操作数为空时大部分表达式将计算为空值，所以它们不会阻止被约束列中的控制。为了保证一个列不包含控制，可以使用下一节中的非空约束。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Not-Null Constraints</title>
____________________________________________________________________________-->
   <title>非空约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A not-null constraint simply specifies that a column must not
    assume the null value.  A syntax example:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个非空约束仅仅指定一个列中不会有空值。语法例子：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    A not-null constraint is always written as a column constraint.  A
    not-null constraint is functionally equivalent to creating a check
    constraint <literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>, but in
    <productname>PostgreSQL</productname> creating an explicit
    not-null constraint is more efficient.  The drawback is that you
    cannot give explicit names to not-null constraints created this
    way.
   </para>
____________________________________________________________________________-->
   <para>
    一个非空约束总是被写成一个列约束。一个非空约束等价于创建一个检查约束<literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>，但在<productname>PostgreSQL</productname>中创建一个显式的非空约束更高效。这种方式创建的非空约束的缺点是我们无法为它给予一个显式的名称。
   </para>

<!--==========================orignal english content==========================
   <para>
    Of course, a column can have more than one constraint.  Just write
    the constraints one after another:
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    The order doesn't matter.  It does not necessarily determine in which
    order the constraints are checked.
   </para>
____________________________________________________________________________-->
   <para>
    当然，一个列可以有多于一个的约束，只需要将这些约束一个接一个写出：
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    约束的顺序没有关系，因为并不需要决定约束被检查的顺序。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <literal>NOT NULL</literal> constraint has an inverse: the
    <literal>NULL</literal> constraint.  This does not mean that the
    column must be null, which would surely be useless.  Instead, this
    simply selects the default behavior that the column might be null.
    The <literal>NULL</literal> constraint is not present in the SQL
    standard and should not be used in portable applications.  (It was
    only added to <productname>PostgreSQL</productname> to be
    compatible with some other database systems.)  Some users, however,
    like it because it makes it easy to toggle the constraint in a
    script file.  For example, you could start with:
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    and then insert the <literal>NOT</literal> key word where desired.
   </para>
____________________________________________________________________________-->
   <para>
    <literal>NOT NULL</literal>约束有一个相反的情况：<literal>NULL</literal>约束。这并不意味着该列必须为空，进而肯定是无用的。相反，它仅仅选择了列可能为空的默认行为。SQL标准中并不存在<literal>NULL</literal>约束，因此它不能被用于可移植的应用中（<productname>PostgreSQL</productname>中加入它是为了和某些其他数据库系统兼容）。但是某些用户喜欢它，因为它使得在一个脚本文件中可以很容易的进行约束切换。例如，初始时我们可以：
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    然后可以在需要的地方插入<literal>NOT</literal>关键词。
   </para>

   <tip>
<!--==========================orignal english content==========================
    <para>
     In most database designs the majority of columns should be marked
     not null.
    </para>
____________________________________________________________________________-->
    <para>
     在大部分数据库中多数列应该被标记为非空。
    </para>
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
<!--==========================orignal english content==========================
   <title>Unique Constraints</title>
____________________________________________________________________________-->
   <title>唯一约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Unique constraints ensure that the data contained in a column, or a
    group of columns, is unique among all the rows in the
    table.  The syntax is:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    when written as a column constraint, and:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
    when written as a table constraint.
   </para>
____________________________________________________________________________-->
   <para>
    唯一约束保证\在一列中或者一组列中保存的数据在表中所有行间是唯一的。写成一个列约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    写成一个表约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    To define a unique constraint for a group of columns, write it as a
    table constraint with the column names separated by commas:
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    This specifies that the combination of values in the indicated columns
    is unique across the whole table, though any one of the columns
    need not be (and ordinarily isn't) unique.
   </para>
____________________________________________________________________________-->
   <para>
    要为一组列定义一个唯一约束，把它写作一个表级约束，列名用逗号分隔：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    这指定这些列的组合值在整个表的范围内是唯一的，但其中任意一列的值并不需要是（一般也不是）唯一的。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can assign your own name for a unique constraint, in the usual way:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    我们可以通常的方式为一个唯一索引命名：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Adding a unique constraint will automatically create a unique B-tree
    index on the column or group of columns listed in the constraint.
    A uniqueness restriction covering only some rows cannot be written as
    a unique constraint, but it is possible to enforce such a restriction by
    creating a unique <link linkend="indexes-partial">partial index</link>.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个唯一约束会在约束中列出的列或列组上自动创建一个唯一B-tree索引。只覆盖某些行的唯一性限制不能被写为一个唯一约束，但可以通过创建一个唯一的<link linkend="indexes-partial">部分索引</link>来强制这种限制。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    In general, a unique constraint is violated if there is more than
    one row in the table where the values of all of the
    columns included in the constraint are equal.
    However, two null values are never considered equal in this
    comparison.  That means even in the presence of a
    unique constraint it is possible to store duplicate
    rows that contain a null value in at least one of the constrained
    columns.  This behavior conforms to the SQL standard, but we have
    heard that other SQL databases might not follow this rule.  So be
    careful when developing applications that are intended to be
    portable.
   </para>
____________________________________________________________________________-->
   <para>
    通常，如果表中有超过一行在约束所包括列上的值相同，将会违反唯一约束。但是在这种比较中，两个空值被认为是不同的。这意味着即便存在一个唯一约束，也可以存储多个在至少一个被约束列中包含空值的行。这种行为符合SQL标准，但我们听说一些其他SQL数据库可能不遵循这个规则。所以在开发需要可移植的应用时应注意这一点。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
<!--==========================orignal english content==========================
   <title>Primary Keys</title>
____________________________________________________________________________-->
   <title>主键</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>primary key</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>primary key</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A primary key constraint indicates that a column, or group of columns,
    can be used as a unique identifier for rows in the table.  This
    requires that the values be both unique and not null.  So, the following
    two table definitions accept the same data:
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    一个主键约束表示可以用作表中行的唯一标识符的一个列或者一组列。这要求那些值都是唯一的并且非空。因此，下面的两个表定义接受相同的数据：
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Primary keys can span more than one column; the syntax
    is similar to unique constraints:
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    主键也可以包含多于一个列，其语法和唯一约束相似：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Adding a primary key will automatically create a unique B-tree index
    on the column or group of columns listed in the primary key, and will
    force the column(s) to be marked <literal>NOT NULL</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个主键将自动在主键中列出的列或列组上创建一个唯一B-tree索引。并且会强制这些列被标记为<literal>NOT NULL</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A table can have at most one primary key.  (There can be any number
    of unique and not-null constraints, which are functionally almost the
    same thing, but only one can be identified as the primary key.)
    Relational database theory
    dictates that every table must have a primary key.  This rule is
    not enforced by <productname>PostgreSQL</productname>, but it is
    usually best to follow it.
   </para>
____________________________________________________________________________-->
   <para>
    一个表最多只能有一个主键（可以有任意数量的唯一和非空约束，它们可以达到和主键几乎一样的功能，但只能有一个被标识为主键）。关系数据库理论要求每一个表都要有一个主键。但<productname>PostgreSQL</productname>中并未强制要求这一点，但是最好能够遵循它。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    Primary keys are useful both for
    documentation purposes and for client applications.  For example,
    a GUI application that allows modifying row values probably needs
    to know the primary key of a table to be able to identify rows
    uniquely.  There are also various ways in which the database system
    makes use of a primary key if one has been declared; for example,
    the primary key defines the default target column(s) for foreign keys
    referencing its table.
   </para>
____________________________________________________________________________-->
   <para>
    主键对于文档和客户端应用都是有用的。例如，一个允许修改行值的 GUI 应用可能需要知道一个表的主键，以便能唯一地标识行。如果定义了主键，数据库系统也有多种方法来利用主键。例如，主键定义了外键要引用的默认目标列。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-fk">
<!--==========================orignal english content==========================
   <title>Foreign Keys</title>
____________________________________________________________________________-->
   <title>外键</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>foreign key</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>foreign key</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    A foreign key constraint specifies that the values in a column (or
    a group of columns) must match the values appearing in some row
    of another table.
    We say this maintains the <firstterm>referential
    integrity</firstterm> between two related tables.
   </para>
____________________________________________________________________________-->
   <para>
    一个外键约束指定一列（或一组列）中的值必须匹配出现在另一个表中某些行的值。我们说这维持了两个关联表之间的<firstterm>引用完整性</firstterm>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Say you have the product table that we have used several times already:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    Let's also assume you have a table storing orders of those
    products.  We want to ensure that the orders table only contains
    orders of products that actually exist.  So we define a foreign
    key constraint in the orders table that references the products
    table:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    Now it is impossible to create orders with non-NULL
    <structfield>product_no</structfield> entries that do not appear in the
    products table.
   </para>
____________________________________________________________________________-->
   <para>
    例如我们有一个使用过多次的产品表：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    让我们假设我们还有一个存储这些产品订单的表。我们希望保证订单表中只包含真正存在的产品的订单。因此我们在订单表中定义一个引用产品表的外键约束：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    现在就不可能创建包含不存在于产品表中的<structfield>product_no</structfield>值（非空）的订单。
   </para>

<!--==========================orignal english content==========================
   <para>
    We say that in this situation the orders table is the
    <firstterm>referencing</firstterm> table and the products table is
    the <firstterm>referenced</firstterm> table.  Similarly, there are
    referencing and referenced columns.
   </para>
____________________________________________________________________________-->
   <para>
    我们说在这种情况下，订单表是<firstterm>引用</firstterm>表而产品表是<firstterm>被引用</firstterm>表。相应地，也有引用和被引用列的说法。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can also shorten the above command to:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    because in absence of a column list the primary key of the
    referenced table is used as the referenced column(s).
   </para>
____________________________________________________________________________-->
   <para>
    我们也可以把上述命令简写为：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    因为如果缺少列的列表，则被引用表的主键将被用作被引用列。
   </para>

<!--==========================orignal english content==========================
   <para>
    A foreign key can also constrain and reference a group of columns.
    As usual, it then needs to be written in table constraint form.
    Here is a contrived syntax example:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    Of course, the number and type of the constrained columns need to
    match the number and type of the referenced columns.
   </para>
____________________________________________________________________________-->
   <para>
    一个外键也可以约束和引用一组列。照例，它需要被写成表约束的形式。下面是一个例子：
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    当然，被约束列的数量和类型应该匹配被引用列的数量和类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can assign your own name for a foreign key constraint,
    in the usual way.
   </para>
____________________________________________________________________________-->
   <para>
    按照前面的方式，我们可以为一个外键约束命名。
   </para>

<!--==========================orignal english content==========================
   <para>
    A table can have more than one foreign key constraint.  This is
    used to implement many-to-many relationships between tables.  Say
    you have tables about products and orders, but now you want to
    allow one order to contain possibly many products (which the
    structure above did not allow).  You could use this table structure:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    Notice that the primary key overlaps with the foreign keys in
    the last table.
   </para>
____________________________________________________________________________-->
   <para>
    一个表可以有超过一个的外键约束。这被用于实现表之间的多对多关系。例如我们有关于产品和订单的表，但我们现在希望一个订单能包含多种产品（这在上面的结构中是不允许的）。我们可以使用这种表结构：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    注意在最后一个表中主键和外键之间有重叠。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    We know that the foreign keys disallow creation of orders that
    do not relate to any products.  But what if a product is removed
    after an order is created that references it?  SQL allows you to
    handle that as well.  Intuitively, we have a few options:
    <itemizedlist spacing="compact">
     <listitem><para>Disallow deleting a referenced product</para></listitem>
     <listitem><para>Delete the orders as well</para></listitem>
     <listitem><para>Something else?</para></listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    我们知道外键不允许创建与任何产品都不相关的订单。但如果一个产品在一个引用它的订单创建之后被移除会发生什么？SQL允许我们处理这种情况。直观上，我们有几种选项：
    <itemizedlist spacing="compact">
     <listitem><para>不允许删除一个被引用的产品</para></listitem>
     <listitem><para>同时也删除引用产品的订单</para></listitem>
     <listitem><para>其他？</para></listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    To illustrate this, let's implement the following policy on the
    many-to-many relationship example above: when someone wants to
    remove a product that is still referenced by an order (via
    <literal>order_items</literal>), we disallow it.  If someone
    removes an order, the order items are removed as well:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    为了说明这些，让我们在上面的多对多关系例子中实现下面的策略：当某人希望移除一个仍然被一个订单引用（通过<literal>order_items</literal>）的产品时 ，我们组织它。如果某人移除一个订单，订单项也同时被移除：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Restricting and cascading deletes are the two most common options.
    <literal>RESTRICT</literal> prevents deletion of a
    referenced row. <literal>NO ACTION</literal> means that if any
    referencing rows still exist when the constraint is checked, an error
    is raised; this is the default behavior if you do not specify anything.
    (The essential difference between these two choices is that
    <literal>NO ACTION</literal> allows the check to be deferred until
    later in the transaction, whereas <literal>RESTRICT</literal> does not.)
    <literal>CASCADE</literal> specifies that when a referenced row is deleted,
    row(s) referencing it should be automatically deleted as well.
    There are two other options:
    <literal>SET NULL</literal> and <literal>SET DEFAULT</literal>.
    These cause the referencing column(s) in the referencing row(s)
    to be set to nulls or their default
    values, respectively, when the referenced row is deleted.
    Note that these do not excuse you from observing any constraints.
    For example, if an action specifies <literal>SET DEFAULT</literal>
    but the default value would not satisfy the foreign key constraint, the
    operation will fail.
   </para>
____________________________________________________________________________-->
   <para>
    限制删除或者级联删除是两种最常见的选项。<literal>RESTRICT</literal>阻止删除一个被引用的行。<literal>NO ACTION</literal>表示在约束被检察时如果有任何引用行存在，则会抛出一个错误，这是我们没有指定任何东西时的默认行为（这两种选择的本质不同在于<literal>NO ACTION</literal>允许检查被推迟到事务的最后，而<literal>RESTRICT</literal>则不会）。<literal>CASCADE</literal>指定当一个被引用行被删除后，引用它的行也应该被自动删除。还有其他两种选项：<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>。这些将导致在被引用行被删除后，引用行中的引用列被置为空值或它们的默认值。注意这些并不会是我们免于遵守任何约束。例如，如果一个动作指定了<literal>SET DEFAULT</literal>，但是默认值不满足外键约束，操作将会失败。
   </para>

<!--==========================orignal english content==========================
   <para>
    Analogous to <literal>ON DELETE</literal> there is also
    <literal>ON UPDATE</literal> which is invoked when a referenced
    column is changed (updated).  The possible actions are the same.
    In this case, <literal>CASCADE</literal> means that the updated values of the
    referenced column(s) should be copied into the referencing row(s).
   </para>
____________________________________________________________________________-->
   <para>
    与<literal>ON DELETE</literal>相似，同样有<literal>ON UPDATE</literal>可以用在一个被引用列被修改（更新）的情况，可选的动作相同。在这种情况下，<literal>CASCADE</literal>意味着被引用列的更新值应该被复制到引用行中。
   </para>

<!--==========================orignal english content==========================
   <para>
    Normally, a referencing row need not satisfy the foreign key constraint
    if any of its referencing columns are null.  If <literal>MATCH FULL</literal>
    is added to the foreign key declaration, a referencing row escapes
    satisfying the constraint only if all its referencing columns are null
    (so a mix of null and non-null values is guaranteed to fail a
    <literal>MATCH FULL</literal> constraint).  If you don't want referencing rows
    to be able to avoid satisfying the foreign key constraint, declare the
    referencing column(s) as <literal>NOT NULL</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    正常情况下，如果一个引用行的任意一个引用列都为空，则它不需要满足外键约束。如果在外键定义中加入了<literal>MATCH FULL</literal>，一个引用行只有在它的所有引用列为空时才不需要满足外键约束（因此空和非空值的混合肯定会导致<literal>MATCH FULL</literal>约束失败）。如果不希望引用行能够避开外键约束，将引用行声明为<literal>NOT NULL</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A foreign key must reference columns that either are a primary key or
    form a unique constraint.  This means that the referenced columns always
    have an index (the one underlying the primary key or unique constraint);
    so checks on whether a referencing row has a match will be efficient.
    Since a <command>DELETE</command> of a row from the referenced table
    or an <command>UPDATE</command> of a referenced column will require
    a scan of the referencing table for rows matching the old value, it
    is often a good idea to index the referencing columns too.  Because this
    is not always needed, and there are many choices available on how
    to index, declaration of a foreign key constraint does not
    automatically create an index on the referencing columns.
   </para>
____________________________________________________________________________-->
   <para>
    一个外键所引用的列必须是一个主键或者被唯一约束所限制。这意味着被引用列总是拥有一个索引（位于主键或唯一约束之下的索引），因此在其上进行的一个引用行是否匹配的检查将会很高效。由于从被引用表中<command>DELETE</command>一行或者<command>UPDATE</command>一个被引用列将要求对引用表进行扫描以得到匹配旧值的行，在引用列上建立合适的索引也会大有益处。由于这种做法并不是必须的，而且创建索引也有很多种选择，所以外键约束的定义并不会自动在引用列上创建索引。
   </para>

<!--==========================orignal english content==========================
   <para>
    More information about updating and deleting data is in <xref
    linkend="dml"/>.  Also see the description of foreign key constraint
    syntax in the reference documentation for
    <xref linkend="sql-createtable"/>.
   </para>
____________________________________________________________________________-->
   <para>
    更多关于更新和删除数据的信息请见<xref linkend="dml"/>。外键约束的语法描述请参考<xref linkend="sql-createtable"/>。
   </para>
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
<!--==========================orignal english content==========================
   <title>Exclusion Constraints</title>
____________________________________________________________________________-->
   <title>排他约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Exclusion constraints ensure that if any two rows are compared on
    the specified columns or expressions using the specified operators,
    at least one of these operator comparisons will return false or null.
    The syntax is:
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    排他约束保证如果将任何两行的指定列或表达式使用指定操作符进行比较，至少其中一个操作符比较将会返回否或空值。语法是：
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    See also <link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link> for details.
   </para>
____________________________________________________________________________-->
   <para>
    详见<link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Adding an exclusion constraint will automatically create an index
    of the type specified in the constraint declaration.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个排他约束将在约束声明所指定的类型上自动创建索引。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
<!--==========================orignal english content==========================
  <title>System Columns</title>
____________________________________________________________________________-->
  <title>系统列</title>

<!--==========================orignal english content==========================
  <para>
   Every table has several <firstterm>system columns</firstterm> that are
   implicitly defined by the system.  Therefore, these names cannot be
   used as names of user-defined columns.  (Note that these
   restrictions are separate from whether the name is a key word or
   not; quoting a name will not allow you to escape these
   restrictions.)  You do not really need to be concerned about these
   columns; just know they exist.
  </para>
____________________________________________________________________________-->
  <para>
   每一个表都拥有一些由系统隐式定义的<firstterm>系统列</firstterm>。因此，这些列的名字不能像用户定义的列一样使用（注意这种限制与名称是否为关键词没有关系，即便用引号限定一个名称也无法绕过这种限制）。 事实上用户不需要关心这些列，只需要知道它们存在即可。
  </para>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>oid</structfield></term>
____________________________________________________________________________-->
    <term><structfield>oid</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      <indexterm>
       <primary>OID</primary>
       <secondary>column</secondary>
      </indexterm>
      The object identifier (object ID) of a row. This column is only
      present if the table was created using <literal>WITH
      OIDS</literal>, or if the <xref linkend="guc-default-with-oids"/>
      configuration variable was set at the time. This column is of type
      <type>oid</type> (same name as the column); see <xref
      linkend="datatype-oid"/> for more information about the type.
     </para>
____________________________________________________________________________-->
     <para>
      <indexterm>
       <primary>OID</primary>
       <secondary>column</secondary>
      </indexterm>
      一行的对象标识符（对象ID）。该列只有在表使用<literal>WITH OIDS</literal>创建时或者<xref linkend="guc-default-with-oids"/>配置变量被设置时才存在。该列的类型为<type>oid</type>（与列名一致），该类型详见<xref linkend="datatype-oid"/>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>tableoid</structfield></term>
____________________________________________________________________________-->
    <term><structfield>tableoid</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The OID of the table containing this row.  This column is
      particularly handy for queries that select from inheritance
      hierarchies (see <xref linkend="ddl-inherit"/>), since without it,
      it's difficult to tell which individual table a row came from.  The
      <structfield>tableoid</structfield> can be joined against the
      <structfield>oid</structfield> column of
      <structname>pg_class</structname> to obtain the table name.
     </para>
____________________________________________________________________________-->
     <para>
      包含这一行的表的OID。该列是特别为从继承层次（见<xref linkend="ddl-inherit"/>）中选择的查询而准备，因为如果没有它将很难知道一行来自于哪个表。<structfield>tableoid</structfield>可以与<structname>pg_class</structname>的<structfield>oid</structfield>列进行连接来获得表的名称。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>xmin</structfield></term>
____________________________________________________________________________-->
    <term><structfield>xmin</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>xmin</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>xmin</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The identity (transaction ID) of the inserting transaction for
      this row version.  (A row version is an individual state of a
      row; each update of a row creates a new row version for the same
      logical row.)
     </para>
____________________________________________________________________________-->
     <para>
      插入该行版本的事务身份（事务ID）。一个行版本是一个行的一个特别版本，对一个逻辑行的每一次更新都将创建一个新的行版本。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>cmin</structfield></term>
____________________________________________________________________________-->
    <term><structfield>cmin</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>cmin</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>cmin</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The command identifier (starting at zero) within the inserting
      transaction.
     </para>
____________________________________________________________________________-->
     <para>
      插入事务中的命令标识符（从0开始）。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>xmax</structfield></term>
____________________________________________________________________________-->
    <term><structfield>xmax</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>xmax</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>xmax</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The identity (transaction ID) of the deleting transaction, or
      zero for an undeleted row version.  It is possible for this column to
      be nonzero in a visible row version. That usually indicates that the
      deleting transaction hasn't committed yet, or that an attempted
      deletion was rolled back.
     </para>
____________________________________________________________________________-->
     <para>
      删除事务的身份（事务ID），对于未删除的行版本为0。对于一个可见的行版本，该列值也可能为非零。这通常表示删除事务还没有提交，或者一个删除尝试被回滚。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>cmax</structfield></term>
____________________________________________________________________________-->
    <term><structfield>cmax</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>cmax</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>cmax</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The command identifier within the deleting transaction, or zero.
     </para>
____________________________________________________________________________-->
     <para>
      删除事务中的命令标识符，或者为0。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><structfield>ctid</structfield></term>
____________________________________________________________________________-->
    <term><structfield>ctid</structfield></term>
    <listitem>
<!--==========================orignal english content==========================
     <indexterm>
      <primary>ctid</primary>
     </indexterm>
____________________________________________________________________________-->
     <indexterm>
      <primary>ctid</primary>
     </indexterm>

<!--==========================orignal english content==========================
     <para>
      The physical location of the row version within its table.  Note that
      although the <structfield>ctid</structfield> can be used to
      locate the row version very quickly, a row's
      <structfield>ctid</structfield> will change if it is
      updated or moved by <command>VACUUM FULL</command>.  Therefore
      <structfield>ctid</structfield> is useless as a long-term row
      identifier.  The OID, or even better a user-defined serial
      number, should be used to identify logical rows.
     </para>
____________________________________________________________________________-->
     <para>
      行版本在其表中的物理位置。注意尽管<structfield>ctid</structfield>可以被用来非常快速地定位行版本，但是一个行的<structfield>ctid</structfield>会在被更新或者被<command>VACUUM FULL</command>移动时改变。因此，<structfield>ctid</structfield>不能作为一个长期行标识符。OID或者最好是一个用户定义的序列号才应该被用来标识逻辑行。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
   <para>
    OIDs are 32-bit quantities and are assigned from a single
    cluster-wide counter.  In a large or long-lived database, it is
    possible for the counter to wrap around.  Hence, it is bad
    practice to assume that OIDs are unique, unless you take steps to
    ensure that this is the case.  If you need to identify the rows in
    a table, using a sequence generator is strongly recommended.
    However, OIDs can be used as well, provided that a few additional
    precautions are taken:

    <itemizedlist>
     <listitem>
      <para>
       A unique constraint should be created on the OID column of each
       table for which the OID will be used to identify rows.  When such
       a unique constraint (or unique index) exists, the system takes
       care not to generate an OID matching an already-existing row.
       (Of course, this is only possible if the table contains fewer
       than 2<superscript>32</superscript> (4 billion) rows, and in practice the
       table size had better be much less than that, or performance
       might suffer.)
      </para>
     </listitem>
     <listitem>
      <para>
       OIDs should never be assumed to be unique across tables; use
       the combination of <structfield>tableoid</structfield> and row OID if you
       need a database-wide identifier.
      </para>
     </listitem>
     <listitem>
      <para>
       Of course, the tables in question must be created <literal>WITH
       OIDS</literal>.  As of <productname>PostgreSQL</productname> 8.1,
       <literal>WITHOUT OIDS</literal> is the default.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    OID是32位量，它从一个服务于整个集簇的计数器分配而来。在一个大型的或者历时长久的数据库中，该计数器有可能会出现绕回。因此，不要总是假设OID是唯一的，除非你采取了措施来保证。如果需要在一个表中标识行，推荐使用一个序列生成器。然而，OID也可以被使用，但是是要采取一些额外的预防措施：

    <itemizedlist>
     <listitem>
      <para>
       如果要将OID用来标识行，应该在OID列上创建一个唯一约束。当这样一个唯一约束（或唯一索引）存在时，系统会注意不生成匹配现有行的OID（当然，这只有在表的航数目少于2<superscript>32</superscript>（40亿）时才成立。并且在实践中表的尺寸最好远比这个值小，否则将会牺牲性能）。
      </para>
     </listitem>
     <listitem>
      <para>
       绝不要认为OID在表之间也是唯一的，使用<structfield>tableoid</structfield>和行OID的组合来作为数据库范围内的标识符。
      </para>
     </listitem>
     <listitem>
      <para>
       当然，问题中的表都必须是用<literal>WITH OIDS</literal>创建。在<productname>PostgreSQL</productname> 8.1中，<literal>WITHOUT OIDS</literal>是默认形式。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Transaction identifiers are also 32-bit quantities.  In a
    long-lived database it is possible for transaction IDs to wrap
    around.  This is not a fatal problem given appropriate maintenance
    procedures; see <xref linkend="maintenance"/> for details.  It is
    unwise, however, to depend on the uniqueness of transaction IDs
    over the long term (more than one billion transactions).
   </para>
____________________________________________________________________________-->
   <para>
    事务标识符也是32位量。在一个历时长久的数据库中事务ID同样会绕回。但如果采取适当的维护过程，这不会是一个致命的问题，详见<xref linkend="maintenance"/>。但是，长期（超过10亿个事务）依赖事务ID的唯一性是不明智的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Command identifiers are also 32-bit quantities.  This creates a hard limit
    of 2<superscript>32</superscript> (4 billion) <acronym>SQL</acronym> commands
    within a single transaction.  In practice this limit is not a
    problem &mdash; note that the limit is on the number of
    <acronym>SQL</acronym> commands, not the number of rows processed.
    Also, only commands that actually modify the database contents will
    consume a command identifier.
   </para>
____________________________________________________________________________-->
   <para>
    命令标识符也是32位量。这对一个事务中包含的<acronym>SQL</acronym>命令设置了一个硬极限：
    2<superscript>32</superscript>（40亿）。在实践中，该限制并不是问题 &mdash; 注意该限制只是针对<acronym>SQL</acronym>命令的数目而不是被处理的行数。同样，只有真正
    修改了数据库内容的命令才会消耗一个命令标识符。
   </para>
 </sect1>

 <sect1 id="ddl-alter">
<!--==========================orignal english content==========================
  <title>Modifying Tables</title>
____________________________________________________________________________-->
  <title>修改表</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When you create a table and you realize that you made a mistake, or
   the requirements of the application change, you can drop the
   table and create it again.  But this is not a convenient option if
   the table is already filled with data, or if the table is
   referenced by other database objects (for instance a foreign key
   constraint).  Therefore <productname>PostgreSQL</productname>
   provides a family of commands to make modifications to existing
   tables.  Note that this is conceptually distinct from altering
   the data contained in the table: here we are interested in altering
   the definition, or structure, of the table.
  </para>
____________________________________________________________________________-->
  <para>
   当我们已经创建了一个表并意识到犯了一个错误或者应用需求发生改变时，我们可以移除表并重新创建它。但如果表中已经被填充数据或者被其他数据库对象引用（例如有一个外键约束），这种做法就显得很不方便。因此，<productname>PostgreSQL</productname>提供了一族命令来对已有的表进行修改。注意这和修改表中所包含的数据是不同的，这里要做的是对表的定义或者说结构进行修改。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can:
   <itemizedlist spacing="compact">
    <listitem>
     <para>Add columns</para>
    </listitem>
    <listitem>
     <para>Remove columns</para>
    </listitem>
    <listitem>
     <para>Add constraints</para>
    </listitem>
    <listitem>
     <para>Remove constraints</para>
    </listitem>
    <listitem>
     <para>Change default values</para>
    </listitem>
    <listitem>
     <para>Change column data types</para>
    </listitem>
    <listitem>
     <para>Rename columns</para>
    </listitem>
    <listitem>
     <para>Rename tables</para>
    </listitem>
   </itemizedlist>

   All these actions are performed using the
   <xref linkend="sql-altertable"/>
   command, whose reference page contains details beyond those given
   here.
  </para>
____________________________________________________________________________-->
  <para>
   利用这些命令，我们可以：
   <itemizedlist spacing="compact">
    <listitem>
     <para>增加列</para>
    </listitem>
    <listitem>
     <para>移除列</para>
    </listitem>
    <listitem>
     <para>增加约束</para>
    </listitem>
    <listitem>
     <para>移除约束</para>
    </listitem>
    <listitem>
     <para>修改默认值</para>
    </listitem>
    <listitem>
     <para>修改列数据类型</para>
    </listitem>
    <listitem>
     <para>重命名列</para>
    </listitem>
    <listitem>
     <para>重命名表</para>
    </listitem>
   </itemizedlist>

   所有这些动作都由<xref linkend="sql-altertable"/>命令执行，其参考页面中包含更详细的信息。
  </para>

  <sect2 id="ddl-alter-adding-a-column">
<!--==========================orignal english content==========================
   <title>Adding a Column</title>
____________________________________________________________________________-->
   <title>增加列</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To add a column, use a command like:
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    The new column is initially filled with whatever default
    value is given (null if you don't specify a <literal>DEFAULT</literal> clause).
   </para>
____________________________________________________________________________-->
   <para>
    要增加一个列，可以使用这样的命令：
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    新列将被默认值所填充（如果没有指定<literal>DEFAULT</literal>子句，则会填充空值）。
   </para>

<!--==========================orignal english content==========================
   <para>
    You can also define constraints on the column at the same time,
    using the usual syntax:
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    In fact all the options that can be applied to a column description
    in <command>CREATE TABLE</command> can be used here.  Keep in mind however
    that the default value must satisfy the given constraints, or the
    <literal>ADD</literal> will fail.  Alternatively, you can add
    constraints later (see below) after you've filled in the new column
    correctly.
   </para>
____________________________________________________________________________-->
   <para>
    也可以同时为列定义约束，语法：
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    事实上<command>CREATE TABLE</command>中关于一列的描述都可以应用在这里。记住不管怎样，默认值必须满足给定的约束，否则<literal>ADD</literal>将会失败。也可以先将新列正确地填充好，然后再增加约束（见后文）。
   </para>

  <tip>
<!--==========================orignal english content==========================
   <para>
    Adding a column with a default requires updating each row of the
    table (to store the new column value).  However, if no default is
    specified, <productname>PostgreSQL</productname> is able to avoid
    the physical update.  So if you intend to fill the column with
    mostly nondefault values, it's best to add the column with no default,
    insert the correct values using <command>UPDATE</command>, and then add any
    desired default as described below.
   </para>
____________________________________________________________________________-->
   <para>
    增加一个带默认值的列需要更新表中的每一行（来存储新列值）。然而，如果不指定默认值，<productname>PostgreSQL</productname>可以避免物理更新。因此如果我们准备向列中填充的值大多是非默认值，最好是增加列的时候不指定默认值，增加列后用<command>UPDATE</command>填充正确的数据并且增加所需要的默认值约束。   </para>
  </tip>
  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
<!--==========================orignal english content==========================
   <title>Removing a Column</title>
____________________________________________________________________________-->
   <title>移除列</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To remove a column, use a command like:
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    Whatever data was in the column disappears.  Table constraints involving
    the column are dropped, too.  However, if the column is referenced by a
    foreign key constraint of another table,
    <productname>PostgreSQL</productname> will not silently drop that
    constraint.  You can authorize dropping everything that depends on
    the column by adding <literal>CASCADE</literal>:
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
   </para>
____________________________________________________________________________-->
   <para>
    为了移除一个列，使用如下的命令：
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    列中的数据将会消失。涉及到该列的表约束也会被移除。然而，如果该列被另一个表的外键所引用，<productname>PostgreSQL</productname>不会安静地移除该约束。我们可以通过增加<literal>CASCADE</literal>来授权移除任何依赖于被删除列的所有东西：
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    关于这个操作背后的一般性机制请见<xref linkend="ddl-depend"/>。
   </para>
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
<!--==========================orignal english content==========================
   <title>Adding a Constraint</title>
____________________________________________________________________________-->
   <title>增加约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To add a constraint, the table constraint syntax is used.  For example:
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    To add a not-null constraint, which cannot be written as a table
    constraint, use this syntax:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    为了增加一个约束，可以使用表约束的语法，例如：
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    要增加一个不能写成表约束的非空约束，可使用语法：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    The constraint will be checked immediately, so the table data must
    satisfy the constraint before it can be added.
   </para>
____________________________________________________________________________-->
   <para>
    该约束会立即被检查，所以表中的数据必须在约束被增加之前就已经符合约束。
   </para>
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
<!--==========================orignal english content==========================
   <title>Removing a Constraint</title>
____________________________________________________________________________-->
   <title>移除约束</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To remove a constraint you need to know its name.  If you gave it
    a name then that's easy.  Otherwise the system assigned a
    generated name, which you need to find out.  The
    <application>psql</application> command <literal>\d
    <replaceable>tablename</replaceable></literal> can be helpful
    here; other interfaces might also provide a way to inspect table
    details.  Then the command is:
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    (If you are dealing with a generated constraint name like <literal>$2</literal>,
    don't forget that you'll need to double-quote it to make it a valid
    identifier.)
   </para>
____________________________________________________________________________-->
   <para>
    为了移除一个约束首先需要知道它的名称。如果在创建时已经给它指定了名称，那么事情就变得很容易。否则约束的名称是由系统生成的，我们必须先找出这个名称。<application>psql</application>的命令<literal>\d
    <replaceable>表名</replaceable></literal>将会对此有所帮助，其他接口也会提供方法来查看表的细节。因此命令是：
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    （如果处理的是自动生成的约束名称，如<literal>$2</literal>，别忘了用双引号使它变成一个合法的标识符。）
   </para>

<!--==========================orignal english content==========================
   <para>
    As with dropping a column, you need to add <literal>CASCADE</literal> if you
    want to drop a constraint that something else depends on.  An example
    is that a foreign key constraint depends on a unique or primary key
    constraint on the referenced column(s).
   </para>
____________________________________________________________________________-->
   <para>
    和移除一个列相似，如果需要移除一个被某些别的东西依赖的约束，也需要加上<literal>CASCADE</literal>。一个例子是一个外键约束依赖于被引用列上的一个唯一或者主键约束。
   </para>

<!--==========================orignal english content==========================
   <para>
    This works the same for all constraint types except not-null
    constraints. To drop a not null constraint use:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    (Recall that not-null constraints do not have names.)
   </para>
____________________________________________________________________________-->
   <para>
    这对除了非空约束之外的所有约束类型都一样有效。为了移除一个非空约束可以用：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    （回忆一下，非空约束是没有名称的，所以不能用第一种方式。）
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Changing a Column's Default Value</title>
____________________________________________________________________________-->
   <title>更改列的默认值</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To set a new default for a column, use a command like:
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    Note that this doesn't affect any existing rows in the table, it
    just changes the default for future <command>INSERT</command> commands.
   </para>
____________________________________________________________________________-->
   <para>
    要为一个列设置一个新默认值，使用命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    注意这不会影响任何表中已经存在的行，它只是为未来的<command>INSERT</command>命令改变了默认值。
   </para>

<!--==========================orignal english content==========================
   <para>
    To remove any default value, use:
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    This is effectively the same as setting the default to null.
    As a consequence, it is not an error
    to drop a default where one hadn't been defined, because the
    default is implicitly the null value.
   </para>
____________________________________________________________________________-->
   <para>
    要移除任何默认值，使用：
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    这等同于将默认值设置为空值。相应的，试图删除一个未被定义的默认值并不会引发错误，因为默认值已经被隐式地设置为空值。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Changing a Column's Data Type</title>
____________________________________________________________________________-->
   <title>修改列的数据类型</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To convert a column to a different data type, use a command like:
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    This will succeed only if each existing entry in the column can be
    converted to the new type by an implicit cast.  If a more complex
    conversion is needed, you can add a <literal>USING</literal> clause that
    specifies how to compute the new values from the old.
   </para>
____________________________________________________________________________-->
   <para>
    为了将一个列转换为一种不同的数据类型，使用如下命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    只有当列中的每一个项都能通过一个隐式造型转换为新的类型时该操作才能成功。如果需要一种更复杂的转换，应该加上一个<literal>USING</literal>子句来指定应该如何把旧值转换为新值。
   </para>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> will attempt to convert the column's
    default value (if any) to the new type, as well as any constraints
    that involve the column.  But these conversions might fail, or might
    produce surprising results.  It's often best to drop any constraints
    on the column before altering its type, and then add back suitably
    modified constraints afterwards.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>将尝试把列的默认值转换为新类型，其他涉及到该列的任何约束也是一样。但是这些转换可能失败或者产生奇特的结果。因此最好在修改类型之前先删除该列上所有的约束，然后在修改完类型后重新加上相应修改过的约束。
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Renaming a Column</title>
____________________________________________________________________________-->
   <title>重命名列</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To rename a column:
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    要重命名一个列：
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
  </sect2>

  <sect2>
<!--==========================orignal english content==========================
   <title>Renaming a Table</title>
____________________________________________________________________________-->
   <title>重命名表</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To rename a table:
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    要重命名一个表：
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
<!--==========================orignal english content==========================
  <title>Privileges</title>
____________________________________________________________________________-->
  <title>权限</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When an object is created, it is assigned an owner. The
   owner is normally the role that executed the creation statement.
   For most kinds of objects, the initial state is that only the owner
   (or a superuser) can do anything with the object. To allow
   other roles to use it, <firstterm>privileges</firstterm> must be
   granted.
  </para>
____________________________________________________________________________-->
  <para>
   一旦一个对象被创建，它会被分配一个所有者。所有者通常是执行创建语句的角色。对于大部分类型的对象，初始状态下只有所有者（或者超级用户）能够对该对象做任何事情。为了允许其他角色使用它，必须分配<firstterm>权限</firstterm>。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are different kinds of privileges: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal>, and <literal>USAGE</literal>.
   The privileges applicable to a particular
   object vary depending on the object's type (table, function, etc).
   For complete information on the different types of privileges
   supported by <productname>PostgreSQL</productname>, refer to the
   <xref linkend="sql-grant"/> reference
   page.  The following sections and chapters will also show you how
   those privileges are used.
  </para>
____________________________________________________________________________-->
  <para>
   有多种不同的权限：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、<literal>TRUNCATE</literal>、<literal>REFERENCES</literal>、<literal>TRIGGER</literal>、<literal>CREATE</literal>、<literal>CONNECT</literal>、<literal>TEMPORARY</literal>、<literal>EXECUTE</literal>以及<literal>USAGE</literal>。可以应用于一个特定对象的权限随着对象的类型（表、函数等）而不同。<productname>PostgreSQL</productname>所支持的不同类型的完整权限信息请参考<xref linkend="sql-grant"/>。下面的章节将简单介绍如何使用这些权限。
  </para>

<!--==========================orignal english content==========================
  <para>
   The right to modify or destroy an object is always the privilege of
   the owner only.
  </para>
____________________________________________________________________________-->
  <para>
   修改或销毁一个对象的权力通常是只有所有者才有的权限。
  </para>

<!--==========================orignal english content==========================
  <para>
   An object can be assigned to a new owner with an <command>ALTER</command>
   command of the appropriate kind for the object, e.g. <xref
   linkend="sql-altertable"/>.  Superusers can always do
   this; ordinary roles can only do it if they are both the current owner
   of the object (or a member of the owning role) and a member of the new
   owning role.
  </para>
____________________________________________________________________________-->
  <para>
   一个对象可以通过该对象类型相应的<command>ALTER</command>命令来重新分配所有者，例如<xref linkend="sql-altertable"/>。超级用户总是可以做到这点，普通角色只有同时是对象的当前所有者（或者是拥有角色的一个成员）以及新拥有角色的一个成员时才能做同样的事。
  </para>

<!--==========================orignal english content==========================
  <para>
   To assign privileges, the <command>GRANT</command> command is
   used. For example, if <literal>joe</literal> is an existing role, and
   <literal>accounts</literal> is an existing table, the privilege to
   update the table can be granted with:
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   Writing <literal>ALL</literal> in place of a specific privilege grants all
   privileges that are relevant for the object type.
  </para>
____________________________________________________________________________-->
  <para>
   要分配权限，可以使用<command>GRANT</command>命令。例如，如果<literal>joe</literal>是一个已有角色，而<literal>accounts</literal>是一个已有表，更新该表的权限可以按如下方式授权：
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   用<literal>ALL</literal>取代特定权限会把与对象类型相关的所有权限全部授权。
  </para>

<!--==========================orignal english content==========================
  <para>
   The special <quote>role</quote> name <literal>PUBLIC</literal> can
   be used to grant a privilege to every role on the system.  Also,
   <quote>group</quote> roles can be set up to help manage privileges when
   there are many users of a database &mdash; for details see
   <xref linkend="user-manag"/>.
  </para>
____________________________________________________________________________-->
  <para>
   一个特殊的名为<literal>PUBLIC</literal>的<quote>角色</quote>可以用来向系统中的每一个角色授予一个权限。同时，在数据库中有很多用户时可以设置<quote>组</quote>角色来帮助管理权限。详见<xref linkend="user-manag"/>。
  </para>

<!--==========================orignal english content==========================
  <para>
   To revoke a privilege, use the fittingly named
   <command>REVOKE</command> command:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   The special privileges of the object owner (i.e., the right to do
   <command>DROP</command>, <command>GRANT</command>, <command>REVOKE</command>, etc.)
   are always implicit in being the owner,
   and cannot be granted or revoked.  But the object owner can choose
   to revoke their own ordinary privileges, for example to make a
   table read-only for themselves as well as others.
  </para>
____________________________________________________________________________-->
  <para>
   为了撤销一个权限，使用<command>REVOKE</command>命令：
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
   对象拥有者的特殊权限（即执行<command>DROP</command>、<command>GRANT</command>、<command>REVOKE</command>等的权力）总是隐式地属于拥有者，并且不能被授予或撤销。但是对象拥有者可以选择撤销他们自己的普通权限，例如把一个表变得对他们自己和其他人只读。
  </para>

<!--==========================orignal english content==========================
  <para>
   Ordinarily, only the object's owner (or a superuser) can grant or
   revoke privileges on an object.  However, it is possible to grant a
   privilege <quote>with grant option</quote>, which gives the recipient
   the right to grant it in turn to others.  If the grant option is
   subsequently revoked then all who received the privilege from that
   recipient (directly or through a chain of grants) will lose the
   privilege.  For details see the <xref linkend="sql-grant"/> and
   <xref linkend="sql-revoke"/> reference pages.
  </para>
____________________________________________________________________________-->
  <para>
   一般情况下，只有对象拥有者（或者超级用户）可以授予或撤销一个对象上的权限。但是可以在授予权限时使用<quote>with grant option</quote>来允许接收人将权限转授给其他人。如果后来授予选项被撤销，则所有从接收人那里获得的权限（直接或者通过授权链获得）都将被撤销。更多详情请见<xref linkend="sql-grant"/>和<xref linkend="sql-revoke"/>参考页。
  </para>
 </sect1>
 
 <sect1 id="ddl-rowsecurity">
<!--==========================orignal english content==========================
  <title>Row Security Policies</title>
____________________________________________________________________________-->
  <title>行安全性策略</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-rowsecurity">
   <primary>policy</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-rowsecurity">
   <primary>policy</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   In addition to the SQL-standard <link linkend="ddl-priv">privilege
   system</link> available through <xref linkend="sql-grant"/>,
   tables can have <firstterm>row security policies</firstterm> that restrict,
   on a per-user basis, which rows can be returned by normal queries
   or inserted, updated, or deleted by data modification commands.
   This feature is also known as <firstterm>Row-Level Security</firstterm>.
   By default, tables do not have any policies, so that if a user has
   access privileges to a table according to the SQL privilege system,
   all rows within it are equally available for querying or updating.
  </para>
____________________________________________________________________________-->
  <para>
   除可以通过<xref linkend="sql-grant"/>使用 SQL 标准的
   <link linkend="ddl-priv">特权系统</link>之外，表还可以具有
   <firstterm>行安全性策略</firstterm>，它针对每一个用户限制哪些行可以
   被普通的查询返回或者可以被数据修改命令插入、更新或删除。这种
   特性也被称为<firstterm>行级安全性</firstterm>。默认情况下，表不具有
   任何策略，这样用户根据 SQL 特权系统具有对表的访问特权，对于
   查询或更新来说其中所有的行都是平等的。
  </para>

<!--==========================orignal english content==========================
  <para>
   When row security is enabled on a table (with
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</link>), all normal access to the table for selecting rows or
   modifying rows must be allowed by a row security policy.  (However, the
   table's owner is typically not subject to row security policies.)  If no
   policy exists for the table, a default-deny policy is used, meaning that
   no rows are visible or can be modified.  Operations that apply to the
   whole table, such as <command>TRUNCATE</command> and <literal>REFERENCES</literal>,
   are not subject to row security.
  </para>
____________________________________________________________________________-->
  <para>
   当在一个表上启用行安全性时（使用
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</link>），所有对该表选择行或者修改行的普通访问都必须被一条
   行安全性策略所允许（不过，表的拥有者通常不服从行安全性策略）。如果
   表上不存在策略，将使用一条默认的否定策略，即所有的行都不可见或者不能
   被修改。应用在整个表上的操作不服从行安全性，例如<command>TRUNCATE</command>和
   <literal>REFERENCES</literal>。
  </para>

<!--==========================orignal english content==========================
  <para>
   Row security policies can be specific to commands, or to roles, or to
   both.  A policy can be specified to apply to <literal>ALL</literal>
   commands, or to <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>,
   or <literal>DELETE</literal>.  Multiple roles can be assigned to a given
   policy, and normal role membership and inheritance rules apply.
  </para>
____________________________________________________________________________-->
  <para>
   行安全性策略可以针对特定的命令、角色或者两者。一条策略可以被指定为
   适用于<literal>ALL</literal>命令，或者<literal>SELECT</literal>、
   <literal>INSERT</literal>、<literal>UPDATE</literal>或者<literal>DELETE</literal>。
   可以为一条给定策略分配多个角色，并且通常的角色成员关系和继承规则也
   适用。
  </para>

<!--==========================orignal english content==========================
  <para>
   To specify which rows are visible or modifiable according to a policy,
   an expression is required that returns a Boolean result.  This
   expression will be evaluated for each row prior to any conditions or
   functions coming from the user's query.  (The only exceptions to this
   rule are <literal>leakproof</literal> functions, which are guaranteed to
   not leak information; the optimizer may choose to apply such functions
   ahead of the row-security check.)  Rows for which the expression does
   not return <literal>true</literal> will not be processed.  Separate expressions
   may be specified to provide independent control over the rows which are
   visible and the rows which are allowed to be modified.  Policy
   expressions are run as part of the query and with the privileges of the
   user running the query, although security-definer functions can be used
   to access data not available to the calling user.
  </para>
____________________________________________________________________________-->
  <para>
   要指定哪些行根据一条策略是可见的或者是可修改的，需要一个返回布尔结果
   的表达式。对于每一行，在计算任何来自用户查询的条件或函数之前，先会计
   算这个表达式（这条规则的唯一例外是<literal>leakproof</literal>函数，
   它们被保证不会泄露信息，优化器可能会选择在行安全性检查之前应用这类
   函数）。使该表达式不返回<literal>true</literal>的行将不会被处理。可以指定
   独立的表达式来单独控制哪些行可见以及哪些行被允许修改。策略表达式会作
   为查询的一部分运行并且带有运行该查询的用户的特权，但是安全性定义者函数
   可以被用来访问对调用用户不可用的数据。
  </para>

<!--==========================orignal english content==========================
  <para>
   Superusers and roles with the <literal>BYPASSRLS</literal> attribute always
   bypass the row security system when accessing a table.  Table owners
   normally bypass row security as well, though a table owner can choose to
   be subject to row security with <link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</link>.
  </para>
____________________________________________________________________________-->
  <para>
   具有<literal>BYPASSRLS</literal>属性的超级用户和角色在访问一个表时总是
   可以绕过行安全性系统。表拥有者通常也能绕过行安全性，不过表拥有者
   可以选择用<link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</link>来服从行安全性。
  </para>

<!--==========================orignal english content==========================
  <para>
   Enabling and disabling row security, as well as adding policies to a
   table, is always the privilege of the table owner only.
  </para>
____________________________________________________________________________-->
  <para>
   启用和禁用行安全性以及向表增加策略是只有表拥有者具有的特权。
  </para>

<!--==========================orignal english content==========================
  <para>
   Policies are created using the <xref linkend="sql-createpolicy"/>
   command, altered using the <xref linkend="sql-alterpolicy"/> command,
   and dropped using the <xref linkend="sql-droppolicy"/> command.  To
   enable and disable row security for a given table, use the
   <xref linkend="sql-altertable"/> command.
  </para>
____________________________________________________________________________-->
  <para>
   策略的创建可以使用<xref linkend="sql-createpolicy"/>命令，策略的修改
   可以使用<xref linkend="sql-alterpolicy"/>命令，而策略的删除可以使用
   <xref linkend="sql-droppolicy"/>命令。要为一个给定表启用或者禁用行
   安全性，可以使用<xref linkend="sql-altertable"/>命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   Each policy has a name and multiple policies can be defined for a
   table.  As policies are table-specific, each policy for a table must
   have a unique name.  Different tables may have policies with the
   same name.
  </para>
____________________________________________________________________________-->
  <para>
   每一条策略都有名称并且可以为一个表定义多条策略。由于策略是表相
   关的，一个表的每一条策略都必须有一个唯一的名称。不同的表可以拥有
   相同名称的策略。
  </para>

<!--==========================orignal english content==========================
  <para>
   When multiple policies apply to a given query, they are combined using
   either <literal>OR</literal> (for permissive policies, which are the
   default) or using <literal>AND</literal> (for restrictive policies).
   This is similar to the rule that a given role has the privileges
   of all roles that they are a member of.  Permissive vs. restrictive
   policies are discussed further below.
  </para>
____________________________________________________________________________-->
  <para>
   当多条策略适用于一个给定的查询时，会把它们用<literal>OR</literal>（对宽容性策略，默认的策略类型）或者<literal>AND</literal>（对限制性策略）组合在一起。这和给定角色拥有它作为成员的所有角色的特权的规则类似。宽容性策略和限制性策略在下文将会进一步讨论。
  </para>

<!--==========================orignal english content==========================
  <para>
   As a simple example, here is how to create a policy on
   the <literal>account</literal> relation to allow only members of
   the <literal>managers</literal> role to access rows, and only rows of their
   accounts:
  </para>
____________________________________________________________________________-->
  <para>
   作为一个简单的例子，这里是如何在<literal>account</literal>关系上
   创建一条策略以允许只有<literal>managers</literal>角色的成员能访问行，
   并且只能访问它们账户的行：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>

<!--==========================orignal english content==========================
  <para>
   The policy above implicitly provides a <literal>WITH CHECK</literal>
   clause identical to its <literal>USING</literal> clause, so that the
   constraint applies both to rows selected by a command (so a manager
   cannot <command>SELECT</command>, <command>UPDATE</command>,
   or <command>DELETE</command> existing rows belonging to a different
   manager) and to rows modified by a command (so rows belonging to a
   different manager cannot be created via <command>INSERT</command>
   or <command>UPDATE</command>).
  </para>
____________________________________________________________________________-->
  <para>
   上面的策略隐含地提供了一个与其该约束适用于被一个命令选择的行（这样一个经理不能<command>SELECT</command>、<command>UPDATE</command>或者<command>DELETE</command>属于其他经理的已有行）以及被一个命令修改的行（这样属于其他经理的行不能通过<command>INSERT</command>或者<command>UPDATE</command>创建）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If no role is specified, or the special user name
   <literal>PUBLIC</literal> is used, then the policy applies to all
   users on the system.  To allow all users to access only their own row in
   a <literal>users</literal> table, a simple policy can be used:
  </para>
____________________________________________________________________________-->
  <para>
   如果没有指定角色或者使用了特殊的用户名<literal>PUBLIC</literal>，
   则该策略适用于系统上所有的用户。要允许所有用户访问<literal>users</literal>
   表中属于他们自己的行，可以使用一条简单的策略：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>

<!--==========================orignal english content==========================
  <para>
   This works similarly to the previous example.
  </para>
____________________________________________________________________________-->
  <para>
   这个例子的效果和前一个类似。
  </para>

<!--==========================orignal english content==========================
  <para>
   To use a different policy for rows that are being added to the table
   compared to those rows that are visible, multiple policies can be
   combined.  This pair of policies would allow all users to view all rows
   in the <literal>users</literal> table, but only modify their own:
  </para>
____________________________________________________________________________-->
  <para>
   为了对增加到表中的行使用与可见行不同的策略，可以组合多条策略。这一对策略将允许所有用户查看<literal>users</literal>表中的所有行，但只能修改他们自己的行：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>

<!--==========================orignal english content==========================
  <para>
   In a <command>SELECT</command> command, these two policies are combined
   using <literal>OR</literal>, with the net effect being that all rows
   can be selected.  In other command types, only the second policy applies,
   so that the effects are the same as before.
  </para>
____________________________________________________________________________-->
  <para>
   在一个<command>SELECT</command>命令中，这两条规则被用<literal>OR</literal>组合在一起，最终的效应就是所有的行都能被选择。在其他命令类型中，只有第二条策略适用，这样其效果就和以前相同。
  </para>

<!--==========================orignal english content==========================
  <para>
   Row security can also be disabled with the <command>ALTER TABLE</command>
   command.  Disabling row security does not remove any policies that are
   defined on the table; they are simply ignored.  Then all rows in the
   table are visible and modifiable, subject to the standard SQL privileges
   system.
  </para>
____________________________________________________________________________-->
  <para>
   也可以用<command>ALTER TABLE</command>命令禁用行安全性。禁用行安全性
   不会移除定义在表上的任何策略，它们只是被简单地忽略。然后该表中的所有
   行都是可见的并且可修改，服从于标准的 SQL 特权系统。
  </para>

<!--==========================orignal english content==========================
  <para>
   Below is a larger example of how this feature can be used in production
   environments.  The table <literal>passwd</literal> emulates a Unix password
   file:
  </para>
____________________________________________________________________________-->
  <para>
   下面是一个较大的例子，它展示了这种特性如何被用于生产环境。表
   <literal>passwd</literal>模拟了一个 Unix 口令文件：
  </para>

<!--==========================orignal english content==========================
<programlisting>
-&minus; Simple passwd-file based example
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -&minus; Administrator
CREATE ROLE bob;    -&minus; Normal user
CREATE ROLE alice;  -&minus; Normal user

-&minus; Populate the table
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-&minus; Be sure to enable row level security on the table
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-&minus; Create policies
-&minus; Administrator can see all rows and add any rows
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-&minus; Normal users can view all rows
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-&minus; Normal users can update their own records, but
-&minus; limit which shells a normal user is allowed to set
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-&minus; Allow admin all normal rights
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-&minus; Users only get select access on public columns
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-&minus; Allow users to update certain columns
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- 简单的口令文件例子
CREATE TABLE passwd (
  user_name              text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- 管理员
CREATE ROLE bob;    -- 普通用户
CREATE ROLE alice;  -- 普通用户

-- 填充表
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- 确保在表上启用行级安全性
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- 创建策略
-- 管理员能看见所有行并且增加任意行
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- 普通用户可以看见所有行
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- 普通用户可以更新它们自己的记录，但是限制普通用户可用的 shell
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = username AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- 允许管理员有所有普通权限
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- 用户只在公共列上得到选择访问
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- 允许用户更新特定行
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   As with any security settings, it's important to test and ensure that
   the system is behaving as expected.  Using the example above, this
   demonstrates that the permission system is working properly.
  </para>
____________________________________________________________________________-->
  <para>
   对于任意安全性设置来说，重要的是测试并确保系统的行为符合预期。
   使用上述的例子，下面展示了权限系统工作正确：
  </para>

<!--==========================orignal english content==========================
<programlisting>
-&minus; admin can view all rows and fields
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-&minus; Test what Alice is able to do
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-&minus; Alice is allowed to change her own real_name, but no others
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-&minus; Alice can change her own password; RLS silently prevents updating other rows
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- admin 可以看到所有的行和域
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- 测试 Alice 能做什么
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Alice 被允许更改她自己的 real_name，但不能改其他的
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Alice 可以更改她自己的口令；行级安全性会悄悄地阻止更新其他行
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>

<!--==========================orignal english content==========================
  <para>
   All of the policies constructed thus far have been permissive policies,
   meaning that when multiple policies are applied they are combined using
   the <quote>OR</quote> Boolean operator.  While permissive policies can be constructed
   to only allow access to rows in the intended cases, it can be simpler to
   combine permissive policies with restrictive policies (which the records
   must pass and which are combined using the <quote>AND</quote> Boolean operator).
   Building on the example above, we add a restrictive policy to require
   the administrator to be connected over a local Unix socket to access the
   records of the <literal>passwd</literal> table:
  </para>
____________________________________________________________________________-->
  <para>
   目前为止所有构建的策略都是宽容性策略，也就是当多条策略都适用时会被适用<quote>OR</quote>布尔操作符组合在一起。而宽容性策略可以被用来仅允许在预计情况中对行的访问，这比将宽容性策略与限制性策略（记录必须通过这类策略并且它们会被<quote>AND</quote>布尔操作符组合起来）组合在一起更简单。在上面的例子之上，我们增加一条限制性策略要求通过一个本地Unix套接字连接过来的管理员访问<literal>passwd</literal>表的记录：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>

<!--==========================orignal english content==========================
  <para>
   We can then see that an administrator connecting over a network will not
   see any records, due to the restrictive policy:
  </para>
____________________________________________________________________________-->
  <para>
   然后，由于这条限制性规则的存在，我们可以看到从网络连接进来的管理员将无法看到任何记录：
  </para>

<!--==========================orignal english content==========================
<programlisting>
=&gt; SELECT current_user;
 current_user 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>
____________________________________________________________________________-->
<programlisting>
=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>

<!--==========================orignal english content==========================
  <para>
   Referential integrity checks, such as unique or primary key constraints
   and foreign key references, always bypass row security to ensure that
   data integrity is maintained.  Care must be taken when developing
   schemas and row level policies to avoid <quote>covert channel</quote> leaks of
   information through such referential integrity checks.
  </para>
____________________________________________________________________________-->
  <para>
   参照完整性检查（例如唯一或逐渐约束和外键引用）总是会绕过行级安全性以
   保证数据完整性得到维护。在开发模式和行级安全性时必须小心避免
   <quote>隐通道</quote>通过这类参照完整性检查泄露信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   In some contexts it is important to be sure that row security is
   not being applied.  For example, when taking a backup, it could be
   disastrous if row security silently caused some rows to be omitted
   from the backup.  In such a situation, you can set the
   <xref linkend="guc-row-security"/> configuration parameter
   to <literal>off</literal>.  This does not in itself bypass row security;
   what it does is throw an error if any query's results would get filtered
   by a policy.  The reason for the error can then be investigated and
   fixed.
  </para>
____________________________________________________________________________-->
  <para>
   在某些环境中确保行安全性没有被应用很重要。例如，在做备份时，如果
   行安全性悄悄地导致某些行被从备份中忽略掉，这会是灾难性的。在这类
   情况下，你可以设置<xref linkend="guc-row-security"/>配置参数为
   <literal>off</literal>。这本身不会绕过行安全性，它所做的是如果任何结果会
   被一条策略过滤掉，就会抛出一个错误。然后错误的原因就可以被找到并且
   修复。
  </para>

<!--==========================orignal english content==========================
  <para>
   In the examples above, the policy expressions consider only the current
   values in the row to be accessed or updated.  This is the simplest and
   best-performing case; when possible, it's best to design row security
   applications to work this way.  If it is necessary to consult other rows
   or other tables to make a policy decision, that can be accomplished using
   sub-<command>SELECT</command>s, or functions that contain <command>SELECT</command>s,
   in the policy expressions.  Be aware however that such accesses can
   create race conditions that could allow information leakage if care is
   not taken.  As an example, consider the following table design:
  </para>
____________________________________________________________________________-->
  <para>
   在上面的例子中，策略表达式只考虑了要被访问的行中的当前值。这是最简
   单并且表现最好的情况。如果可能，最好设计行安全性应用以这种方式工作。
   如果需要参考其他行或者其他表来做出策略的决定，可以在策略表达式中通过
   使用子-<command>SELECT</command>或者包含<command>SELECT</command>的函数
   来实现。不过要注意这类访问可能会导致竞争条件，在不小心的情况下这可能
   会导致信息泄露。作为一个例子，考虑下面的表设计：
  </para>

<!--==========================orignal english content==========================
<programlisting>
-&minus; definition of privilege groups
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -&minus; alice is the administrator
GRANT SELECT ON groups TO public;

-&minus; definition of users' privilege levels
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-&minus; table holding the information to be protected
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-&minus; a row should be visible to/updatable by users whose security group_id is
-&minus; greater than or equal to the row's group_id
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-&minus; we rely only on RLS to protect the information table
GRANT ALL ON information TO public;
</programlisting>
____________________________________________________________________________-->
<programlisting>
-- 特权组的定义
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- alice 是管理员
GRANT SELECT ON groups TO public;

-- 用户的特权级别的定义
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- 保存要被保护的信息的表
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- 对于安全性 group_id 大于等于一行的 group_id 的用户，
-- 这一行应该是可见的/可更新的
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- 我们只依赖于行级安全性来保护信息表
GRANT ALL ON information TO public;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   Now suppose that <literal>alice</literal> wishes to change the <quote>slightly
   secret</quote> information, but decides that <literal>mallory</literal> should not
   be trusted with the new content of that row, so she does:
  </para>
____________________________________________________________________________-->
  <para>
   现在假设<literal>alice</literal>希望更改<quote>有一点点秘密</quote>
   的信息，但是觉得<literal>mallory</literal>不应该看到该行中的新
   内容，因此她这样做：
  </para>

<!--==========================orignal english content==========================
<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>
____________________________________________________________________________-->
<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   That looks safe; there is no window wherein <literal>mallory</literal> should be
   able to see the <quote>secret from mallory</quote> string.  However, there is
   a race condition here.  If <literal>mallory</literal> is concurrently doing,
   say,
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   and her transaction is in <literal>READ COMMITTED</literal> mode, it is possible
   for her to see <quote>secret from mallory</quote>.  That happens if her
   transaction reaches the <structname>information</structname> row just
   after <literal>alice</literal>'s does.  It blocks waiting
   for <literal>alice</literal>'s transaction to commit, then fetches the updated
   row contents thanks to the <literal>FOR UPDATE</literal> clause.  However, it
   does <emphasis>not</emphasis> fetch an updated row for the
   implicit <command>SELECT</command> from <structname>users</structname>, because that
   sub-<command>SELECT</command> did not have <literal>FOR UPDATE</literal>; instead
   the <structname>users</structname> row is read with the snapshot taken at the start
   of the query.  Therefore, the policy expression tests the old value
   of <literal>mallory</literal>'s privilege level and allows her to see the
   updated row.
  </para>
____________________________________________________________________________-->
  <para>
   这看起来是安全的，没有窗口可供<literal>mallory</literal>看到
   <quote>对 mallory 保密</quote>的字符串。不过，这里有一种
   竞争条件。如果<literal>mallory</literal>正在并行地做：
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   并且她的事务处于<literal>READ COMMITTED</literal>模式，她就可能看到
   <quote>s对 mallory 保密</quote>的东西。如果她的事务在<literal>alice</literal>
   做完之后就到达<structname>信息</structname>行，这就会发生。它会阻塞等待
   <literal>alice</literal>的事务提交，然后拜<literal>FOR UPDATE</literal>子句所赐
   取得更新后的行内容。不过，对于来自<structname>users</structname>的隐式
   <command>SELECT</command>，它<emphasis>不会</emphasis>取得一个已更新的行，
   因为子-<command>SELECT</command>没有<literal>FOR UPDATE</literal>，相反
   会使用查询开始时取得的快照读取<structname>users</structname>行。因此，
   策略表达式会测试<literal>mallory</literal>的特权级别的旧值并且允许她看到
   被更新的行。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are several ways around this problem.  One simple answer is to use
   <literal>SELECT ... FOR SHARE</literal> in sub-<command>SELECT</command>s in row
   security policies.  However, that requires granting <literal>UPDATE</literal>
   privilege on the referenced table (here <structname>users</structname>) to the
   affected users, which might be undesirable.  (But another row security
   policy could be applied to prevent them from actually exercising that
   privilege; or the sub-<command>SELECT</command> could be embedded into a security
   definer function.)  Also, heavy concurrent use of row share locks on the
   referenced table could pose a performance problem, especially if updates
   of it are frequent.  Another solution, practical if updates of the
   referenced table are infrequent, is to take an exclusive lock on the
   referenced table when updating it, so that no concurrent transactions
   could be examining old row values.  Or one could just wait for all
   concurrent transactions to end after committing an update of the
   referenced table and before making changes that rely on the new security
   situation.
  </para>
____________________________________________________________________________-->
  <para>
   有多种方法能解决这个问题。一种简单的答案是在行安全性策略中的
   子-<command>SELECT</command>里使用<literal>SELECT ... FOR SHARE</literal>。
   不过，这要求在被引用表（这里是<structname>users</structname>）上授予
   <literal>UPDATE</literal>特权给受影响的用户，这可能不是我们想要的（
   但是另一条行安全性策略可能被应用来阻止它们实际使用这个特权，或者
   子-<command>SELECT</command>可能被嵌入到一个安全性定义者函数中）。
   还有，在被引用的表上过多并发地使用行共享锁可能会导致性能问题，
   特别是表更新比较频繁时。另一种解决方案（如果被引用表上的更新
   不频繁就可行）是在更新被引用表时对它取一个排他锁，这样就没有
   并发事务能够检查旧的行值了。或者我们可以在提交对被引用表的更新
   之后、在做依赖于新安全性情况的更改之前等待所有并发事务结束。
  </para>

<!--==========================orignal english content==========================
  <para>
   For additional details see <xref linkend="sql-createpolicy"/>
   and <xref linkend="sql-altertable"/>.
  </para>
____________________________________________________________________________-->
  <para>
   更多细节请见<xref linkend="sql-createpolicy"/>
   和<xref linkend="sql-altertable"/>。
  </para>

 </sect1>

 <sect1 id="ddl-schemas">
<!--==========================orignal english content==========================
  <title>Schemas</title>
____________________________________________________________________________-->
  <title>模式</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   A <productname>PostgreSQL</productname> database cluster
   contains one or more named databases.  Users and groups of users are
   shared across the entire cluster, but no other data is shared across
   databases.  Any given client connection to the server can access
   only the data in a single database, the one specified in the connection
   request.
  </para>
____________________________________________________________________________-->
  <para>
   一个<productname>PostgreSQL</productname>数据库集簇中包含一个或更多命名的数据库。用户和用户组被整个集簇共享，但没有其他数据在数据库之间共享。任何给定客户端连接只能访问在连接中指定的数据库中的数据。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    Users of a cluster do not necessarily have the privilege to access every
    database in the cluster.  Sharing of user names means that there
    cannot be different users named, say, <literal>joe</literal> in two databases
    in the same cluster; but the system can be configured to allow
    <literal>joe</literal> access to only some of the databases.
   </para>
____________________________________________________________________________-->
   <para>
    一个集簇的用户并不必拥有访问集簇中每一个数据库的权限。用户名的共享意味着不可能在同一个集簇中出现重名的不同用户，例如两个数据库中都有叫<literal>joe</literal>的用户。但系统可以被配置为只允许<literal>joe</literal>访问某些数据库。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   A database contains one or more named <firstterm>schemas</firstterm>, which
   in turn contain tables.  Schemas also contain other kinds of named
   objects, including data types, functions, and operators.  The same
   object name can be used in different schemas without conflict; for
   example, both <literal>schema1</literal> and <literal>myschema</literal> can
   contain tables named <literal>mytable</literal>.  Unlike databases,
   schemas are not rigidly separated: a user can access objects in any
   of the schemas in the database they are connected to, if they have
   privileges to do so.
  </para>
____________________________________________________________________________-->
  <para>
   一个数据库包含一个或多个命名<firstterm>模式</firstterm>，模式中包含着表。模式还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中二不会出现冲突，例如<literal>schema1</literal>和<literal>myschema</literal>都可以包含名为<literal>mytable</literal>的表。和数据库不同，模式并不是被严格地隔离：一个用户可以访问他们所连接的数据库中的所有模式内的对象，只要他们有足够的权限。
  </para>

<!--==========================orignal english content==========================
  <para>
   There are several reasons why one might want to use schemas:

   <itemizedlist>
    <listitem>
     <para>
      To allow many users to use one database without interfering with
      each other.
     </para>
    </listitem>

    <listitem>
     <para>
      To organize database objects into logical groups to make them
      more manageable.
     </para>
    </listitem>

    <listitem>
     <para>
      Third-party applications can be put into separate schemas so
      they do not collide with the names of other objects.
     </para>
    </listitem>
   </itemizedlist>

   Schemas are analogous to directories at the operating system level,
   except that schemas cannot be nested.
  </para>
____________________________________________________________________________-->
  <para>
   下面是一些使用方案的原因：

   <itemizedlist>
    <listitem>
     <para>
      允许多个用户使用一个数据库并且不会互相干扰。
     </para>
    </listitem>

    <listitem>
     <para>
      将数据库对象组织成逻辑组以便更容易管理。
     </para>
    </listitem>

    <listitem>
     <para>
      第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。     </para>
    </listitem>
   </itemizedlist>

   模式类似于操作系统层的目录，但是模式不能嵌套。
  </para>

  <sect2 id="ddl-schemas-create">
<!--==========================orignal english content==========================
   <title>Creating a Schema</title>
____________________________________________________________________________-->
   <title>创建模式</title>

<!--==========================orignal english content==========================
   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To create a schema, use the <xref linkend="sql-createschema"/>
    command.  Give the schema a name
    of your choice.  For example:
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    要创建一个模式，可使用<xref linkend="sql-createschema"/>命令，并且给出选择的模式名称。例如：
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>qualified name</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>qualified name</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To create or access objects in a schema, write a
    <firstterm>qualified name</firstterm> consisting of the schema name and
    table name separated by a dot:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    This works anywhere a table name is expected, including the table
    modification commands and the data access commands discussed in
    the following chapters.
    (For brevity we will speak of tables only, but the same ideas apply
    to other kinds of named objects, such as types and functions.)
   </para>
____________________________________________________________________________-->
   <para>
    在一个模式中创建或访问对象，需要使用由模式名和表名构成的<firstterm>限定名</firstterm>，模式名和表名之间以点号分隔：
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    在任何需要一个表名的地方都可以这样用，包括表修改命令和后续章节要讨论的数据访问命令（为了简洁我们在这里只谈到表，但是这种方式对其他类型的命名对象同样有效，例如类型和函数）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Actually, the even more general syntax
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    can be used too, but at present this is just for <foreignphrase>pro
    forma</foreignphrase> compliance with the SQL standard.  If you write a database name,
    it must be the same as the database you are connected to.
   </para>
____________________________________________________________________________-->
   <para>
    事实上，还有更加通用的语法：
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    也可以使用，但是目前它只是在<foreignphrase>形式上</foreignphrase>与SQL标准兼容。如果我们写一个数据库名称，它必须是我们正在连接的数据库。
   </para>

<!--==========================orignal english content==========================
   <para>
    So to create a table in the new schema, use:
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    因此，如果要在一个新模式中创建一个表，可用：
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To drop a schema if it's empty (all objects in it have been
    dropped), use:
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    To drop a schema including all contained objects, use:
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
   </para>
____________________________________________________________________________-->
   <para>
    要删除一个为空的模式（其中的所有对象已经被删除），可用：
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    要删除一个模式以及其中包含的所有对象，可用：
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    有关于此的更一般的机制请参见<xref linkend="ddl-depend"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Often you will want to create a schema owned by someone else
    (since this is one of the ways to restrict the activities of your
    users to well-defined namespaces).  The syntax for that is:
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
    You can even omit the schema name, in which case the schema name
    will be the same as the user name.  See <xref
    linkend="ddl-schemas-patterns"/> for how this can be useful.
   </para>
____________________________________________________________________________-->
   <para>
    我们常常希望创建一个由其他人所拥有的模式（因为这是将用户动作限制在良定义的名字空间中的方法之一）。其语法是：
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
    我们甚至可以省略模式名称，在此种情况下模式名称将会使用用户名，参见<xref linkend="ddl-schemas-patterns"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Schema names beginning with <literal>pg_</literal> are reserved for
    system purposes and cannot be created by users.
   </para>
____________________________________________________________________________-->
   <para>
    以<literal>pg_</literal>开头的模式名被保留用于系统目的，所以不能被用户所创建。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-public">
<!--==========================orignal english content==========================
   <title>The Public Schema</title>
____________________________________________________________________________-->
   <title>公共模式</title>

<!--==========================orignal english content==========================
   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    In the previous sections we created tables without specifying any
    schema names.  By default such tables (and other objects) are
    automatically put into a schema named <quote>public</quote>.  Every new
    database contains such a schema.  Thus, the following are equivalent:
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    and:
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    在前面的小节中，我们创建的表都没有指定任何模式名称。默认情况下这些表（以及其他对象）会自动的被放入一个名为<quote>public</quote>的模式中。任何新数据库都包含这样一个模式。因此，下面的命令是等效的：
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    以及：
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
  </sect2>

  <sect2 id="ddl-schemas-path">
<!--==========================orignal english content==========================
   <title>The Schema Search Path</title>
____________________________________________________________________________-->
   <title>模式搜索路径</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>search path</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>search path</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Qualified names are tedious to write, and it's often best not to
    wire a particular schema name into applications anyway.  Therefore
    tables are often referred to by <firstterm>unqualified names</firstterm>,
    which consist of just the table name.  The system determines which table
    is meant by following a <firstterm>search path</firstterm>, which is a list
    of schemas to look in.  The first matching table in the search path
    is taken to be the one wanted.  If there is no match in the search
    path, an error is reported, even if matching table names exist
    in other schemas in the database.
   </para>
____________________________________________________________________________-->
   <para>
    限定名写起来很冗长，通常最好不要把一个特定模式名拉到应用中。因此，表名通常被使用<firstterm>非限定名</firstterm>来引用，它只由表名构成。系统将沿着一条<firstterm>搜索路径</firstterm>来决定该名称指的是哪个表，搜索路径是一个进行查看的模式列表。 搜索路径中第一个匹配的表将被认为是所需要的。如果在搜索路径中没有任何匹配，即使在数据库的其他模式中存在匹配的表名也将会报告一个错误。
   </para>

<!--==========================orignal english content==========================
   <para>
    The ability to create like-named objects in different schemas complicates
    writing a query that references precisely the same objects every time.  It
    also opens up the potential for users to change the behavior of other
    users' queries, maliciously or accidentally.  Due to the prevalence of
    unqualified names in queries and their use
    in <productname>PostgreSQL</productname> internals, adding a schema
    to <varname>search_path</varname> effectively trusts all users having
    <literal>CREATE</literal> privilege on that schema.  When you run an
    ordinary query, a malicious user able to create objects in a schema of
    your search path can take control and execute arbitrary SQL functions as
    though you executed them.
   </para>
____________________________________________________________________________-->
   <para>
    在不同方案中创建命名相同的对象的能力使得编写每次都准确引用相同对象的查询变得复杂。这也使得用户有可能更改其他用户查询的行为，不管是出于恶意还是无意。由于未经限定的名称在查询中以及在<productname>PostgreSQL</productname>内部的广泛使用，在<varname>search_path</varname>中增加一个方案实际上是信任所有在该方案中具有<literal>CREATE</literal>特权的用户。在你运行一个普通查询时，恶意用户可以在你的搜索路径中的以方案中创建能够夺取控制权并且执行任意SQL函数的对象，而这些事情就像是你在执行一样。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    The first schema named in the search path is called the current schema.
    Aside from being the first schema searched, it is also the schema in
    which new tables will be created if the <command>CREATE TABLE</command>
    command does not specify a schema name.
   </para>
____________________________________________________________________________-->
   <para>
    搜索路径中的第一个模式被称为当前模式。除了是第一个被搜索的模式外，如果<command>CREATE TABLE</command>命令没有指定模式名，它将是新创建表所在的模式。
   </para>

<!--==========================orignal english content==========================
   <indexterm>
    <primary><varname>search_path</varname> configuration parameter</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary><varname>search_path</varname>配置参数</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    To show the current search path, use the following command:
<programlisting>
SHOW search_path;
</programlisting>
    In the default setup this returns:
<screen>
 search_path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "$user", public
</screen>
    The first element specifies that a schema with the same name as
    the current user is to be searched.  If no such schema exists,
    the entry is ignored.  The second element refers to the
    public schema that we have seen already.
   </para>
____________________________________________________________________________-->
   <para>
    要显示当前搜索路径，使用下面的命令：
<programlisting>
SHOW search_path;
</programlisting>
    在默认设置下这将返回：
<screen>
 search_path
--------------
 "$user",public
</screen>
    第一个元素说明一个和当前用户同名的模式会被搜索。如果不存在这个模式，该项将被忽略。第二个元素指向我们已经见过的公共模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    The first schema in the search path that exists is the default
    location for creating new objects.  That is the reason that by
    default objects are created in the public schema.  When objects
    are referenced in any other context without schema qualification
    (table modification, data modification, or query commands) the
    search path is traversed until a matching object is found.
    Therefore, in the default configuration, any unqualified access
    again can only refer to the public schema.
   </para>
____________________________________________________________________________-->
   <para>
    搜索路径中的第一个模式是创建新对象的默认存储位置。这就是默认情况下对象会被创建在公共模式中的原因。当对象在任何其他没有模式限定的环境中被引用（表修改、数据修改或查询命令）时，搜索路径将被遍历直到一个匹配对象被找到。因此，在默认配置中，任何非限定访问将只能指向公共模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    To put our new schema in the path, we use:
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    (We omit the <literal>$user</literal> here because we have no
    immediate need for it.)  And then we can access the table without
    schema qualification:
<programlisting>
DROP TABLE mytable;
</programlisting>
    Also, since <literal>myschema</literal> is the first element in
    the path, new objects would by default be created in it.
   </para>
____________________________________________________________________________-->
   <para>
    要把新模式放在搜索路径中，我们可以使用：
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    （我们在这里省略了<literal>$user</literal>，因为我们并不立即需要它）。然后我们可以删除该表而无需使用方案进行限定：
<programlisting>
DROP TABLE mytable;
</programlisting>
    同样，由于<literal>myschema</literal>是路径中的第一个元素，新对象会被默认创建在其中。
   </para>

<!--==========================orignal english content==========================
   <para>
    We could also have written:
<programlisting>
SET search_path TO myschema;
</programlisting>
    Then we no longer have access to the public schema without
    explicit qualification.  There is nothing special about the public
    schema except that it exists by default.  It can be dropped, too.
   </para>
____________________________________________________________________________-->
   <para>
    我们也可以这样写：
<programlisting>
SET search_path TO myschema;
</programlisting>
    这样我们在没有显式限定时再也不必去访问公共模式了。公共模式没有什么特别之处，它只是默认存在而已，它也可以被删除。
   </para>

<!--==========================orignal english content==========================
   <para>
    See also <xref linkend="functions-info"/> for other ways to manipulate
    the schema search path.
   </para>
____________________________________________________________________________-->
   <para>
    其他操作模式搜索路径的方法请见<xref linkend="functions-info"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The search path works in the same way for data type names, function names,
    and operator names as it does for table names.  Data type and function
    names can be qualified in exactly the same way as table names.  If you
    need to write a qualified operator name in an expression, there is a
    special provision: you must write
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
    This is needed to avoid syntactic ambiguity.  An example is:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    In practice one usually relies on the search path for operators,
    so as not to have to write anything so ugly as that.
   </para>
____________________________________________________________________________-->
   <para>
    搜索路径对于数据类型名称、函数名称和操作符名称的作用与表名一样。数据类型和函数名称可以使用和表名完全相同的限定方式。如果我们需要在一个表达式中写一个限定的操作符名称，我们必须写成一种特殊的形式：
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
    这是为了避免句法歧义。例如：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    实际上我们通常都会依赖于搜索路径来查找操作符，因此没有必要去写如此“丑陋”的东西。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-priv">
<!--==========================orignal english content==========================
   <title>Schemas and Privileges</title>
____________________________________________________________________________-->
   <title>模式和权限</title>

<!--==========================orignal english content==========================
   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    By default, users cannot access any objects in schemas they do not
    own.  To allow that, the owner of the schema must grant the
    <literal>USAGE</literal> privilege on the schema.  To allow users
    to make use of the objects in the schema, additional privileges
    might need to be granted, as appropriate for the object.
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，用户不能访问不属于他们的方案中的任何对象。要允许这种行为，模式的拥有者必须在该模式上授予<literal>USAGE</literal>权限。为了允许用户使用方案中的对象，可能还需要根据对象授予额外的权限。
   </para>

<!--==========================orignal english content==========================
   <para>
    A user can also be allowed to create objects in someone else's
    schema.  To allow that, the <literal>CREATE</literal> privilege on
    the schema needs to be granted.  Note that by default, everyone
    has <literal>CREATE</literal> and <literal>USAGE</literal> privileges on
    the schema
    <literal>public</literal>.  This allows all users that are able to
    connect to a given database to create objects in its
    <literal>public</literal> schema.
    Some <link linkend="ddl-schemas-patterns">usage patterns</link> call for
    revoking that privilege:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    (The first <quote>public</quote> is the schema, the second
    <quote>public</quote> means <quote>every user</quote>.  In the
    first sense it is an identifier, in the second sense it is a
    key word, hence the different capitalization; recall the
    guidelines from <xref linkend="sql-syntax-identifiers"/>.)
   </para>
____________________________________________________________________________-->
   <para>
    一个用户也可以被允许在其他某人的模式中创建对象。要允许这种行为，模式上的<literal>CREATE</literal>权限必须被授予。注意在默认情况下，所有人都拥有在<literal>public</literal>模式上的<literal>CREATE</literal>和<literal>USAGE</literal>权限。这使得用户能够连接到一个给定数据库并在它的<literal>public</literal>模式中创建对象。回收这一特权的<link linkend="ddl-schemas-patterns">使用模式</link>调用：
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    （第一个<quote>public</quote>是方案，第二个<quote>public</quote>指的是<quote>每一个用户</quote>。第一种是一个标识符，第二种是一个关键词，所以两者的大小写不同。请回想<xref linkend="sql-syntax-identifiers"/>中的指导方针。）
   </para>
  </sect2>

  <sect2 id="ddl-schemas-catalog">
<!--==========================orignal english content==========================
   <title>The System Catalog Schema</title>
____________________________________________________________________________-->
   <title>系统目录模式</title>

<!--==========================orignal english content==========================
   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    In addition to <literal>public</literal> and user-created schemas, each
    database contains a <literal>pg_catalog</literal> schema, which contains
    the system tables and all the built-in data types, functions, and
    operators.  <literal>pg_catalog</literal> is always effectively part of
    the search path.  If it is not named explicitly in the path then
    it is implicitly searched <emphasis>before</emphasis> searching the path's
    schemas.  This ensures that built-in names will always be
    findable.  However, you can explicitly place
    <literal>pg_catalog</literal> at the end of your search path if you
    prefer to have user-defined names override built-in names.
   </para>
____________________________________________________________________________-->
   <para>
    除<literal>public</literal>和用户创建的模式之外，每一个数据库还包括一个<literal>pg_catalog</literal>模式，它包含了系统表和所有内建的数据类型、函数以及操作符。<literal>pg_catalog</literal>总是搜索路径的一个有效部分。如果没有在路径中显式地包括该模式，它将在路径中的模式<emphasis>之前</emphasis>被搜索。这保证了内建的名称总是能被找到。然而，如果我们希望用用户定义的名称重载内建的名称，可以显式的将<literal>pg_catalog</literal>放在搜索路径的末尾。
   </para>

<!--==========================orignal english content==========================
   <para>
    Since system table names begin with <literal>pg_</literal>, it is best to
    avoid such names to ensure that you won't suffer a conflict if some
    future version defines a system table named the same as your
    table.  (With the default search path, an unqualified reference to
    your table name would then be resolved as the system table instead.)
    System tables will continue to follow the convention of having
    names beginning with <literal>pg_</literal>, so that they will not
    conflict with unqualified user-table names so long as users avoid
    the <literal>pg_</literal> prefix.
   </para>
____________________________________________________________________________-->
   <para>
    由于系统表名称以<literal>pg_</literal>开头，最好还是避免使用这样的名称，以避免和未来新版本中
    可能出现的系统表名发生冲突。系统表将继续采用以<literal>pg_</literal>开头的方式，这样它们不会
    与非限制的用户表名称冲突。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-patterns">
<!--==========================orignal english content==========================
   <title>Usage Patterns</title>
____________________________________________________________________________-->
   <title>使用模式</title>

<!--==========================orignal english content==========================
   <para>
    Schemas can be used to organize your data in many ways.  There are a few
    usage patterns easily supported by the default configuration, only one of
    which suffices when database users mistrust other database users:
    <itemizedlist>
     <listitem>
      <!-&minus; "DROP SCHEMA public" is inferior to this REVOKE, because pg_dump
           doesn't preserve that DROP. -&minus;>
      <para>
       Constrain ordinary users to user-private schemas.  To implement this,
       issue <literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>,
       and create a schema for each user with the same name as that user.  If
       affected users had logged in before this, consider auditing the public
       schema for objects named like objects in
       schema <literal>pg_catalog</literal>.  Recall that the default search
       path starts with <literal>$user</literal>, which resolves to the user
       name.  Therefore, if each user has a separate schema, they access their
       own schemas by default.
      </para>
     </listitem>

     <listitem>
      <para>
       Remove the public schema from each user's default search path
       using <literal>ALTER ROLE <replaceable>user</replaceable> SET
       search_path = "$user"</literal>.  Everyone retains the ability to
       create objects in the public schema, but only qualified names will
       choose those objects.  While qualified table references are fine, calls
       to functions in the public schema <link linkend="typeconv-func">will be
       unsafe or unreliable</link>.  Also, a user holding
       the <literal>CREATEROLE</literal> privilege can undo this setting and
       issue arbitrary queries under the identity of users relying on the
       setting.  If you create functions or extensions in the public schema or
       grant <literal>CREATEROLE</literal> to users not warranting this
       almost-superuser ability, use the first pattern instead.
      </para>
     </listitem>

     <listitem>
      <para>
       Remove the public schema from <varname>search_path</varname> in
       <link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>.
       The ensuing user experience matches the previous pattern.  In addition
       to that pattern's implications for functions
       and <literal>CREATEROLE</literal>, this trusts database owners
       like <literal>CREATEROLE</literal>.  If you create functions or
       extensions in the public schema or assign
       the <literal>CREATEROLE</literal>
       privilege, <literal>CREATEDB</literal> privilege or individual database
       ownership to users not warranting almost-superuser access, use the
       first pattern instead.
      </para>
     </listitem>

     <listitem>
      <para>
       Keep the default.  All users access the public schema implicitly.  This
       simulates the situation where schemas are not available at all, giving
       a smooth transition from the non-schema-aware world.  However, any user
       can issue arbitrary queries under the identity of any user not electing
       to protect itself individually.  This pattern is acceptable only when
       the database has a single user or a few mutually-trusting users.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    有一些默认配置可以轻易支持的使用模式，当数据库用户不信任其他数据库用户时，使用其中之一就足够了：
    <itemizedlist>
     <listitem>
      <!-- "DROP SCHEMA public" is inferior to this REVOKE, because pg_dump
           doesn't preserve that DROP. -->
      <para>
       将普通用户约束在其私有的方案中。要实现这一点，发出<literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>，并且为每一个用户创建一个用其用户名命名的方案。如果受影响的用户在做这些之前就已经登入，应该对与方案<literal>pg_catalog</literal>中对象命名相似的对象审计public方案。回忆一下，默认的搜索路径开始于<literal>$user</literal>，它会被解析为用户名。因此，如果每个用户都有一个单独的方案，默认他们访问他们自己的方案。
      </para>
     </listitem>

     <listitem>
      <para>
       使用<literal>ALTER ROLE <replaceable>user</replaceable> SET search_path = "$user"</literal>从每个用户的默认搜索路径中去掉public方案。每个人都保留着在public方案中创建对象的能力，但是只有限定的名称才能选择那些对象。虽然限定的表引用是好的，但对public方案中函数的调用<link linkend="typeconv-func">将是不安全或不可靠的</link>。此外，持有<literal>CREATEROLE</literal>特权的用户可以撤销这种设置并且以依赖于这种设置的用户的身份发出任意查询。如果你在public方案中创建方案或扩展或者把<literal>CREATEROLE</literal>授予给不能正当使用这种几乎是超级用户能力的用户，应该使用第一种模式。
      </para>
     </listitem>

     <listitem>
      <para>
       从<link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>中的<varname>search_path</varname>去掉public方案。接下来的用户体验符合前一种模式。除了上一中模式对函数和<literal>CREATEROLE</literal>的暗示之外，这种模式像<literal>CREATEROLE</literal>那样信任数据库拥有者。如果你在public方案中创建函数或扩展，或者向不能正当使用几乎是超级用户访问的用户授予<literal>CREATEROLE</literal>特权、<literal>CREATEDB</literal>特权或数据库的拥有关系，请使用第一种模式。
      </para>
     </listitem>

     <listitem>
      <para>
       保持默认。所有用户都隐式地访问public模式。这模拟了方案根本不可用的情况，可以用于从没有方案的世界平滑过渡。不过，任何用户都能以任何无法自我保护的用户的身份发出任意查询。只有当数据库仅有单个用户或者少数相互信任的用户时，这种模式才可接受。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    For any pattern, to install shared applications (tables to be used by
    everyone, additional functions provided by third parties, etc.), put them
    into separate schemas.  Remember to grant appropriate privileges to allow
    the other users to access them.  Users can then refer to these additional
    objects by qualifying the names with a schema name, or they can put the
    additional schemas into their search path, as they choose.
   </para>
____________________________________________________________________________-->
   <para>
    对于任何一种模式，为了安装共享的应用（所有人都要用其中的表，第三方提供的额外函数，等等），可把它们放在单独的方案中。记住授予适当的特权以允许其他用户访问它们。然后用户可以通过以方案名限定名称的方式来引用这些额外的对象，或者他们可以把额外的方案放在自己的搜索路径中。
   </para>
  </sect2>

  <sect2 id="ddl-schemas-portability">
<!--==========================orignal english content==========================
   <title>Portability</title>
____________________________________________________________________________-->
   <title>可移植性</title>

<!--==========================orignal english content==========================
   <para>
    In the SQL standard, the notion of objects in the same schema
    being owned by different users does not exist.  Moreover, some
    implementations do not allow you to create schemas that have a
    different name than their owner.  In fact, the concepts of schema
    and user are nearly equivalent in a database system that
    implements only the basic schema support specified in the
    standard.  Therefore, many users consider qualified names to
    really consist of
    <literal><replaceable>user_name</replaceable>.<replaceable>table_name</replaceable></literal>.
    This is how <productname>PostgreSQL</productname> will effectively
    behave if you create a per-user schema for every user.
   </para>
____________________________________________________________________________-->
   <para>
    在SQL标准中，在由不同用户拥有的同一个模式中的对象是不存在的。此外，某些实现不允许创建与拥有者名称不同名的模式。事实上，在那些仅实现了标准中基本模式支持的数据库中，模式和用户的概念是等同的。因此，很多用户认为限定名称实际上是由<literal><replaceable>user_name</replaceable>.<replaceable>table_name</replaceable></literal>组成的。如果我们为每一个用户都创建了一个模式，<productname>PostgreSQL</productname>实际也是这样认为的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Also, there is no concept of a <literal>public</literal> schema in the
    SQL standard.  For maximum conformance to the standard, you should
    not use the <literal>public</literal> schema.
   </para>
____________________________________________________________________________-->
   <para>
    同样，在SQL标准中也没有<literal>public</literal>模式的概念。为了最大限度的与标准一致，我们不应使用（甚至是删除）<literal>public</literal>模式。
   </para>

<!--==========================orignal english content==========================
   <para>
    Of course, some SQL database systems might not implement schemas
    at all, or provide namespace support by allowing (possibly
    limited) cross-database access.  If you need to work with those
    systems, then maximum portability would be achieved by not using
    schemas at all.
   </para>
____________________________________________________________________________-->
   <para>
    当然，某些SQL数据库系统可能根本没有实现方案，或者提供允许跨数据库访问的名字空间。如果需要使用这样一些系统，最好不要使用方案。
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
<!--==========================orignal english content==========================
  <title>Inheritance</title>
____________________________________________________________________________-->
  <title>继承</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>inheritance</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>inheritance</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> implements table inheritance,
   which can be a useful tool for database designers.  (SQL:1999 and
   later define a type inheritance feature, which differs in many
   respects from the features described here.)
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>实现了表继承，这对数据库设计者来说是一种有用的工具（SQL:1999及其后的版本定义了一种类型继承特性，但和这里介绍的继承有很大的不同）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Let's start with an example: suppose we are trying to build a data
   model for cities.  Each state has many cities, but only one
   capital. We want to be able to quickly retrieve the capital city
   for any particular state. This can be done by creating two tables,
   one for state capitals and one for cities that are not
   capitals. However, what happens when we want to ask for data about
   a city, regardless of whether it is a capital or not? The
   inheritance feature can help to resolve this problem. We define the
   <structname>capitals</structname> table so that it inherits from
   <structname>cities</structname>:

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -&minus; in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   In this case, the <structname>capitals</structname> table <firstterm>inherits</firstterm>
   all the columns of its parent table, <structname>cities</structname>. State
   capitals also have an extra column, <structfield>state</structfield>, that shows
   their state.
  </para>
____________________________________________________________________________-->
  <para>
   让我们从一个例子开始：假设我们要为城市建立一个数据模型。每一个州有很多城市，但是只有一个首府。我们希望能够快速地检索任何特定州的首府城市。这可以通过创建两个表来实现：一个用于州首府，另一个用于不是首府的城市。然而，当我们想要查看一个城市的数据（不管它是不是一个首府）时会发生什么？继承特性将有助于解决这个问题。我们可以将<structname>capitals</structname>表定义为继承自<structname>cities</structname>表：

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   在这种情况下，<structname>capitals</structname>表<firstterm>继承</firstterm>了它的父表<structname>cities</structname>的所有列。州首府还有一个额外的列<structfield>state</structfield>用来表示它所属的州。
  </para>

<!--==========================orignal english content==========================
  <para>
   In <productname>PostgreSQL</productname>, a table can inherit from
   zero or more other tables, and a query can reference either all
   rows of a table or all rows of a table plus all of its descendant tables.
   The latter behavior is the default.
   For example, the following query finds the names of all cities,
   including state capitals, that are located at an altitude over
   500 feet:

<programlisting>
SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;
</programlisting>

   Given the sample data from the <productname>PostgreSQL</productname>
   tutorial (see <xref linkend="tutorial-sql-intro"/>), this returns:

<programlisting>
   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个其他表继承，而对一个表的查询则可以引用一个表的所有行或者该表的所有行加上它所有的后代表。默认情况是后一种行为。例如，下面的查询将查找所有海拔高于500尺的城市的名称，包括州首府：

<programlisting>
SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;
</programlisting>

   对于来自<productname>PostgreSQL</productname>教程（见<xref linkend="tutorial-sql-intro"/>）的例子数据，它将返回：

<programlisting>
   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   On the other hand, the following query finds all the cities that
   are not state capitals and are situated at an altitude over 500 feet:

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在另一方面，下面的查询将找到海拔超过500尺且不是州首府的所有城市：

<programlisting>
SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Here the <literal>ONLY</literal> keyword indicates that the query
   should apply only to <structname>cities</structname>, and not any tables
   below <structname>cities</structname> in the inheritance hierarchy.  Many
   of the commands that we have already discussed &mdash;
   <command>SELECT</command>, <command>UPDATE</command> and
   <command>DELETE</command> &mdash; support the
   <literal>ONLY</literal> keyword.
  </para>
____________________________________________________________________________-->
  <para>
   这里的<literal>ONLY</literal>关键词指示查询只被应用于<structname>cities</structname>上，而其他在继承层次中位于<structname>cities</structname>之下的其他表都不会被该查询涉及。很多我们已经讨论过的命令（如<command>SELECT</command>、<command>UPDATE</command>和<command>DELETE</command>）都支持<literal>ONLY</literal>关键词。
  </para>

<!--==========================orignal english content==========================
  <para>
   You can also write the table name with a trailing <literal>*</literal>
   to explicitly specify that descendant tables are included:

<programlisting>
SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;
</programlisting>

   Writing <literal>*</literal> is not necessary, since this behavior is always
   the default.  However, this syntax is still supported for
   compatibility with older releases where the default could be changed.
  </para>
____________________________________________________________________________-->
  <para>
   我们也可以在表名后写上一个<literal>*</literal>来显式地将后代表包括在查询范围内：

<programlisting>
SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;
</programlisting>

   写<literal>*</literal>不是必需的，因为这种行为总是默认的。不过，为了兼容可以修改默认值的较老版本，现在仍然支持这种语法。
  </para>

<!--==========================orignal english content==========================
  <para>
   In some cases you might wish to know which table a particular row
   originated from. There is a system column called
   <structfield>tableoid</structfield> in each table which can tell you the
   originating table:

<programlisting>
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>

   which returns:

<programlisting>
 tableoid |   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   (If you try to reproduce this example, you will probably get
   different numeric OIDs.)  By doing a join with
   <structname>pg_class</structname> you can see the actual table names:

<programlisting>
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   which returns:

<programlisting>
 relname  |   name    | altitude
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   在某些情况下，我们可能希望知道一个特定行来自于哪个表。每个表中的系统列<structfield>tableoid</structfield>可以告诉我们行来自于哪个表：

<programlisting>
SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>

   将会返回：

<programlisting>
 tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845
</programlisting>

   （如果重新生成这个结果，可能会得到不同的OID数字。）通过与<structname>pg_class</structname>进行连接可以看到实际的表名：

<programlisting>
SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   将会返回：

<programlisting>
 relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845
</programlisting>
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Another way to get the same effect is to use the <type>regclass</type>
   alias type, which will print the table OID symbolically:

<programlisting>
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   另一种得到同样效果的方法是使用<type>regclass</type>别名类型，
   它将象征性地打印出表的 OID：

<programlisting>
SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Inheritance does not automatically propagate data from
   <command>INSERT</command> or <command>COPY</command> commands to
   other tables in the inheritance hierarchy. In our example, the
   following <command>INSERT</command> statement will fail:
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   We might hope that the data would somehow be routed to the
   <structname>capitals</structname> table, but this does not happen:
   <command>INSERT</command> always inserts into exactly the table
   specified.  In some cases it is possible to redirect the insertion
   using a rule (see <xref linkend="rules"/>).  However that does not
   help for the above case because the <structname>cities</structname> table
   does not contain the column <structfield>state</structfield>, and so the
   command will be rejected before the rule can be applied.
  </para>
____________________________________________________________________________-->
  <para>
   继承不会自动地将来自<command>INSERT</command>或<command>COPY</command>命令的数据传播到继承层次中的其他表中。在我们的例子中，下面的<command>INSERT</command>语句将会失败：
<programlisting>
INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   我们也许希望数据能被以某种方式被引入到<structname>capitals</structname>表中，但是这不会发生：<command>INSERT</command>总是向指定的表中插入。在某些情况下，可以通过使用一个规则（见<xref linkend="rules"/>）来将插入动作重定向。但是这对上面的情况并没有帮助，因为<structname>cities</structname>表根本就不包含<structfield>state</structfield>列，因而这个命令将在触发规则之前就被拒绝。
  </para>

<!--==========================orignal english content==========================
  <para>
   All check constraints and not-null constraints on a parent table are
   automatically inherited by its children, unless explicitly specified
   otherwise with <literal>NO INHERIT</literal> clauses.  Other types of constraints
   (unique, primary key, and foreign key constraints) are not inherited.
  </para>
____________________________________________________________________________-->
  <para>
   父表上的所有检查约束和非空约束都将自动被它的后代所继承，除非显式地指定了<literal>NO INHERIT</literal>子句。其他类型的约束（唯一、主键和外键约束）则不会被继承。
  </para>

<!--==========================orignal english content==========================
  <para>
   A table can inherit from more than one parent table, in which case it has
   the union of the columns defined by the parent tables.  Any columns
   declared in the child table's definition are added to these.  If the
   same column name appears in multiple parent tables, or in both a parent
   table and the child's definition, then these columns are <quote>merged</quote>
   so that there is only one such column in the child table.  To be merged,
   columns must have the same data types, else an error is raised.
   Inheritable check constraints and not-null constraints are merged in a
   similar fashion.  Thus, for example, a merged column will be marked
   not-null if any one of the column definitions it came from is marked
   not-null.  Check constraints are merged if they have the same name,
   and the merge will fail if their conditions are different.
  </para>
____________________________________________________________________________-->
  <para>
   一个表可以从超过一个的父表继承，在这种情况下它拥有父表们所定义的列的并集。任何定义在子表上的列也会被加入到其中。如果在这个集合中出现重名列，那么这些列将被<quote>合并</quote>，这样在子表中只会有一个这样的列。重名列能被合并的前提是这些列必须具有相同的数据类型，否则会导致错误。可继承的检查约束和非空约束会以类似的方式被合并。例如，如果合并成一个合并列的任一列定义被标记为非空，则该合并列会被标记为非空。如果检查约束的名称相同，则他们会被合并，但如果它们的条件不同则合并会失败。
  </para>

<!--==========================orignal english content==========================
  <para>
   Table inheritance is typically established when the child table is
   created, using the <literal>INHERITS</literal> clause of the
   <xref linkend="sql-createtable"/>
   statement.
   Alternatively, a table which is already defined in a compatible way can
   have a new parent relationship added, using the <literal>INHERIT</literal>
   variant of <xref linkend="sql-altertable"/>.
   To do this the new child table must already include columns with
   the same names and types as the columns of the parent. It must also include
   check constraints with the same names and check expressions as those of the
   parent. Similarly an inheritance link can be removed from a child using the
   <literal>NO INHERIT</literal> variant of <command>ALTER TABLE</command>.
   Dynamically adding and removing inheritance links like this can be useful
   when the inheritance relationship is being used for table
   partitioning (see <xref linkend="ddl-partitioning"/>).
  </para>
____________________________________________________________________________-->
  <para>
   表继承通常是在子表被创建时建立，使用<xref linkend="sql-createtable"/>语句的<literal>INHERITS</literal>子句。一个已经被创建的表也可以另外一种方式增加一个新的父亲关系，使用<xref linkend="sql-altertable"/>的<literal>INHERIT</literal>变体。要这样做，新的子表必须已经包括和父表相同名称和数据类型的列。子表还必须包括和父表相同的检查约束和检查表达式。相似地，一个继承链接也可以使用<command>ALTER TABLE</command>的 <literal>NO INHERIT</literal>变体从一个子表中移除。动态增加和移除继承链接可以用于实现表划分（见<xref linkend="ddl-partitioning"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   One convenient way to create a compatible table that will later be made
   a new child is to use the <literal>LIKE</literal> clause in <command>CREATE
   TABLE</command>. This creates a new table with the same columns as
   the source table. If there are any <literal>CHECK</literal>
   constraints defined on the source table, the <literal>INCLUDING
   CONSTRAINTS</literal> option to <literal>LIKE</literal> should be
   specified, as the new child must have constraints matching the parent
   to be considered compatible.
  </para>
____________________________________________________________________________-->
  <para>
   一种创建一个未来将被用做子女的新表的方法是在<command>CREATE
   TABLE</command>中使用<literal>LIKE</literal>子句。这将创建一个和源表具有相同列的新表。如果源表上定义有任何<literal>CHECK</literal>约束，<literal>LIKE</literal>的<literal>INCLUDING CONSTRAINTS</literal>选项可以用来让新的子表也包含和父表相同的约束。
  </para>

<!--==========================orignal english content==========================
  <para>
   A parent table cannot be dropped while any of its children remain. Neither
   can columns or check constraints of child tables be dropped or altered
   if they are inherited
   from any parent tables. If you wish to remove a table and all of its
   descendants, one easy way is to drop the parent table with the
   <literal>CASCADE</literal> option (see <xref linkend="ddl-depend"/>).
  </para>
____________________________________________________________________________-->
  <para>
   当有任何一个子表存在时，父表不能被删除。当子表的列或者检查约束继承于父表时，它们也不能被删除或修改。如果希望移除一个表和它的所有后代，一种简单的方法是使用<literal>CASCADE</literal>选项删除父表（见<xref linkend="ddl-depend"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <xref linkend="sql-altertable"/> will
   propagate any changes in column data definitions and check
   constraints down the inheritance hierarchy.  Again, dropping
   columns that are depended on by other tables is only possible when using
   the <literal>CASCADE</literal> option. <command>ALTER
   TABLE</command> follows the same rules for duplicate column merging
   and rejection that apply during <command>CREATE TABLE</command>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="sql-altertable"/>将会把列的数据定义或检查约束上的任何变化沿着继承层次向下传播。同样，删除被其他表依赖的列只能使用<literal>CASCADE</literal>选项。<command>ALTER TABLE</command>对于重名列的合并和拒绝遵循与<command>CREATE TABLE</command>同样的规则。
  </para>

<!--==========================orignal english content==========================
  <para>
   Inherited queries perform access permission checks on the parent table
   only.  Thus, for example, granting <literal>UPDATE</literal> permission on
   the <structname>cities</structname> table implies permission to update rows in
   the <structname>capitals</structname> table as well, when they are
   accessed through <structname>cities</structname>.  This preserves the appearance
   that the data is (also) in the parent table.  But
   the <structname>capitals</structname> table could not be updated directly
   without an additional grant.  In a similar way, the parent table's row
   security policies (see <xref linkend="ddl-rowsecurity"/>) are applied to
   rows coming from child tables during an inherited query.  A child table's
   policies, if any, are applied only when it is the table explicitly named
   in the query; and in that case, any policies attached to its parent(s) are
   ignored.
  </para>
____________________________________________________________________________-->
  <para>
   继承的查询仅在附表上执行访问权限检查。例如，在<structname>cities</structname>表上授予<literal>UPDATE</literal>权限也隐含着通过<structname>cities</structname>访问时在<structname>capitals</structname>表中更新行的权限。这保留了数据（也）在父表中的样子。但是如果没有额外的授权，则不能直接更新<structname>capitals</structname>表。以类似的方式，父表的行安全性策略（见<xref linkend="ddl-rowsecurity"/>）适用于继承查询期间来自于子表的行。只有当子表在查询中被明确提到时，其策略（如果有）才会被应用，在那种情况下，附着在其父表上的任何策略都会被忽略。
  </para>
  
<!--==========================orignal english content==========================
  <para>
   Foreign tables (see <xref linkend="ddl-foreign-data"/>) can also
   be part of inheritance hierarchies, either as parent or child
   tables, just as regular tables can be.  If a foreign table is part
   of an inheritance hierarchy then any operations not supported by
   the foreign table are not supported on the whole hierarchy either.
  </para>
____________________________________________________________________________-->
  <para>
   外部表（见<xref linkend="ddl-foreign-data"/>）也可以是继承层次
   中的一部分，即可以作为父表也可以作为子表，就像常规表一样。如果
   一个外部表是继承层次的一部分，那么任何不被该外部表支持的操作也
   不被整个层次所支持。
  </para>

 <sect2 id="ddl-inherit-caveats">
<!--==========================orignal english content==========================
  <title>Caveats</title>
____________________________________________________________________________-->
  <title>警告</title>

<!--==========================orignal english content==========================
  <para>
   Note that not all SQL commands are able to work on
   inheritance hierarchies.  Commands that are used for data querying,
   data modification, or schema modification
   (e.g., <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   most variants of <literal>ALTER TABLE</literal>, but
   not <literal>INSERT</literal> or <literal>ALTER TABLE ...
   RENAME</literal>) typically default to including child tables and
   support the <literal>ONLY</literal> notation to exclude them.
   Commands that do database maintenance and tuning
   (e.g., <literal>REINDEX</literal>, <literal>VACUUM</literal>)
   typically only work on individual, physical tables and do not
   support recursing over inheritance hierarchies.  The respective
   behavior of each individual command is documented in its reference
   page (<xref linkend="sql-commands"/>).
  </para>
____________________________________________________________________________-->
  <para>
   注意并非所有的SQL命令都能工作在继承层次上。用于数据查询、数据修改或模式修改（例如<literal>SELECT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、大部分<literal>ALTER TABLE</literal>的变体，但<literal>INSERT</literal>或<literal>ALTER TABLE ... RENAME</literal>不在此列）的命令会默认将子表包含在内并且支持<literal>ONLY</literal>记号来排除子表。负责数据库维护和调整的命令（如<literal>REINDEX</literal>、<literal>VACUUM</literal>）只工作在独立的、物理的表上并且不支持在继承层次上的递归。每个命令相应的行为请参见它们的参考页（<xref linkend="sql-commands"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   A serious limitation of the inheritance feature is that indexes (including
   unique constraints) and foreign key constraints only apply to single
   tables, not to their inheritance children. This is true on both the
   referencing and referenced sides of a foreign key constraint. Thus,
   in the terms of the above example:

   <itemizedlist>
    <listitem>
     <para>
      If we declared <structname>cities</structname>.<structfield>name</structfield> to be
      <literal>UNIQUE</literal> or a <literal>PRIMARY KEY</literal>, this would not stop the
      <structname>capitals</structname> table from having rows with names duplicating
      rows in <structname>cities</structname>.  And those duplicate rows would by
      default show up in queries from <structname>cities</structname>.  In fact, by
      default <structname>capitals</structname> would have no unique constraint at all,
      and so could contain multiple rows with the same name.
      You could add a unique constraint to <structname>capitals</structname>, but this
      would not prevent duplication compared to <structname>cities</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Similarly, if we were to specify that
      <structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal> some
      other table, this constraint would not automatically propagate to
      <structname>capitals</structname>.  In this case you could work around it by
      manually adding the same <literal>REFERENCES</literal> constraint to
      <structname>capitals</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Specifying that another table's column <literal>REFERENCES
      cities(name)</literal> would allow the other table to contain city names, but
      not capital names.  There is no good workaround for this case.
     </para>
    </listitem>
   </itemizedlist>

   These deficiencies will probably be fixed in some future release,
   but in the meantime considerable care is needed in deciding whether
   inheritance is useful for your application.
  </para>
____________________________________________________________________________-->
  <para>
   继承特性的一个严肃的限制是索引（包括唯一约束）和外键约束值应用在单个表上而非它们的继承子女。在外键约束的引用端和被引用端都是这样。因此，按照上面的例子：

   <itemizedlist>
    <listitem>
     <para>
      如果我们声明<structname>cities</structname>.<structfield>name</structfield>为<literal>UNIQUE</literal>或者<literal>PRIMARY KEY</literal>，这将不会阻止<structname>capitals</structname>表中拥有和<structname>cities</structname>中城市同名的行。而且这些重复的行将会默认显示在<structname>cities</structname>的查询中。事实上，<structname>capitals</structname>在默认情况下是根本不能拥有唯一约束的，并且因此能够包含多个同名的行。我们可以为<structname>capitals</structname>增加一个唯一约束，但这无法阻止相对于<structname>cities</structname>的重复。
     </para>
    </listitem>

    <listitem>
     <para>
      相似地，如果我们指定<structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal>某个其他表，该约束不会自动地传播到<structname>capitals</structname>。在此种情况下，我们可以变通地在<structname>capitals</structname>上手工创建一个相同的<literal>REFERENCES</literal>约束。
     </para>
    </listitem>

    <listitem>
     <para>
      指定另一个表的列<literal>REFERENCES cities(name)</literal>将允许其他表包含城市名称，但不会包含首府名称。这对于这个例子不是一个好的变通方案。
     </para>
    </listitem>
   </itemizedlist>

   这些不足可能还将存在于某些未来的发布中，但是同时在决定继承是否对我们的应用有用时需要相当小心。
  </para>

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
<!--==========================orignal english content==========================
   <title>Table Partitioning</title>
____________________________________________________________________________-->
   <title>表分区</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>partitioning</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>partitioning</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>partitioned table</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>partitioned table</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> supports basic table
    partitioning. This section describes why and how to implement
    partitioning as part of your database design.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持基本的表划分。本小节介绍为何以及怎样把划分实现为数据库设计的一部分。
   </para>

   <sect2 id="ddl-partitioning-overview">
<!--==========================orignal english content==========================
     <title>Overview</title>
____________________________________________________________________________-->
     <title>概述</title>

<!--==========================orignal english content==========================
   <para>
     Partitioning refers to splitting what is logically one large table into
     smaller physical pieces.  Partitioning can provide several benefits:
    <itemizedlist>
     <listitem>
      <para>
       Query performance can be improved dramatically in certain situations,
       particularly when most of the heavily accessed rows of the table are in a
       single partition or a small number of partitions.  The partitioning
       substitutes for leading columns of indexes, reducing index size and
       making it more likely that the heavily-used parts of the indexes
       fit in memory.
      </para>
     </listitem>

     <listitem>
      <para>
       When queries or updates access a large percentage of a single
       partition, performance can be improved by taking advantage
       of sequential scan of that partition instead of using an
       index and random access reads scattered across the whole table.
      </para>
     </listitem>

     <listitem>
      <para>
       Bulk loads and deletes can be accomplished by adding or removing
       partitions, if that requirement is planned into the partitioning design.
       Doing <command>ALTER TABLE DETACH PARTITION</command> or dropping an individual
       partition using <command>DROP TABLE</command> is far faster than a bulk
       operation.  These commands also entirely avoid the
       <command>VACUUM</command> overhead caused by a bulk <command>DELETE</command>.
      </para>
     </listitem>

     <listitem>
      <para>
       Seldom-used data can be migrated to cheaper and slower storage media.
      </para>
     </listitem>
    </itemizedlist>

     The benefits will normally be worthwhile only when a table would
     otherwise be very large. The exact point at which a table will
     benefit from partitioning depends on the application, although a
     rule of thumb is that the size of the table should exceed the physical
     memory of the database server.
    </para>
____________________________________________________________________________-->
   <para>
    划分指的是将逻辑上的一个大表分成一些小的物理上的片。划分有很多益处：
   <itemizedlist>
    <listitem>
     <para>
      在某些情况下查询性能能够显著提升，特别是当那些访问压力大的行在一个分区或者少数几个分区时。划分可以取代索引的主导列、减小索引尺寸以及使索引中访问压力大的部分更有可能被放在内存中。
     </para>
    </listitem>

    <listitem>
     <para>
      当查询或更新访问一个分区的大部分行时，可以通过该分区上的一个顺序扫描来取代分散到整个表上的索引和随机访问，这样可以改善性能。
     </para>
    </listitem>

    <listitem>
     <para>
      如果批量操作的需求是在分区设计时就规划好的，则批量装载和删除可以通过增加或者去除分区来完成。执行<command>ALTER TABLE DETACH PARTITION</command>或者使用<command>DROP TABLE</command>删除一个分区远快于批量操作。这些命令也完全避免了批量<command>DELETE</command>导致的<command>VACUUM</command>开销。
     </para>
    </listitem>

    <listitem>
     <para>
      很少使用的数据可以被迁移到便宜且较慢的存储介质上。
     </para>
    </listitem>
   </itemizedlist>

    当一个表非常大时，划分所带来的好处是非常值得的。一个表何种情况下会从划分获益取决于应用，一个经验法则是当表的尺寸超过了数据库服务器物理内存时，划分会为表带来好处。
   </para>

<!--==========================orignal english content==========================
   <para>
     <productname>PostgreSQL</productname> offers built-in support for the
     following forms of partitioning:

     <variablelist>
      <varlistentry>
       <term>Range Partitioning</term>

       <listitem>
        <para>
         The table is partitioned into <quote>ranges</quote> defined
         by a key column or set of columns, with no overlap between
         the ranges of values assigned to different partitions.  For
         example, one might partition by date ranges, or by ranges of
         identifiers for particular business objects.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>List Partitioning</term>

       <listitem>
        <para>
         The table is partitioned by explicitly listing which key values
         appear in each partition.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Hash Partitioning</term>

       <listitem>
        <para>
         The table is partitioned by specifying a modulus and a remainder for
         each partition. Each partition will hold the rows for which the hash
         value of the partition key divided by the specified modulus will
         produce the specified remainder.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     If your application needs to use other forms of partitioning not listed
     above, alternative methods such as inheritance and
     <literal>UNION ALL</literal> views can be used instead.  Such methods
     offer flexibility but do not have some of the performance benefits
     of built-in declarative partitioning.
    </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>对下列分区形式提供了内建支持：

    <variablelist>
     <varlistentry>
      <term>范围划分</term>

      <listitem>
       <para>
        表被根据一个关键列或一组列划分为<quote>范围</quote>，不同的分区的范围之间没有重叠。例如，我们可以根据日期范围划分，或者根据特定业务对象的标识符划分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>列表划分</term>

      <listitem>
       <para>
        通过显式地列出每一个分区中出现的键值来划分表。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
       <term>哈希分区</term>

       <listitem>
        <para>
         通过为每个分区指定模数和余数来对表进行分区。每个分区所持有的行都满足：分区键的值除以为其指定的模数将产生为其指定的余数。
        </para>
       </listitem>
      </varlistentry>
    </variablelist>

    如果你的应用需要使用上面所列之外的分区形式，可以使用诸如继承和<literal>UNION ALL</literal>视图之类的替代方法。这些方法很灵活，但是却缺少内建声明式分区的一些性能优势。
   </para>
   </sect2>

   <sect2 id="ddl-partitioning-declarative">
<!--==========================orignal english content==========================
     <title>Declarative Partitioning</title>
____________________________________________________________________________-->
     <title>声明式划分</title>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> offers a way to specify how to
    divide a table into pieces called partitions.  The table that is divided
    is referred to as a <firstterm>partitioned table</firstterm>.  The
    specification consists of the <firstterm>partitioning method</firstterm>
    and a list of columns or expressions to be used as the
    <firstterm>partition key</firstterm>.
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了一种方法指定如何把一个表划分成称为分区的片段。被划分的表被称作<firstterm>分区表</firstterm>。这种说明由<firstterm>分区方法</firstterm>以及要被用作<firstterm>分区键</firstterm>的列或者表达式列表组成。
   </para>

<!--==========================orignal english content==========================
   <para>
    All rows inserted into a partitioned table will be routed to one of the
    <firstterm>partitions</firstterm> based on the value of the partition
    key.  Each partition has a subset of the data defined by its
    <firstterm>partition bounds</firstterm>.  The currently supported
    partitioning methods are range, list, and hash.
   </para>
____________________________________________________________________________-->
   <para>
    所有被插入到分区表的行将被基于分区键的值路由到<firstterm>分区</firstterm>中。每个分区都有一个由其<firstterm>分区边界</firstterm>定义的数据子集。当前支持的分区方法是范围、列表以及哈希。
   </para>

<!--==========================orignal english content==========================
   <para>
    Partitions may themselves be defined as partitioned tables, using what is
    called <firstterm>sub-partitioning</firstterm>.  Partitions may have their
    own indexes, constraints and default values, distinct from those of other
    partitions.  See <xref linkend="sql-createtable"/> for more details on
    creating partitioned tables and partitions.
   </para>
____________________________________________________________________________-->
   <para>
    分区本身也可能被定义为分区表，这种用法被称为<firstterm>子分区</firstterm>。分区可以有自己的与其他分区不同的索引、约束以及默认值。创建分区表及分区的更多细节请见<xref linkend="sql-createtable"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is not possible to turn a regular table into a partitioned table or
    vice versa.  However, it is possible to add a regular or partitioned table
    containing data as a partition of a partitioned table, or remove a
    partition from a partitioned table turning it into a standalone table;
    see <xref linkend="sql-altertable"/> to learn more about the
    <command>ATTACH PARTITION</command> and <command>DETACH PARTITION</command>
    sub-commands.
   </para>
____________________________________________________________________________-->
   <para>
    无法把一个常规表转换成分区表，反之亦然。不过，可以把一个包含数据的常规表或者分区表作为分区加入到另一个分区表，或者从分区表中移走一个分区并且把它变成一个独立的表。有关<command>ATTACH PARTITION</command>和<command>DETACH PARTITION</command>子命令的内容请见<xref linkend="sql-altertable"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Individual partitions are linked to the partitioned table with inheritance
    behind-the-scenes; however, it is not possible to use some of the
    generic features of inheritance (discussed below) with declaratively
    partitioned tables or their partitions.  For example, a partition
    cannot have any parents other than the partitioned table it is a
    partition of, nor can a regular table inherit from a partitioned table
    making the latter its parent.  That means partitioned tables and their
    partitions do not participate in inheritance with regular tables.
    Since a partition hierarchy consisting of the partitioned table and its
    partitions is still an inheritance hierarchy, all the normal rules of
    inheritance apply as described in <xref linkend="ddl-inherit"/> with
    some exceptions, most notably:

    <itemizedlist>
     <listitem>
      <para>
       Both <literal>CHECK</literal> and <literal>NOT NULL</literal>
       constraints of a partitioned table are always inherited by all its
       partitions.  <literal>CHECK</literal> constraints that are marked
       <literal>NO INHERIT</literal> are not allowed to be created on
       partitioned tables.
      </para>
     </listitem>

     <listitem>
      <para>
       Using <literal>ONLY</literal> to add or drop a constraint on only the
       partitioned table is supported as long as there are no partitions.  Once
       partitions exist, using <literal>ONLY</literal> will result in an error
       as adding or dropping constraints on only the partitioned table, when
       partitions exist, is not supported.  Instead, constraints on the
       partitions themselves can be added and (if they are not present in the
       parent table) dropped.
      </para>
     </listitem>

     <listitem>
      <para>
       As a partitioned table does not have any data directly, attempts to use
       <command>TRUNCATE</command> <literal>ONLY</literal> on a partitioned
       table will always return an error.
      </para>
     </listitem>

     <listitem>
      <para>
       Partitions cannot have columns that are not present in the parent.  It
       is not possible to specify columns when creating partitions with
       <command>CREATE TABLE</command>, nor is it possible to add columns to
       partitions after-the-fact using <command>ALTER TABLE</command>.  Tables may be
       added as a partition with <command>ALTER TABLE ... ATTACH PARTITION</command>
       only if their columns exactly match the parent, including any
       <literal>oid</literal> column.
      </para>
     </listitem>

     <listitem>
      <para>
       You cannot drop the <literal>NOT NULL</literal> constraint on a
       partition's column if the constraint is present in the parent table.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    个体分区在内部以继承的方式链接到分区表，不过无法对声明式分区表或其分区使用继承的某些一般特性（下文讨论）。例如，分区不能有除其所属分区表之外的父表，一个常规表也不能从分区表继承使得后者成为其父表。这意味着分区表及其分区不会参与到与常规表的继承关系中。由于分区表及其分区组成的分区层次仍然是一种继承层次，所有<xref linkend="ddl-inherit"/>中所述的继承的普通规则也适用，不过有一些例外，尤其是：

    <itemizedlist>
      <listitem>
      <para>
       分区表的<literal>CHECK</literal>约束和<literal>NOT NULL</literal>约束总是会被其所有的分区所继承。不允许在分区表上创建标记为<literal>NO INHERIT</literal>的<literal>CHECK</literal>约束。
      </para>
     </listitem>

     <listitem>
      <para>
       只要分区表中不存在分区，则支持使用<literal>ONLY</literal>仅在分区表上增加或者删除约束。一旦分区存在，那样做就会导致错误，因为当分区存在时是不支持仅在分区表上增加或删除约束的。不过，分区表本身上的约束可以被增加（如果它们不出现在父表中）和删除。
      </para>
     </listitem>

     <listitem>
      <para>
       由于分区表并不直接拥有任何数据，尝试在分区表上使用<command>TRUNCATE</command> <literal>ONLY</literal>将总是返回错误。
      </para>
     </listitem>

     <listitem>
      <para>
       分区不能有在父表中不存在的列。在使用<command>CREATE TABLE</command>创建分区时不能指定列，在事后使用<command>ALTER TABLE</command>时也不能为分区增加列。只有当表的列正好匹配父表时（包括任何<literal>oid</literal>列），才能使用<command>ALTER TABLE ... ATTACH PARTITION</command>将它作为分区加入。
      </para>
     </listitem>

     <listitem>
      <para>
       如果<literal>NOT NULL</literal>约束在父表中存在，那么就不能删除分区的列上的对应的<literal>NOT NULL</literal>约束。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Partitions can also be foreign tables, although they have some limitations
    that normal tables do not; see <xref linkend="sql-createforeigntable"/> for
    more information.
   </para>
____________________________________________________________________________-->
   <para>
    分区也可以是外部表，不过它们有一些普通表没有的限制，详情请见<xref linkend="sql-createforeigntable"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Updating the partition key of a row might cause it to be moved into a
    different partition where this row satisfies the partition bounds.
   </para>
____________________________________________________________________________-->
   <para>
    更新行的分区键可能导致它满足另一个不同的分区的分区边界，进而被移动到那个分区中。
   </para>

   <sect3 id="ddl-partitioning-declarative-example">
<!--==========================orignal english content==========================
    <title>Example</title>
____________________________________________________________________________-->
    <title>例子</title>

<!--==========================orignal english content==========================
   <para>
    Suppose we are constructing a database for a large ice cream company.
    The company measures peak temperatures every day as well as ice cream
    sales in each region. Conceptually, we want a table like:

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

    We know that most queries will access just the last week's, month's or
    quarter's data, since the main use of this table will be to prepare
    online reports for management.  To reduce the amount of old data that
    needs to be stored, we decide to only keep the most recent 3 years
    worth of data. At the beginning of each month we will remove the oldest
    month's data.  In this situation we can use partitioning to help us meet
    all of our different requirements for the measurements table.
   </para>
____________________________________________________________________________-->
   <para>
    假定我们正在为一个大型的冰激凌公司构建数据库。该公司每天测量最高温度以及每个区域的冰激凌销售情况。概念上，我们想要一个这样的表：

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

    我们知道大部分查询只会访问上周的、上月的或者上季度的数据，因为这个表的主要用途是为管理层准备在线报告。为了减少需要被存放的旧数据量，我们决定只保留最近3年的数据。在每个月的开始我们将去除掉最早的那个月的数据。在这种情况下我们可以使用分区技术来帮助我们满足对measurement表的所有不同需求。
   </para>

<!--==========================orignal english content==========================
   <para>
    To use declarative partitioning in this case, use the following steps:

    <orderedlist spacing="compact">
     <listitem>
      <para>
       Create <structname>measurement</structname> table as a partitioned
       table by specifying the <literal>PARTITION BY</literal> clause, which
       includes the partitioning method (<literal>RANGE</literal> in this
       case) and the list of column(s) to use as the partition key.

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>

      <para>
       You may decide to use multiple columns in the partition key for range
       partitioning, if desired.  Of course, this will often result in a larger
       number of partitions, each of which is individually smaller.  On the
       other hand, using fewer columns may lead to a coarser-grained
       partitioning criteria with smaller number of partitions.  A query
       accessing the partitioned table will have to scan fewer partitions if
       the conditions involve some or all of these columns.
       For example, consider a table range partitioned using columns
       <structfield>lastname</structfield> and <structfield>firstname</structfield> (in that order)
       as the partition key.
      </para>
     </listitem>

     <listitem>
      <para>
       Create partitions.  Each partition's definition must specify the bounds
       that correspond to the partitioning method and partition key of the
       parent.  Note that specifying bounds such that the new partition's
       values will overlap with those in one or more existing partitions will
       cause an error.  Inserting data into the parent table that does not map
       to one of the existing partitions will cause an error; an appropriate
       partition must be added manually.
      </para>

      <para>
       Partitions thus created are in every way normal
       <productname>PostgreSQL</productname>
       tables (or, possibly, foreign tables).  It is possible to specify a
       tablespace and storage parameters for each partition separately.
      </para>

      <para>
       It is not necessary to create table constraints describing partition
       boundary condition for partitions.  Instead, partition constraints are
       generated implicitly from the partition bound specification whenever
       there is need to refer to them.

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting>
      </para>

      <para>
       To implement sub-partitioning, specify the
       <literal>PARTITION BY</literal> clause in the commands used to create
       individual partitions, for example:

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       After creating partitions of <structname>measurement_y2006m02</structname>,
       any data inserted into <structname>measurement</structname> that is mapped to
       <structname>measurement_y2006m02</structname> (or data that is directly inserted
       into <structname>measurement_y2006m02</structname>, provided it satisfies its
       partition constraint) will be further redirected to one of its
       partitions based on the <structfield>peaktemp</structfield> column.  The partition
       key specified may overlap with the parent's partition key, although
       care should be taken when specifying the bounds of a sub-partition
       such that the set of data it accepts constitutes a subset of what
       the partition's own bounds allows; the system does not try to check
       whether that's really the case.
      </para>
     </listitem>

     <listitem>
      <para>
       Create an index on the key column(s), as well as any other indexes you
       might want, on the partitioned table. (The key index is not strictly
       necessary, but in most scenarios it is helpful.)
       This automatically creates
       one index on each partition, and any partitions you create or attach
       later will also contain the index.

<programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
      </para>
     </listitem>

      <listitem>
       <para>
        Ensure that the <xref linkend="guc-enable-partition-pruning"/>
        configuration parameter is not disabled in <filename>postgresql.conf</filename>.
        If it is, queries will not be optimized as desired.
       </para>
      </listitem>
    </orderedlist>
   </para>
____________________________________________________________________________-->
   <para>
    要在这种情况下使用声明式分区，可采用下面的步骤：

    <orderedlist spacing="compact">
     <listitem>
      <para>
       通过指定<literal>PARTITION BY</literal>子句把<structname>measurement</structname>表创建为分区表，该子句包括分区方法（这个例子中是<literal>RANGE</literal>）以及用作分区键的列列表。

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>

      <para>
       你可能需要决定在分区键中使用多列进行范围分区。当然，这通常会导致较大数量的分区，其中每一个个体都比较小。另一方面，使用较少的列可能会导致粗粒度的分区策略得到较少数量的分区。如果条件涉及这些列中的一部分或者全部，访问分区表的查询将不得不扫描较少的分区。例如，考虑一个使用列<structfield>lastname</structfield>和<structfield>firstname</structfield>（按照这样的顺序）作为分区键进行范围分区的表。
      </para>
     </listitem>

     <listitem>
      <para>
       创建分区。每个分区的定义必须指定对应于父表的分区方法和分区键的边界。注意，如果指定的边界使得新分区的值会与已有分区中的值重叠，则会导致错误。向父表中插入无法映射到任何现有分区的数据将会导致错误，这种情况下应该手工增加一个合适的分区。
      </para>

      <para>
       分区以普通<productname>PostgreSQL</productname>表（或者可能是外部表）的方式创建。可以为每个分区单独指定表空间和存储参数。
      </para>

      <para>
       没有必要创建表约束来描述分区的分区边界条件。相反，只要需要引用分区约束时，分区约束会自动地隐式地从分区边界说明中生成。

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting>
      </para>

      <para>
       为了实现子分区，在创建分区的命令中指定<literal>PARTITION BY</literal>子句，例如：

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       在创建了<structname>measurement_y2006m02</structname>的分区之后，任何被插入到<structname>measurement</structname>中且被映射到<structname>measurement_y2006m02</structname>的数据（或者直接被插入到<structname>measurement_y2006m02</structname>的数据，假定它满足这个分区的分区约束）将被基于<structfield>peaktemp</structfield>列进一步重定向到<structname>measurement_y2006m02</structname>的一个分区。指定的分区键可以与父亲的分区键重叠，不过在指定子分区的边界时要注意它接受的数据集合是分区自身边界允许的数据集合的一个子集，系统不会尝试检查事情情况是否如此。
      </para>
     </listitem>

     <listitem>
      <para>
       在分区表的键列上创建一个索引，还有其他需要的索引（键索引并不是必需的，但是大部分场景中它都能很有帮助）。这会自动在每个分区上创建一个索引，并且后来创建或者附着的任何分区也将会包含索引。

<programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
      </para>
     </listitem>

      <listitem>
       <para>
        确保<xref linkend="guc-enable-partition-pruning"/>配置参数在<filename>postgresql.conf</filename>中没有被禁用。如果被禁用，查询将不会按照想要的方式被优化。
       </para>
      </listitem>
    </orderedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    In the above example we would be creating a new partition each month, so
    it might be wise to write a script that generates the required DDL
    automatically.
   </para>
____________________________________________________________________________-->
   <para>
    在上面的例子中，我们会每个月创建一个新分区，因此写一个脚本来自动生成所需的DDL会更好。
   </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-maintenance">
<!--==========================orignal english content==========================
    <title>Partition Maintenance</title>
____________________________________________________________________________-->
    <title>分区维护</title>

<!--==========================orignal english content==========================
    <para>
      Normally the set of partitions established when initially defining the
      table are not intended to remain static.  It is common to want to
      remove old partitions of data and periodically add new partitions for
      new data. One of the most important advantages of partitioning is
      precisely that it allows this otherwise painful task to be executed
      nearly instantaneously by manipulating the partition structure, rather
      than physically moving large amounts of data around.
    </para>
____________________________________________________________________________-->
    <para>
      通常在初始定义分区表时建立的分区并非保持静态不变。移除旧分区的数据并且为新数据周期性地增加新分区的需求比比皆是。分区的最大好处之一就是可以通过操纵分区结构来近乎瞬时地执行这类让人头痛的任务，而不是物理地去除大量数据。
    </para>

<!--==========================orignal english content==========================
    <para>
     The simplest option for removing old data is to drop the partition that
     is no longer necessary:
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     This can very quickly delete millions of records because it doesn't have
     to individually delete every record.  Note however that the above command
     requires taking an <literal>ACCESS EXCLUSIVE</literal> lock on the parent
     table.
    </para>
____________________________________________________________________________-->
    <para>
     移除旧数据最简单的选择是删除掉不再需要的分区：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     这可以非常快地删除数百万行记录，因为它不需要逐个删除每个记录。不过要注意上面的命令需要在父表上拿到<literal>ACCESS EXCLUSIVE</literal>锁。
    </para>

<!--==========================orignal english content==========================
   <para>
     Another option that is often preferable is to remove the partition from
     the partitioned table but retain access to it as a table in its own
     right:

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
</programlisting>

     This allows further operations to be performed on the data before
     it is dropped. For example, this is often a useful time to back up
     the data using <command>COPY</command>, <application>pg_dump</application>, or
     similar tools. It might also be a useful time to aggregate data
     into smaller formats, perform other data manipulations, or run
     reports.
   </para>
____________________________________________________________________________-->
   <para>
     另一种通常更好的选项是把分区从分区表中移除，但是保留它作为一个独立的表：

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
</programlisting>

     这允许在它被删除之前在其数据上执行进一步的操作。例如，这通常是一种使用<command>COPY</command>、<application>pg_dump</application>或类似工具备份数据的好时候。这也是把数据聚集成较小的格式、执行其他数据操作或者运行报表的好时机。
   </para>

<!--==========================orignal english content==========================
   <para>
     Similarly we can add a new partition to handle new data. We can create an
     empty partition in the partitioned table just as the original partitions
     were created above:

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     As an alternative, it is sometimes more convenient to create the
     new table outside the partition structure, and make it a proper
     partition later. This allows the data to be loaded, checked, and
     transformed prior to it appearing in the partitioned table:

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-&minus; possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>
____________________________________________________________________________-->
   <para>
     类似地，我们可以增加一个新分区来处理新数据。我们可以在分区表中创建一个空分区，就像上面创建的初始分区那样：

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     另外一种选择是，有时候在分区结构之外创建新表更加方便，然后将它作为一个合适的分区。这允许先对数据进行装载、检查和转换，然后再让它们出现在分区表中：

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Before running the <command>ATTACH PARTITION</command> command, it is
     recommended to create a <literal>CHECK</literal> constraint on the table to
     be attached describing the desired partition constraint.  That way,
     the system will be able to skip the scan to validate the implicit
     partition constraint. Without such a constraint, the table will be
     scanned to validate the partition constraint while holding an
     <literal>ACCESS EXCLUSIVE</literal> lock on the parent table.
     One may then drop the constraint after <command>ATTACH PARTITION</command>
     is finished, because it is no longer necessary.
    </para>
____________________________________________________________________________-->
    <para>
     在运行<command>ATTACH PARTITION</command>命令之前，推荐在要被挂接的表上创建一个<literal>CHECK</literal>约束来描述想要的分区约束。采用这种方法，系统将能够跳过验证隐式分区约束的扫描。如果没有这样一个约束，则将会扫描表来验证分区约束，其间会持有一个父表上的<literal>ACCESS EXCLUSIVE</literal>锁。人们可能在<command>ATTACH PARTITION</command>完成之后删除该约束，因为之后就不再需要它了。
    </para>
   </sect3>

   <sect3 id="ddl-partitioning-declarative-limitations">
<!--==========================orignal english content==========================
    <title>Limitations</title>
____________________________________________________________________________-->
    <title>限制</title>

<!--==========================orignal english content==========================
   <para>
    The following limitations apply to partitioned tables:
    <itemizedlist>
     <listitem>
      <para>
       There is no way to create an
       exclusion constraint spanning all partitions; it is only possible
       to constrain each leaf partition individually.
      </para>
     </listitem>

     <listitem>
      <para>
       While primary keys are supported on partitioned tables, foreign
       keys referencing partitioned tables are not supported.  (Foreign key
       references from a partitioned table to some other table are supported.)
      </para>
     </listitem>

     <listitem>
      <para>
       When an <command>UPDATE</command> causes a row to move from one
       partition to another, there is a chance that another concurrent
       <command>UPDATE</command> or <command>DELETE</command> will get a
       serialization failure error.  Suppose session 1 is performing an
       <command>UPDATE</command> on a partition key, and meanwhile a concurrent
       session 2 for which this row is visible performs an
       <command>UPDATE</command> or <command>DELETE</command> operation on this
       row.  In such case, session 2's <command>UPDATE</command> or
       <command>DELETE</command>, will detect the row movement and raise a
       serialization failure error (which always returns with an SQLSTATE code
       '40001').  Applications may wish to retry the transaction if this
       occurs.  In the usual case where the table is not partitioned, or where
       there is no row movement, session 2 would have identified the newly
       updated row and carried out the
       <command>UPDATE</command>/<command>DELETE</command> on this new row
       version.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>BEFORE ROW</literal> triggers, if necessary, must be defined
       on individual partitions, not the partitioned table.
      </para>
     </listitem>

     <listitem>
      <para>
       Mixing temporary and permanent relations in the same partition tree is
       not allowed.  Hence, if the partitioned table is permanent, so must be
       its partitions and likewise if the partitioned table is temporary.  When
       using temporary relations, all members of the partition tree have to be
       from the same session.
      </para>
     </listitem>
    </itemizedlist>
    </para>
____________________________________________________________________________-->
   <para>
    分区表有下列限制：
    <itemizedlist>
     <listitem>
      <para>
       没有办法创建跨越所有分区的排除约束，只可能单个约束每个叶子分区。
      </para>
     </listitem>

     <listitem>
      <para>
       虽然在分区表上支持主键，但引用分区表的外键不受支持（但支持从分区表到某个其他表的外键引用）。
      </para>
     </listitem>

     <listitem>
      <para>
       当一个<command>UPDATE</command>导致一行从一个分区移动到另一个分区时，另一个并发的<command>UPDATE</command>或<command>DELETE</command>可能会产生一个串行化错误。假设会话1正在执行一个分区键上的<command>UPDATE</command>，同时一个并发的能看见这个行的会话2执行了对该行的<command>UPDATE</command>或者<command>DELETE</command>操作。在这种情况下，会话2的<command>UPDATE</command>或者<command>DELETE</command>会检测到行的移动，并抛出一个串行化的错误(将总是会返回一个SQLSTATE '40001')。
      如果发生这种情况，应用程序可能希望重试该事务。 在没有分区表或没有行移动的通常情况下，
      会话2将识别新更新的行并在新行上执行<command>UPDATE</command>/<command>DELETE</command>。
      </para>
     </listitem>

     <listitem>
      <para>
       如果必要，必须在个体分区上定义<literal>BEFORE ROW</literal>触发器，分区表上不需要。
      </para>
     </listitem>

     <listitem>
      <para>
       不允许在同一个分区树中混杂临时关系和持久关系。因此，如果分区表是持久的，则其分区也必须是持久的，反之亦然。在使用临时关系时，分区数的所有成员都必须来自于同一个会话。
      </para>
     </listitem>
    </itemizedlist>
    </para>
    </sect3>
   </sect2>

   <sect2 id="ddl-partitioning-implementation-inheritance">
<!--==========================orignal english content==========================
    <title>Implementation Using Inheritance</title>
____________________________________________________________________________-->
    <title>使用继承实现</title>
<!--==========================orignal english content==========================
    <para>
     While the built-in declarative partitioning is suitable for most
     common use cases, there are some circumstances where a more flexible
     approach may be useful.  Partitioning can be implemented using table
     inheritance, which allows for several features not supported
     by declarative partitioning, such as:

     <itemizedlist>
      <listitem>
       <para>
        For declarative partitioning, partitions must have exactly the same set
        of columns as the partitioned table, whereas with table inheritance,
        child tables may have extra columns not present in the parent.
       </para>
      </listitem>

      <listitem>
       <para>
        Table inheritance allows for multiple inheritance.
       </para>
      </listitem>

      <listitem>
       <para>
        Declarative partitioning only supports range, list and hash
        partitioning, whereas table inheritance allows data to be divided in a
        manner of the user's choosing.  (Note, however, that if constraint
        exclusion is unable to prune child tables effectively, query performance
        might be poor.)
       </para>
      </listitem>

      <listitem>
       <para>
        Some operations require a stronger lock when using declarative
        partitioning than when using table inheritance.  For example, adding
        or removing a partition to or from a partitioned table requires taking
        an <literal>ACCESS EXCLUSIVE</literal> lock on the parent table,
        whereas a <literal>SHARE UPDATE EXCLUSIVE</literal> lock is enough
        in the case of regular inheritance.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     虽然内建的声明式分区适合于大部分常见的用例，但还是有一些场景需要更加灵活的方法。分区可以使用表继承来实现，这能够带来一些声明式分区不支持的特性，例如：

     <itemizedlist>
      <listitem>
       <para>
        对声明式分区来说，分区必须具有和分区表正好相同的列集合，而在表继承中，子表可以有父表中没有出现过的额外列。
       </para>
      </listitem>

      <listitem>
       <para>
        表继承允许多继承。
       </para>
      </listitem>

      <listitem>
       <para>
        声明式分区仅支持范围、列表以及哈希分区，而表继承允许数据按照用户的选择来划分（不过注意，如果约束排除不能有效地剪枝子表，查询性能可能会很差）。
       </para>
      </listitem>

      <listitem>
       <para>
        在使用声明式分区时，一些操作比使用表继承时要求更长的持锁时间。例如，向分区表中增加分区或者从分区表移除分区要求在父表上取得一个<literal>ACCESS EXCLUSIVE</literal>锁，而在常规继承的情况下一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁就足够了。
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <sect3 id="ddl-partitioning-inheritance-example">
<!--==========================orignal english content==========================
     <title>Example</title>
____________________________________________________________________________-->
     <title>例子</title>

<!--==========================orignal english content==========================
     <para>
      We use the same <structname>measurement</structname> table we used
      above.  To implement partitioning using inheritance, use
      the following steps:

      <orderedlist spacing="compact">
       <listitem>
        <para>
         Create the <quote>master</quote> table, from which all of the
         <quote>child</quote> tables will inherit.  This table will contain no data.  Do not
         define any check constraints on this table, unless you intend them
         to be applied equally to all child tables.  There is no point in
         defining any indexes or unique constraints on it, either.  For our
         example, the master table is the <structname>measurement</structname>
         table as originally defined.
        </para>
       </listitem>

       <listitem>
        <para>
         Create several <quote>child</quote> tables that each inherit from
         the master table.  Normally, these tables will not add any columns
         to the set inherited from the master.  Just as with declarative
         partitioning, these tables are in every way normal
         <productname>PostgreSQL</productname> tables (or foreign tables).
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Add non-overlapping table constraints to the child tables to
         define the allowed key values in each.
        </para>

        <para>
         Typical examples would be:
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
         Ensure that the constraints guarantee that there is no overlap
         between the key values permitted in different child tables.  A common
         mistake is to set up range constraints like:
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         This is wrong since it is not clear which child table the key
         value 200 belongs in.
        </para>

        <para>
         It would be better to instead create child tables as follows:

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         For each child table, create an index on the key column(s),
         as well as any other indexes you might want.
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         We want our application to be able to say <literal>INSERT INTO
         measurement ...</literal> and have the data be redirected into the
         appropriate child table.  We can arrange that by attaching
         a suitable trigger function to the master table.
         If data will be added only to the latest child, we can
         use a very simple trigger function:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
         After creating the function, we create a trigger which
         calls the trigger function:

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>

         We must redefine the trigger function each month so that it always
         points to the current child table.  The trigger definition does
         not need to be updated, however.
        </para>

        <para>
         We might want to insert data and have the server automatically
         locate the child table into which the row should be added. We
         could do this with a more complex trigger function, for example:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

         The trigger definition is the same as before.
         Note that each <literal>IF</literal> test must exactly match the
         <literal>CHECK</literal> constraint for its child table.
        </para>

        <para>
         While this function is more complex than the single-month case,
         it doesn't need to be updated as often, since branches can be
         added in advance of being needed.
        </para>

        <note>
         <para>
          In practice, it might be best to check the newest child first,
          if most inserts go into that child.  For simplicity, we have
          shown the trigger's tests in the same order as in other parts
          of this example.
         </para>
        </note>

        <para>
         A different approach to redirecting inserts into the appropriate
         child table is to set up rules, instead of a trigger, on the
         master table.  For example:

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

         A rule has significantly more overhead than a trigger, but the
         overhead is paid once per query rather than once per row, so this
         method might be advantageous for bulk-insert situations.  In most
         cases, however, the trigger method will offer better performance.
        </para>

        <para>
         Be aware that <command>COPY</command> ignores rules.  If you want to
         use <command>COPY</command> to insert data, you'll need to copy into the
         correct child table rather than directly into the master. <command>COPY</command>
         does fire triggers, so you can use it normally if you use the trigger
         approach.
        </para>

        <para>
         Another disadvantage of the rule approach is that there is no simple
         way to force an error if the set of rules doesn't cover the insertion
         date; the data will silently go into the master table instead.
        </para>
       </listitem>

       <listitem>
        <para>
         Ensure that the <xref linkend="guc-constraint-exclusion"/>
         configuration parameter is not disabled in
         <filename>postgresql.conf</filename>; otherwise
         child tables may be accessed unnecessarily.
        </para>
       </listitem>
      </orderedlist>
     </para>
____________________________________________________________________________-->
     <para>
      我们使用上面用过的同一个<structname>measurement</structname>表。为了使用继承实现分区，可使用下面的步骤：

      <orderedlist spacing="compact">
       <listitem>
        <para>
         创建<quote>主</quote>表，所有的<quote>子</quote>表都将从它继承。这个表将不包含数据。不要在这个表上定义任何检查约束，除非想让它们应用到所有的子表上。同样，在这个表上定义索引或者唯一约束也没有意义。对于我们的例子来说，主表是最初定义的<structname>measurement</structname>表。
        </para>
       </listitem>

       <listitem>
        <para>
         创建数个<quote>子</quote>表，每一个都从主表继承。通常，这些表将不会在从主表继承的列集合之外增加任何列。正如声明性分区那样，这些表就是普通的<productname>PostgreSQL</productname>表（或者外部表）。
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         为子表增加不重叠的表约束来定义每个分区允许的键值。
        </para>

        <para>
         典型的例子是：
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
         确保约束能保证不同子表允许的键值之间没有重叠。设置范围约束的常见错误：
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         这是错误的，因为不清楚键值200属于哪一个子表。
        </para>

        <para>
         像下面这样创建子表会更好：

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         对于每个子表，在键列上创建一个索引，以及任何想要的其他索引。
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         我们希望我们的应用能够使用<literal>INSERT INTO measurement ...</literal>并且数据将被重定向到合适的分区表。我们可以通过为主表附加一个合适的触发器函数来实现这一点。如果数据将只被增加到最后一个分区，我们可以使用一个非常简单的触发器函数：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
         完成函数创建后，我们创建一个调用该触发器函数的触发器：

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>

         我们必须在每个月重新定义触发器函数，这样它才会总是指向当前的子表。而触发器的定义则不需要被更新。
        </para>

        <para>
         我们也可能希望插入数据时服务器会自动地定位应该加入数据的子表。我们可以通过一个更复杂的触发器函数来实现之，例如：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

         触发器的定义和以前一样。注意每一个<literal>IF</literal>测试必须准确地匹配它的子表的<literal>CHECK</literal>约束。
        </para>

        <para>
         当该函数比单月形式更加复杂时，并不需要频繁地更新它，因为可以在需要的时候提前加入分支。
        </para>

       <note>
        <para>
         在实践中，如果大部分插入都会进入最新的子表，最好先检查它。为了简洁，我们为触发器的检查采用了和本例中其他部分一致的顺序。
        </para>
       </note>

       <para>
         把插入重定向到一个合适的子表中的另一种不同方法是在主表上设置规则而不是触发器。例如：

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

         规则的开销比触发器大很多，但是这种开销是每个查询只有一次，而不是每行一次，因此这种方法可能对批量插入的情况有优势。不过，在大部分情况下，触发器方法将提供更好的性能。
        </para>

        <para>
         注意<command>COPY</command>会忽略规则。如果想要使用<command>COPY</command>插入数据，则需要拷贝到正确的子表而不是直接放在主表中。<command>COPY</command>会引发触发器，因此在使用触发器方法时可以正常使用它。
        </para>

        <para>
         规则方法的另一个缺点是，如果规则集合无法覆盖插入日期，则没有简单的方法能够强制产生错误，数据将会无声无息地进入到主表中。
        </para>
       </listitem>

       <listitem>
        <para>
         确认<xref linkend="guc-constraint-exclusion"/>配置参数在<filename>postgresql.conf</filename>中没有被禁用，否则将会不必要地访问子表。
        </para>
       </listitem>
      </orderedlist>
     </para>

<!--==========================orignal english content==========================
     <para>
      As we can see, a complex table hierarchy could require a
      substantial amount of DDL.  In the above example we would be creating
      a new child table each month, so it might be wise to write a script that
      generates the required DDL automatically.
     </para>
____________________________________________________________________________-->
     <para>
      如我们所见，一个复杂的表层次可能需要大量的DDL。在上面的例子中，我们可能为每个月创建一个新的子表，因此编写一个脚本来自动生成所需要的DDL可能会更好。
     </para>
    </sect3>

    <sect3 id="ddl-partitioning-inheritance-maintenance">
<!--==========================orignal english content==========================
     <title>Maintenance for Inheritance Partitioning</title>
____________________________________________________________________________-->
     <title>继承分区的维护</title>
<!--==========================orignal english content==========================
     <para>
      To remove old data quickly, simply drop the child table that is no longer
      necessary:
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要快速移除旧数据，只需要简单地去掉不再需要的子表：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>

<!--==========================orignal english content==========================
    <para>
     To remove the child table from the inheritance hierarchy table but retain access to
     it as a table in its own right:

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要从继承层次表中去掉子表，但还是把它当做一个表保留：

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     To add a new child table to handle new data, create an empty child table
     just as the original children were created above:

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     Alternatively, one may want to create and populate the new child table
     before adding it to the table hierarchy.  This could allow data to be
     loaded, checked, and transformed before being made visible to queries on
     the parent table.

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-&minus; possibly some other data preparation work
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     要增加一个新子表来处理新数据，可以像上面创建的原始子表那样创建一个空的子表：

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     或者，用户可能想要创建新子表并且在将它加入到表层次之前填充它。这可以允许数据在被父表上的查询可见之前对数据进行装载、检查以及转换。

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
   </sect3>

   <sect3 id="ddl-partitioning-inheritance-caveats">
<!--==========================orignal english content==========================
    <title>Caveats</title>
____________________________________________________________________________-->
    <title>提醒</title>

<!--==========================orignal english content==========================
    <para>
     The following caveats apply to partitioning implemented using
     inheritance:
     <itemizedlist>
      <listitem>
       <para>
        There is no automatic way to verify that all of the
        <literal>CHECK</literal> constraints are mutually
        exclusive.  It is safer to create code that generates
        child tables and creates and/or modifies associated objects than
        to write each by hand.
       </para>
      </listitem>

      <listitem>
       <para>
        The schemes shown here assume that the values of a row's key column(s)
        never change, or at least do not change enough to require it to move to another partition.
        An <command>UPDATE</command> that attempts
        to do that will fail because of the <literal>CHECK</literal> constraints.
        If you need to handle such cases, you can put suitable update triggers
        on the child tables, but it makes management of the structure
        much more complicated.
       </para>
      </listitem>

      <listitem>
       <para>
        If you are using manual <command>VACUUM</command> or
        <command>ANALYZE</command> commands, don't forget that
        you need to run them on each child table individually. A command like:
<programlisting>
ANALYZE measurement;
</programlisting>
        will only process the master table.
       </para>
      </listitem>

      <listitem>
       <para>
        <command>INSERT</command> statements with <literal>ON CONFLICT</literal>
        clauses are unlikely to work as expected, as the <literal>ON CONFLICT</literal>
        action is only taken in case of unique violations on the specified
        target relation, not its child relations.
       </para>
      </listitem>

      <listitem>
       <para>
        Triggers or rules will be needed to route rows to the desired
        child table, unless the application is explicitly aware of the
        partitioning scheme.  Triggers may be complicated to write, and will
        be much slower than the tuple routing performed internally by
        declarative partitioning.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     下面的提醒适用于用继承实现的分区：
     <itemizedlist>
      <listitem>
       <para>
        没有自动的方法啊验证所有的<literal>CHECK</literal>约束之间是否互斥。编写代码来产生子表以及创建和修改相关对象比手写命令要更加安全。
       </para>
      </listitem>

      <listitem>
       <para>
        这里展示的模式假定行的键列值从不改变，或者说改变不足以让行移动到另一个分区。由于<literal>CHECK</literal>约束的存在，尝试那样做的<command>UPDATE</command>将会失败。如果需要处理那种情况，可以在子表上放置适当的更新触发器，但是那会使对结构的管理更加复杂。
       </para>
      </listitem>

      <listitem>
       <para>
        如果使用手工的<command>VACUUM</command>或者<command>ANALYZE</command>命令，不要忘记需要在每个子表上单独运行它们。这样的命令：
<programlisting>
ANALYZE measurement;
</programlisting>
        将只会处理主表。
       </para>
      </listitem>

      <listitem>
       <para>
        带有<literal>ON CONFLICT</literal>子句的<command>INSERT</command>语句不太可能按照预期工作，因为只有在指定的目标关系而不是其子关系上发生唯一违背时才会采取<literal>ON CONFLICT</literal>行动。
       </para>
      </listitem>

      <listitem>
       <para>
        将会需要触发器或者规则将行路由到想要的子表中，除非应用明确地知道分区的模式。编写触发器可能会很复杂，并且会比声明式分区在内部执行的元组路由慢很多。
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect3>
  </sect2>

  <sect2 id="ddl-partition-pruning">
<!--==========================orignal english content==========================
   <title>Partition Pruning</title>
____________________________________________________________________________-->
   <title>分区剪枝</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>partition pruning</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>partition pruning</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Partition pruning</firstterm> is a query optimization technique
    that improves performance for declaratively partitioned tables.
    As an example:

<programlisting>
SET enable_partition_pruning = on;                 -&minus; the default
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    Without partition pruning, the above query would scan each of the
    partitions of the <structname>measurement</structname> table. With
    partition pruning enabled, the planner will examine the definition
    of each partition and prove that the partition need not
    be scanned because it could not contain any rows meeting the query's
    <literal>WHERE</literal> clause.  When the planner can prove this, it
    excludes (<firstterm>prunes</firstterm>) the partition from the query
    plan.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>分区剪枝</firstterm>是一种提升声明式分区表性能的查询优化技术。例如：

<programlisting>
SET enable_partition_pruning = on;                 -- the default
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    如果没有分区剪枝，上面的查询将会扫描<structname>measurement</structname>表的每一个分区。如果启用了分区剪枝，规划器将会检查每个分区的定义并且检验该分区是否因为不包含符合查询<literal>WHERE</literal>子句的行而无需扫描。当规划器可以证实这一点时，它会把分区从查询计划中排除（<firstterm>剪枝</firstterm>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    By using the EXPLAIN command and the <xref
    linkend="guc-enable-partition-pruning"/> configuration parameter, it's
    possible to show the difference between a plan for which partitions have
    been pruned and one for which they have not.  A typical unoptimized
    plan for this type of table setup is:
<programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    Some or all of the partitions might use index scans instead of
    full-table sequential scans, but the point here is that there
    is no need to scan the older partitions at all to answer this query.
    When we enable partition pruning, we get a significantly
    cheaper plan that will deliver the same answer:
<programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Append  (cost=0.00..36.21 rows=617 width=0)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    通过使用EXPLAIN命令和<xref linkend="guc-enable-partition-pruning"/>配置参数，可以展示剪枝掉分区的计划与没有剪枝的计划之间的差别。对这种类型的表设置，一种典型的未优化计划是：
<programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-----------------------------------------------------------------------------------
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    某些或者全部的分区可能会使用索引扫描取代全表顺序扫描，但是这里的重点是根本不需要扫描较老的分区来回答这个查询。当我们启用分区剪枝时，我们会得到一个便宜很多的计划，而它能给出相同的答案：
<programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-----------------------------------------------------------------------------------
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Append  (cost=0.00..36.21 rows=617 width=0)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that partition pruning is driven only by the constraints defined
    implicitly by the partition keys, not by the presence of indexes.
    Therefore it isn't necessary to define indexes on the key columns.
    Whether an index needs to be created for a given partition depends on
    whether you expect that queries that scan the partition will
    generally scan a large part of the partition or just a small part.
    An index will be helpful in the latter case but not the former.
   </para>
____________________________________________________________________________-->
   <para>
    注意，分区剪枝仅由分区键隐式定义的约束所驱动，而不是由索引的存在驱动。因此，没有必要在键列上定义索引。是否需要为一个给定分区创建索引取决于预期的查询扫描该分区时会扫描大部分还是小部分。后一种情况下索引的帮助会比前者大。
   </para>

<!--==========================orignal english content==========================
   <para>
    Partition pruning can be performed not only during the planning of a
    given query, but also during its execution.  This is useful as it can
    allow more partitions to be pruned when clauses contain expressions
    whose values are not known at query planning time; for example,
    parameters defined in a <command>PREPARE</command> statement, using a
    value obtained from a subquery or using a parameterized value on the
    inner side of a nested loop join.  Partition pruning during execution
    can be performed at any of the following times:

    <itemizedlist>
     <listitem>
      <para>
       During initialization of the query plan.  Partition pruning can be
       performed here for parameter values which are known during the
       initialization phase of execution.  Partitions which are pruned
       during this stage will not show up in the query's
       <command>EXPLAIN</command> or <command>EXPLAIN ANALYZE</command>.
       It is possible to determine the number of partitions which were
       removed during this phase by observing the
       <quote>Subplans Removed</quote> property in the
       <command>EXPLAIN</command> output.
      </para>
     </listitem>

     <listitem>
      <para>
       During actual execution of the query plan.  Partition pruning may
       also be performed here to remove partitions using values which are
       only known during actual query execution.  This includes values
       from subqueries and values from execution-time parameters such as
       those from parameterized nested loop joins.  Since the value of
       these parameters may change many times during the execution of the
       query, partition pruning is performed whenever one of the
       execution parameters being used by partition pruning changes.
       Determining if partitions were pruned during this phase requires
       careful inspection of the <literal>loops</literal> property in
       the <command>EXPLAIN ANALYZE</command> output.  Subplans
       corresponding to different partitions may have different values
       for it depending on how many times each of them was pruned during
       execution.  Some may be shown as <literal>(never executed)</literal>
       if they were pruned every time.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    不仅在给定查询的规划期间可以执行分区剪枝，在其执行期间也能执行分区剪枝。这非常有用，因为如果子句中包含查询规划时值未知的表达式时，这可以剪枝掉更多的分区，例如在<command>PREPARE</command>语句中定义的参数会使用从子查询拿到的值或者嵌套循环连接内侧关系上的参数化值。执行期间的分区剪枝可能在下列任何时刻执行：

    <itemizedlist>
     <listitem>
      <para>
       在查询计划的初始化期间。对于执行的初始化阶段就已知值的参数，可以在这里执行分区剪枝。这个阶段中被剪枝掉的分区将不会显示在查询的<command>EXPLAIN</command>或<command>EXPLAIN ANALYZE</command>结果中。通过观察<command>EXPLAIN</command>输出的<quote>Subplans Removed</quote>属性，可以确定被剪枝掉的分区数。
      </para>
     </listitem>

     <listitem>
      <para>
       在查询计划的实际执行期间。这里可以使用只有在实际查询执行时才能知道的值执行分区剪枝。这包括来自子查询的值以及来自执行时参数的值（例如来自于参数化嵌套循环连接的参数）。由于在查询执行期间这些参数的值可能会改变多次，所以只要分区剪枝使用到的执行参数发生改变，就会执行一次分区剪枝。要判断分区是否在这个阶段被剪枝，需要仔细地观察<command>EXPLAIN ANALYZE</command>输出中的<literal>loops</literal>属性。
      对应于不同分区的子计划可以具有不同的值，这取决于在执行期间每个分区被修剪的次数。 
      如果每次都被剪枝，有些分区可能会显示为<literal>(never executed)</literal>。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Partition pruning can be disabled using the
    <xref linkend="guc-enable-partition-pruning"/> setting.
   </para>
____________________________________________________________________________-->
   <para>
    可以使用<xref linkend="guc-enable-partition-pruning"/>设置禁用分区剪枝。
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     Currently, pruning of partitions during the planning of an
     <command>UPDATE</command> or <command>DELETE</command> command is
     implemented using the constraint exclusion method (however, it is
     controlled by the <literal>enable_partition_pruning</literal> rather than
     <literal>constraint_exclusion</literal>) &mdash; see the following section
     for details and caveats that apply.
    </para>
____________________________________________________________________________-->
    <para>
     当前，<command>UPDATE</command> or <command>DELETE</command>命令规划时的分区剪枝采用约束排除方法实现（但是，它是由<literal>enable_partition_pruning</literal>而不是<literal>constraint_exclusion</literal>控制 &mdash; 其细节及相应的提醒请参考接下来的小节。
    </para>

<!--==========================orignal english content==========================
    <para>
     Also, execution-time partition pruning currently only occurs for the
     <literal>Append</literal> node type, not <literal>MergeAppend</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     此外，执行时的分区剪枝当前仅发生在<literal>Append</literal>节点类型上，对<literal>MergeAppend</literal>则不会。
    </para>

<!--==========================orignal english content==========================
    <para>
     Both of these behaviors are likely to be changed in a future release
     of <productname>PostgreSQL</productname>.
    </para>
____________________________________________________________________________-->
    <para>
     这些行为都很可能在未来的<productname>PostgreSQL</productname>发行中被改变。
    </para>
   </note>
  </sect2>

  <sect2 id="ddl-partitioning-constraint-exclusion">
<!--==========================orignal english content==========================
   <title>Partitioning and Constraint Exclusion</title>
____________________________________________________________________________-->
   <title>分区和约束排除</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <firstterm>Constraint exclusion</firstterm> is a query optimization
    technique similar to partition pruning.  While it is primarily used
    for partitioning implemented using the legacy inheritance method, it can be
    used for other purposes, including with declarative partitioning.
   </para>
____________________________________________________________________________-->
   <para>
    <firstterm>约束排除</firstterm>是一种与分区剪枝类似的查询优化技术。虽然它主要被用于使用传统继承方法实现的分区上，但它也可以被用于其他目的，包括用于声明式分区。
   </para>

<!--==========================orignal english content==========================
   <para>
    Constraint exclusion works in a very similar way to partition
    pruning, except that it uses each table's <literal>CHECK</literal>
    constraints &mdash; which gives it its name &mdash; whereas partition
    pruning uses the table's partition bounds, which exist only in the
    case of declarative partitioning.  Another difference is that
    constraint exclusion is only applied at plan time; there is no attempt
    to remove partitions at execution time.
   </para>
____________________________________________________________________________-->
   <para>
    约束排除以非常类似于分区剪枝的方式工作，不过它使用每个表的<literal>CHECK</literal>约束 &mdash; 这也是它得名的原因 &mdash; 而分区剪枝使用表的分区边界，分区边界仅存在于声明式分区的情况中。另一点不同之处是约束排除仅在规划时应用，在执行时不会尝试移除分区。
   </para>

<!--==========================orignal english content==========================
   <para>
    The fact that constraint exclusion uses <literal>CHECK</literal>
    constraints, which makes it slow compared to partition pruning, can
    sometimes be used as an advantage: because constraints can be defined
    even on declaratively-partitioned tables, in addition to their internal
    partition bounds, constraint exclusion may be able
    to elide additional partitions from the query plan.
   </para>
____________________________________________________________________________-->
   <para>
    由于约束排除使用<literal>CHECK</literal>约束，这导致它比分区剪枝要慢，但有时候可以被当作一种优点加以利用：因为甚至可以在声明式分区的表上（在分区边界之外）定义约束，约束排除可能可以从查询计划中消去额外的分区。
   </para>

<!--==========================orignal english content==========================
   <para>
    The default (and recommended) setting of
    <xref linkend="guc-constraint-exclusion"/> is neither
    <literal>on</literal> nor <literal>off</literal>, but an intermediate setting
    called <literal>partition</literal>, which causes the technique to be
    applied only to queries that are likely to be working on inheritance partitioned
    tables.  The <literal>on</literal> setting causes the planner to examine
    <literal>CHECK</literal> constraints in all queries, even simple ones that
    are unlikely to benefit.
   </para>
____________________________________________________________________________-->
   <para>
    <xref linkend="guc-constraint-exclusion"/>的默认（也是推荐的）设置不是<literal>on</literal>也不是<literal>off</literal>，而是一种被称为<literal>partition</literal>的中间设置，这会导致该技术仅被应用于可能工作在继承分区表上的查询。<literal>on</literal>设置导致规划器检查所有查询中的<literal>CHECK</literal>约束，甚至是那些不太可能受益的简单查询。
   </para>

<!--==========================orignal english content==========================
   <para>
    The following caveats apply to constraint exclusion:

   <itemizedlist>
    <listitem>
     <para>
      Constraint exclusion is only applied during query planning; unlike
      partition pruning, it cannot be applied during query execution.
     </para>
    </listitem>

    <listitem>
     <para>
      Constraint exclusion only works when the query's <literal>WHERE</literal>
      clause contains constants (or externally supplied parameters).
      For example, a comparison against a non-immutable function such as
      <function>CURRENT_TIMESTAMP</function> cannot be optimized, since the
      planner cannot know which child table the function's value might fall
      into at run time.
     </para>
    </listitem>

    <listitem>
     <para>
      Keep the partitioning constraints simple, else the planner may not be
      able to prove that child tables might not need to be visited.  Use simple
      equality conditions for list partitioning, or simple
      range tests for range partitioning, as illustrated in the preceding
      examples.  A good rule of thumb is that partitioning constraints should
      contain only comparisons of the partitioning column(s) to constants
      using B-tree-indexable operators, because only B-tree-indexable
      column(s) are allowed in the partition key.
     </para>
    </listitem>

    <listitem>
     <para>
      All constraints on all children of the parent table are examined
      during constraint exclusion, so large numbers of children are likely
      to increase query planning time considerably.  So the legacy
      inheritance based partitioning will work well with up to perhaps a
      hundred child tables; don't try to use many thousands of children.
     </para>
    </listitem>

   </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    下列提醒适用于约束排除：

   <itemizedlist>
    <listitem>
     <para>
      约束排除仅适用于查询规划期间，和分区剪枝不同，它不适用于查询执行期间。
     </para>
    </listitem>

    <listitem>
     <para>
      只有查询的<literal>WHERE</literal>子句包含常量（或者外部提供的参数）时，约束排除才能有效果。例如，针对一个非不变函数（如<function>CURRENT_TIMESTAMP</function>）的比较不能被优化，因为规划器不知道该函数的值在运行时会落到哪个子表中。
     </para>
    </listitem>

    <listitem>
     <para>
      保持分区约束简单化，否则规划器可能无法验证哪些子表可能不需要被访问。如前面的例子所示，对列表分区使用简单的等值条件，对范围分区使用简单的范围测试。一种好的经验规则是分区约束应该仅包含分区列与常量使用B-树的可索引操作符的比较，因为只有B-树的可索引列才允许出现在分区键中。
     </para>
    </listitem>

    <listitem>
     <para>
      约束排除期间会检查父表的所有子表上的所有约束，因此大量的子表很可能明显地增加查询规划时间。因此，传统的基于继承的分区可以很好地处理上百个子表，不要尝试使用上千个子表。
     </para>
    </listitem>

   </itemizedlist>
   </para>
  </sect2>
 </sect1>

 <sect1 id="ddl-foreign-data">
<!--==========================orignal english content==========================
  <title>Foreign Data</title>
____________________________________________________________________________-->
  <title>外部数据</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    <productname>PostgreSQL</productname> implements portions of the SQL/MED
    specification, allowing you to access data that resides outside
    PostgreSQL using regular SQL queries.  Such data is referred to as
    <firstterm>foreign data</firstterm>.  (Note that this usage is not to be confused
    with foreign keys, which are a type of constraint within the database.)
   </para>
____________________________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>实现了部分的SQL/MED规定，允许我们使用普通SQL查询来访问位于PostgreSQL之外的数据。这种数据被称为<firstterm>外部数据</firstterm>（注意这种用法不要和外键混淆，后者是数据库中的一种约束）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Foreign data is accessed with help from a
    <firstterm>foreign data wrapper</firstterm>. A foreign data wrapper is a
    library that can communicate with an external data source, hiding the
    details of connecting to the data source and obtaining data from it.
    There are some foreign data wrappers available as <filename>contrib</filename>
    modules; see <xref linkend="contrib"/>.  Other kinds of foreign data
    wrappers might be found as third party products.  If none of the existing
    foreign data wrappers suit your needs, you can write your own; see <xref
    linkend="fdwhandler"/>.
   </para>
____________________________________________________________________________-->
   <para>
    外部数据可以在一个<firstterm>外部数据包装器</firstterm>的帮助下被访问。一个外部数据包装器是一个库，它可以与一个外部数据源通讯，并隐藏连接到数据源和从它获取数据的细节。在<filename>contrib</filename>模块中有一些外部数据包装器，参见<xref linkend="contrib"/>。其他类型的外部数据包装器可以在第三方产品中找到。如果这些现有的外部数据包装器都不能满足你的需要，可以自己编写一个，参见<xref linkend="fdwhandler"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    To access foreign data, you need to create a <firstterm>foreign server</firstterm>
    object, which defines how to connect to a particular external data source
    according to the set of options used by its supporting foreign data
    wrapper. Then you need to create one or more <firstterm>foreign
    tables</firstterm>, which define the structure of the remote data. A
    foreign table can be used in queries just like a normal table, but a
    foreign table has no storage in the PostgreSQL server.  Whenever it is
    used, <productname>PostgreSQL</productname> asks the foreign data wrapper
    to fetch data from the external source, or transmit data to the external
    source in the case of update commands.
   </para>
____________________________________________________________________________-->
   <para>
    要访问外部数据，我们需要建立一个<firstterm>外部服务器</firstterm>对象，它根据它所支持的外部数据包装器所使用的一组选项定义了如何连接到一个特定的外部数据源。接着我们需要创建一个或多个<firstterm>外部表</firstterm>，它们定义了外部数据的结构。一个外部表可以在查询中像一个普通表一样地使用，但是在PostgreSQL服务器中外部表没有存储数据。不管使用什么外部数据包装器，<productname>PostgreSQL</productname>会要求外部数据包装器从外部数据源获取数据，或者在更新命令的情况下传送数据到外部数据源。
   </para>

<!--==========================orignal english content==========================
   <para>
    Accessing remote data may require authenticating to the external
    data source.  This information can be provided by a
    <firstterm>user mapping</firstterm>, which can provide additional data
    such as user names and passwords based
    on the current <productname>PostgreSQL</productname> role.
   </para>
____________________________________________________________________________-->
   <para>
    访问远程数据可能需要在外部数据源的授权。这些信息通过一个<firstterm>用户映射</firstterm>提供，它基于当前的<productname>PostgreSQL</productname>角色提供了附加的数据例如用户名和密码。
   </para>

<!--==========================orignal english content==========================
   <para>
    For additional information, see
    <xref linkend="sql-createforeigndatawrapper"/>,
    <xref linkend="sql-createserver"/>,
    <xref linkend="sql-createusermapping"/>,
    <xref linkend="sql-createforeigntable"/>, and
    <xref linkend="sql-importforeignschema"/>.
   </para>
____________________________________________________________________________-->
   <para>
    更多信息请见
    <xref linkend="sql-createforeigndatawrapper"/>、
    <xref linkend="sql-createserver"/>、
    <xref linkend="sql-createusermapping"/>、
    <xref linkend="sql-createforeigntable"/>以及
    <xref linkend="sql-importforeignschema"/>。
   </para>
 </sect1>

 <sect1 id="ddl-others">
<!--==========================orignal english content==========================
  <title>Other Database Objects</title>
____________________________________________________________________________-->
  <title>其他数据库对象</title>

<!--==========================orignal english content==========================
  <para>
   Tables are the central objects in a relational database structure,
   because they hold your data.  But they are not the only objects
   that exist in a database.  Many other kinds of objects can be
   created to make the use and management of the data more efficient
   or convenient.  They are not discussed in this chapter, but we give
   you a list here so that you are aware of what is possible:
  </para>
____________________________________________________________________________-->
  <para>
   表是一个关系型数据库结构中的核心对象，因为它们承载了我们的数据。但是它们并不是数据库中的唯一一种对象。有很多其他种类的对象可以被创建来使得数据的使用和刮泥更加方便或高效。在本章中不会讨论它们，但是我们在会给出一个列表：
  </para>

  <itemizedlist>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Views
    </para>
____________________________________________________________________________-->
    <para>
     视图
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Functions, procedures, and operators
    </para>
____________________________________________________________________________-->
    <para>
     函数、过程和操作符
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Data types and domains
    </para>
____________________________________________________________________________-->
    <para>
     数据类型和域
    </para>
   </listitem>

   <listitem>
<!--==========================orignal english content==========================
    <para>
     Triggers and rewrite rules
    </para>
____________________________________________________________________________-->
    <para>
     触发器和重写规则
    </para>
   </listitem>
  </itemizedlist>

<!--==========================orignal english content==========================
  <para>
   Detailed information on
   these topics appears in <xref linkend="server-programming"/>.
  </para>
____________________________________________________________________________-->
  <para>
   这些主题的详细信息请见<xref linkend="server-programming"/>。
  </para>
 </sect1>

 <sect1 id="ddl-depend">
<!--==========================orignal english content==========================
  <title>Dependency Tracking</title>
____________________________________________________________________________-->
  <title>依赖跟踪</title>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   When you create complex database structures involving many tables
   with foreign key constraints, views, triggers, functions, etc. you
   implicitly create a net of dependencies between the objects.
   For instance, a table with a foreign key constraint depends on the
   table it references.
  </para>
____________________________________________________________________________-->
  <para>
   当我们创建一个涉及到很多具有外键约束、视图、触发器、函数等的表的复杂数据库结构时，我们隐式地创建了一张对象之间的依赖关系网。例如，具有一个外键约束的表依赖于它所引用的表。
  </para>

<!--==========================orignal english content==========================
  <para>
   To ensure the integrity of the entire database structure,
   <productname>PostgreSQL</productname> makes sure that you cannot
   drop objects that other objects still depend on.  For example,
   attempting to drop the products table we considered in <xref
   linkend="ddl-constraints-fk"/>, with the orders table depending on
   it, would result in an error message like this:
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   The error message contains a useful hint: if you do not want to
   bother deleting all the dependent objects individually, you can run:
<screen>
DROP TABLE products CASCADE;
</screen>
   and all the dependent objects will be removed, as will any objects
   that depend on them, recursively.  In this case, it doesn't remove
   the orders table, it only removes the foreign key constraint.
   It stops there because nothing depends on the foreign key constraint.
   (If you want to check what <command>DROP ... CASCADE</command> will do,
   run <command>DROP</command> without <literal>CASCADE</literal> and read the
   <literal>DETAIL</literal> output.)
  </para>
____________________________________________________________________________-->
  <para>
   为了保证整个数据库结构的完整性，<productname>PostgreSQL</productname>确保我们无法删除仍然被其他对象依赖的对象。例如，尝试删除<xref linkend="ddl-constraints-fk"/>中的产品表会导致一个如下的错误消息，因为有订单表依赖于产品表：
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   该错误消息包含了一个有用的提示：如果我们不想一个一个去删除所有的依赖对象，我们可以执行：
<screen>
DROP TABLE products CASCADE;
</screen>
   这样所有的依赖对象将被移除，同样依赖于它们的任何对象也会被递归删除。在这种情况下，订单表不会被移除，但是它的外键约束会被移除。之所以在这里会停下，是因为没有什么依赖着外键约束（如果希望检查<command>DROP ... CASCADE</command>会干什么，运行不带<literal>CASCADE</literal>的<command>DROP</command>并阅读<literal>DETAIL</literal>输出）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Almost all <command>DROP</command> commands in <productname>PostgreSQL</productname> support
   specifying <literal>CASCADE</literal>.  Of course, the nature of
   the possible dependencies varies with the type of the object.  You
   can also write <literal>RESTRICT</literal> instead of
   <literal>CASCADE</literal> to get the default behavior, which is to
   prevent dropping objects that any other objects depend on.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的几乎所有<command>DROP</command>命令都支持<literal>CASCADE</literal>。当然，其本质的区别随着对象的类型而不同。我们也可以用<literal>RESTRICT</literal>代替<literal>CASCADE</literal>来获得默认行为，它将阻止删除任何被其他对象依赖的对象。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    According to the SQL standard, specifying either
    <literal>RESTRICT</literal> or <literal>CASCADE</literal> is
    required in a <command>DROP</command> command.  No database system actually
    enforces that rule, but whether the default behavior
    is <literal>RESTRICT</literal> or <literal>CASCADE</literal> varies
    across systems.
   </para>
____________________________________________________________________________-->
   <para>
    根据SQL标准，在<command>DROP</command>命令中指定<literal>RESTRICT</literal>或<literal>CASCADE</literal>是被要求的。但没有哪个数据库系统真正强制了这个规则，但是不同的系统中两种默认行为都是可能的。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   If a <command>DROP</command> command lists multiple
   objects, <literal>CASCADE</literal> is only required when there are
   dependencies outside the specified group.  For example, when saying
   <literal>DROP TABLE tab1, tab2</literal> the existence of a foreign
   key referencing <literal>tab1</literal> from <literal>tab2</literal> would not mean
   that <literal>CASCADE</literal> is needed to succeed.
  </para>
____________________________________________________________________________-->
  <para>
   如果一个<command>DROP</command>命令列出了多个对象，只有在存在指定对象构成的组之外的依赖关系时才需要<literal>CASCADE</literal>。例如，如果发出命令<literal>DROP TABLE tab1, tab2</literal>且存在从<literal>tab2</literal>到<literal>tab1</literal>的外键引用，那么就不需要<literal>CASCADE</literal>即可成功执行。
  </para>

<!--==========================orignal english content==========================
  <para>
   For user-defined functions, <productname>PostgreSQL</productname> tracks
   dependencies associated with a function's externally-visible properties,
   such as its argument and result types, but <emphasis>not</emphasis> dependencies
   that could only be known by examining the function body.  As an example,
   consider this situation:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   (See <xref linkend="xfunc-sql"/> for an explanation of SQL-language
   functions.)  <productname>PostgreSQL</productname> will be aware that
   the <function>get_color_note</function> function depends on the <type>rainbow</type>
   type: dropping the type would force dropping the function, because its
   argument type would no longer be defined.  But <productname>PostgreSQL</productname>
   will not consider <function>get_color_note</function> to depend on
   the <structname>my_colors</structname> table, and so will not drop the function if
   the table is dropped.  While there are disadvantages to this approach,
   there are also benefits.  The function is still valid in some sense if the
   table is missing, though executing it would cause an error; creating a new
   table of the same name would allow the function to work again.
  </para>
____________________________________________________________________________-->
  <para>
   对于用户定义的函数，<productname>PostgreSQL</productname>会追踪与函数外部可见性质相关的依赖性，例如它的参数和结果类型，但<emphasis>不</emphasis>追踪检查函数体才能知道的依赖性。例如，考虑这种情况：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   （SQL 元函数的解释见<xref linkend="xfunc-sql"/>）。<productname>PostgreSQL</productname>将会注意到<function>get_color_note</function>函数依赖于<type>rainbow</type>类型：删掉该类型会强制删除该函数，因为该函数的参数类型就无法定义了。但是<productname>PostgreSQL</productname>不会认为<function>get_color_note</function>依赖于<structname>my_colors</structname>表，因此即使该表被删除也不会删除这个函数。虽然这种方法有缺点，但是也有好处。如果该表丢失，这个函数在某种程度上仍然是有效的，但是执行它会导致错误。创建一个同名的新表将允许该函数重新有效。
  </para>
 </sect1>

</chapter>
