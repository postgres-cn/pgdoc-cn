<!-- doc/src/sgml/sources.sgml -->

 <chapter id="source">
<!--==========================orignal english content==========================
  <title>PostgreSQL Coding Conventions</title>
____________________________________________________________________________-->
  <title>PostgreSQL编码习惯</title>

  <sect1 id="source-format">
<!--==========================orignal english content==========================
   <title>Formatting</title>
____________________________________________________________________________-->
   <title>格式化</title>

<!--==========================orignal english content==========================
   <para>
    Source code formatting uses 4 column tab spacing, with
    tabs preserved (i.e., tabs are not expanded to spaces).
    Each logical indentation level is one additional tab stop.
   </para>
____________________________________________________________________________-->
   <para>
    源代码格式化使用 4 列制表间隔，并且保留制表符（即制表符不会被扩展成空格）。每一个逻辑缩进层就是一个额外的制表位。
   </para>

<!--==========================orignal english content==========================
   <para>
    Layout rules (brace positioning, etc) follow BSD conventions.  In
    particular, curly braces for the controlled blocks of <literal>if</literal>,
    <literal>while</literal>, <literal>switch</literal>, etc go on their own lines.
   </para>
____________________________________________________________________________-->
   <para>
    布局规则（括号定位等）遵循 BSD 习惯。特别地，<literal>if</literal>、<literal>while</literal>、<literal>switch</literal>等受控块的花括号要独自占据一行。
   </para>

<!--==========================orignal english content==========================
   <para>
    Limit line lengths so that the code is readable in an 80-column window.
    (This doesn't mean that you must never go past 80 columns.  For instance,
    breaking a long error message string in arbitrary places just to keep the
    code within 80 columns is probably not a net gain in readability.)
   </para>
____________________________________________________________________________-->
   <para>
    限制行长度，这样在 80 列窗口中代码也是可读的（这并不意味着你不能超过 80 列。例如，为了保持代码在 80 列以内而在任意位置打断一段长的错误消息字符串可能不会给可读性带来什么好处）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Do not use C++ style comments (<literal>//</literal> comments).  Strict ANSI C
    compilers do not accept them.  For the same reason, do not use C++
    extensions such as declaring new variables mid-block.
   </para>
____________________________________________________________________________-->
   <para>
    不使用 C++ 风格的注释（<literal>//</literal>注释）。严格的 ANSI C 编译器不接受这样的注释。出于相同的原因，不使用 C++ 扩展，例如在块中声明新变量。
   </para>

<!--==========================orignal english content==========================
   <para>
    The preferred style for multi-line comment blocks is
<programlisting>
/*
 * comment text begins here
 * and continues here
 */
</programlisting>
    Note that comment blocks that begin in column 1 will be preserved as-is
    by <application>pgindent</application>, but it will re-flow indented comment blocks
    as though they were plain text.  If you want to preserve the line breaks
    in an indented block, add dashes like this:
<programlisting>
    /*-&minus;-&minus;-&minus;-&minus;-&minus;
     * comment text begins here
     * and continues here
     *-&minus;-&minus;-&minus;-&minus;-&minus;
     */
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    多行注释块更好的风格是
<programlisting>
/*
 * 注释文本从这里开始
 * 延续到这里
 */
</programlisting>
    注意从列 1 开始的注释块将被<application>pgindent</application>原样保留，但是它将重新对缩进的注释块断行，好像它们是纯文本一样。如果你想要保留一个缩进块中的换行，可以像这样增加破折号：
<programlisting>
    /*----------
     * 注释文本从这里开始
     * 延续到这里
     *----------
     */
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    While submitted patches do not absolutely have to follow these formatting
    rules, it's a good idea to do so.  Your code will get run through
    <application>pgindent</application> before the next release, so there's no point in
    making it look nice under some other set of formatting conventions.
    A good rule of thumb for patches is <quote>make the new code look like
    the existing code around it</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    虽然在提交补丁时并不是一定要遵守这些格式化规则，但是最好能遵守。在下一次发行前你提交的代码将会通过<application>pgindent</application>，因此使用某种其他格式化习惯无法使代码被编排得很好。对于补丁，一种比较好的经验规则是<quote>让新代码看起来像它周围的原有代码</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The <filename>src/tools</filename> directory contains sample settings
    files that can be used with the <productname>emacs</productname>,
    <productname>xemacs</productname> or <productname>vim</productname>
    editors to help ensure that they format code according to these
    conventions.
   </para>
____________________________________________________________________________-->
   <para>
    <filename>src/tools</filename>目录包含有可以用于<productname>emacs</productname>、<productname>xemacs</productname>或者<productname>vim</productname>编辑器的设置文件，它们可以帮助确保这些编辑器会根据上述习惯格式化代码。
   </para>

<!--==========================orignal english content==========================
   <para>
    The text browsing tools <application>more</application> and
    <application>less</application> can be invoked as:
<programlisting>
more -x4
less -x4
</programlisting>
    to make them show tabs appropriately.
   </para>
____________________________________________________________________________-->
   <para>
    可以这样调用文本浏览工具<application>more</application>和<application>less</application>：
<programlisting>
more -x4
less -x4
</programlisting>
    来让它们以合适的方式显示制表符。
   </para>
  </sect1>

  <sect1 id="error-message-reporting">
<!--==========================orignal english content==========================
   <title>Reporting Errors Within the Server</title>
____________________________________________________________________________-->
   <title>在服务器中报告错误</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>ereport</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>ereport</primary>
   </indexterm>
<!--==========================orignal english content==========================
   <indexterm>
    <primary>elog</primary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>elog</primary>
   </indexterm>

<!--==========================orignal english content==========================
   <para>
    Error, warning, and log messages generated within the server code
    should be created using <function>ereport</function>, or its older cousin
    <function>elog</function>.  The use of this function is complex enough to
    require some explanation.
   </para>
____________________________________________________________________________-->
   <para>
    服务器代码内产生的错误、警告和日志消息应该使用<function>ereport</function>或者更老的<function>elog</function>生成。这个函数的使用有些复杂，因此有必要做一些解释。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are two required elements for every message: a severity level
    (ranging from <literal>DEBUG</literal> to <literal>PANIC</literal>) and a primary
    message text.  In addition there are optional elements, the most
    common of which is an error identifier code that follows the SQL spec's
    SQLSTATE conventions.
    <function>ereport</function> itself is just a shell function, that exists
    mainly for the syntactic convenience of making message generation
    look like a function call in the C source code.  The only parameter
    accepted directly by <function>ereport</function> is the severity level.
    The primary message text and any optional message elements are
    generated by calling auxiliary functions, such as <function>errmsg</function>,
    within the <function>ereport</function> call.
   </para>
____________________________________________________________________________-->
   <para>
    对于每一个消息都有两个必要的元素：一个严重性级别（从<literal>DEBUG</literal>到<literal>PANIC</literal>）和一个主消息文本。此外还有一些可选元素，其中最常见的是一个遵守 SQL 规范中 SQLSTATE 习惯的错误标识符代码。<function>ereport</function>本身只是一个 shell 函数，它的存在主要是为了在语法习惯上让消息的产生更像 C 源代码中的函数调用而已。<function>ereport</function>直接接受的唯一参数是严重性级别。主消息文本和任何其他可选消息元素通过在<function>ereport</function>调用中使用辅助函数产生，例如<function>errmsg</function>。
   </para>

<!--==========================orignal english content==========================
   <para>
    A typical call to <function>ereport</function> might look like this:
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    This specifies error severity level <literal>ERROR</literal> (a run-of-the-mill
    error).  The <function>errcode</function> call specifies the SQLSTATE error code
    using a macro defined in <filename>src/include/utils/errcodes.h</filename>.  The
    <function>errmsg</function> call provides the primary message text.  Notice the
    extra set of parentheses surrounding the auxiliary function calls &mdash;
    these are annoying but syntactically necessary.
   </para>
____________________________________________________________________________-->
   <para>
    对于<function>ereport</function>的一次典型调用可能看起来像：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    这会指定错误严重性级别为<literal>ERROR</literal>（一个普通错误）。<function>errcode</function>调用使用<filename>src/include/utils/errcodes.h</filename>中定义的一个宏指定 SQLSTATE 错误代码。<function>errmsg</function>调用提供主消息文本。注意辅助函数调用周围的额外圆括号 &mdash; 它们虽然很烦人但是在语法上是必需的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Here is a more complex example:
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_AMBIGUOUS_FUNCTION),
         errmsg("function %s is not unique",
                func_signature_string(funcname, nargs,
                                      NIL, actual_arg_types)),
         errhint("Unable to choose a best candidate function. "
                 "You might need to add explicit typecasts.")));
</programlisting>
    This illustrates the use of format codes to embed run-time values into
    a message text.  Also, an optional <quote>hint</quote> message is provided.
   </para>
____________________________________________________________________________-->
   <para>
    这里有一个更复杂的例子：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_AMBIGUOUS_FUNCTION),
         errmsg("function %s is not unique",
                func_signature_string(funcname, nargs,
                                      NIL, actual_arg_types)),
         errhint("Unable to choose a best candidate function. "
                 "You might need to add explicit typecasts.")));
</programlisting>
    这展示了使用格式代码把运行时值嵌入到一个消息文本中的方法，其中还提供了一个可选的<quote>hint</quote>消息。
   </para>
   
<!--==========================orignal english content==========================
   <para>
    If the severity level is <literal>ERROR</literal> or higher,
    <function>ereport</function> aborts the execution of the user-defined
    function and does not return to the caller. If the severity level is
    lower than <literal>ERROR</literal>, <function>ereport</function> returns normally.
   </para>
____________________________________________________________________________-->
   <para>
    如果严重级别是<literal>ERROR</literal>或更高，<function>ereport</function>
    会中止用户定义函数的执行并且不会返回到调用者。如果严重级别低于
    <literal>ERROR</literal>，<function>ereport</function>会正常返回。
   </para>

<!--==========================orignal english content==========================
   <para>
    The available auxiliary routines for <function>ereport</function> are:
  <itemizedlist>
   <listitem>
    <para>
     <function>errcode(sqlerrcode)</function> specifies the SQLSTATE error identifier
     code for the condition.  If this routine is not called, the error
     identifier defaults to
     <literal>ERRCODE_INTERNAL_ERROR</literal> when the error severity level is
     <literal>ERROR</literal> or higher, <literal>ERRCODE_WARNING</literal> when the
     error level is <literal>WARNING</literal>, otherwise (for <literal>NOTICE</literal>
     and below) <literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>.
     While these defaults are often convenient, always think whether they
     are appropriate before omitting the <function>errcode()</function> call.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg(const char *msg, ...)</function> specifies the primary error
     message text, and possibly run-time values to insert into it.  Insertions
     are specified by <function>sprintf</function>-style format codes.  In addition to
     the standard format codes accepted by <function>sprintf</function>, the format
     code <literal>%m</literal> can be used to insert the error message returned
     by <function>strerror</function> for the current value of <literal>errno</literal>.
     <footnote>
      <para>
       That is, the value that was current when the <function>ereport</function> call
       was reached; changes of <literal>errno</literal> within the auxiliary reporting
       routines will not affect it.  That would not be true if you were to
       write <literal>strerror(errno)</literal> explicitly in <function>errmsg</function>'s
       parameter list; accordingly, do not do so.
      </para>
     </footnote>
     <literal>%m</literal> does not require any
     corresponding entry in the parameter list for <function>errmsg</function>.
     Note that the message string will be run through <function>gettext</function>
     for possible localization before format codes are processed.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_internal(const char *msg, ...)</function> is the same as
     <function>errmsg</function>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for <quote>cannot happen</quote> cases that are probably
     not worth expending translation effort on.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errmsg</function>, but with
     support for various plural forms of the message.
     <replaceable>fmt_singular</replaceable> is the English singular format,
     <replaceable>fmt_plural</replaceable> is the English plural format,
     <replaceable>n</replaceable> is the integer value that determines which plural
     form is needed, and the remaining arguments are formatted according
     to the selected format string.  For more information see
     <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail(const char *msg, ...)</function> supplies an optional
     <quote>detail</quote> message; this is to be used when there is additional
     information that seems inappropriate to put in the primary message.
     The message string is processed in just the same way as for
     <function>errmsg</function>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_internal(const char *msg, ...)</function> is the same
     as <function>errdetail</function>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for detail messages that are not worth expending
     translation effort on, for instance because they are too technical to be
     useful to most users.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errdetail</function>, but with
     support for various plural forms of the message.
     For more information see <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log(const char *msg, ...)</function> is the same as
     <function>errdetail</function> except that this string goes only to the server
     log, never to the client.  If both <function>errdetail</function> (or one of
     its equivalents above) and
     <function>errdetail_log</function> are used then one string goes to the client
     and the other to the log.  This is useful for error details that are
     too security-sensitive or too bulky to include in the report
     sent to the client.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log_plural(const char *fmt_singular, const char
     *fmt_plural, unsigned long n, ...)</function> is like
     <function>errdetail_log</function>, but with support for various plural forms of
     the message.
     For more information see <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint(const char *msg, ...)</function> supplies an optional
     <quote>hint</quote> message; this is to be used when offering suggestions
     about how to fix the problem, as opposed to factual details about
     what went wrong.
     The message string is processed in just the same way as for
     <function>errmsg</function>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcontext(const char *msg, ...)</function> is not normally called
     directly from an <function>ereport</function> message site; rather it is used
     in <literal>error_context_stack</literal> callback functions to provide
     information about the context in which an error occurred, such as the
     current location in a PL function.
     The message string is processed in just the same way as for
     <function>errmsg</function>.  Unlike the other auxiliary functions, this can
     be called more than once per <function>ereport</function> call; the successive
     strings thus supplied are concatenated with separating newlines.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errposition(int cursorpos)</function> specifies the textual location
     of an error within a query string.  Currently it is only useful for
     errors detected in the lexical and syntactic analysis phases of
     query processing.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtable(Relation rel)</function> specifies a relation whose
     name and schema name should be included as auxiliary fields in the error
     report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtablecol(Relation rel, int attnum)</function> specifies
     a column whose name, table name, and schema name should be included as
     auxiliary fields in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtableconstraint(Relation rel, const char *conname)</function>
     specifies a table constraint whose name, table name, and schema name
     should be included as auxiliary fields in the error report.  Indexes
     should be considered to be constraints for this purpose, whether or
     not they have an associated <structname>pg_constraint</structname> entry.  Be
     careful to pass the underlying heap relation, not the index itself, as
     <literal>rel</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdatatype(Oid datatypeOid)</function> specifies a data
     type whose name and schema name should be included as auxiliary fields
     in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>
     specifies a domain constraint whose name, domain name, and schema name
     should be included as auxiliary fields in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_file_access()</function> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     file-access-related system call.  It uses the saved
     <literal>errno</literal> to determine which error code to generate.
     Usually this should be used in combination with <literal>%m</literal> in the
     primary error message text.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_socket_access()</function> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     socket-related system call.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhidestmt(bool hide_stmt)</function> can be called to specify
     suppression of the <literal>STATEMENT:</literal> portion of a message in the
     postmaster log.  Generally this is appropriate if the message text
     includes the current statement already.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhidecontext(bool hide_ctx)</function> can be called to
     specify suppression of the <literal>CONTEXT:</literal> portion of a message in
     the postmaster log.  This should only be used for verbose debugging
     messages where the repeated inclusion of context would bloat the log
     volume too much.
    </para>
   </listitem>
  </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    <function>ereport</function>可用的辅助例程是：
  <itemizedlist>
   <listitem>
    <para>
     <function>errcode(sqlerrcode)</function>指定对于该情况的 SQLSTATE 错误标识符代码。如果没有调用这个例程，错误严重性级别是<literal>ERROR</literal>或更高时错误标识符会默认成<literal>ERRCODE_INTERNAL_ERROR</literal>，错误级别是<literal>WARNING</literal>时标识符为<literal>ERRCODE_WARNING</literal>，否则（对于<literal>NOTICE</literal>及以下的级别）标识符会被设置为<literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>。虽然这些默认值常常很方便，在忽略<function>errcode()</function>调用之前请总是思考一下它们是否合适。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg(const char *msg, ...)</function>指定主错误消息文本，以及需要插入其中的运行时值。这种插入以<function>sprintf</function>-风格的格式代码指定。除了<function>sprintf</function>接受的标准格式代码，格式代码<literal>%m</literal>可以用来插入由<function>strerror</function>为<literal>errno</literal>的当前值返回的错误消息。
     <footnote>
      <para>
       也就是说，该值时到达<function>ereport</function>调用时的当前值，在辅助报告例程内<literal>errno</literal>的改变不会影响它。但如果你在<function>errmsg</function>的参数列表中显式地写了<literal>strerror(errno)</literal>则不是这样，因此不要那样做。
      </para>
     </footnote>
     <literal>%m</literal>不要求<function>errmsg</function>参数列表中的任何对应项。注意在格式代码被处理之前，消息字符串将通过<function>gettext</function>来进行可能的本地化。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_internal(const char *msg, ...)</function>与<function>errmsg</function>相同，不过消息串将不会被翻译，也不会被包括在国际化的消息字典中。这不应该被用于<quote>不能发生</quote>的情况中，因为那些情况下不值得花费精力去做翻译。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function>很像<function>errmsg</function>，但是支持消息的多种复数形式。<replaceable>fmt_singular</replaceable>是英语单数格式，<replaceable>fmt_plural</replaceable>是英语复数格式，<replaceable>n</replaceable>是决定需要何种复数形式的整数值，剩下的参数会被根据选中的格式字符串进行格式化。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail(const char *msg, ...)</function>提供了一个可选的<quote>详情</quote>消息，如果有额外的信息但不适合放在主消息中时就可以使用这种方式。消息字符串的处理与<function>errmsg</function>相同。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_internal(const char *msg, ...)</function>与<function>errdetail</function>相同，不过消息串将不会被翻译，也不会被包括在国际化的消息字典中。这应该被用于不值得花费精力翻译的详情消息上，例如它们对大部分用户太过技术化而没什么用处。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function>与<function>errdetail</function>相似，但是支持消息的多种复数形式。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log(const char *msg, ...)</function>与<function>errdetail</function>相同，除了这个字符串只会进入服务器的日志而不会发往客户端。如果同时使用了<function>errdetail</function>（或者上述的一种等效函数）以及<function>errdetail_log</function>，那么一个字符串会被发往客户端而另一个会被发往日志。如果错误细节的安全性过于敏感或者体积过于庞大而不适合于发往客户端，这个函数就非常有用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log_plural(const char *fmt_singular, const char
     *fmt_plural, unsigned long n, ...)</function>与<function>errdetail_log</function>
     相似，但是支持多种复数形式的消息。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint(const char *msg, ...)</function>提供一个可选的<quote>hint</quote>消息，它被用来提供关于如何修复该问题的建议。该消息字符串以和<function>errmsg</function>相同的方式处理。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcontext(const char *msg, ...)</function>通常不会被直接从一个<function>ereport</function>消息站点调用，它被用在<literal>error_context_stack</literal>回调函数中来提供错误发生的上下文，例如一个 PL 函数中的当前位置。该消息字符串以和<function>errmsg</function>相同的方式处理。不同于其他辅助函数，在每次<function>ereport</function>调用中可以多次调用这个函数，这样提供的连续的字符串将被用单独的新行串接在一起。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errposition(int cursorpos)</function>指定一个查询字符串中错误的文本位置。当前，它只对查询处理的词法和语法分析阶段中检测到的错误有用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtable(Relation rel)</function>指定一个关系，它的名称和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtablecol(Relation rel, int attnum)</function>指定一个列，它的名称、表名和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtableconstraint(Relation rel, const char *conname)</function>指定一个约束，它的名称、表名和模式名称应该被包括在错误报告中作为辅助域。索引应当为考虑成用于这种目的的约束，不管它们有没有一个相关联的<structname>pg_constraint</structname>项。要小心地以<literal>rel</literal>传递底层堆关系而不是索引本身。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdatatype(Oid datatypeOid)</function>指定一个数据类型，它的名称和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>指定一个域约束，它的名称、域名和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_file_access()</function>是一个便捷函数，它可以在一个文件访问相关的系统调用中为一个失败选择一个合适的 SQLSTATE 错误标识符。它使用保存下来的<literal>errno</literal>来决定要差生哪种错误代码。通常，应该把它和主错误消息文本中的<literal>%m</literal>联合使用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_socket_access()</function>是一个便捷函数，它可以在一个套接字相关的系统调用中为一个失败选择一个合适的 SQLSTATE 错误标识符。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhidestmt(bool hide_stmt)</function>可以被调用来指定 postmaster 日志中一个消息的<literal>STATEMENT:</literal>部分的禁止。通常如果该消息文本已经包括当前语句这就是合适的。
    </para>
   </listitem>
   <listitem>
    <para>
     可以调用<function>errhidecontext(bool hide_ctx)</function>来指示抑制 postmaster 日志中消息里的<literal>CONTEXT:</literal>部分。这只应该被用于 verbose 模式的调试消息，这类消息中被重复包含的上下文信息会让日志容量膨胀得非常厉害。
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <note>
<!--==========================orignal english content==========================
    <para>
     At most one of the functions <function>errtable</function>,
     <function>errtablecol</function>, <function>errtableconstraint</function>,
     <function>errdatatype</function>, or <function>errdomainconstraint</function> should
     be used in an <function>ereport</function> call.  These functions exist to
     allow applications to extract the name of a database object associated
     with the error condition without having to examine the
     potentially-localized error message text.
     These functions should be used in error reports for which it's likely
     that applications would wish to have automatic error handling.  As of
     <productname>PostgreSQL</productname> 9.3, complete coverage exists only for
     errors in SQLSTATE class 23 (integrity constraint violation), but this
     is likely to be expanded in future.
    </para>
____________________________________________________________________________-->
    <para>
     在一个<function>ereport</function>调用中，最多可以使用一个<function>errtable</function>、<function>errtablecol</function>、<function>errtableconstraint</function>、<function>errdatatype</function>或者<function>errdomainconstraint</function>函数。这些函数存在是为了允许应用抽取与错误情况相关的数据库对象名，而不需要检查可能已被本地化的错误消息文本。这些函数应该被用在应用需要对其进行自动错误处理的错误报告中。从<productname>PostgreSQL</productname> 9.3 开始，完整的覆盖只为 SQLSTATE 类别 23 中的错误存在（完整性约束违背），但是在未来这些很可能会被扩展。
    </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    There is an older function <function>elog</function> that is still heavily used.
    An <function>elog</function> call:
<programlisting>
elog(level, "format string", ...);
</programlisting>
    is exactly equivalent to:
<programlisting>
ereport(level, (errmsg_internal("format string", ...)));
</programlisting>
    Notice that the SQLSTATE error code is always defaulted, and the message
    string is not subject to translation.
    Therefore, <function>elog</function> should be used only for internal errors and
    low-level debug logging.  Any message that is likely to be of interest to
    ordinary users should go through <function>ereport</function>.  Nonetheless,
    there are enough internal <quote>cannot happen</quote> error checks in the
    system that <function>elog</function> is still widely used; it is preferred for
    those messages for its notational simplicity.
   </para>
____________________________________________________________________________-->
   <para>
    有一个还在大量使用的旧的函数<function>elog</function>。一个<function>elog</function>调用：
<programlisting>
elog(level, "format string", ...);
</programlisting>
    完全等效于：
<programlisting>
ereport(level, (errmsg_internal("format string", ...)));
</programlisting>
    注意 SQLSTATE 错误代码总是被给予默认值，并且消息字符串不受翻译限制。因此，<function>elog</function>应该只被用于内部错误和低层次的调试日志。任何普通用户感兴趣的消息应该通过<function>ereport</function>。不管怎样，在仍广泛使用<function>elog</function>的系统中，有足够多的内部<quote>不可能发生</quote>的错误检查，出于记号简洁的目的这更适合于那些消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    Advice about writing good error messages can be found in
    <xref linkend="error-style-guide"/>.
   </para>
____________________________________________________________________________-->
   <para>
    有关编写好的错误消息的建议可见<xref linkend="error-style-guide"/>。
   </para>
  </sect1>

  <sect1 id="error-style-guide">
<!--==========================orignal english content==========================
   <title>Error Message Style Guide</title>
____________________________________________________________________________-->
   <title>错误消息风格指导</title>

<!--==========================orignal english content==========================
   <para>
    This style guide is offered in the hope of maintaining a consistent,
    user-friendly style throughout all the messages generated by
    <productname>PostgreSQL</productname>.
   </para>
____________________________________________________________________________-->
   <para>
    提供这个风格指导是希望在所有由<productname>PostgreSQL</productname>产生的消息间维护一种一致的、用户友好的风格。
   </para>

  <simplesect>
<!--==========================orignal english content==========================
   <title>What Goes Where</title>
____________________________________________________________________________-->
   <title>什么去哪里</title>

<!--==========================orignal english content==========================
   <para>
    The primary message should be short, factual, and avoid reference to
    implementation details such as specific function names.
    <quote>Short</quote> means <quote>should fit on one line under normal
    conditions</quote>.  Use a detail message if needed to keep the primary
    message short, or if you feel a need to mention implementation details
    such as the particular system call that failed. Both primary and detail
    messages should be factual.  Use a hint message for suggestions about what
    to do to fix the problem, especially if the suggestion might not always be
    applicable.
   </para>
____________________________________________________________________________-->
   <para>
    主要的消息应该简短、实事求是并且避免引用诸如特定函数名这样的实现细节。<quote>简短</quote>意味着<quote>在正常情况下应该能放在一行内</quote>。如果需要保持主要消息简短，或者如果你觉得有必要提到诸如特定系统调用失败这样的实现细节，可以使用一个详细消息。主要消息和详细消息都应该实事求是。对于有关如何修复问题的建议可以使用一个提示消息，特别是该建议可能不总是合适时。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, instead of:
<programlisting>
IpcMemoryCreate: shmget(key=%d, size=%u, 0%o) failed: %m
(plus a long addendum that is basically a hint)
</programlisting>
    write:
<programlisting>
Primary:    could not create shared memory segment: %m
Detail:     Failed syscall was shmget(key=%d, size=%u, 0%o).
Hint:       the addendum
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    例如，与其用：
<programlisting>
IpcMemoryCreate: shmget(key=%d, size=%u, 0%o) failed: %m
(plus a long addendum that is basically a hint)
</programlisting>
    不如写：
<programlisting>
Primary:    could not create shared memory segment: %m
Detail:     Failed syscall was shmget(key=%d, size=%u, 0%o).
Hint:       the addendum
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: keeping the primary message short helps keep it to the point,
    and lets clients lay out screen space on the assumption that one line is
    enough for error messages.  Detail and hint messages can be relegated to a
    verbose mode, or perhaps a pop-up error-details window.  Also, details and
    hints would normally be suppressed from the server log to save
    space. Reference to implementation details is best avoided since users
    aren't expected to know the details.
   </para>
____________________________________________________________________________-->
   <para>
    原理：保持主要消息简短有助于扣住主题并且有助于客户端基于错误消息放在一行足以的假设来安排屏幕空间。详细消息和提示消息可以被归入一种详情模式，或者可能是一种弹出式错误细节窗口。还有，详细消息和提示消息通常会被排除在服务器日志之外以解决空间。最好避免对实现细节的引用，因为用户根本就不想知道细节。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Formatting</title>
____________________________________________________________________________-->
   <title>格式化</title>

<!--==========================orignal english content==========================
   <para>
    Don't put any specific assumptions about formatting into the message
    texts.  Expect clients and the server log to wrap lines to fit their own
    needs.  In long messages, newline characters (\n) can be used to indicate
    suggested paragraph breaks.  Don't end a message with a newline.  Don't
    use tabs or other formatting characters.  (In error context displays,
    newlines are automatically added to separate levels of context such as
    function calls.)
   </para>
____________________________________________________________________________-->
   <para>
    不要对消息文本的格式化做任何特定假设。可以期望客户端和服务器日志换行来适应其自身的需要。在长消息中，新行字符（\n）可以被用来指示建议的分段。不要用一个新行结束一个消息。不要使用制表符或其他格式化字符（在错误上下文显示中，新行会自动被增加来分割上下文的层次，例如函数调用）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Messages are not necessarily displayed on terminal-type
    displays.  In GUI displays or browsers these formatting instructions are
    at best ignored.
   </para>
____________________________________________________________________________-->
   <para>
    原理：消息不一定非得显示在终端上。在 GUI 显示或浏览器中，这些格式化指令最多会被忽略。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Quotation Marks</title>
____________________________________________________________________________-->
   <title>引号</title>

<!--==========================orignal english content==========================
   <para>
    English text should use double quotes when quoting is appropriate.
    Text in other languages should consistently use one kind of quotes that is
    consistent with publishing customs and computer output of other programs.
   </para>
____________________________________________________________________________-->
   <para>
    在引用时，英语文本应该使用双引号。其他语言中的文本应该一致地使用一种符合出版习惯和其他程序计算机输出的引号。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: The choice of double quotes over single quotes is somewhat
    arbitrary, but tends to be the preferred use.  Some have suggested
    choosing the kind of quotes depending on the type of object according to
    SQL conventions (namely, strings single quoted, identifiers double
    quoted).  But this is a language-internal technical issue that many users
    aren't even familiar with, it won't scale to other kinds of quoted terms,
    it doesn't translate to other languages, and it's pretty pointless, too.
   </para>
____________________________________________________________________________-->
   <para>
    原理：选择双引号而不是单引号其实有点武断，但是更倾向于是首选用法。有人建议过按照 SQL 习惯根据对象类型来选择引号的种类（即，字符串单引号，标识符双引号）。但是这是一个很多用户根本不熟悉的语言内部的技术问题，它不会扩散到其他种类的被引用术语，也不会翻译成其他语言，并且也相当没有意义。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Use of Quotes</title>
____________________________________________________________________________-->
   <title>引号的使用</title>

<!--==========================orignal english content==========================
   <para>
    Use quotes always to delimit file names, user-supplied identifiers, and
    other variables that might contain words.  Do not use them to mark up
    variables that will not contain words (for example, operator names).
   </para>
____________________________________________________________________________-->
   <para>
    总是用引号界定文件名、用户提供的标识符以及其他可能包含词的变量。不要用它们来标记不会包含词的变量（例如，操作符名称）。
   </para>

<!--==========================orignal english content==========================
   <para>
    There are functions in the backend that will double-quote their own output
    at need (for example, <function>format_type_be()</function>).  Do not put
    additional quotes around the output of such functions.
   </para>
____________________________________________________________________________-->
   <para>
    在后端有函数会根据需要对其自身的输出加上双引号（例如<function>format_type_be()</function>）。不要在这种函数的输出周围再加上额外的引号。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Objects can have names that create ambiguity when embedded in a
    message.  Be consistent about denoting where a plugged-in name starts and
    ends.  But don't clutter messages with unnecessary or duplicate quote
    marks.
   </para>
____________________________________________________________________________-->
   <para>
    原理：在被嵌入到一个消息时，对象可能具有产生歧义的名称。对于标记一个插入名称的开始和结束要始终如一。但不要在消息中混入不必要的或者重复的引号。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Grammar and Punctuation</title>
____________________________________________________________________________-->
   <title>语法和标点</title>

<!--==========================orignal english content==========================
   <para>
    The rules are different for primary error messages and for detail/hint
    messages:
   </para>
____________________________________________________________________________-->
   <para>
    主要错误消息的规则与详细/提示消息的规则不同：
   </para>

<!--==========================orignal english content==========================
   <para>
    Primary error messages: Do not capitalize the first letter.  Do not end a
    message with a period.  Do not even think about ending a message with an
    exclamation point.
   </para>
____________________________________________________________________________-->
   <para>
    主要错误消息：不要大写第一个字母。不要用一个句点结束一个消息。甚至不要考虑用一个感叹号结束一个消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    Detail and hint messages: Use complete sentences, and end each with
    a period.  Capitalize the first word of sentences.  Put two spaces after
    the period if another sentence follows (for English text; might be
    inappropriate in other languages).
   </para>
____________________________________________________________________________-->
   <para>
    详细和提示消息：使用完整的句子，并且每一个都用句点结束。对句子的第一个词进行首字母大写。如果后面跟着另一个句子，在据点后面放两个空格（对于英语文本有效，在其他语言中可能不合适）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Error context strings: Do not capitalize the first letter and do
    not end the string with a period.  Context strings should normally
    not be complete sentences.
   </para>
____________________________________________________________________________-->
   <para>
    错误上下文字符串：不要大写第一个字母并且不要用一个句点结束字符串。上下文字符串通常不应该是完整的句子。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Avoiding punctuation makes it easier for client applications to
    embed the message into a variety of grammatical contexts.  Often, primary
    messages are not grammatically complete sentences anyway.  (And if they're
    long enough to be more than one sentence, they should be split into
    primary and detail parts.)  However, detail and hint messages are longer
    and might need to include multiple sentences.  For consistency, they should
    follow complete-sentence style even when there's only one sentence.
   </para>
____________________________________________________________________________-->
   <para>
    原理：避免标点让客户端应用能更容易地把消息嵌入到各种各样的语法上下文中。主要消息场上不是语法上完整的句子（并且如果它们比一个句子还长，它们应该被分成主要和详细部分）。不过，详细和提示消息会更长并且需要包括多个句子。为了一致，即便它们只是一个句子，它们也应该遵循完整句子的风格。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Upper Case vs. Lower Case</title>
____________________________________________________________________________-->
   <title>大写 vs. 小写</title>

<!--==========================orignal english content==========================
   <para>
    Use lower case for message wording, including the first letter of a
    primary error message.  Use upper case for SQL commands and key words if
    they appear in the message.
   </para>
____________________________________________________________________________-->
   <para>
    对消息用于使用小写形式，包括一个主要错误消息的第一个字母。如果 SQL 命令或者关键词出现在消息中，为它们使用大写形式。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: It's easier to make everything look more consistent this
    way, since some messages are complete sentences and some not.
   </para>
____________________________________________________________________________-->
   <para>
    原理：用这种方式能更容易使所有的东西看起来更加一致，因为一些消息是完整的句子而另一些不是。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Avoid Passive Voice</title>
____________________________________________________________________________-->
   <title>避免被动态</title>

<!--==========================orignal english content==========================
   <para>
    Use the active voice.  Use complete sentences when there is an acting
    subject (<quote>A could not do B</quote>).  Use telegram style without
    subject if the subject would be the program itself; do not use
    <quote>I</quote> for the program.
   </para>
____________________________________________________________________________-->
   <para>
    使用主动语态。在有主语时使用完整句子（<quote>A could not do B</quote>）。如果主语是程序本身，使用没有主语的电报风格，但不要为程序使用<quote>I</quote>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: The program is not human.  Don't pretend otherwise.
   </para>
____________________________________________________________________________-->
   <para>
    原理：程序不是人类。所以不要假装。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Present vs. Past Tense</title>
____________________________________________________________________________-->
   <title>现在式 vs. 过去式</title>

<!--==========================orignal english content==========================
   <para>
    Use past tense if an attempt to do something failed, but could perhaps
    succeed next time (perhaps after fixing some problem).  Use present tense
    if the failure is certainly permanent.
   </para>
____________________________________________________________________________-->
   <para>
    如果一次尝试做某事失败但是可能在下一次成功（也许在修复某个问题之后），则使用过去式。如果失败必定是持久的，使用现在式。
   </para>

<!--==========================orignal english content==========================
   <para>
    There is a nontrivial semantic difference between sentences of the form:
<programlisting>
could not open file "%s": %m
</programlisting>
and:
<programlisting>
cannot open file "%s"
</programlisting>
    The first one means that the attempt to open the file failed.  The
    message should give a reason, such as <quote>disk full</quote> or
    <quote>file doesn't exist</quote>.  The past tense is appropriate because
    next time the disk might not be full anymore or the file in question might
    exist.
   </para>
____________________________________________________________________________-->
   <para>
    在以下形式的句子之间存在着非平凡的语义区别：
<programlisting>
could not open file "%s": %m
</programlisting>
和
<programlisting>
cannot open file "%s"
</programlisting>
    第一个表示打开文件的尝试失败。该消息应该给出一个原因，例如<quote>磁盘满</quote>或者<quote>文件不存在</quote>。过去式更合适，因为下一次磁盘可能不再满或者请求的文件可能就存在了。
   </para>

<!--==========================orignal english content==========================
   <para>
    The second form indicates that the functionality of opening the named file
    does not exist at all in the program, or that it's conceptually
    impossible.  The present tense is appropriate because the condition will
    persist indefinitely.
   </para>
____________________________________________________________________________-->
   <para>
    第二种形式指示打开所提及文件的功能在程序中根本就不存在，或者概念上是不可能的。现在式更合适，因为该情况将无限期保持。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Granted, the average user will not be able to draw great
    conclusions merely from the tense of the message, but since the language
    provides us with a grammar we should use it correctly.
   </para>
____________________________________________________________________________-->
   <para>
    原理：诚然，普通用户没有能力从消息的时态上得出重要的结论，但是由于语言为我们提供了语法，我们就应该正确地使用它。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Type of the Object</title>
____________________________________________________________________________-->
   <title>对象类型</title>

<!--==========================orignal english content==========================
   <para>
    When citing the name of an object, state what kind of object it is.
   </para>
____________________________________________________________________________-->
   <para>
    在引用一个对象的名称时，说明该对象的种类。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Otherwise no one will know what <quote>foo.bar.baz</quote>
    refers to.
   </para>
____________________________________________________________________________-->
   <para>
    原理：否则没有人会了解什么<quote>foo.bar.baz</quote>。
    refers to.
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Brackets</title>
____________________________________________________________________________-->
   <title>括号</title>

<!--==========================orignal english content==========================
   <para>
    Square brackets are only to be used (1) in command synopses to denote
    optional arguments, or (2) to denote an array subscript.
   </para>
____________________________________________________________________________-->
   <para>
    方括号只被用于： (1) 在命令对照表中标记可选参数，或者 (2) 用于标记一个数组下标。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Anything else does not correspond to widely-known customary
    usage and will confuse people.
   </para>
____________________________________________________________________________-->
   <para>
    原理：任何其他用法都无法符合总所周知的习惯用法并且将使人们混乱。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Assembling Error Messages</title>
____________________________________________________________________________-->
   <title>组装错误消息</title>

<!--==========================orignal english content==========================
   <para>
   When a message includes text that is generated elsewhere, embed it in
   this style:
<programlisting>
could not open file %s: %m
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
   当一个消息包括在别处产生的文本时，这样将它嵌入：
<programlisting>
could not open file %s: %m
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: It would be difficult to account for all possible error codes
    to paste this into a single smooth sentence, so some sort of punctuation
    is needed.  Putting the embedded text in parentheses has also been
    suggested, but it's unnatural if the embedded text is likely to be the
    most important part of the message, as is often the case.
   </para>
____________________________________________________________________________-->
   <para>
    原理：将这种文本粘贴到一个单一的语句中很难解释所有可能的错误代码，因此需要某种标点。也有人建议把被嵌入的文本放在圆括号中，但是如果被嵌入的文本可能是消息中最重要的一部分（这是常有的事）时就显得不自然。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Reasons for Errors</title>
____________________________________________________________________________-->
   <title>错误原因</title>

<!--==========================orignal english content==========================
   <para>
    Messages should always state the reason why an error occurred.
    For example:
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
    If no reason is known you better fix the code.
   </para>
____________________________________________________________________________-->
   <para>
    消息应该总是说明为什么错误会发生的原因。例如：
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
    如果没有已知原因，你最好修复代码。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Function Names</title>
____________________________________________________________________________-->
   <title>函数名</title>

<!--==========================orignal english content==========================
   <para>
    Don't include the name of the reporting routine in the error text. We have
    other mechanisms for finding that out when needed, and for most users it's
    not helpful information.  If the error text doesn't make as much sense
    without the function name, reword it.
<programlisting>
BAD:    pg_atoi: error in "z": cannot parse "z"
BETTER: invalid input syntax for integer: "z"
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    不要在错误文本中包括报告例程的名称。需要时，我们有其他机制能够知道这些，并且对于大部分用户来说这种信息没有用处。如果没有函数名错误文本就没有意义，那么请重写它。
<programlisting>
BAD:    pg_atoi: error in "z": cannot parse "z"
BETTER: invalid input syntax for integer: "z"
</programlisting>
   </para>

<!--==========================orignal english content==========================
   <para>
    Avoid mentioning called function names, either; instead say what the code
    was trying to do:
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
    If it really seems necessary, mention the system call in the detail
    message.  (In some cases, providing the actual values passed to the
    system call might be appropriate information for the detail message.)
   </para>
____________________________________________________________________________-->
   <para>
    也要避免提及被调用的函数，而不是说代码尝试做过什么：
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
    如果它真地看起来必要，在详细消息中提及系统调用（在某些情况中，可以为详细消息提供传递给系统调用的实际值）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: Users don't know what all those functions do.
   </para>
____________________________________________________________________________-->
   <para>
    原理：用户不知道所有那些函数做了什么。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Tricky Words to Avoid</title>
____________________________________________________________________________-->
   <title>应该避免的捣蛋词</title>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Unable</title>
____________________________________________________________________________-->
    <title>Unable</title>
<!--==========================orignal english content==========================
   <para>
    <quote>Unable</quote> is nearly the passive voice.  Better use
    <quote>cannot</quote> or <quote>could not</quote>, as appropriate.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>Unable</quote>接近于被动态。酌情使用<quote>cannot</quote>或者<quote>could not</quote>更好。
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Bad</title>
____________________________________________________________________________-->
    <title>Bad</title>
<!--==========================orignal english content==========================
   <para>
    Error messages like <quote>bad result</quote> are really hard to interpret
    intelligently.  It's better to write why the result is <quote>bad</quote>,
    e.g., <quote>invalid format</quote>.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>bad result</quote>之类的错误消息实在很难被解释。最好写出为什么结果<quote>不好</quote>，例如<quote>无效格式</quote>。
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Illegal</title>
____________________________________________________________________________-->
    <title>Illegal</title>
<!--==========================orignal english content==========================
   <para>
    <quote>Illegal</quote> stands for a violation of the law, the rest is
    <quote>invalid</quote>. Better yet, say why it's invalid.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>Illegal</quote>表示未被了法律，剩下的才是<quote>invalid</quote>。同样，说明为什么无效。
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Unknown</title>
____________________________________________________________________________-->
    <title>Unknown</title>
<!--==========================orignal english content==========================
   <para>
    Try to avoid <quote>unknown</quote>.  Consider <quote>error: unknown
    response</quote>.  If you don't know what the response is, how do you know
    it's erroneous? <quote>Unrecognized</quote> is often a better choice.
    Also, be sure to include the value being complained of.
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    尝试避免<quote>unknown</quote>。考虑<quote>error: unknown
    response</quote>。如果你不知道响应是什么，你怎么知道它是错误的？<quote>Unrecognized</quote>常常是一个更好的选择。还有，确定不要包括被抱怨的值。
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Find vs. Exists</title>
____________________________________________________________________________-->
    <title>找到 vs. 存在</title>
<!--==========================orignal english content==========================
   <para>
    If the program uses a nontrivial algorithm to locate a resource (e.g., a
    path search) and that algorithm fails, it is fair to say that the program
    couldn't <quote>find</quote> the resource.  If, on the other hand, the
    expected location of the resource is known but the program cannot access
    it there then say that the resource doesn't <quote>exist</quote>.  Using
    <quote>find</quote> in this case sounds weak and confuses the issue.
   </para>
____________________________________________________________________________-->
   <para>
    如果程序使用了一个非平凡的算法来定位一个资源（例如一个路径搜索）并且该算法失败了，说该程序无法<quote>找到</quote>该资源比较公平。换句话说，如果该资源应该在的位置是已知的，但是程序无法在那里访问它，那么才说该资源不<quote>存在</quote>。在这种情况中使用<quote>找到</quote>听起来很弱并且会使问题混淆。
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>May vs. Can vs. Might</title>
____________________________________________________________________________-->
    <title>May vs. Can vs. Might</title>
<!--==========================orignal english content==========================
   <para>
    <quote>May</quote> suggests permission (e.g., "You may borrow my rake."),
    and has little use in documentation or error messages.
    <quote>Can</quote> suggests ability (e.g., "I can lift that log."),
    and <quote>might</quote> suggests possibility (e.g., "It might rain
    today.").  Using the proper word clarifies meaning and assists
    translation.
   </para>
____________________________________________________________________________-->
   <para>
    <quote>May</quote>表示权限（例如，"You may borrow my rake."），并且在文档或错误消息中用处有限。
    <quote>Can</quote>表示能力（例如，"I can lift that log."），而<quote>might</quote>表示可能性（例如，"It might rain
    today."）。请使用合适的词来使含义清晰并且便于翻译。
   </para>
  </formalpara>

  <formalpara>
<!--==========================orignal english content==========================
    <title>Contractions</title>
____________________________________________________________________________-->
    <title>缩略形式</title>
<!--==========================orignal english content==========================
   <para>
    Avoid contractions, like <quote>can't</quote>;  use
    <quote>cannot</quote> instead.
   </para>
____________________________________________________________________________-->
   <para>
    避免缩略，如<quote>can't</quote>，请使用<quote>cannot</quote>。
   </para>
  </formalpara>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Proper Spelling</title>
____________________________________________________________________________-->
   <title>适当的拼写</title>

<!--==========================orignal english content==========================
   <para>
    Spell out words in full.  For instance, avoid:
  <itemizedlist>
   <listitem>
    <para>
     spec
    </para>
   </listitem>
   <listitem>
    <para>
     stats
    </para>
   </listitem>
   <listitem>
    <para>
     parens
    </para>
   </listitem>
   <listitem>
    <para>
     auth
    </para>
   </listitem>
   <listitem>
    <para>
     xact
    </para>
   </listitem>
  </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    完整地拼出单词。例如，避免：
  <itemizedlist>
   <listitem>
    <para>
     spec
    </para>
   </listitem>
   <listitem>
    <para>
     stats
    </para>
   </listitem>
   <listitem>
    <para>
     parens
    </para>
   </listitem>
   <listitem>
    <para>
     auth
    </para>
   </listitem>
   <listitem>
    <para>
     xact
    </para>
   </listitem>
  </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Rationale: This will improve consistency.
   </para>
____________________________________________________________________________-->
   <para>
    基本原理：这将增强一致性。
   </para>

  </simplesect>

  <simplesect>
<!--==========================orignal english content==========================
   <title>Localization</title>
____________________________________________________________________________-->
   <title>本地化</title>

<!--==========================orignal english content==========================
   <para>
    Keep in mind that error message texts need to be translated into other
    languages.  Follow the guidelines in <xref linkend="nls-guidelines"/>
    to avoid making life difficult for translators.
   </para>
____________________________________________________________________________-->
   <para>
    记住错误消息文本需要被翻译成其他语言。请遵循<xref linkend="nls-guidelines"/>中的方针以避免让翻译者为难。
   </para>
  </simplesect>

  </sect1>
  
  <sect1 id="source-conventions">
<!--==========================orignal english content==========================
   <title>Miscellaneous Coding Conventions</title>
____________________________________________________________________________-->
   <title>其他编码习惯</title>

   <simplesect>
<!--==========================orignal english content==========================
    <title>C Standard</title>
____________________________________________________________________________-->
    <title>C 标准</title>
<!--==========================orignal english content==========================
    <para>
     Code in <productname>PostgreSQL</productname> should only rely on language
     features available in the C89 standard. That means a conforming
     C89 compiler has to be able to compile postgres, at least aside
     from a few platform dependent pieces. Features from later
     revision of the C standard or compiler specific features can be
     used, if a fallback is provided.
    </para>
____________________________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>中的代码应该只依赖于 C89 标准中的语言特性。这意味着遵循 C89 的编译器肯定能编译 postgres，至少除开少数平台依赖问题之外。 如果提供了回退机制，也可以使用来自后续 C 标准版本的特性或者编译器相关的特性。
    </para>
<!--==========================orignal english content==========================
    <para>
     For example <literal>static inline</literal> and
     <literal>_StaticAssert()</literal> are currently used, even
     though they are from newer revisions of the C standard. If not
     available we respectively fall back to defining the functions
     without inline, and to using a C89 compatible replacement that
     performs the same checks, but emits rather cryptic messages.
    </para>
____________________________________________________________________________-->
    <para>
     例如虽然<literal>static inline</literal>和<literal>_StaticAssert()</literal>来自于新版的 C 标准，但是<productname>PostgreSQL</productname>中仍然用到了它们。如果它们不可用，我们分别会回退到定义没有内联的函数以及使用兼容 C89 的替代品来执行相同的检查（但是会发出晦涩的消息）。
    </para>
   </simplesect>

   <simplesect>
<!--==========================orignal english content==========================
    <title>Function-Like Macros and Inline Functions</title>
____________________________________________________________________________-->
    <title>类函数的宏以及内联函数</title>
<!--==========================orignal english content==========================
    <para>
     Both, macros with arguments and <literal>static inline</literal>
     functions, may be used. The latter are preferable if there are
     multiple-evaluation hazards when written as a macro, as e.g. the
     case with
<programlisting>
#define Max(x, y)       ((x) > (y) ? (x) : (y))
</programlisting>
     or when the macro would be very long. In other cases it's only
     possible to use macros, or at least easier.  For example because
     expressions of various types need to be passed to the macro.
    </para>
____________________________________________________________________________-->
    <para>
     带有参数的宏以及<literal>static inline</literal>函数都可能被使用。当类似如下情况写作宏时会有多次计算风险或者宏可能非常长时，使用后者会更好。
<programlisting>
#define Max(x, y)       ((x) > (y) ? (x) : (y))
</programlisting>
     在其他情况下只能使用宏，或者说使用宏至少更容易。例如，由于多种类型的表达式需要被传递给宏。
    </para>
<!--==========================orignal english content==========================
    <para>
     When the definition of an inline function references symbols
     (i.e. variables, functions) that are only available as part of the
     backend, the function may not be visible when included from frontend
     code.
<programlisting>
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */
</programlisting>
     In this example <literal>CurrentMemoryContext</literal>, which is only
     available in the backend, is referenced and the function thus
     hidden with a <literal>#ifndef FRONTEND</literal>. This rule
     exists because some compilers emit references to symbols
     contained in inline functions even if the function is not used.
    </para>
____________________________________________________________________________-->
    <para>
     当一个内联函数的定义引用只在后端中可用的符号（即变量、函数）时，从前端代码引用该函数时该函数可能不可见。
<programlisting>
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */
</programlisting>
     在这个例子中，<literal>CurrentMemoryContext</literal>只在后端中可用，但该函数引用了它并且该函数因此被<literal>#ifndef FRONTEND</literal>隐藏。之所以存在这条规则，是因为即使内联函数中包含的符号没有被使用，有些编译器也会发出对它们的引用。
    </para>
   </simplesect>

   <simplesect>
<!--==========================orignal english content==========================
    <title>Writing Signal Handlers</title>
____________________________________________________________________________-->
    <title>编写信号处理器</title>
<!--==========================orignal english content==========================
    <para>
     To be suitable to run inside a signal handler code has to be
     written very carefully. The fundamental problem is that, unless
     blocked, a signal handler can interrupt code at any time. If code
     inside the signal handler uses the same state as code outside
     chaos may ensue. As an example consider what happens if a signal
     handler tries to acquire a lock that's already held in the
     interrupted code.
    </para>
____________________________________________________________________________-->
    <para>
     为了能适合在信号处理器中运行，代码必须被非常仔细地编写。根本问题是，除非被阻塞，信号处理器能在任何时候打断代码。如果信号处理器内部的代码使用和外面代码相同的状态，很可能会出现混乱。例如，可以想想如果一个信号处理器试图取得已经在被打断代码中持有的锁时会发生什么。
    </para>
<!--==========================orignal english content==========================
    <para>
     Barring special arrangements code in signal handlers may only
     call async-signal safe functions (as defined in POSIX) and access
     variables of type <literal>volatile sig_atomic_t</literal>. A few
     functions in <command>postgres</command> are also deemed signal safe, importantly
     <function>SetLatch()</function>.
    </para>
____________________________________________________________________________-->
    <para>
     除特殊安排的代码之外，在信号处理器中只应该调用对异步信号安全的函数（如 POSIX 中定义的那样）并且只访问<literal>volatile sig_atomic_t</literal>类型的变量。一些<command>postgres</command>中的函数也被视作是信号安全的，其中很重要的一个是<function>SetLatch()</function>。
    </para>
<!--==========================orignal english content==========================
    <para>
     In most cases signal handlers should do nothing more than note
     that a signal has arrived, and wake up code running outside of
     the handler using a latch. An example of such a handler is the
     following:
<programlisting>
static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}
</programlisting>
     <varname>errno</varname> is saved and restored because
     <function>SetLatch()</function> might change it. If that were not done
     interrupted code that's currently inspecting <varname>errno</varname> might see the wrong
     value.
    </para>
____________________________________________________________________________-->
    <para>
     在大部分情况下，信号处理器应该只提示一个信号已经到达，并且使用一个 latch 唤醒运行在处理器之外的代码。这样一个处理器的例子如下：
<programlisting>
static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}
</programlisting>
     <varname>errno</varname>会被保存并且恢复，因为<function>SetLatch()</function>可能会更改它。如果不这样做，当前正在观测<varname>errno</varname>的被中断代码可能会看到错误的值。
    </para>
   </simplesect>

   <simplesect>
<!--==========================orignal english content==========================
    <title>Calling Function Pointers</title>
____________________________________________________________________________-->
    <title>调用函数指针</title>

<!--==========================orignal english content==========================
    <para>
     For clarity, it is preferred to explicitly dereference a function pointer
     when calling the pointed-to function if the pointer is a simple variable,
     for example:
<programlisting>
(*emit_log_hook) (edata);
</programlisting>
     (even though <literal>emit_log_hook(edata)</literal> would also work).
     When the function pointer is part of a structure, then the extra
     punctuation can and usually should be omitted, for example:
<programlisting>
paramInfo->paramFetch(paramInfo, paramId);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     为了清晰，如果函数指针是一个简单的变量，在调用指向的函数时显式地对其解除引用会更好。例如：
<programlisting>
(*emit_log_hook) (edata);
</programlisting>
     （虽然<literal>emit_log_hook(edata)</literal>还会有效）。当函数指针是一个结构的组成部分时，则额外的标点能够被省略并且通常也应该被省略，例如：
<programlisting>
paramInfo->paramFetch(paramInfo, paramId);
</programlisting>
    </para>
   </simplesect>

  </sect1>

 </chapter>
