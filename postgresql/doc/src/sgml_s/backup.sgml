<!-- doc/src/sgml/backup.sgml -->

<chapter id="backup">
<!--==========================orignal english content==========================
 <title>Backup and Restore</title>
____________________________________________________________________________-->
 <title>备份和恢复</title>

<!--==========================orignal english content==========================
 <indexterm zone="backup"><primary>backup</primary></indexterm>
____________________________________________________________________________-->
 <indexterm zone="backup"><primary>backup</primary></indexterm>

<!--==========================orignal english content==========================
 <para>
  As with everything that contains valuable data, <productname>PostgreSQL</productname>
  databases should be backed up regularly. While the procedure is
  essentially simple, it is important to have a clear understanding of
  the underlying techniques and assumptions.
 </para>
____________________________________________________________________________-->
 <para>
  由于包含着有价值的数据，<productname>PostgreSQL</productname>数据库应当被定期地备份。虽然过程相当简单，但清晰地理解其底层技术和假设是非常重要的。
 </para>

<!--==========================orignal english content==========================
 <para>
  There are three fundamentally different approaches to backing up
  <productname>PostgreSQL</productname> data:
  <itemizedlist>
   <listitem><para><acronym>SQL</acronym> dump</para></listitem>
   <listitem><para>File system level backup</para></listitem>
   <listitem><para>Continuous archiving</para></listitem>
  </itemizedlist>
  Each has its own strengths and weaknesses; each is discussed in turn
  in the following sections.
 </para>
____________________________________________________________________________-->
 <para>
  有三种不同的基本方法来备份<productname>PostgreSQL</productname>数据：
  <itemizedlist>
   <listitem><para><acronym>SQL</acronym>转储</para></listitem>
   <listitem><para>文件系统级备份</para></listitem>
   <listitem><para>连续归档</para></listitem>
  </itemizedlist>
  每一种都有其优缺点，在下面的小节中将分别讨论。
 </para>

 <sect1 id="backup-dump">
<!--==========================orignal english content==========================
  <title><acronym>SQL</acronym> Dump</title>
____________________________________________________________________________-->
  <title><acronym>SQL</acronym>转储</title>

<!--==========================orignal english content==========================
  <para>
   The idea behind this dump method is to generate a file with SQL
   commands that, when fed back to the server, will recreate the
   database in the same state as it was at the time of the dump.
   <productname>PostgreSQL</productname> provides the utility program
   <xref linkend="app-pgdump"/> for this purpose. The basic usage of this
   command is:
<synopsis>
pg_dump <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
   As you see, <application>pg_dump</application> writes its result to the
   standard output. We will see below how this can be useful.
   While the above command creates a text file, <application>pg_dump</application>
   can create files in other formats that allow for parallelism and more
   fine-grained control of object restoration.
  </para>
____________________________________________________________________________-->
  <para>
   SQL 转储方法的思想是创建一个由SQL命令组成的文件，当把这个文件回馈给服务器时，服务器将利用其中的SQL命令重建与转储时状态一样的数据库。 <productname>PostgreSQL</productname>为此提供了工具<xref linkend="app-pgdump"/>。这个工具的基本用法是：
<synopsis>
pg_dump <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
   正如你所见，<application>pg_dump</application>把结果输出到标准输出。我们后面将看到这样做有什么用处。
   尽管上述命令会创建一个文本文件，<application>pg_dump</application>可以用其他格式创建文件以支持并行
   和细粒度的对象恢复控制。
  </para>

<!--==========================orignal english content==========================
  <para>
   <application>pg_dump</application> is a regular <productname>PostgreSQL</productname>
   client application (albeit a particularly clever one). This means
   that you can perform this backup procedure from any remote host that has
   access to the database. But remember that <application>pg_dump</application>
   does not operate with special permissions. In particular, it must
   have read access to all tables that you want to back up, so in order
   to back up the entire database you almost always have to run it as a
   database superuser.  (If you do not have sufficient privileges to back up
   the entire database, you can still back up portions of the database to which
   you do have access using options such as
   <option>-n <replaceable>schema</replaceable></option>
   or <option>-t <replaceable>table</replaceable></option>.)
  </para>
____________________________________________________________________________-->
  <para>
   <application>pg_dump</application>是一个普通的<productname>PostgreSQL</productname>客户端应用（尽管是个
   相当聪明的东西）。这就意味着你可以在任何可以访问该数据库的远端主机上进行备份工作。但是请记住
   <application>pg_dump</application>不会以任何特殊权限运行。具体说来，就是它必须要有你想备份的表的读
   权限，因此为了备份整个数据库你几乎总是必须以一个数据库超级用户来运行它（如果你没有足够的特权
   来备份整个数据库，你仍然可以使用诸如<option>-n <replaceable>schema</replaceable></option>
   或<option>-t <replaceable>table</replaceable></option>选项来备份该数据库中你能够
   访问的部分）。
  </para>

<!--==========================orignal english content==========================
  <para>
   To specify which database server <application>pg_dump</application> should
   contact, use the command line options <option>-h
   <replaceable>host</replaceable></option> and <option>-p <replaceable>port</replaceable></option>. The
   default host is the local host or whatever your
   <envar>PGHOST</envar> environment variable specifies. Similarly,
   the default port is indicated by the <envar>PGPORT</envar>
   environment variable or, failing that, by the compiled-in default.
   (Conveniently, the server will normally have the same compiled-in
   default.)
  </para>
____________________________________________________________________________-->
  <para>
   要声明<application>pg_dump</application>连接哪个数据库服务器，使用命令行选项<option>-h<replaceable>host</replaceable></option>和 <option>-p <replaceable>port</replaceable></option>。 默认主机是本地主机或你的<envar>PGHOST</envar>环境变量指定的主机。 类似地，默认端口是环境变量<envar>PGPORT</envar>或（如果<envar>PGPORT</envar>不存在）内建的默认值。 （服务器通常有相同的默认值，所以还算方便。）
  </para>

<!--==========================orignal english content==========================
  <para>
   Like any other <productname>PostgreSQL</productname> client application,
   <application>pg_dump</application> will by default connect with the database
   user name that is equal to the current operating system user name. To override
   this, either specify the <option>-U</option> option or set the
   environment variable <envar>PGUSER</envar>. Remember that
   <application>pg_dump</application> connections are subject to the normal
   client authentication mechanisms (which are described in <xref
   linkend="client-authentication"/>).
  </para>
____________________________________________________________________________-->
  <para>
   和任何其他<productname>PostgreSQL</productname>客户端应用一样， <application>pg_dump</application>默认使用与当前操作系统用户名同名的数据库用户名进行连接。 要使用其他名字，要么声明<option>-U</option>选项，要么设置环境变量<envar>PGUSER</envar>。请注意<application>pg_dump</application>的连接也要通过客户认证机制（在<xref linkend="client-authentication"/>里描述）。
  </para>

<!--==========================orignal english content==========================
  <para>
   An important advantage of <application>pg_dump</application> over the other backup
   methods described later is that <application>pg_dump</application>'s output can
   generally be re-loaded into newer versions of <productname>PostgreSQL</productname>,
   whereas file-level backups and continuous archiving are both extremely
   server-version-specific.  <application>pg_dump</application> is also the only method
   that will work when transferring a database to a different machine
   architecture, such as going from a 32-bit to a 64-bit server.
  </para>
____________________________________________________________________________-->
  <para>
   <application>pg_dump</application>对于其他备份方法的一个重要优势是，<application>pg_dump</application>的输出可以很容易地在新版本的<productname>PostgreSQL</productname>中载入，而文件级备份和连续归档都是极度的服务器版本限定的。<application>pg_dump</application>也是唯一可以将一个数据库传送到一个不同机器架构上的方法，例如从一个32位服务器到一个64位服务器。
  </para>

<!--==========================orignal english content==========================
  <para>
   Dumps created by <application>pg_dump</application> are internally consistent,
   meaning, the dump represents a snapshot of the database at the time
   <application>pg_dump</application> began running. <application>pg_dump</application> does not
   block other operations on the database while it is working.
   (Exceptions are those operations that need to operate with an
   exclusive lock, such as most forms of <command>ALTER TABLE</command>.)
  </para>
____________________________________________________________________________-->
  <para>
   由<application>pg_dump</application>创建的备份在内部是一致的， 也就是说，转储表现了<application>pg_dump</application>开始运行时刻的数据库快照，且在<application>pg_dump</application>运行过程中发生的更新将不会被转储。<application>pg_dump</application>工作的时候并不阻塞其他的对数据库的操作。 （但是会阻塞那些需要排它锁的操作，比如大部分形式的<command>ALTER TABLE</command>）
  </para>

  <sect2 id="backup-dump-restore">
<!--==========================orignal english content==========================
   <title>Restoring the Dump</title>
____________________________________________________________________________-->
   <title>从转储中恢复</title>

<!--==========================orignal english content==========================
   <para>
    Text files created by <application>pg_dump</application> are intended to
    be read in by the <application>psql</application> program. The
    general command form to restore a dump is
<synopsis>
psql <replaceable class="parameter">dbname</replaceable> &lt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
    where <replaceable class="parameter">dumpfile</replaceable> is the
    file output by the <application>pg_dump</application> command. The database <replaceable
    class="parameter">dbname</replaceable> will not be created by this
    command, so you must create it yourself from <literal>template0</literal>
    before executing <application>psql</application> (e.g., with
    <literal>createdb -T template0 <replaceable
    class="parameter">dbname</replaceable></literal>).  <application>psql</application>
    supports options similar to <application>pg_dump</application> for specifying
    the database server to connect to and the user name to use. See
    the <xref linkend="app-psql"/> reference page for more information.
    Non-text file dumps are restored using the <xref
    linkend="app-pgrestore"/> utility.
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_dump</application>生成的文本文件可以由<application>psql</application>程序读取。 从转储中恢复的常用命令是：
<synopsis>
psql <replaceable class="parameter">dbname</replaceable> &lt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
    其中<replaceable class="parameter">dumpfile</replaceable>就是<application>pg_dump</application>命令的输出文件。这条命令不会创建数据库<replaceable class="parameter">dbname</replaceable>，你必须在执行<application>psql</application>前自己从<literal>template0</literal>创建（例如，用命令<literal>createdb -T template0 <replaceable
    class="parameter">dbname</replaceable></literal>）。<application>psql</application>支持类似<application>pg_dump</application>的选项用以指定要连接的数据库服务器和要使用的用户名。参阅<xref linkend="app-psql"/>的手册获取更多信息。
    非文本文件转储可以使用<xref linkend="app-pgrestore"/>工具来恢复。
   </para>

<!--==========================orignal english content==========================
   <para>
    Before restoring an SQL dump, all the users who own objects or were
    granted permissions on objects in the dumped database must already
    exist. If they do not, the restore will fail to recreate the
    objects with the original ownership and/or permissions.
    (Sometimes this is what you want, but usually it is not.)
   </para>
____________________________________________________________________________-->
   <para>
    在开始恢复之前，转储库中对象的拥有者以及在其上被授予了权限的用户必须已经存在。如果它们不存在，那么恢复过程将无法将对象创建成具有原来的所属关系以及权限（有时候这就是你所需要的，但通常不是）。
   </para>

<!--==========================orignal english content==========================
   <para>
    By default, the <application>psql</application> script will continue to
    execute after an SQL error is encountered. You might wish to run
    <application>psql</application> with
    the <literal>ON_ERROR_STOP</literal> variable set to alter that
    behavior and have <application>psql</application> exit with an
    exit status of 3 if an SQL error occurs:
<programlisting>
psql -&minus;set ON_ERROR_STOP=on <replaceable>dbname</replaceable> &lt; <replaceable>dumpfile</replaceable>
</programlisting>
    Either way, you will only have a partially restored database.
    Alternatively, you can specify that the whole dump should be
    restored as a single transaction, so the restore is either fully
    completed or fully rolled back. This mode can be specified by
    passing the <option>-1</option> or <option>-&minus;single-transaction</option>
    command-line options to <application>psql</application>. When using this
    mode, be aware that even a minor error can rollback a
    restore that has already run for many hours. However, that might
    still be preferable to manually cleaning up a complex database
    after a partially restored dump.
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，<application>psql</application>脚本在遇到一个SQL错误后会继续执行。你也许希望在遇到一个SQL错误后让<application>psql</application>退出，那么可以设置<literal>ON_ERROR_STOP</literal>变量来运行<application>psql</application>，这将使<application>psql</application>在遇到SQL错误后退出并返回状态3：
<programlisting>
psql --set ON_ERROR_STOP=on dbname &lt; infile
</programlisting>
    不管怎样，你将只能得到一个部分恢复的数据库。作为另一种选择，你可以指定让整个恢复作为一个单独的事务运行，这样恢复要么完全完成要么完全回滚。这种模式可以通过向<application>psql</application>传递<option>-1</option>或<option>--single-transaction</option>命令行选项来指定。在使用这种模式时，注意即使是很小的一个错误也会导致运行了数小时的恢复被回滚。但是，这仍然比在一个部分恢复后手工清理复杂的数据库要更好。
   </para>

<!--==========================orignal english content==========================
   <para>
    The ability of <application>pg_dump</application> and <application>psql</application> to
    write to or read from pipes makes it possible to dump a database
    directly from one server to another, for example:
<programlisting>
pg_dump -h <replaceable>host1</replaceable> <replaceable>dbname</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>dbname</replaceable>
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_dump</application>和<application>psql</application>读写管道的能力使得直接从一个服务器转储一个数据库到另一个服务器成为可能，例如：
<programlisting>
pg_dump -h <replaceable>host1</replaceable> <replaceable>dbname</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>dbname</replaceable>
</programlisting>
   </para>

   <important>
<!--==========================orignal english content==========================
    <para>
     The dumps produced by <application>pg_dump</application> are relative to
     <literal>template0</literal>. This means that any languages, procedures,
     etc. added via <literal>template1</literal> will also be dumped by
     <application>pg_dump</application>. As a result, when restoring, if you are
     using a customized <literal>template1</literal>, you must create the
     empty database from <literal>template0</literal>, as in the example
     above.
    </para>
____________________________________________________________________________-->
    <para>
     <application>pg_dump</application>产生的转储是相对于<literal>template0</literal>。这意味着在<literal>template1</literal>中加入的任何语言、过程等都会被<application>pg_dump</application>转储。结果是，如果在恢复时使用的是一个自定义的<literal>template1</literal>，你必须从<literal>template0</literal>创建一个空的数据库，正如上面的例子所示。
    </para>
   </important>

<!--==========================orignal english content==========================
   <para>
    After restoring a backup, it is wise to run <xref
    linkend="sql-analyze"/> on each
    database so the query optimizer has useful statistics;
    see <xref linkend="vacuum-for-statistics"/>
    and <xref linkend="autovacuum"/> for more information.
    For more advice on how to load large amounts of data
    into <productname>PostgreSQL</productname> efficiently, refer to <xref
    linkend="populate"/>.
   </para>
____________________________________________________________________________-->
   <para>
    一旦完成恢复，在每个数据库上运行<xref linkend="sql-analyze"/>是明智的举动，这样优化器就有有用的统计数据了，更多信息参见<xref linkend="vacuum-for-statistics"/>和<xref linkend="autovacuum"/>。更多关于如何有效地向<productname>PostgreSQL</productname>里装载大量数据的建议， 请参考<xref linkend="populate"/>。
   </para>
  </sect2>

  <sect2 id="backup-dump-all">
<!--==========================orignal english content==========================
   <title>Using <application>pg_dumpall</application></title>
____________________________________________________________________________-->
   <title>使用<application>pg_dumpall</application></title>

<!--==========================orignal english content==========================
   <para>
    <application>pg_dump</application> dumps only a single database at a time,
    and it does not dump information about roles or tablespaces
    (because those are cluster-wide rather than per-database).
    To support convenient dumping of the entire contents of a database
    cluster, the <xref linkend="app-pg-dumpall"/> program is provided.
    <application>pg_dumpall</application> backs up each database in a given
    cluster, and also preserves cluster-wide data such as role and
    tablespace definitions. The basic usage of this command is:
<synopsis>
pg_dumpall &gt; <replaceable>dumpfile</replaceable>
</synopsis>
    The resulting dump can be restored with <application>psql</application>:
<synopsis>
psql -f <replaceable class="parameter">dumpfile</replaceable> postgres
</synopsis>
    (Actually, you can specify any existing database name to start from,
    but if you are loading into an empty cluster then <literal>postgres</literal>
    should usually be used.)  It is always necessary to have
    database superuser access when restoring a <application>pg_dumpall</application>
    dump, as that is required to restore the role and tablespace information.
    If you use tablespaces, make sure that the tablespace paths in the
    dump are appropriate for the new installation.
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_dump</application>每次只转储一个数据库，而且它不会转储关于角色或表空间（因为它们是集簇范围的）的信息。为了支持方便地转储一个数据库集簇的全部内容，提供了<xref linkend="app-pg-dumpall"/>程序。<application>pg_dumpall</application>备份一个给定集簇中的每一个数据库，并且也保留了集簇范围的数据，如角色和表空间定义。该命令的基本用法是：
<synopsis>
pg_dumpall &gt; <replaceable>dumpfile</replaceable>
</synopsis>
    转储的结果可以使用<application>psql</application>恢复：
<synopsis>
psql -f <replaceable class="parameter">dumpfile</replaceable> postgres
</synopsis>
    （实际上，你可以指定恢复到任何已有数据库名，但是如果你正在将转储载入到一个空集簇中则通常要用（<literal>postgres</literal>）。在恢复一个<application>pg_dumpall</application>转储时常常需要具有数据库超级用户访问权限，因为它需要恢复角色和表空间信息。如果你在使用表空间，请确保转储中的表空间路径适合于新的安装。
   </para>

<!--==========================orignal english content==========================
   <para>
    <application>pg_dumpall</application> works by emitting commands to re-create
    roles, tablespaces, and empty databases, then invoking
    <application>pg_dump</application> for each database.  This means that while
    each database will be internally consistent, the snapshots of
    different databases are not synchronized.
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_dumpall</application>工作时会发出命令重新创建角色、表空间和空数据库，接着为每一个数据库<application>pg_dump</application>。这意味着每个数据库自身是一致的，但是不同数据库的快照并不同步。
   </para>

<!--==========================orignal english content==========================
   <para>
    Cluster-wide data can be dumped alone using the
    <application>pg_dumpall</application> <option>-&minus;globals-only</option> option.
    This is necessary to fully backup the cluster if running the
    <application>pg_dump</application> command on individual databases.
   </para>
____________________________________________________________________________-->
   <para>
    集簇范围的数据可以使用<application>pg_dumpall</application>的<option>--globals-only</option>选项来单独转储。如果在单个数据库上运行<application>pg_dump</application>命令，上述做法对于完全备份整个集簇是必需的。
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
<!--==========================orignal english content==========================
   <title>Handling Large Databases</title>
____________________________________________________________________________-->
   <title>处理大型数据库</title>

<!--==========================orignal english content==========================
   <para>
    Some operating systems have maximum file size limits that cause
    problems when creating large <application>pg_dump</application> output files.
    Fortunately, <application>pg_dump</application> can write to the standard
    output, so you can use standard Unix tools to work around this
    potential problem.  There are several possible methods:
   </para>
____________________________________________________________________________-->
   <para>
    在一些具有最大文件尺寸限制的操作系统上创建大型的<application>pg_dump</application>输出文件可能会出现问题。幸运地是，<application>pg_dump</application>可以写出到标准输出，因此你可以使用标准Unix工具来处理这种潜在的问题。有几种可能的方法：
   </para>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Use compressed dumps.</title>
____________________________________________________________________________-->
    <title>使用压缩转储。</title>
<!--==========================orignal english content==========================
    <para>
     You can use your favorite compression program, for example
     <application>gzip</application>:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>

     Reload with:

<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

     or:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     你可以使用你喜欢的压缩程序，例如<application>gzip</application>：

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>

     恢复：

<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

     或者：

<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Use <command>split</command>.</title>
____________________________________________________________________________-->
    <title>使用<command>split</command>。</title>
<!--==========================orignal english content==========================
    <para>
     The <command>split</command> command
     allows you to split the output into smaller files that are
     acceptable in size to the underlying file system. For example, to
     make chunks of 1 megabyte:

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 1m - <replaceable class="parameter">filename</replaceable>
</programlisting>

     Reload with:

<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     <command>split</command>命令允许你将输出分割成较小的文件以便能够适应底层文件系统的尺寸要求。例如，让每一块的大小为1兆字节：

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 1m - <replaceable class="parameter">filename</replaceable>
</programlisting>

     恢复：

<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Use <application>pg_dump</application>'s custom dump format.</title>
____________________________________________________________________________-->
    <title>使用<application>pg_dump</application>的自定义转储格式。</title>
<!--==========================orignal english content==========================
    <para>
     If <productname>PostgreSQL</productname> was built on a system with the
     <application>zlib</application> compression library installed, the custom dump
     format will compress data as it writes it to the output file. This will
     produce dump file sizes similar to using <command>gzip</command>, but it
     has the added advantage that tables can be restored selectively. The
     following command dumps a database using the custom dump format:

<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>

     A custom-format dump is not a script for <application>psql</application>, but
     instead must be restored with <application>pg_restore</application>, for example:

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>

     See the <xref linkend="app-pgdump"/> and <xref
     linkend="app-pgrestore"/> reference pages for details.
    </para>
____________________________________________________________________________-->
    <para>
     如果<productname>PostgreSQL</productname>所在的系统上安装了<application>zlib</application>压缩库，自定义转储格式将在写出数据到输出文件时对其压缩。这将产生和使用<command>gzip</command>时差不多大小的转储文件，但是这种方式的一个优势是其中的表可以被有选择地恢复。下面的命令使用自定义转储格式来转储一个数据库：

<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>

     自定义格式的转储不是<application>psql</application>的脚本，只能通过<application>pg_restore</application>恢复，例如：

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>

     详情请参阅<xref linkend="app-pgdump"/>和<xref linkend="app-pgrestore"/>。
    </para>
   </formalpara>

<!--==========================orignal english content==========================
   <para>
    For very large databases, you might need to combine <command>split</command>
    with one of the other two approaches.
   </para>
____________________________________________________________________________-->
   <para>
    对于非常大型的数据库，你可能需要将<command>split</command>配合其他两种方法之一进行使用。
   </para>

   <formalpara>
<!--==========================orignal english content==========================
    <title>Use <application>pg_dump</application>'s parallel dump feature.</title>
____________________________________________________________________________-->
    <title>使用<application>pg_dump</application>的并行转储特性。</title>
<!--==========================orignal english content==========================
    <para>
     To speed up the dump of a large database, you can use
     <application>pg_dump</application>'s parallel mode. This will dump
     multiple tables at the same time. You can control the degree of
     parallelism with the <command>-j</command> parameter. Parallel dumps
     are only supported for the "directory" archive format.

<programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">out.dir</replaceable> <replaceable class="parameter">dbname</replaceable>
</programlisting>

     You can use <command>pg_restore -j</command> to restore a dump in parallel.
     This will work for any archive of either the "custom" or the "directory"
     archive mode, whether or not it has been created with <command>pg_dump -j</command>.
    </para>
____________________________________________________________________________-->
    <para>
     为了加快转储一个大型数据库的速度，你可以使用<application>pg_dump</application>的并行模式。它将同时转储多个表。你可以使用<command>-j</command>参数控制并行度。并行转储只支持“目录”归档格式。

<programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">out.dir</replaceable> <replaceable class="parameter">dbname</replaceable>
</programlisting>

     你可以使用<command>pg_restore -j</command>来以并行方式恢复一个转储。它只能适合于“自定义”归档或者“目录”归档，但不管归档是否由<command>pg_dump -j</command>创建。
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="backup-file">
<!--==========================orignal english content==========================
  <title>File System Level Backup</title>
____________________________________________________________________________-->
  <title>文件系统级别备份</title>

<!--==========================orignal english content==========================
  <para>
   An alternative backup strategy is to directly copy the files that
   <productname>PostgreSQL</productname> uses to store the data in the database;
   <xref linkend="creating-cluster"/> explains where these files
   are located.  You can use whatever method you prefer
   for doing file system backups; for example:

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   另外一种备份策略是直接复制<productname>PostgreSQL</productname>用于存储数据库中数据的文件，<xref linkend="creating-cluster"/>解释了这些文件的位置。你可以采用任何你喜欢的方式进行文件系统备份，例如：

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   There are two restrictions, however, which make this method
   impractical, or at least inferior to the <application>pg_dump</application>
   method:

   <orderedlist>
    <listitem>
     <para>
      The database server <emphasis>must</emphasis> be shut down in order to
      get a usable backup. Half-way measures such as disallowing all
      connections will <emphasis>not</emphasis> work
      (in part because <command>tar</command> and similar tools do not take
      an atomic snapshot of the state of the file system,
      but also because of internal buffering within the server).
      Information about stopping the server can be found in
      <xref linkend="server-shutdown"/>.  Needless to say, you
      also need to shut down the server before restoring the data.
     </para>
    </listitem>

    <listitem>
     <para>
      If you have dug into the details of the file system layout of the
      database, you might be tempted to try to back up or restore only certain
      individual tables or databases from their respective files or
      directories. This will <emphasis>not</emphasis> work because the
      information contained in these files is not usable without
      the commit log files,
      <filename>pg_xact/*</filename>, which contain the commit status of
      all transactions. A table file is only usable with this
      information. Of course it is also impossible to restore only a
      table and the associated <filename>pg_xact</filename> data
      because that would render all other tables in the database
      cluster useless.  So file system backups only work for complete
      backup and restoration of an entire database cluster.
     </para>
    </listitem>
   </orderedlist>
  </para>
____________________________________________________________________________-->
  <para>
   但是这种方法有两个限制，使得这种方法不实用，或者说至少比<application>pg_dump</application>方法差：

   <orderedlist>
    <listitem>
     <para>
      为了得到一个可用的备份，数据库服务器<emphasis>必须</emphasis>被关闭。例如阻止所有连接的半路措施是<emphasis>不起作用</emphasis>的（部分原因是<command>tar</command>和类似工具无法得到文件系统状态的一个原子的快照，还有服务器内部缓冲的原因）。关于停止服务器的信息可以在<xref linkend="server-shutdown"/>中找到。不用说，在恢复数据之前你也需要关闭服务器。
     </para>
    </listitem>

    <listitem>
     <para>
      如果你已经深入地了解了数据库的文件系统布局的细节，你可能会有兴趣尝试通过相应的文件或目录来备份或恢复特定的表或数据库。这种方法也<emphasis>不会</emphasis>起作用，因为包含在这些文件中的信息只有配合提交日志文件（<filename>pg_xact/*</filename>）才有用，提交日志文件包含了所有事务的提交状态。一个表文件只有和这些信息一起才有用。当然也不可能只恢复一个表及相关的<filename>pg_xact</filename>数据，因为这会导致数据库集簇中所有其他表变得无用。因此文件系统备份值适合于完整地备份或恢复整个数据库集簇。
     </para>
    </listitem>
   </orderedlist>
  </para>

<!--==========================orignal english content==========================
  <para>
   An alternative file-system backup approach is to make a
   <quote>consistent snapshot</quote> of the data directory, if the
   file system supports that functionality (and you are willing to
   trust that it is implemented correctly).  The typical procedure is
   to make a <quote>frozen snapshot</quote> of the volume containing the
   database, then copy the whole data directory (not just parts, see
   above) from the snapshot to a backup device, then release the frozen
   snapshot.  This will work even while the database server is running.
   However, a backup created in this way saves
   the database files in a state as if the database server was not
   properly shut down; therefore, when you start the database server
   on the backed-up data, it will think the previous server instance
   crashed and will replay the WAL log.  This is not a problem; just
   be aware of it (and be sure to include the WAL files in your backup).
   You can perform a <command>CHECKPOINT</command> before taking the
   snapshot to reduce recovery time.
  </para>
____________________________________________________________________________-->
  <para>
   另一种文件系统备份方法是创建一个数据目录的<quote>一致快照</quote>，如果文件系统支持此功能（并且你相信它的实现正确）。典型的过程是创建一个包含数据库的卷的<quote>冻结快照</quote>，然后从该快照复制整个数据目录（如上，不能是部分复制）到备份设备，最后释放冻结快照。即使在数据库服务器运行时，这种方式也有效。但是，以这种方式创建的备份保存的文件看起来就像数据库没有被正确关闭时的状态。因此，当你从备份数据上启动数据库服务器时，它会认为上一次的服务器实例崩溃了并尝试重放WAL日志。这不是问题，只是需要注意（当然WAL文件必须要包括在备份中）。你可以在拍摄快照之前执行一次<command>CHECKPOINT</command>以便节省恢复时间。
  </para>

<!--==========================orignal english content==========================
  <para>
   If your database is spread across multiple file systems, there might not
   be any way to obtain exactly-simultaneous frozen snapshots of all
   the volumes.  For example, if your data files and WAL log are on different
   disks, or if tablespaces are on different file systems, it might
   not be possible to use snapshot backup because the snapshots
   <emphasis>must</emphasis> be simultaneous.
   Read your file system documentation very carefully before trusting
   the consistent-snapshot technique in such situations.
  </para>
____________________________________________________________________________-->
  <para>
   如果你的数据库跨越多个文件系统，可能没有任何方式可以对所有卷获得完全同步的冻结快照。例如，如果你的数据文件和WAL日志放置在不同的磁盘上，或者表空间在不同的文件系统中，可能没有办法使用快照备份，因为快照<emphasis>必须</emphasis>是同步的。在这些情况下，一定要仔细阅读你的文件系统文档以了解其对一致快照技术的支持。
  </para>

<!--==========================orignal english content==========================
  <para>
   If simultaneous snapshots are not possible, one option is to shut down
   the database server long enough to establish all the frozen snapshots.
   Another option is to perform a continuous archiving base backup (<xref
   linkend="backup-base-backup"/>) because such backups are immune to file
   system changes during the backup.  This requires enabling continuous
   archiving just during the backup process; restore is done using
   continuous archive recovery (<xref linkend="backup-pitr-recovery"/>).
  </para>
____________________________________________________________________________-->
  <para>
   如果没有可能获得同步快照，一种选择是将数据库服务器关闭足够长的时间以建立所有的冻结快照。另一种选择是执行一次连续归档基础备份（<xref linkend="backup-base-backup"/>），因为这种备份对于备份期间发生的文件系统改变是免疫的。这要求在备份过程中允许连续归档，恢复时使用连续归档恢复（<xref linkend="backup-pitr-recovery"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another option is to use <application>rsync</application> to perform a file
   system backup.  This is done by first running <application>rsync</application>
   while the database server is running, then shutting down the database
   server long enough to do an <command>rsync -&minus;checksum</command>.
   (<option>-&minus;checksum</option> is necessary because <command>rsync</command> only
   has file modification-time granularity of one second.)  The
   second <application>rsync</application> will be quicker than the first,
   because it has relatively little data to transfer, and the end result
   will be consistent because the server was down.  This method
   allows a file system backup to be performed with minimal downtime.
  </para>
____________________________________________________________________________-->
  <para>
   还有一种选择是使用<application>rsync</application>来执行一次文件系统备份。其做法是先在数据库服务器运行时执行<application>rsync</application>，然后关闭数据库服务器足够长时间来做一次<command>rsync --checksum</command>
（<option>--checksum</option>是必需的，因为<command>rsync</command>的文件修改
时间粒度只能精确到秒）。第二次<application>rsync</application>会比第一次快，因为它只需要传送相对很少的数据，由于服务器是停止的，所以最终结果将是一致的。这种方法允许在最小停机时间内执行一次文件系统备份。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that a file system backup will typically be larger
   than an SQL dump. (<application>pg_dump</application> does not need to dump
   the contents of indexes for example, just the commands to recreate
   them.)  However, taking a file system backup might be faster.
  </para>
____________________________________________________________________________-->
  <para>
   注意一个文件系统备份通常会比一个SQL转储体积更大（例如<application>pg_dump</application>不需要转储索引的内容，而是转储用于重建索引的命令）。但是，做一次文件系统备份可能更快。
  </para>
 </sect1>

 <sect1 id="continuous-archiving">
<!--==========================orignal english content==========================
  <title>Continuous Archiving and Point-in-Time Recovery (PITR)</title>
____________________________________________________________________________-->
  <title>连续归档和时间点恢复（PITR）</title>

<!--==========================orignal english content==========================
  <indexterm zone="backup">
   <primary>continuous archiving</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="backup">
   <primary>continuous archiving</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="backup">
   <primary>point-in-time recovery</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="backup">
   <primary>point-in-time recovery</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   At all times, <productname>PostgreSQL</productname> maintains a
   <firstterm>write ahead log</firstterm> (WAL) in the <filename>pg_wal/</filename>
   subdirectory of the cluster's data directory. The log records
   every change made to the database's data files.  This log exists
   primarily for crash-safety purposes: if the system crashes, the
   database can be restored to consistency by <quote>replaying</quote> the
   log entries made since the last checkpoint.  However, the existence
   of the log makes it possible to use a third strategy for backing up
   databases: we can combine a file-system-level backup with backup of
   the WAL files.  If recovery is needed, we restore the file system backup and
   then replay from the backed-up WAL files to bring the system to a
   current state.  This approach is more complex to administer than
   either of the previous approaches, but it has some significant
   benefits:
  <itemizedlist>
   <listitem>
    <para>
     We do not need a perfectly consistent file system backup as the starting point.
     Any internal inconsistency in the backup will be corrected by log
     replay (this is not significantly different from what happens during
     crash recovery).  So we do not need a file system snapshot capability,
     just <application>tar</application> or a similar archiving tool.
    </para>
   </listitem>
   <listitem>
    <para>
     Since we can combine an indefinitely long sequence of WAL files
     for replay, continuous backup can be achieved simply by continuing to archive
     the WAL files.  This is particularly valuable for large databases, where
     it might not be convenient to take a full backup frequently.
    </para>
   </listitem>
   <listitem>
    <para>
     It is not necessary to replay the WAL entries all the
     way to the end.  We could stop the replay at any point and have a
     consistent snapshot of the database as it was at that time.  Thus,
     this technique supports <firstterm>point-in-time recovery</firstterm>: it is
     possible to restore the database to its state at any time since your base
     backup was taken.
    </para>
   </listitem>
   <listitem>
    <para>
     If we continuously feed the series of WAL files to another
     machine that has been loaded with the same base backup file, we
     have a <firstterm>warm standby</firstterm> system: at any point we can bring up
     the second machine and it will have a nearly-current copy of the
     database.
    </para>
   </listitem>
  </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   在任何时间，<productname>PostgreSQL</productname>在数据集簇目录的<filename>pg_wal/</filename>子目录下都保持有一个<firstterm>预写式日志</firstterm>（WAL）。这个日志存在的目的是为了保证崩溃后的安全：如果系统崩溃，可以<quote>重放</quote>从最后一次检查点以来的日志项来恢复数据库的一致性。该日志的存在也使得第三种备份数据库的策略变得可能：我们可以把一个文件系统级别的备份和WAL文件的备份结合起来。当需要恢复时，我们先恢复文件系统备份，然后从备份的WAL文件中重放来把系统带到一个当前状态。这种方法比之前的方法管理起来要更复杂，但是有其显著的优点：
  <itemizedlist>
   <listitem>
    <para>
     我们不需要一个完美的一致的文件系统备份作为开始点。备份中的任何内部不一致性将通过日志重放（这和崩溃恢复期间发生的并无显著不同）来修正。因此我们不需要文件系统快照功能，只需要<application>tar</application>或一个类似的归档工具。
    </para>
   </listitem>
   <listitem>
    <para>
     由于我们可以结合一个无穷长的WAL文件序列用于重放，可以通过简单地归档WAL文件来达到连续备份。这对于大型数据库特别有用，因为在其中不方便频繁地进行完全备份。
    </para>
   </listitem>
   <listitem>
    <para>
     并不需要一直重放WAL项一直到最后。我们可以在任何点停止重放，并得到一个数据库在当时的一致快照。这样，该技术支持<firstterm>时间点恢复</firstterm>：在得到你的基础备份以后，可以将数据库恢复到它在其后任何时间的状态。
    </para>
   </listitem>
   <listitem>
    <para>
     如果我们连续地将一系列WAL文件输送给另一台已经载入了相同基础备份文件的机器，我们就得到了一个<firstterm>热后备</firstterm>系统：在任何时间点我们都能提出第二台机器，它差不多是数据库的当前副本。
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    <application>pg_dump</application> and
    <application>pg_dumpall</application> do not produce file-system-level
    backups and cannot be used as part of a continuous-archiving solution.
    Such dumps are <emphasis>logical</emphasis> and do not contain enough
    information to be used by WAL replay.
   </para>
____________________________________________________________________________-->
   <para>
    <application>pg_dump</application>和<application>pg_dumpall</application>不会产生文件系统级别的备份，并且不能用于连续归档方案。这类转储是<emphasis>逻辑</emphasis>的并且不包含足够的信息用于WAL重放。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   As with the plain file-system-backup technique, this method can only
   support restoration of an entire database cluster, not a subset.
   Also, it requires a lot of archival storage: the base backup might be bulky,
   and a busy system will generate many megabytes of WAL traffic that
   have to be archived.  Still, it is the preferred backup technique in
   many situations where high reliability is needed.
  </para>
____________________________________________________________________________-->
  <para>
   就简单的文件系统备份技术来说，这种方法只能支持整个数据库集簇的恢复，却无法支持其中一个子集的恢复。另外，它需要大量的归档存储：一个基础备份的体积可能很庞大，并且一个繁忙的系统将会产生大量需要被归档的WAL流量。尽管如此，在很多需要高可靠性的情况下，它是首选的备份技术。
  </para>

<!--==========================orignal english content==========================
  <para>
   To recover successfully using continuous archiving (also called
   <quote>online backup</quote> by many database vendors), you need a continuous
   sequence of archived WAL files that extends back at least as far as the
   start time of your backup.  So to get started, you should set up and test
   your procedure for archiving WAL files <emphasis>before</emphasis> you take your
   first base backup.  Accordingly, we first discuss the mechanics of
   archiving WAL files.
  </para>
____________________________________________________________________________-->
  <para>
   要使用连续归档（也被很多数据库厂商称为<quote>在线备份</quote>）成功地恢复，你需要一个从基础备份时间开始的连续的归档WAL文件序列。为了开始，在你建立第一个基础备份<emphasis>之前</emphasis>，你应该建立并测试用于归档WAL文件的过程。对应地，我们首先讨论归档WAL文件的机制。
  </para>

  <sect2 id="backup-archiving-wal">
<!--==========================orignal english content==========================
   <title>Setting Up WAL Archiving</title>
____________________________________________________________________________-->
   <title>建立WAL归档</title>

<!--==========================orignal english content==========================
   <para>
    In an abstract sense, a running <productname>PostgreSQL</productname> system
    produces an indefinitely long sequence of WAL records.  The system
    physically divides this sequence into WAL <firstterm>segment
    files</firstterm>, which are normally 16MB apiece (although the segment size
    can be altered during <application>initdb</application>).  The segment
    files are given numeric names that reflect their position in the
    abstract WAL sequence.  When not using WAL archiving, the system
    normally creates just a few segment files and then
    <quote>recycles</quote> them by renaming no-longer-needed segment files
    to higher segment numbers.  It's assumed that segment files whose
    contents precede the last checkpoint are no longer of
    interest and can be recycled.
   </para>
____________________________________________________________________________-->
   <para>
    抽象地来说，一个运行中的<productname>PostgreSQL</productname>系统产生一个无穷长的WAL记录序列。系统从物理上将这个序列划分成WAL <firstterm>段文件</firstterm>，通常是每个16MB（段尺寸在<application>initdb</application>期间可修改）。段文件会被分配一个数字名称以便反映它在整个抽象WAL序列中的位置。在没有使用WAL归档时，系统通常只创建少量段文件，并且通过重命名不再使用的段文件为更高的段编号来<quote>回收</quote>它们。系统假设内容位于最后一个检查点之前的段文件是无用的且可以被回收。
   </para>

<!--==========================orignal english content==========================
   <para>
    When archiving WAL data, we need to capture the contents of each segment
    file once it is filled, and save that data somewhere before the segment
    file is recycled for reuse.  Depending on the application and the
    available hardware, there could be many different ways of <quote>saving
    the data somewhere</quote>: we could copy the segment files to an NFS-mounted
    directory on another machine, write them onto a tape drive (ensuring that
    you have a way of identifying the original name of each file), or batch
    them together and burn them onto CDs, or something else entirely.  To
    provide the database administrator with flexibility,
    <productname>PostgreSQL</productname> tries not to make any assumptions about how
    the archiving will be done.  Instead, <productname>PostgreSQL</productname> lets
    the administrator specify a shell command to be executed to copy a
    completed segment file to wherever it needs to go.  The command could be
    as simple as a <literal>cp</literal>, or it could invoke a complex shell
    script &mdash; it's all up to you.
   </para>
____________________________________________________________________________-->
   <para>
    在归档WAL数据时，我们需要在每一段被填充满时捕捉其内容，并且在段文件被回收重用之前保存该数据。依靠应用和可用的硬件，有很多不同的方法来<quote>保存数据</quote>：我们可以将段文件拷贝到一个已挂载的位于另一台机器上的NFS目录，或者将它们写出到一个磁带驱动器（确保你有办法标识每个文件的原始文件名），或者将它们批量烧录到CD上，或者其他什么方法。为了向数据库管理员提供灵活性，<productname>PostgreSQL</productname>不对如何归档做任何假设。取而代之的是，<productname>PostgreSQL</productname>让管理员声明一个shell命令来拷贝一个完整的段文件到它需要去的地方。 该命令可以简单得就是一个<literal>cp</literal>，或者它可以调用一个复杂的 shell 脚本 &mdash; 所有都由你决定。
   </para>

<!--==========================orignal english content==========================
   <para>
    To enable WAL archiving, set the <xref linkend="guc-wal-level"/>
    configuration parameter to <literal>replica</literal> or higher,
    <xref linkend="guc-archive-mode"/> to <literal>on</literal>,
    and specify the shell command to use in the <xref
    linkend="guc-archive-command"/> configuration parameter.  In practice
    these settings will always be placed in the
    <filename>postgresql.conf</filename> file.
    In <varname>archive_command</varname>,
    <literal>%p</literal> is replaced by the path name of the file to
    archive, while <literal>%f</literal> is replaced by only the file name.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Use <literal>%%</literal> if you need to embed an actual <literal>%</literal>
    character in the command.  The simplest useful command is something
    like:
<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
</programlisting>
    which will copy archivable WAL segments to the directory
    <filename>/mnt/server/archivedir</filename>.  (This is an example, not a
    recommendation, and might not work on all platforms.)  After the
    <literal>%p</literal> and <literal>%f</literal> parameters have been replaced,
    the actual command executed might look like this:
<programlisting>
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
</programlisting>
    A similar command will be generated for each new file to be archived.
   </para>
____________________________________________________________________________-->
   <para>
    要启用WAL归档，需设置<xref linkend="guc-wal-level"/>配置参数为<literal>replica</literal>或更高，设置<xref linkend="guc-archive-mode"/>为<literal>on</literal>，并且使用<xref linkend="guc-archive-command"/>配置参数指定一个shell命令。实际上，这些设置总是被放置在<filename>postgresql.conf</filename>文件中。在<varname>archive_command</varname>中，<literal>%p</literal>会被将要归档的文件路径所替代，而<literal>%f</literal>只会被文件名所替代（路径名是相对于当前工作目录而言的，即集簇的数据目录）。如果你需要在命令中嵌入一个真正的<literal>%</literal>字符，可以使用<literal>%%</literal>。最简单的命令类似于：
<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
</programlisting>
    它将把 WAL 段拷贝到目录<filename>/mnt/server/archivedir</filename>（这个只是一个例子，并非我们建议的方法，可能不能在所有系统上都正确运行）。在<literal>%p</literal>和<literal>%f</literal>参数被替换之后，实际被执行的命令看起来可能是：
<programlisting>
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
</programlisting>
    对每一个将要被归档的新文件都会生成一个类似的命令。
   </para>

<!--==========================orignal english content==========================
   <para>
    The archive command will be executed under the ownership of the same
    user that the <productname>PostgreSQL</productname> server is running as.  Since
    the series of WAL files being archived contains effectively everything
    in your database, you will want to be sure that the archived data is
    protected from prying eyes; for example, archive into a directory that
    does not have group or world read access.
   </para>
____________________________________________________________________________-->
   <para>
    归档命令将在运行<productname>PostgreSQL</productname>服务器的同一个用户的权限下执行。因为被归档的一系列WAL 文件实际上包含你的数据库里的所有东西，所以你应该确保自己的归档数据不会被别人窥探； 比如，归档到一个没有组或者全局读权限的目录里。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is important that the archive command return zero exit status if and
    only if it succeeds.  Upon getting a zero result,
    <productname>PostgreSQL</productname> will assume that the file has been
    successfully archived, and will remove or recycle it.  However, a nonzero
    status tells <productname>PostgreSQL</productname> that the file was not archived;
    it will try again periodically until it succeeds.
   </para>
____________________________________________________________________________-->
   <para>
    有一点很重要：当且仅当归档命令成功时，它才返回零退出。在得到一个零值结果之后，<productname>PostgreSQL</productname>将假设该文件已经成功归档， 因此它稍后将被删除或者被新的数据覆盖。但是，一个非零值告诉<productname>PostgreSQL</productname>该文件没有被归档； 因此它会周期性的重试直到成功。
   </para>

<!--==========================orignal english content==========================
   <para>
    The archive command should generally be designed to refuse to overwrite
    any pre-existing archive file.  This is an important safety feature to
    preserve the integrity of your archive in case of administrator error
    (such as sending the output of two different servers to the same archive
    directory).
   </para>
____________________________________________________________________________-->
   <para>
    归档命令通常应该被设计成拒绝覆盖已经存在的归档文件。这是一个非常重要的安全特性， 可以在管理员操作失误（比如把两个不同的服务器的输出发送到同一个归档目录）的时候保持你的归档的完整性。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is advisable to test your proposed archive command to ensure that it
    indeed does not overwrite an existing file, <emphasis>and that it returns
    nonzero status in this case</emphasis>.
    The example command above for Unix ensures this by including a separate
    <command>test</command> step.  On some Unix platforms, <command>cp</command> has
    switches such as <option>-i</option> that can be used to do the same thing
    less verbosely, but you should not rely on these without verifying that
    the right exit status is returned.  (In particular, GNU <command>cp</command>
    will return status zero when <option>-i</option> is used and the target file
    already exists, which is <emphasis>not</emphasis> the desired behavior.)
   </para>
____________________________________________________________________________-->
   <para>
    我们建议你首先要测试你准备使用到归档命令，以保证它实际上不会覆盖现有的文件，<emphasis>并且在这种情况下它返回非零状态</emphasis>。以上Unix中的命令例子通过包含一个独立的<command>test</command>步骤来保证这一点。在某些Unix平台上，<command>cp</command>具有诸如<option>-i</option>的开关，可用来更简洁地完成这一切，但是在没有验证返回的退出状态正确之前你不能依赖它们（特别地，GNU的<command>cp</command>在使用<option>-i</option>时将对已存在的目标文件返回状态零，这并<emphasis>不</emphasis>是我们所期望的行为）。
   </para>

<!--==========================orignal english content==========================
   <para>
    While designing your archiving setup, consider what will happen if
    the archive command fails repeatedly because some aspect requires
    operator intervention or the archive runs out of space. For example, this
    could occur if you write to tape without an autochanger; when the tape
    fills, nothing further can be archived until the tape is swapped.
    You should ensure that any error condition or request to a human operator
    is reported appropriately so that the situation can be
    resolved reasonably quickly. The <filename>pg_wal/</filename> directory will
    continue to fill with WAL segment files until the situation is resolved.
    (If the file system containing <filename>pg_wal/</filename> fills up,
    <productname>PostgreSQL</productname> will do a PANIC shutdown.  No committed
    transactions will be lost, but the database will remain offline until
    you free some space.)
   </para>
____________________________________________________________________________-->
   <para>
    在设计你的归档环境时，请考虑一下如果归档命令不停失败会发生什么情况， 因为有些情况要求操作者的干涉，或者是归档空间不够了。 例如，如果你往磁带机上写，但是没有自动换带机，那么就有可能发生这种情况； 如果磁带满了，除非换磁带，否则任何事也做不了。 你应该确保任何错误情况或者任何要求操作员干涉的情况都会被正确报告， 这样才能迅速解决这些问题。否则<filename>pg_wal/</filename>目录会不停地被WAL段文件填充，直到问题解决（如果包含<filename>pg_wal/</filename>的文件系统被填满，<productname>PostgreSQL</productname>将会做一次致命关闭。不会有未提交事务被丢失，但是数据库将会保持离线直到你释放一部分空间）。
   </para>

<!--==========================orignal english content==========================
   <para>
    The speed of the archiving command is unimportant as long as it can keep up
    with the average rate at which your server generates WAL data.  Normal
    operation continues even if the archiving process falls a little behind.
    If archiving falls significantly behind, this will increase the amount of
    data that would be lost in the event of a disaster. It will also mean that
    the <filename>pg_wal/</filename> directory will contain large numbers of
    not-yet-archived segment files, which could eventually exceed available
    disk space. You are advised to monitor the archiving process to ensure that
    it is working as you intend.
   </para>
____________________________________________________________________________-->
   <para>
    归档命令的速度并不要紧，只要它能跟上你的服务器生成 WAL 数据的平均速度即可。即使归档进程稍微落后，正常的操作也会继续进行。 如果归档进程慢很多，就会增加灾难发生的时候丢失的数据量。这同时也意味着<filename>pg_wal/</filename>目录包含大量未归档的段文件， 并且可能最后超出了可用磁盘空间。我们建议你监控归档进程，确保它是按照你的期望运转的。
   </para>

<!--==========================orignal english content==========================
   <para>
    In writing your archive command, you should assume that the file names to
    be archived can be up to 64 characters long and can contain any
    combination of ASCII letters, digits, and dots.  It is not necessary to
    preserve the original relative path (<literal>%p</literal>) but it is necessary to
    preserve the file name (<literal>%f</literal>).
   </para>
____________________________________________________________________________-->
   <para>
    在写自己的归档命令的时候，你应该假设被归档的文件名最长为64个字符并且可以包含 ASCII 字母、数字以及点的任意组合。 我们不需要保持原始的相对路径（<literal>%p</literal>），但是有必要保持文件名（<literal>%f</literal>）。
   </para>

<!--==========================orignal english content==========================
   <para>
    Note that although WAL archiving will allow you to restore any
    modifications made to the data in your <productname>PostgreSQL</productname> database,
    it will not restore changes made to configuration files (that is,
    <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> and
    <filename>pg_ident.conf</filename>), since those are edited manually rather
    than through SQL operations.
    You might wish to keep the configuration files in a location that will
    be backed up by your regular file system backup procedures.  See
    <xref linkend="runtime-config-file-locations"/> for how to relocate the
    configuration files.
   </para>
____________________________________________________________________________-->
   <para>
    请注意尽管 WAL 归档允许你恢复任何对你的<productname>PostgreSQL</productname>数据库中数据所做的修改， 但它不会恢复对配置文件的修改（即<filename>postgresql.conf</filename>、<filename>pg_hba.conf</filename>以及<filename>pg_ident.conf</filename>），因为这些文件都是手工编辑的，而不是通过 SQL 操作来编辑的。 所以你可能会需要把你的配置文件放在一个日常文件系统备份过程可处理的位置。如何重定位配置文件请参阅<xref linkend="runtime-config-file-locations"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    The archive command is only invoked on completed WAL segments.  Hence,
    if your server generates only little WAL traffic (or has slack periods
    where it does so), there could be a long delay between the completion
    of a transaction and its safe recording in archive storage.  To put
    a limit on how old unarchived data can be, you can set
    <xref linkend="guc-archive-timeout"/> to force the server to switch
    to a new WAL segment file at least that often.  Note that archived
    files that are archived early due to a forced switch are still the same
    length as completely full files.  It is therefore unwise to set a very
    short <varname>archive_timeout</varname> &mdash; it will bloat your archive
    storage.  <varname>archive_timeout</varname> settings of a minute or so are
    usually reasonable.
   </para>
____________________________________________________________________________-->
   <para>
    归档命令只会为完成的WAL段调用。因此如果你的服务器产生了一点点WAL流量（或者在产生时有宽松的周期），从一个事务完成到它被安全地记录在归档存储中之间将会有较长的延迟。要为未归档数据设置一个年龄限制，你可以设置<xref linkend="guc-archive-timeout"/>来强制要求服务器按照其设定的频度切换到一个新的WAL段。注意由于强制切换而被归档的文件还是具有和完全归档的文件相同的长度。因此设置一个很短的<varname>archive_timeout</varname>是很不明智的 &mdash; 它会膨胀你的归档存储。将<varname>archive_timeout</varname>设置为1分钟左右通常是合理的。
   </para>

<!--==========================orignal english content==========================
   <para>
    Also, you can force a segment switch manually with
    <function>pg_switch_wal</function> if you want to ensure that a
    just-finished transaction is archived as soon as possible.  Other utility
    functions related to WAL management are listed in <xref
    linkend="functions-admin-backup-table"/>.
   </para>
____________________________________________________________________________-->
   <para>
    同样，如果你希望确保一个刚刚完成的事务能被尽快归档，可以使用<function>pg_switch_wal</function>进行一次手动段切换。其他与WAL管理相关的使用函数在<xref linkend="functions-admin-backup-table"/>中列出。
   </para>

<!--==========================orignal english content==========================
   <para>
    When <varname>wal_level</varname> is <literal>minimal</literal> some SQL commands
    are optimized to avoid WAL logging, as described in <xref
    linkend="populate-pitr"/>.  If archiving or streaming replication were
    turned on during execution of one of these statements, WAL would not
    contain enough information for archive recovery.  (Crash recovery is
    unaffected.)  For this reason, <varname>wal_level</varname> can only be changed at
    server start.  However, <varname>archive_command</varname> can be changed with a
    configuration file reload.  If you wish to temporarily stop archiving,
    one way to do it is to set <varname>archive_command</varname> to the empty
    string (<literal>''</literal>).
    This will cause WAL files to accumulate in <filename>pg_wal/</filename> until a
    working <varname>archive_command</varname> is re-established.
   </para>
____________________________________________________________________________-->
   <para>
    如<xref linkend="populate-pitr"/>所述，当<varname>wal_level</varname>为<literal>minimal</literal>时，一些SQL命令被优化为避免记录WAL日志。在这些语句的其中之一的执行过程中如果打开了归档或流复制，WAL中将不会包含足够的信息用于归档恢（崩溃恢复不受影响）。出于这个原因，<varname>wal_level</varname>只能在服务器启动时修改。但是，<varname>archive_command</varname>可以通过重载配置文件来修改。如果你希望暂时停止归档，一种方式是将<varname>archive_command</varname>设置为空串（<literal>''</literal>）。这将导致WAL文件积累在<filename>pg_wal/</filename>中，直到一个可用的<varname>archive_command</varname>被重新建立。
   </para>
  </sect2>

  <sect2 id="backup-base-backup">
<!--==========================orignal english content==========================
   <title>Making a Base Backup</title>
____________________________________________________________________________-->
   <title> 制作一个基础备份</title>

<!--==========================orignal english content==========================
   <para>
    The easiest way to perform a base backup is to use the
    <xref linkend="app-pgbasebackup"/> tool. It can create
    a base backup either as regular files or as a tar archive. If more
    flexibility than <xref linkend="app-pgbasebackup"/> can provide is
    required, you can also make a base backup using the low level API
    (see <xref linkend="backup-lowlevel-base-backup"/>).
   </para>
____________________________________________________________________________-->
   <para>
    执行一次基础备份最简单的方法是使用<xref linkend="app-pgbasebackup"/>工具。它将会以普通文件或一个tar归档的方式创建一个基础备份。如果需要比<xref linkend="app-pgbasebackup"/>更高的灵活性，你也可以使用低级API（见<xref linkend="backup-lowlevel-base-backup"/>）来制作一个基础备份。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is not necessary to be concerned about the amount of time it takes
    to make a base backup. However, if you normally run the
    server with <varname>full_page_writes</varname> disabled, you might notice a drop
    in performance while the backup runs since <varname>full_page_writes</varname> is
    effectively forced on during backup mode.
   </para>
____________________________________________________________________________-->
   <para>
    没有必要关心创建一个基础备份所需的时间。但是，如果你正常地运行停用了<varname>full_page_writes</varname>的服务器，你可能会注意到备份运行时的性能下降，因为<varname>full_page_writes</varname>在备份模式期间会被实际强制实施。
   </para>

<!--==========================orignal english content==========================
   <para>
    To make use of the backup, you will need to keep all the WAL
    segment files generated during and after the file system backup.
    To aid you in doing this, the base backup process
    creates a <firstterm>backup history file</firstterm> that is immediately
    stored into the WAL archive area. This file is named after the first
    WAL segment file that you need for the file system backup.
    For example, if the starting WAL file is
    <literal>0000000100001234000055CD</literal> the backup history file will be
    named something like
    <literal>0000000100001234000055CD.007C9330.backup</literal>. (The second
    part of the file name stands for an exact position within the WAL
    file, and can ordinarily be ignored.) Once you have safely archived
    the file system backup and the WAL segment files used during the
    backup (as specified in the backup history file), all archived WAL
    segments with names numerically less are no longer needed to recover
    the file system backup and can be deleted. However, you should
    consider keeping several backup sets to be absolutely certain that
    you can recover your data.
   </para>
____________________________________________________________________________-->
   <para>
    要使用备份，你将需要保留所有在文件系统备份期间及之后生成的WAL段文件。为了便于你做这些，基础备份过程会创建一个<firstterm>备份历史文件</firstterm>，它将被立刻存储到WAL归档区域。该文件以文件系统备份中你需要的第一个WAL段文件命名。例如，如果开始的WAL文件是<literal>0000000100001234000055CD</literal>，则备份历史文件将被命名为<literal>0000000100001234000055CD.007C9330.backup</literal>.（文件名的第二部分表明WAL文件中的一个准确位置，一般可以被忽略）。一旦你已经安全地归档了文件系统备份和在备份过程中被使用的WAL段文件（如备份历史文件中所指定的） ，所有名字在数字上低于备份历史文件中记录值的已归档WAL段对于恢复文件系统备份就不再需要了，并且可以被删除。但是你应该考虑保持多个备份集以绝对保证你能恢复你的数据。
   </para>

<!--==========================orignal english content==========================
   <para>
    The backup history file is just a small text file. It contains the
    label string you gave to <xref linkend="app-pgbasebackup"/>, as well as
    the starting and ending times and WAL segments of the backup.
    If you used the label to identify the associated dump file,
    then the archived history file is enough to tell you which dump file to
    restore.
   </para>
____________________________________________________________________________-->
   <para>
    备份历史文件是一个很小的文本文件。它包含你指定给<xref linkend="app-pgbasebackup"/>的标签字符串，以及备份的起止时间以及起止WAL段。如果你使用该标签来标识相关转储文件，则已归档的历史文件足以说明需要哪个转储文件进行恢复。
   </para>

<!--==========================orignal english content==========================
   <para>
    Since you have to keep around all the archived WAL files back to your
    last base backup, the interval between base backups should usually be
    chosen based on how much storage you want to expend on archived WAL
    files.  You should also consider how long you are prepared to spend
    recovering, if recovery should be necessary &mdash; the system will have to
    replay all those WAL segments, and that could take awhile if it has
    been a long time since the last base backup.
   </para>
____________________________________________________________________________-->
   <para>
    由于你不得不保存最后一次基础备份之后的所有归档WAL文件，基础备份之间的间隔通常应该根据你希望在归档WAL文件上花费的存储空间来设定。你也应该考虑你准备花多长时间来进行恢复，如果需要恢复 &mdash; 系统将不得不重放所有那些WAL段，如果这些WAL段覆盖了最后一次基础备份以后的很长时间，重放过程将会花费一些时间。
   </para>
  </sect2>

  <sect2 id="backup-lowlevel-base-backup">
<!--==========================orignal english content==========================
   <title>Making a Base Backup Using the Low Level API</title>
____________________________________________________________________________-->
   <title>使用低级API制作一个基础备份</title>
<!--==========================orignal english content==========================
   <para>
    The procedure for making a base backup using the low level
    APIs contains a few more steps than
    the <xref linkend="app-pgbasebackup"/> method, but is relatively
    simple. It is very important that these steps are executed in
    sequence, and that the success of a step is verified before
    proceeding to the next step.
   </para>
____________________________________________________________________________-->
   <para>
    使用低级API制作一个基础备份的过程比<xref linkend="app-pgbasebackup"/>方法要包含更多的步骤，但相对要更简单。很重要的一点是，这些步骤要按照顺序执行，并且在执行下一步之前要验证上一步是否成功。
   </para>
<!--==========================orignal english content==========================
   <para>
    Low level base backups can be made in a non-exclusive or an exclusive
    way. The non-exclusive method is recommended and the exclusive one is
    deprecated and will eventually be removed.
   </para>
____________________________________________________________________________-->
   <para>
    可以用非排他或者排他的方法来制作低级基础备份。我们推荐非排他方法，而排他
    的方法已经被废弃并且最终将被去除。
   </para>
   <sect3 id="backup-lowlevel-base-backup-nonexclusive">
<!--==========================orignal english content==========================
    <title>Making a non-exclusive low level backup</title>
____________________________________________________________________________-->
    <title>制作一个非排他低级备份</title>
<!--==========================orignal english content==========================
    <para>
     A non-exclusive low level backup is one that allows other
     concurrent backups to be running (both those started using
     the same backup API and those started using
     <xref linkend="app-pgbasebackup"/>).
    </para>
____________________________________________________________________________-->
    <para>
     非排他低级备份允许其他并发备份运行（既包括那些使用同样的
     备份 API 开始的备份，也包括那些使用
     <xref linkend="app-pgbasebackup"/>开始的备份）。
    </para>
<!--==========================orignal english content==========================
    <para>
  <orderedlist>
   <listitem>
    <para>
     Ensure that WAL archiving is enabled and working.
    </para>
   </listitem>
   <listitem>
    <para>
     Connect to the server (it does not matter which database) as a user with
     rights to run pg_start_backup (superuser, or a user who has been granted
     EXECUTE on the function) and issue the command:
<programlisting>
SELECT pg_start_backup('label', false, false);
</programlisting>
     where <literal>label</literal> is any string you want to use to uniquely
     identify this backup operation. The connection
     calling <function>pg_start_backup</function> must be maintained until the end of
     the backup, or the backup will be automatically aborted.
    </para>

    <para>
     By default, <function>pg_start_backup</function> can take a long time to finish.
     This is because it performs a checkpoint, and the I/O
     required for the checkpoint will be spread out over a significant
     period of time, by default half your inter-checkpoint interval
     (see the configuration parameter
     <xref linkend="guc-checkpoint-completion-target"/>).  This is
     usually what you want, because it minimizes the impact on query
     processing.  If you want to start the backup as soon as
     possible, change the second parameter to <literal>true</literal>, which will
     issue an immediate checkpoint using as much I/O as available.
    </para>

    <para>
     The third parameter being <literal>false</literal> tells
     <function>pg_start_backup</function> to initiate a non-exclusive base backup.
    </para>
   </listitem>
   <listitem>
    <para>
     Perform the backup, using any convenient file-system-backup tool
     such as <application>tar</application> or <application>cpio</application> (not
     <application>pg_dump</application> or
     <application>pg_dumpall</application>).  It is neither
     necessary nor desirable to stop normal operation of the database
     while you do this. See
     <xref linkend="backup-lowlevel-base-backup-data"/> for things to
     consider during this backup.
    </para>
   </listitem>
   <listitem>
    <para>
     In the same connection as before, issue the command:
<programlisting>
SELECT * FROM pg_stop_backup(false, true);
</programlisting>
     This terminates backup mode. On a primary, it also performs an automatic
     switch to the next WAL segment.  On a standby, it is not possible to
     automatically switch WAL segments, so you may wish to run
     <function>pg_switch_wal</function> on the primary to perform a manual
     switch. The reason for the switch is to arrange for
     the last WAL segment file written during the backup interval to be
     ready to archive.
    </para>
    <para>
     The <function>pg_stop_backup</function> will return one row with three
     values. The second of these fields should be written to a file named
     <filename>backup_label</filename> in the root directory of the backup. The
     third field should be written to a file named
     <filename>tablespace_map</filename> unless the field is empty. These files are
     vital to the backup working, and must be written without modification.
    </para>
   </listitem>
   <listitem>
    <para>
     Once the WAL segment files active during the backup are archived, you are
     done.  The file identified by <function>pg_stop_backup</function>'s first return
     value is the last segment that is required to form a complete set of
     backup files.  On a primary, if <varname>archive_mode</varname> is enabled and the
     <literal>wait_for_archive</literal> parameter is <literal>true</literal>,
     <function>pg_stop_backup</function> does not return until the last segment has
     been archived.
     On a standby, <varname>archive_mode</varname> must be <literal>always</literal> in order
     for <function>pg_stop_backup</function> to wait.
     Archiving of these files happens automatically since you have
     already configured <varname>archive_command</varname>. In most cases this
     happens quickly, but you are advised to monitor your archive
     system to ensure there are no delays.
     If the archive process has fallen behind
     because of failures of the archive command, it will keep retrying
     until the archive succeeds and the backup is complete.
     If you wish to place a time limit on the execution of
     <function>pg_stop_backup</function>, set an appropriate
     <varname>statement_timeout</varname> value, but make note that if
     <function>pg_stop_backup</function> terminates because of this your backup
     may not be valid.
    </para>
    <para>
     If the backup process monitors and ensures that all WAL segment files
     required for the backup are successfully archived then the
     <literal>wait_for_archive</literal> parameter (which defaults to true) can be set
     to false to have
     <function>pg_stop_backup</function> return as soon as the stop backup record is
     written to the WAL.  By default, <function>pg_stop_backup</function> will wait
     until all WAL has been archived, which can take some time.  This option
     must be used with caution: if WAL archiving is not monitored correctly
     then the backup might not include all of the WAL files and will
     therefore be incomplete and not able to be restored.
    </para>
   </listitem>
  </orderedlist>
    </para>
____________________________________________________________________________-->
    <para>
  <orderedlist>
   <listitem>
    <para>
     确保WAL归档被启用且正在工作。
    </para>
   </listitem>
   <listitem>
    <para>
     作为一个具有运行 pg_start_backup 权利的用户（超级用户，或者被授予在该
     函数上 EXECUTE 的用户）连接到服务器（不在乎是哪个数据库）并且发出命令：
<programlisting>
SELECT pg_start_backup('label', false, false);
</programlisting>
     其中<literal>label</literal>是用来唯一标识这次备份操作的任意字符串。调用
     <function>pg_start_backup</function>的连接必须被保持到备份结束，否则备份
     将被自动中止。
    </para>

    <para>
     默认情况下，<function>pg_start_backup</function>可能需要较长的时间完成。
     这是因为它会执行一个检查点，并且该检查点所需要的 I/O 将会分散到一段
     显著的时间上，默认情况下是你的检查点间隔（见配置参数
     <xref linkend="guc-checkpoint-completion-target"/>）的一半。这通常
     是你所想要的，因为它可以最小化对查询处理的影响。如果你想要尽可能快地
     开始备份，请把第二个参数改成<literal>true</literal>，这将会发出一个立即的检查点并且使用尽可能多的I/O。
    </para>

    <para>
     第三个参数为<literal>false</literal>会告诉<function>pg_start_backup</function>
     开始一次非排他基础备份。
    </para>
   </listitem>
   <listitem>
    <para>
     使用任何趁手的文件系统备份工具（例如<application>tar</application>或者
     <application>cpio</application>，不是<application>pg_dump</application>
     或者<application>pg_dumpall</application>）执行备份。当你做这些
     时，不需要也不值得停止正常的数据库操作。在这类备份期间要考虑的事情
     请见小节<xref linkend="backup-lowlevel-base-backup-data"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     在同一个连接中，发出命令：
<programlisting>
SELECT * FROM pg_stop_backup(false);
</programlisting>
     这会终止备份模式。在主控机上，它还执行一次自动切换到下一个WAL段。在后备机上，它无法自动切换WAL段，因此用户可能希望在主控机上运行<function>pg_switch_wal</function>来执行一次手工切换。要做切换的原因是让在备份期间写入的最后一个WAL段文件能准备好被归档。
    </para>
    <para>
     <function>pg_stop_backup</function>将返回一个具有三个值的行。这些域的
     第二个应该被写入到该备份根目录中名为<filename>backup_label</filename>的
     文件。第三个域应该被写入到一个名为<filename>tablespace_map</filename>
     的文件，除非该域为空。这些文件对该备份正常工作来说是至关重要的，
     不能被随意修改。
    </para>
   </listitem>
   <listitem>
    <para>
     一旦备份期间活动的WAL段文件被归档，备份就完成了。由
     <function>pg_stop_backup</function>的第一个返回值标识的文件是构成一个
     完整备份文件集合所需的最后一个段。在主控机上，如果<varname>archive_mode</varname>被启用并且<literal>wait_for_archive</literal>参数为<literal>true</literal>，在最后一个段被归档之前<function>pg_stop_backup</function>都不会返回。在后备机上，为了让<function>pg_stop_backup</function>等待，<varname>archive_mode</varname>必须为<literal>always</literal>。从你已经配置好<varname>archive_command</varname>之后这些文件的
     归档就会自动发生。在大部分情况下，这些归档会很快发生，但是建议你监
     控你的归档系统确保没有延迟。如果归档进程由于归档命令的失败而落后，
     它将会持续重试知道归档成功并且备份完成。如果你希望对
     <function>pg_stop_backup</function>的执行给出一个时间限制，可以设置一个
     合适的<varname>statement_timeout</varname>值，但要注意如果
     <function>pg_stop_backup</function>因此而中止会致使备份可能失效。
    </para>
    <para>
     如果备份进程监控并且确保备份所需的所有WAL段文件都被成功地归档，那么<literal>wait_for_archive</literal>参数（默认为true）可以被设置为false，以便<function>pg_stop_backup</function>在停止备份记录被写入到WAL后立即返回。默认情况下，<function>pg_stop_backup</function>将会等待，直至所有WAL都被归档，这种等待会花一段时间。这个选项必须被小心地使用：如果WAL归档没有被正确的监控，则备份可能没有包括所有的WAL文件并且因此将变得不完整和不可恢复。
    </para>
   </listitem>
  </orderedlist>
    </para>
   </sect3>
   <sect3 id="backup-lowlevel-base-backup-exclusive">
<!--==========================orignal english content==========================
    <title>Making an exclusive low level backup</title>
____________________________________________________________________________-->
    <title>制作一个排他低级备份</title>
<!--==========================orignal english content==========================
    <para>
     The process for an exclusive backup is mostly the same as for a
     non-exclusive one, but it differs in a few key steps. This type of backup
     can only be taken on a primary and does not allow concurrent backups.
     Prior to <productname>PostgreSQL</productname> 9.6, this
     was the only low-level method available, but it is now recommended that
     all users upgrade their scripts to use non-exclusive backups if possible.
    </para>
____________________________________________________________________________-->
    <para>
     一个排他备份的处理绝大部分都和非排他备份相同，但是在一些关键步骤上
     不同。这种备份只能在主控机上制作，并且不允许并发备份。在<productname>PostgreSQL</productname> 9.6 之前，这是唯一可用的低级方法，但是现在
     推荐所有用户在可能的情况下升级他们的脚本来使用非排他备份。
    </para>
<!--==========================orignal english content==========================
    <para>
  <orderedlist>
   <listitem>
    <para>
     Ensure that WAL archiving is enabled and working.
    </para>
   </listitem>
   <listitem>
    <para>
     Connect to the server (it does not matter which database) as a user with
     rights to run pg_start_backup (superuser, or a user who has been granted
     EXECUTE on the function) and issue the command:
<programlisting>
SELECT pg_start_backup('label');
</programlisting>
     where <literal>label</literal> is any string you want to use to uniquely
     identify this backup operation.
     <function>pg_start_backup</function> creates a <firstterm>backup label</firstterm> file,
     called <filename>backup_label</filename>, in the cluster directory with
     information about your backup, including the start time and label string.
     The function also creates a <firstterm>tablespace map</firstterm> file,
     called <filename>tablespace_map</filename>, in the cluster directory with
     information about tablespace symbolic links in <filename>pg_tblspc/</filename> if
     one or more such link is present.  Both files are critical to the
     integrity of the backup, should you need to restore from it.
    </para>

    <para>
     By default, <function>pg_start_backup</function> can take a long time to finish.
     This is because it performs a checkpoint, and the I/O
     required for the checkpoint will be spread out over a significant
     period of time, by default half your inter-checkpoint interval
     (see the configuration parameter
     <xref linkend="guc-checkpoint-completion-target"/>).  This is
     usually what you want, because it minimizes the impact on query
     processing.  If you want to start the backup as soon as
     possible, use:
<programlisting>
SELECT pg_start_backup('label', true);
</programlisting>
     This forces the checkpoint to be done as quickly as possible.
    </para>
   </listitem>
   <listitem>
    <para>
     Perform the backup, using any convenient file-system-backup tool
     such as <application>tar</application> or <application>cpio</application> (not
     <application>pg_dump</application> or
     <application>pg_dumpall</application>).  It is neither
     necessary nor desirable to stop normal operation of the database
     while you do this. See
     <xref linkend="backup-lowlevel-base-backup-data"/> for things to
     consider during this backup.
    </para>
    <para>
      Note that if the server crashes during the backup it may not be
      possible to restart until the <literal>backup_label</literal> file has been
      manually deleted from the <envar>PGDATA</envar> directory.
    </para>
   </listitem>
   <listitem>
    <para>
     Again connect to the database as a user with rights to run
     pg_stop_backup (superuser, or a user who has been granted EXECUTE on
     the function), and issue the command:
<programlisting>
SELECT pg_stop_backup();
</programlisting>
     This function terminates backup mode and
     performs an automatic switch to the next WAL segment. The reason for the
     switch is to arrange for the last WAL segment written during the backup
     interval to be ready to archive.
    </para>
   </listitem>
   <listitem>
    <para>
     Once the WAL segment files active during the backup are archived, you are
     done.  The file identified by <function>pg_stop_backup</function>'s result is
     the last segment that is required to form a complete set of backup files.
     If <varname>archive_mode</varname> is enabled,
     <function>pg_stop_backup</function> does not return until the last segment has
     been archived.
     Archiving of these files happens automatically since you have
     already configured <varname>archive_command</varname>. In most cases this
     happens quickly, but you are advised to monitor your archive
     system to ensure there are no delays.
     If the archive process has fallen behind
     because of failures of the archive command, it will keep retrying
     until the archive succeeds and the backup is complete.
     If you wish to place a time limit on the execution of
     <function>pg_stop_backup</function>, set an appropriate
     <varname>statement_timeout</varname> value, but make note that if
     <function>pg_stop_backup</function> terminates because of this your backup
     may not be valid.
    </para>
   </listitem>
  </orderedlist>
    </para>
____________________________________________________________________________-->
    <para>
  <orderedlist>
   <listitem>
    <para>
     确保 WAL 归档被启用且正常工作。
    </para>
   </listitem>
   <listitem>
    <para>
     作为一个具有运行 pg_start_backup 权利的用户（超级用户，或者被授予在该
     函数上 EXECUTE 的用户）连接到服务器（不在乎是哪个数据库）并且发出命令：
<programlisting>
SELECT pg_start_backup('label');
</programlisting>
     这里<literal>label</literal>是任何你希望用来唯一标识这个备份操作的字符串。
     <function>pg_start_backup</function>在集簇目录中创建一个关于备份信息的
     <firstterm>备份标签</firstterm>文件，也被称为<filename>backup_label</filename>，
     其中包括了开始时间和标签字符串。该函数也会在集簇目录中创建一个
     名为<filename>tablespace_map</filename>的<firstterm>表空间映射</firstterm>文件，
     如果在<filename>pg_tblspc/</filename>中有一个或者多个表空间符号链接存在，
     该文件会包含它们的信息。如果你需要从备份中恢复，这两个文件对于备份的
     完整性都至关重要。
    </para>

    <para>
     默认情况下，<function>pg_start_backup</function>会花费很长时间来完成。这是因为它会执行一个检查点，而检查点所需要的I/O在相当一段时间内将会被传播，默认情况下这段时间是内部检查点间隔的一半（参见配置参数<xref linkend="guc-checkpoint-completion-target"/>）。这通常是你所希望的，因为它能将对查询处理的影响最小化。如果你要尽快开始备份，可使用：
<programlisting>
SELECT pg_start_backup('label', true);
</programlisting>
     这会使检查点尽可能快地被完成。
    </para>
   </listitem>
   <listitem>
    <para>
     使用任何方便的文件系统备份工具执行备份，例如<application>tar</application>
     或<application>cpio</application>（不是<application>pg_dump</application>
     或<application>pg_dumpall</application>）。在此期间，不需要也
     不值得停止正常的数据库操作。在备份期间要考虑的事情可见
     <xref linkend="backup-lowlevel-base-backup-data"/>小节。
    </para>
    <para>
      注意，如果服务器在备份期间崩溃，它可能无法重启，直至从<envar>PGDATA</envar>目录中手工地移除<literal>backup_label</literal>文件。
    </para>
   </listitem>
   <listitem>
    <para>
     再次以具有运行 pg_stop_backup 权利的用户（超级用户，或者已经被授予
     该函数上 EXECUTE 的用户）连接到数据库并且发出命令：
<programlisting>
SELECT pg_stop_backup();
</programlisting>
     这个函数将终止备份模式，并且执行一个自动切换到下一个WAL段。进行切换的原因是将在备份期间生成的最新WAL段文件安排为可归档。
    </para>
   </listitem>
   <listitem>
    <para>
     一旦备份期间活动的WAL段文件被归档，你的工作就完成了。
     <function>pg_stop_backup</function>的结果所标识的文件是构成一个完整备份
     文件组所需的最新段。如果<varname>archive_mode</varname>被启用，直到最
     新段被归档<function>pg_stop_backup</function>都不会返回。由于你已经配置了
     <varname>archive_command</varname>，这些文件的归档过程会自动发生。在
     大部分情况下这会很快发生，但还是建议你监控你的归档系统来确保不会有
     延迟。如果归档处理由于归档命令的错误而延迟，它会保持重试直到归档成
     功和备份完成。如果你希望在<function>pg_stop_backup</function>的执行上
     设置一个时间限制，可对<varname>statement_timeout</varname>设
     置一个合适的值，但要注意如果<function>pg_stop_backup</function>因此而
     中止会致使备份可能失效。
    </para>
   </listitem>
  </orderedlist>
   </para>
  </sect3>
   <sect3 id="backup-lowlevel-base-backup-data">
<!--==========================orignal english content==========================
   <title>Backing up the data directory</title>
____________________________________________________________________________-->
   <title>备份数据目录</title>
<!--==========================orignal english content==========================
   <para>
    Some file system backup tools emit warnings or errors
    if the files they are trying to copy change while the copy proceeds.
    When taking a base backup of an active database, this situation is normal
    and not an error.  However, you need to ensure that you can distinguish
    complaints of this sort from real errors.  For example, some versions
    of <application>rsync</application> return a separate exit code for
    <quote>vanished source files</quote>, and you can write a driver script to
    accept this exit code as a non-error case.  Also, some versions of
    GNU <application>tar</application> return an error code indistinguishable from
    a fatal error if a file was truncated while <application>tar</application> was
    copying it.  Fortunately, GNU <application>tar</application> versions 1.16 and
    later exit with 1 if a file was changed during the backup,
    and 2 for other errors.  With GNU <application>tar</application> version 1.23 and
    later, you can use the warning options <literal>-&minus;warning=no-file-changed
    -&minus;warning=no-file-removed</literal> to hide the related warning messages.
   </para>
____________________________________________________________________________-->
   <para>
    如果被拷贝的文件在拷贝过程中发生变化，某些文件系统备份工具会发出警告或错误。在建立一个活动数据库的基础备份时，这种情况是正常的，并非一个错误。然而，你需要确保你能够把它们和真正的错误区分开。例如，某些版本的<application>rsync</application>为<quote>消失的源文件</quote>返回一个独立的退出码，且你可以编写一个驱动脚本来将该退出码接受为一种非错误情况。同样，如果一个文件在被<application>tar</application>复制的过程中被截断，某些版本的GNU <application>tar</application>会返回一个与致命错误无法区分的错误代码。幸运的是，如果一个文件在备份期间被改变，版本为1.16及其后的GNU <application>tar</application>将会退出并返回1，而对于其他错误返回2。在版本1.23及其后的GNU <application>tar</application>中，你可以使用警告选项<literal>--warning=no-file-changed
    --warning=no-file-removed</literal>来隐藏相关的警告消息。
   </para>

<!--==========================orignal english content==========================
   <para>
    Be certain that your backup includes all of the files under
    the database cluster directory (e.g., <filename>/usr/local/pgsql/data</filename>).
    If you are using tablespaces that do not reside underneath this directory,
    be careful to include them as well (and be sure that your backup
    archives symbolic links as links, otherwise the restore will corrupt
    your tablespaces).
   </para>
____________________________________________________________________________-->
   <para>
    确认你的备份包含数据库集簇目录（例如<filename>/usr/local/pgsql/data</filename>）下的所有文件。如果你使用了不在此目录下的表空间，注意也把它们包括在内（并且确保你的备份将符号链接归档为链接，否则恢复过程将破坏你的表空间）。
   </para>

<!--==========================orignal english content==========================
   <para>
    You should, however, omit from the backup the files within the
    cluster's <filename>pg_wal/</filename> subdirectory.  This
    slight adjustment is worthwhile because it reduces the risk
    of mistakes when restoring.  This is easy to arrange if
    <filename>pg_wal/</filename> is a symbolic link pointing to someplace outside
    the cluster directory, which is a common setup anyway for performance
    reasons.  You might also want to exclude <filename>postmaster.pid</filename>
    and <filename>postmaster.opts</filename>, which record information
    about the running <application>postmaster</application>, not about the
    <application>postmaster</application> which will eventually use this backup.
    (These files can confuse <application>pg_ctl</application>.)
   </para>
____________________________________________________________________________-->
   <para>
    不过，你应当从备份中忽略集簇的<filename>pg_wal/</filename>子目录中的文件。这种微小的调整是值得的，因为它降低了恢复时的错误风险。如果<filename>pg_wal/</filename>是一个指向位于集簇目录之外其他地方的符号链接就很容易安排了，这是一种出于性能原因的常见设置。你可能也希望排除<filename>postmaster.pid</filename>和<filename>postmaster.opts</filename>，它们记录了关于<application>postmaster</application>运行的信息，但与最终使用这个备份的<application>postmaster</application>无关（这些文件可能会使<application>pg_ctl</application>搞混淆）。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is often a good idea to also omit from the backup the files
    within the cluster's <filename>pg_replslot/</filename> directory, so that
    replication slots that exist on the master do not become part of the
    backup.  Otherwise, the subsequent use of the backup to create a standby
    may result in indefinite retention of WAL files on the standby, and
    possibly bloat on the master if hot standby feedback is enabled, because
    the clients that are using those replication slots will still be connecting
    to and updating the slots on the master, not the standby.  Even if the
    backup is only intended for use in creating a new master, copying the
    replication slots isn't expected to be particularly useful, since the
    contents of those slots will likely be badly out of date by the time
    the new master comes on line.
   </para>
____________________________________________________________________________-->
   <para>
    从备份中忽略集簇的<filename>pg_replslot/</filename>子目录中的文件通常也是个好主意，这样
    主控机上存在的复制槽不会成为备份的一部分。否则，后续用该备份创建一个后备机可能会导致该
    后备机上的WAL文件被无限期保留，并且在启用了热后备反馈的情况下可能导致主控机膨胀，因为使用
    那些复制槽的客户端将继续连接到主控机（而不是后备机）并且继续更新其上的槽。即使该备份是要被
    用来创建一个新的主控机，拷贝复制槽也不是特别有用，因为这些槽的内容在新主控机上线时很可能已
    经过时。
   </para>

<!--==========================orignal english content==========================
   <para>
    The contents of the directories <filename>pg_dynshmem/</filename>,
    <filename>pg_notify/</filename>, <filename>pg_serial/</filename>,
    <filename>pg_snapshots/</filename>, <filename>pg_stat_tmp/</filename>,
    and <filename>pg_subtrans/</filename> (but not the directories themselves) can be
    omitted from the backup as they will be initialized on postmaster startup.
    If <xref linkend="guc-stats-temp-directory"/> is set and is under the data
    directory then the contents of that directory can also be omitted.
   </para>
____________________________________________________________________________-->
   <para>
    目录<filename>pg_dynshmem/</filename>、<filename>pg_notify/</filename>、<filename>pg_serial/</filename>、<filename>pg_snapshots/</filename>、<filename>pg_stat_tmp/</filename>和<filename>pg_subtrans/</filename>的内容（但不是这些目录本身）可以从备份中省略，因为它们在postmaster启动时会被初始化。如果<xref linkend="guc-stats-temp-directory"/>被设置并且位于数据目录中，则该目录的内容也可以被省略。
   </para>

<!--==========================orignal english content==========================
   <para>
    Any file or directory beginning with <filename>pgsql_tmp</filename> can be
    omitted from the backup.  These files are removed on postmaster start and
    the directories will be recreated as needed.
   </para>
____________________________________________________________________________-->
   <para>
    任何以<filename>pgsql_tmp</filename>开始的文件或目录都可以从备份中省略。这些文件在postmaster启动时会被移除，而目录将被根据需要重建。
   </para>

<!--==========================orignal english content==========================
   <para>
    <filename>pg_internal.init</filename> files can be omitted from the
    backup whenever a file of that name is found.  These files contain
    relation cache data that is always rebuilt when recovering.
   </para>
____________________________________________________________________________-->
   <para>
    只要找到名为<filename>pg_internal.init</filename>的文件，它就可以从备份中省略。这些文件包含关系缓冲数据，它们在恢复时总是会被重建。
   </para>

<!--==========================orignal english content==========================
   <para>
    The backup label
    file includes the label string you gave to <function>pg_start_backup</function>,
    as well as the time at which <function>pg_start_backup</function> was run, and
    the name of the starting WAL file.  In case of confusion it is therefore
    possible to look inside a backup file and determine exactly which
    backup session the dump file came from.  The tablespace map file includes
    the symbolic link names as they exist in the directory
    <filename>pg_tblspc/</filename> and the full path of each symbolic link.
    These files are not merely for your information; their presence and
    contents are critical to the proper operation of the system's recovery
    process.
   </para>
____________________________________________________________________________-->
   <para>
    备份标签文件包含你指定给
    <function>pg_start_backup</function>的标签字符串，以及
    <function>pg_start_backup</function>被运行的时刻和起始WAL文件的名字。
    在发生混乱的情况下就可以在备份文件中查看并准确地决定该转储文件来
    自于哪个备份会话。表空间映射文件包括存在于目录<filename>pg_tblspc/</filename>
    中的符号链接名称以及每一个符号链接的完整路径。这些文件不仅是为了供参考，
    它们的存在和内容对于系统恢复过程的正确操作是至关重要。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is also possible to make a backup while the server is
    stopped.  In this case, you obviously cannot use
    <function>pg_start_backup</function> or <function>pg_stop_backup</function>, and
    you will therefore be left to your own devices to keep track of which
    backup is which and how far back the associated WAL files go.
    It is generally better to follow the continuous archiving procedure above.
   </para>
____________________________________________________________________________-->
   <para>
    在服务器停止时也可以创建一个备份。在这种情况下，你显然不能使用
    <function>pg_start_backup</function>或<function>pg_stop_backup</function>，
    并且因此你只能依靠你的自己的策略来跟踪哪个备份是哪个，
    以及相关WAL文件应该走回到什么程度。通常最好遵循上面的连续归档过程。
   </para>
   </sect3>
  </sect2>

  <sect2 id="backup-pitr-recovery">
<!--==========================orignal english content==========================
   <title>Recovering Using a Continuous Archive Backup</title>
____________________________________________________________________________-->
   <title>使用一个连续归档备份进行恢复</title>

<!--==========================orignal english content==========================
   <para>
    Okay, the worst has happened and you need to recover from your backup.
    Here is the procedure:
  <orderedlist>
   <listitem>
    <para>
     Stop the server, if it's running.
    </para>
   </listitem>
   <listitem>
    <para>
     If you have the space to do so,
     copy the whole cluster data directory and any tablespaces to a temporary
     location in case you need them later. Note that this precaution will
     require that you have enough free space on your system to hold two
     copies of your existing database. If you do not have enough space,
     you should at least save the contents of the cluster's <filename>pg_wal</filename>
     subdirectory, as it might contain logs which
     were not archived before the system went down.
    </para>
   </listitem>
   <listitem>
    <para>
     Remove all existing files and subdirectories under the cluster data
     directory and under the root directories of any tablespaces you are using.
    </para>
   </listitem>
   <listitem>
    <para>
     Restore the database files from your file system backup.  Be sure that they
     are restored with the right ownership (the database system user, not
     <literal>root</literal>!) and with the right permissions.  If you are using
     tablespaces,
     you should verify that the symbolic links in <filename>pg_tblspc/</filename>
     were correctly restored.
    </para>
   </listitem>
   <listitem>
    <para>
     Remove any files present in <filename>pg_wal/</filename>; these came from the
     file system backup and are therefore probably obsolete rather than current.
     If you didn't archive <filename>pg_wal/</filename> at all, then recreate
     it with proper permissions,
     being careful to ensure that you re-establish it as a symbolic link
     if you had it set up that way before.
    </para>
   </listitem>
   <listitem>
    <para>
     If you have unarchived WAL segment files that you saved in step 2,
     copy them into <filename>pg_wal/</filename>.  (It is best to copy them,
     not move them, so you still have the unmodified files if a
     problem occurs and you have to start over.)
    </para>
   </listitem>
   <listitem>
    <para>
     Create a recovery command file <filename>recovery.conf</filename> in the cluster
     data directory (see <xref linkend="recovery-config"/>). You might
     also want to temporarily modify <filename>pg_hba.conf</filename> to prevent
     ordinary users from connecting until you are sure the recovery was successful.
    </para>
   </listitem>
   <listitem>
    <para>
     Start the server.  The server will go into recovery mode and
     proceed to read through the archived WAL files it needs.  Should the
     recovery be terminated because of an external error, the server can
     simply be restarted and it will continue recovery.  Upon completion
     of the recovery process, the server will rename
     <filename>recovery.conf</filename> to <filename>recovery.done</filename> (to prevent
     accidentally re-entering recovery mode later) and then
     commence normal database operations.
    </para>
   </listitem>
   <listitem>
    <para>
     Inspect the contents of the database to ensure you have recovered to
     the desired state.  If not, return to step 1.  If all is well,
     allow your users to connect by restoring <filename>pg_hba.conf</filename> to normal.
    </para>
   </listitem>
  </orderedlist>
   </para>
____________________________________________________________________________-->
   <para>
    好，现在最坏的情况发生了，你需要从你的备份进行恢复。这里是其过程：
  <orderedlist>
   <listitem>
    <para>
     如果服务器仍在运行，停止它。
    </para>
   </listitem>
   <listitem>
    <para>
     如果你具有足够的空间，将整个集簇数据目录和表空间复制到一个临时位置，稍后你将用到它们。注意这种预防措施将要求在你的系统上有足够的空闲空间来保留现有数据库的两个拷贝。如果你没有足够的空间，你至少要保存集簇的<filename>pg_wal</filename>子目录的内容，因为它可能包含在系统垮掉之前还未被归档的日志。
    </para>
   </listitem>
   <listitem>
    <para>
     移除所有位于集簇数据目录和正在使用的表空间根目录下的文件和子目录。
    </para>
   </listitem>
   <listitem>
    <para>
     从你的文件系统备份中恢复数据库文件。注意它们要使用正确的所有权恢复（数据库系统用户，不是<literal>root</literal>！）并且使用正确的权限。如果你在使用表空间，你应该验证<filename>pg_tblspc/</filename>中的符号链接被正确地恢复。
    </para>
   </listitem>
   <listitem>
    <para>
     移除<filename>pg_wal/</filename>中的任何文件，这些是来自于文件系统备份而不是当前日志，因此可以被忽略。如果你根本没有归档<filename>pg_wal/</filename>，那么以正确的权限重建它。注意如果以前它是一个符号链接，请确保你也以同样的方式重建它。
    </para>
   </listitem>
   <listitem>
    <para>
     如果你有在第2步中保存的未归档WAL段文件，把它们拷贝到<filename>pg_wal/</filename>（最好是拷贝而不是移动它们，这样如果在开始恢复后出现问题你任然有未修改的文件）。
    </para>
   </listitem>
   <listitem>
    <para>
     在集簇数据目录中创建一个恢复命令文件<filename>recovery.conf</filename>（见<xref linkend="recovery-config"/>）。你可能还想临时修改<filename>pg_hba.conf</filename>来阻止普通用户在成功恢复之前连接。
    </para>
   </listitem>
   <listitem>
    <para>
     启动服务器。服务器将会进入到恢复模式并且进而根据需要读取归档WAL文件。恢复可能因为一个外部错误而被终止，可以简单地重新启动服务器，这样它将继续恢复。恢复过程结束后，服务器将把<filename>recovery.conf</filename>重命名为<filename>recovery.done</filename>（为了阻止以后意外地重新进入恢复模式），并且开始正常数据库操作。
    </para>
   </listitem>
   <listitem>
    <para>
     检查数据库的内容来确保你已经恢复到了期望的状态。如果没有，返回到第1步。如果一切正常，通过恢复<filename>pg_hba.conf</filename>为正常来允许用户连接。
    </para>
   </listitem>
  </orderedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    The key part of all this is to set up a recovery configuration file that
    describes how you want to recover and how far the recovery should
    run.  You can use <filename>recovery.conf.sample</filename> (normally
    located in the installation's <filename>share/</filename> directory) as a
    prototype.  The one thing that you absolutely must specify in
    <filename>recovery.conf</filename> is the <varname>restore_command</varname>,
    which tells <productname>PostgreSQL</productname> how to retrieve archived
    WAL file segments.  Like the <varname>archive_command</varname>, this is
    a shell command string.  It can contain <literal>%f</literal>, which is
    replaced by the name of the desired log file, and <literal>%p</literal>,
    which is replaced by the path name to copy the log file to.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Write <literal>%%</literal> if you need to embed an actual <literal>%</literal>
    character in the command.  The simplest useful command is
    something like:
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
    which will copy previously archived WAL segments from the directory
    <filename>/mnt/server/archivedir</filename>.  Of course, you can use something
    much more complicated, perhaps even a shell script that requests the
    operator to mount an appropriate tape.
   </para>
____________________________________________________________________________-->
   <para>
    所有这些的关键部分是设置一个恢复配置文件，它描述你希望如何恢复以及恢复要运行到什么程度。你可以使用<filename>recovery.conf.sample</filename>（通常在安装的<filename>share/</filename>目录中）作为一个原型。你绝对必须在<filename>recovery.conf</filename>中指定的是<varname>restore_command</varname>，它告诉<productname>PostgreSQL</productname>如何获取归档WAL文件段。与<varname>archive_command</varname>相似，这也是一个shell命令字符串。它可以包含<literal>%f</literal>（将被期望的日志文件名替换）和<literal>%p</literal>（将被日志文件被拷贝的目标路径名替换）。（路径名是相对于当前工作目录的，即集簇的数据目录）。如果你需要在命令中嵌入一个真正的<literal>%</literal>字符，可以写成<literal>%%</literal>。最简单的命令类似于：
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
    它将从目录<filename>/mnt/server/archivedir</filename>中拷贝之前归档的WAL段。当然，你可以使用更复杂的，甚至是一个要求操作者装载合适磁带的shell脚本。
   </para>

<!--==========================orignal english content==========================
   <para>
    It is important that the command return nonzero exit status on failure.
    The command <emphasis>will</emphasis> be called requesting files that are not
    present in the archive; it must return nonzero when so asked.  This is not
    an error condition.  An exception is that if the command was terminated by
    a signal (other than <systemitem>SIGTERM</systemitem>, which is used as
    part of a database server shutdown) or an error by the shell (such as
    command not found), then recovery will abort and the server will not start
    up.
   </para>
____________________________________________________________________________-->
   <para>
    重要的是命令在失败时返回非零退出状态。该命令<emphasis>将</emphasis>被调用来请求不在归档中的文件，
    在这种情况下它应该返回非零值。这不是一种错误情况。一种例外是该命令被一个信号（除了被用作数
    据库服务器关闭动作一部分的<systemitem>SIGTERM</systemitem>）终止或者被shell的错误
    （例如命令未找到）终止，那样恢复将中止并且服务器将不会启动。
   </para>

<!--==========================orignal english content==========================
   <para>
    Not all of the requested files will be WAL segment
    files; you should also expect requests for files with a suffix of
    <literal>.history</literal>. Also be aware that
    the base name of the <literal>%p</literal> path will be different from
    <literal>%f</literal>; do not expect them to be interchangeable.
   </para>
____________________________________________________________________________-->
   <para>
    并非所有被请求的文件都是WAL段文件，你也许还会请求一些具有<literal>.history</literal>后缀的文件。还要注意的是，<literal>%p</literal>路径的基本名字将会和<literal>%f</literal>
    不同，但不要期望它们可以互换。
   </para>

<!--==========================orignal english content==========================
   <para>
    WAL segments that cannot be found in the archive will be sought in
    <filename>pg_wal/</filename>; this allows use of recent un-archived segments.
    However, segments that are available from the archive will be used in
    preference to files in <filename>pg_wal/</filename>.
   </para>
____________________________________________________________________________-->
   <para>
    归档中找不到的WAL段可以在<filename>pg_wal/</filename>中看到，这使得可以使用最近未归档的段。但是，在归档中可用的段将会被优先于<filename>pg_wal/</filename>中的文件被使用。
   </para>

<!--==========================orignal english content==========================
   <para>
    Normally, recovery will proceed through all available WAL segments,
    thereby restoring the database to the current point in time (or as
    close as possible given the available WAL segments).  Therefore, a normal
    recovery will end with a <quote>file not found</quote> message, the exact text
    of the error message depending upon your choice of
    <varname>restore_command</varname>.  You may also see an error message
    at the start of recovery for a file named something like
    <filename>00000001.history</filename>.  This is also normal and does not
    indicate a problem in simple recovery situations; see
    <xref linkend="backup-timelines"/> for discussion.
   </para>
____________________________________________________________________________-->
   <para>
    通常，恢复将会处理完所有可用的WAL段，从而将数据库恢复到当前时间点（或者尽可能接近给定的可
    用WAL段）。因此，一个正常的恢复将会以一个<quote>文件未找到</quote>消息结束，错误消息的准确文
    本取决于你选择的<varname>restore_command</varname>。你也可能在恢复的开始看到一个针对名称类
    似于<filename>00000001.history</filename>文件的错误消息。这也是正常的并且不表示在简单恢复情
    况中的问题，对此的讨论见<xref linkend="backup-timelines"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    If you want to recover to some previous point in time (say, right before
    the junior DBA dropped your main transaction table), just specify the
    required <link linkend="recovery-target-settings">stopping point</link> in <filename>recovery.conf</filename>.  You can specify
    the stop point, known as the <quote>recovery target</quote>, either by
    date/time, named restore point or by completion of a specific transaction
    ID.  As of this writing only the date/time and named restore point options
    are very usable, since there are no tools to help you identify with any
    accuracy which transaction ID to use.
   </para>
____________________________________________________________________________-->
   <para>
    如果你希望恢复到之前的某个时间点（例如，恢复到幼稚的DBA丢弃了你主要的交易表之前），只需要
    在<filename>recovery.conf</filename>中指定要求的<link linkend="recovery-target-settings">停止点</link>。你可以使用日期/时间、命名恢复点或一个
    指定事务ID的结束时间来定义停止点（也被称为<quote>恢复目标</quote>）。在这种写法中，只有日期/时
    间和命名恢复点选项非常有用，因为没有工具可以帮助你准确地确定要用哪个事务ID。
   </para>

   <note>
<!--==========================orignal english content==========================
     <para>
      The stop point must be after the ending time of the base backup, i.e.,
      the end time of <function>pg_stop_backup</function>.  You cannot use a base backup
      to recover to a time when that backup was in progress.  (To
      recover to such a time, you must go back to your previous base backup
      and roll forward from there.)
     </para>
____________________________________________________________________________-->
     <para>
      停止点必须位于基础备份的完成时间之后，即<function>pg_stop_backup</function>的完成时间。在备份过程中你不能使用基础备份来恢复（要恢复到这个时间，你必须回到你之前的基础备份并且从这里开始前滚）。
     </para>
   </note>

<!--==========================orignal english content==========================
   <para>
    If recovery finds corrupted WAL data, recovery will
    halt at that point and the server will not start. In such a case the
    recovery process could be re-run from the beginning, specifying a
    <quote>recovery target</quote> before the point of corruption so that recovery
    can complete normally.
    If recovery fails for an external reason, such as a system crash or
    if the WAL archive has become inaccessible, then the recovery can simply
    be restarted and it will restart almost from where it failed.
    Recovery restart works much like checkpointing in normal operation:
    the server periodically forces all its state to disk, and then updates
    the <filename>pg_control</filename> file to indicate that the already-processed
    WAL data need not be scanned again.
   </para>
____________________________________________________________________________-->
   <para>
    如果恢复找到被破坏的WAL数据，恢复将会停止于该点并且服务器不会启动。在这种情况下，恢复进程需要从开头重新开始运行，并指定一个在损坏点之前的<quote>恢复目标</quote>以便恢复能够正常完成。如果恢复由于一个外部原因失败，例如一个系统崩溃或者WAL归档变为不可访问，则该次恢复可以被简单地重启并且它将会从几乎是上次失败的地方继续。恢复重启工作起来很像普通操作时的检查点：服务器周期性地强制把它的所有状态写到磁盘中，然后更新<filename>pg_control</filename>文件来说明已经处理过的WAL数据，这样它们就不会被再次扫描。
   </para>

  </sect2>

  <sect2 id="backup-timelines">
<!--==========================orignal english content==========================
   <title>Timelines</title>
____________________________________________________________________________-->
   <title>时间线</title>

<!--==========================orignal english content==========================
  <indexterm zone="backup">
   <primary>timelines</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="backup">
   <primary>timelines</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
    The ability to restore the database to a previous point in time creates
    some complexities that are akin to science-fiction stories about time
    travel and parallel universes.  For example, in the original history of the database,
    suppose you dropped a critical table at 5:15PM on Tuesday evening, but
    didn't realize your mistake until Wednesday noon.
    Unfazed, you get out your backup, restore to the point-in-time 5:14PM
    Tuesday evening, and are up and running.  In <emphasis>this</emphasis> history of
    the database universe, you never dropped the table.  But suppose
    you later realize this wasn't such a great idea, and would like
    to return to sometime Wednesday morning in the original history.
    You won't be able
    to if, while your database was up-and-running, it overwrote some of the
    WAL segment files that led up to the time you now wish you
    could get back to.  Thus, to avoid this, you need to distinguish the series of
    WAL records generated after you've done a point-in-time recovery from
    those that were generated in the original database history.
   </para>
____________________________________________________________________________-->
   <para>
    将数据库恢复到一个之前的时间点的能力带来了一些复杂性，这和有关时间旅行和平行宇宙的科幻小说有些相似。例如，在数据库的最初历史中，假设你在周二晚上5：15时丢弃了一个关键表，但是一直到周三中午才意识到你的错误。不用苦恼，你取出你的备份，恢复到周二晚上5：14的时间点，并上线运行。在数据库宇宙的<emphasis>这个</emphasis>历史中，你从没有丢弃该表。但是假设你后来意识到这并非一个好主意，并且想回到最初历史中周三早上的某个时间。你没法这样做，在你的数据库在线运行期间，它重写了某些WAL段文件，而这些文件本来可以将你引向你希望回到的时间。因此，为了避免出现这种状况，你需要将完成时间点恢复后生成的WAL记录序列与初始数据库历史中产生的WAL记录序列区分开来。
   </para>

<!--==========================orignal english content==========================
   <para>
    To deal with this problem, <productname>PostgreSQL</productname> has a notion
    of <firstterm>timelines</firstterm>.  Whenever an archive recovery completes,
    a new timeline is created to identify the series of WAL records
    generated after that recovery.  The timeline
    ID number is part of WAL segment file names so a new timeline does
    not overwrite the WAL data generated by previous timelines.  It is
    in fact possible to archive many different timelines.  While that might
    seem like a useless feature, it's often a lifesaver.  Consider the
    situation where you aren't quite sure what point-in-time to recover to,
    and so have to do several point-in-time recoveries by trial and error
    until you find the best place to branch off from the old history.  Without
    timelines this process would soon generate an unmanageable mess.  With
    timelines, you can recover to <emphasis>any</emphasis> prior state, including
    states in timeline branches that you abandoned earlier.
   </para>
____________________________________________________________________________-->
   <para>
    要解决这个问题，<productname>PostgreSQL</productname>有一个<firstterm>时间线</firstterm>概念。无论何时当一次归档恢复完成，一个新的时间线被创建来标识恢复之后生成的WAL记录序列。时间线ID号是WAL段文件名的一部分，因此一个新的时间线不会重写由之前的时间线生成的WAL数据。实际上可以归档很多不同的时间线。虽然这可能看起来是一个无用的特性，但是它常常扮演救命稻草的角色。考虑到你不太确定需要恢复到哪个时间点的情况，你可能不得不做多次时间点恢复尝试和错误，直到最终找到从旧历史中分支出去的最佳位置。如果没有时间线，该处理将会很快生成一堆不可管理的混乱。而有了时间线，你可以恢复到<emphasis>任何</emphasis>之前的状态，包括早先被你放弃的时间线分支中的状态。
   </para>

<!--==========================orignal english content==========================
   <para>
    Every time a new timeline is created, <productname>PostgreSQL</productname> creates
    a <quote>timeline history</quote> file that shows which timeline it branched
    off from and when.  These history files are necessary to allow the system
    to pick the right WAL segment files when recovering from an archive that
    contains multiple timelines.  Therefore, they are archived into the WAL
    archive area just like WAL segment files.  The history files are just
    small text files, so it's cheap and appropriate to keep them around
    indefinitely (unlike the segment files which are large).  You can, if
    you like, add comments to a history file to record your own notes about
    how and why this particular timeline was created.  Such comments will be
    especially valuable when you have a thicket of different timelines as
    a result of experimentation.
   </para>
____________________________________________________________________________-->
   <para>
    每次当一个新的时间线被创建，<productname>PostgreSQL</productname>会创建一个<quote>时间线历史</quote>文件，它显示了新时间线是什么时候从哪个时间线分支出来的。系统在从一个包含多个时间线的归档中恢复时，这些历史文件对于允许系统选取正确的WAL段文件非常必要。因此，和WAL段文件相似，它们也要被归档到WAL归档区域。历史文件是很小的文本文件，因此将它们无限期地保存起来的代价很小，而且也是很合适的（而段文件都很大）。如果你喜欢，你可以在一个历史文件中增加注释来记录如何和为什么要创建该时间线。当你由于试验的结果拥有了一大堆错综复杂的不同时间线时，这种注释将会特别有价值。
   </para>

<!--==========================orignal english content==========================
   <para>
    The default behavior of recovery is to recover along the same timeline
    that was current when the base backup was taken.  If you wish to recover
    into some child timeline (that is, you want to return to some state that
    was itself generated after a recovery attempt), you need to specify the
    target timeline ID in <filename>recovery.conf</filename>.  You cannot recover into
    timelines that branched off earlier than the base backup.
   </para>
____________________________________________________________________________-->
   <para>
    恢复的默认行为是沿着相同的时间线进行恢复，该时间线是基础备份创建时的当前时间线。如果你希望恢复到某个子女时间线（即，你希望回到在一次恢复尝试后产生的某个状态），你需要在<filename>recovery.conf</filename>中指定目标时间线ID。你不能恢复到早于该基础备份之前分支出去的时间线。
   </para>
  </sect2>

  <sect2 id="backup-tips">
<!--==========================orignal english content==========================
   <title>Tips and Examples</title>
____________________________________________________________________________-->
   <title>建议和例子</title>

<!--==========================orignal english content==========================
   <para>
    Some tips for configuring continuous archiving are given here.
   </para>
____________________________________________________________________________-->
   <para>
    这里将给出一些配置连续归档的建议。
   </para>

    <sect3 id="backup-standalone">
<!--==========================orignal english content==========================
     <title>Standalone Hot Backups</title>
____________________________________________________________________________-->
     <title>单机热备份</title>

<!--==========================orignal english content==========================
     <para>
      It is possible to use <productname>PostgreSQL</productname>'s backup facilities to
      produce standalone hot backups. These are backups that cannot be used
      for point-in-time recovery, yet are typically much faster to backup and
      restore than <application>pg_dump</application> dumps.  (They are also much larger
      than <application>pg_dump</application> dumps, so in some cases the speed advantage
      might be negated.)
     </para>
____________________________________________________________________________-->
     <para>
      可以使用<productname>PostgreSQL</productname>的备份功能来产生单机热备份。这些备份不能被用于时间点恢复，然而备份和恢复时要比使用<application>pg_dump</application>转储更快（它们也比<application>pg_dump</application>转储更大，所以在某些情况下速度优势可能会被否定）。
     </para>

<!--==========================orignal english content==========================
     <para>
      As with base backups, the easiest way to produce a standalone
      hot backup is to use the <xref linkend="app-pgbasebackup"/>
      tool. If you include the <literal>-X</literal> parameter when calling
      it, all the write-ahead log required to use the backup will be
      included in the backup automatically, and no special action is
      required to restore the backup.
     </para>
____________________________________________________________________________-->
     <para>
      在基础备份的帮助下，产生一个单机热备份最简单的方式是使用<xref linkend="app-pgbasebackup"/>工具。如果你在调用它时使用了<literal>-X</literal>参数，使用该备份所需的所有事务日志将会被自动包含在该备份中，并且恢复该备份也不需要特殊的动作。
     </para>

<!--==========================orignal english content==========================
     <para>
      If more flexibility in copying the backup files is needed, a lower
      level process can be used for standalone hot backups as well.
      To prepare for low level standalone hot backups, make sure
      <varname>wal_level</varname> is set to
      <literal>replica</literal> or higher, <varname>archive_mode</varname> to
      <literal>on</literal>, and set up an <varname>archive_command</varname> that performs
      archiving only when a <emphasis>switch file</emphasis> exists.  For example:
<programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'
</programlisting>
      This command will perform archiving when
      <filename>/var/lib/pgsql/backup_in_progress</filename> exists, and otherwise
      silently return zero exit status (allowing <productname>PostgreSQL</productname>
      to recycle the unwanted WAL file).
     </para>
____________________________________________________________________________-->
     <para>
      如果在复制备份文件时需要更多灵活性，也可以使用一个较低层的处理来创建单机热备份。要为低层
      单机热备份做准备，确保<varname>wal_level</varname>被设置为<literal>replica</literal>或更高，
      <varname>archive_mode</varname>设置为<literal>on</literal>，并且设置一个<varname>archive_command</varname>，该命令只当一个<emphasis>开关文件</emphasis>存在时执行归档。例如：
<programlisting>
archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'
</programlisting>
      该命令在<filename>/var/lib/pgsql/backup_in_progress</filename>存在时执行归档，否则会安静地返回0值退出状态（让<productname>PostgreSQL</productname>能回收不需要的WAL文件）。
     </para>

<!--==========================orignal english content==========================
     <para>
      With this preparation, a backup can be taken using a script like the
      following:
<programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
</programlisting>
      The switch file <filename>/var/lib/pgsql/backup_in_progress</filename> is
      created first, enabling archiving of completed WAL files to occur.
      After the backup the switch file is removed. Archived WAL files are
      then added to the backup so that both base backup and all required
      WAL files are part of the same <application>tar</application> file.
      Please remember to add error handling to your backup scripts.
     </para>
____________________________________________________________________________-->
     <para>
      通过这样的准备，可以使用一个如下所示的脚本来建立备份：
<programlisting>
touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/
</programlisting>
      开关文件<filename>/var/lib/pgsql/backup_in_progress</filename>首先被创建，这使对于未完成WAL文件的归档操作发生。备份完成之后开关文件会被删除。归档的WAL文件则被加入到备份中，这样基础备份和所有需要的WAL文件都是同一个<application>tar</application>文件的组成部分。请记住在你的备份脚本中加入错误处理。
     </para>

    </sect3>

    <sect3 id="compressed-archive-logs">
<!--==========================orignal english content==========================
     <title>Compressed Archive Logs</title>
____________________________________________________________________________-->
     <title>压缩的归档日志</title>

<!--==========================orignal english content==========================
     <para>
      If archive storage size is a concern, you can use
      <application>gzip</application> to compress the archive files:
<programlisting>
archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'
</programlisting>
      You will then need to use <application>gunzip</application> during recovery:
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      如果担心归档存储的尺寸，你可以使用<application>gzip</application>来压缩归档文件：
<programlisting>
archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'
</programlisting>
      那么在恢复时你将需要使用<application>gunzip</application>：
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'
</programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
<!--==========================orignal english content==========================
     <title><varname>archive_command</varname> Scripts</title>
____________________________________________________________________________-->
     <title><varname>archive_command</varname>脚本</title>

<!--==========================orignal english content==========================
     <para>
      Many people choose to use scripts to define their
      <varname>archive_command</varname>, so that their
      <filename>postgresql.conf</filename> entry looks very simple:
<programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
</programlisting>
      Using a separate script file is advisable any time you want to use
      more than a single command in the archiving process.
      This allows all complexity to be managed within the script, which
      can be written in a popular scripting language such as
      <application>bash</application> or <application>perl</application>.
     </para>
____________________________________________________________________________-->
     <para>
      很多人选择使用脚本来定义他们的<varname>archive_command</varname>，这样他们的<filename>postgresql.conf</filename>项看起来非常简单：
<programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
</programlisting>
      任何时候如果你希望在归档处理中使用多个命令，明智的方法是使用一个独立的脚本文件。这可以使脚本更为复杂，它可以使用一种流行的脚本语言来编写，例如<application>bash</application>或<application>perl</application>。
     </para>

<!--==========================orignal english content==========================
     <para>
      Examples of requirements that might be solved within a script include:
      <itemizedlist>
       <listitem>
        <para>
         Copying data to secure off-site data storage
        </para>
       </listitem>
       <listitem>
        <para>
         Batching WAL files so that they are transferred every three hours,
         rather than one at a time
        </para>
       </listitem>
       <listitem>
        <para>
         Interfacing with other backup and recovery software
        </para>
       </listitem>
       <listitem>
        <para>
         Interfacing with monitoring software to report errors
        </para>
       </listitem>
      </itemizedlist>
     </para>
____________________________________________________________________________-->
     <para>
      需要在一个脚本内解决的需求例子包括：
      <itemizedlist>
       <listitem>
        <para>
         将数据拷贝到安全的场外数据存储
        </para>
       </listitem>
       <listitem>
        <para>
         批处理WAL文件，这样它们可以每三小时被传输一次，而不是一次一个
        </para>
       </listitem>
       <listitem>
        <para>
         与其他备份和恢复软件交互
        </para>
       </listitem>
       <listitem>
        <para>
         与监控软件交互以报告错误
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <tip>
<!--==========================orignal english content==========================
      <para>
       When using an <varname>archive_command</varname> script, it's desirable
       to enable <xref linkend="guc-logging-collector"/>.
       Any messages written to <systemitem>stderr</systemitem> from the script will then
       appear in the database server log, allowing complex configurations to
       be diagnosed easily if they fail.
      </para>
____________________________________________________________________________-->
      <para>
       在使用一个<varname>archive_command</varname>脚本时，最好启用<xref linkend="guc-logging-collector"/>。任何从该脚本被写到<systemitem>stderr</systemitem>的消息将出现在数据库服务器日志中，这允许在复杂配置失败后能更容易被诊断。
      </para>
     </tip>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
<!--==========================orignal english content==========================
   <title>Caveats</title>
____________________________________________________________________________-->
   <title>警告</title>

<!--==========================orignal english content==========================
   <para>
    At this writing, there are several limitations of the continuous archiving
    technique.  These will probably be fixed in future releases:

  <itemizedlist>
   <listitem>
    <para>
     If a <xref linkend="sql-createdatabase"/>
     command is executed while a base backup is being taken, and then
     the template database that the <command>CREATE DATABASE</command> copied
     is modified while the base backup is still in progress, it is
     possible that recovery will cause those modifications to be
     propagated into the created database as well.  This is of course
     undesirable.  To avoid this risk, it is best not to modify any
     template databases while taking a base backup.
    </para>
   </listitem>

   <listitem>
    <para>
     <xref linkend="sql-createtablespace"/>
     commands are WAL-logged with the literal absolute path, and will
     therefore be replayed as tablespace creations with the same
     absolute path.  This might be undesirable if the log is being
     replayed on a different machine.  It can be dangerous even if the
     log is being replayed on the same machine, but into a new data
     directory: the replay will still overwrite the contents of the
     original tablespace.  To avoid potential gotchas of this sort,
     the best practice is to take a new base backup after creating or
     dropping tablespaces.
    </para>
   </listitem>
  </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在编写此文档时，连续归档技术存在一些限制。这可能会在未来的发布中被修复：

  <itemizedlist>
   <listitem>
    <para>
     如果一个<xref linkend="sql-createdatabase"/>命令在基础备份时被执行，然后在基础备份进行时<command>CREATE DATABASE</command>所复制的模板数据库被修改，恢复中可能会导致这些修改也被传播到已创建的数据库中。这当然是我们不希望的。为了避免这种风险，最好不要在创建基础备份时修改任何模板数据库。
    </para>
   </listitem>

   <listitem>
    <para>
     <xref linkend="sql-createtablespace"/>命令会WAL以其字面绝对路径记录，并且因此将在重放时以相同的绝对路径来创建表空间。当日志在一台不同的机器上被重放时，这可能也不是我们希望的。即使日志在同一台机器上被重放也是危险的，就算是恢复到一个新的数据目录重放过程也会覆盖原来表空间的内容。为了避免这种潜在的陷阱，最佳做法是在创建或丢弃表空间后创建一个新的基础备份。
    </para>
   </listitem>
  </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    It should also be noted that the default <acronym>WAL</acronym>
    format is fairly bulky since it includes many disk page snapshots.
    These page snapshots are designed to support crash recovery, since
    we might need to fix partially-written disk pages.  Depending on
    your system hardware and software, the risk of partial writes might
    be small enough to ignore, in which case you can significantly
    reduce the total volume of archived logs by turning off page
    snapshots using the <xref linkend="guc-full-page-writes"/>
    parameter.  (Read the notes and warnings in <xref linkend="wal"/>
    before you do so.)  Turning off page snapshots does not prevent
    use of the logs for PITR operations.  An area for future
    development is to compress archived WAL data by removing
    unnecessary page copies even when <varname>full_page_writes</varname> is
    on.  In the meantime, administrators might wish to reduce the number
    of page snapshots included in WAL by increasing the checkpoint
    interval parameters as much as feasible.
   </para>
____________________________________________________________________________-->
   <para>
    还需要注意的是，默认的<acronym>WAL</acronym>格式相当庞大，因为它包括了很多磁盘页快照。这些页快照被设计用于支持崩溃恢复，因为我们可能需要修复断裂的磁盘页。依靠你的系统硬件和软件，页断裂的风险可能会小到可以忽略，在此种情况下你可以通过使用<xref linkend="guc-full-page-writes"/>参数关闭页快照来显著降低归档日志的总容量（在这样做之前阅读<xref linkend="wal"/>中的注解和警告）。关闭页快照并不会阻止使用日志进行PITR操作。一个未来的开发点是通过移除不需要的页拷贝来压缩归档的WAL数据，即使<varname>full_page_writes</varname>为on。同时，管理员可能希望通过尽可能增大检查点间隔参数来减少WAL中包含的页快照数量。
   </para>
  </sect2>
 </sect1>

</chapter>
